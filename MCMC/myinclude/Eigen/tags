!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABx_lx	src/Core/util/Constants.h	/^  ABx_lx              = 0x200,$/;"	e	enum:Eigen::DecompositionOptions
ALIVE	src/OrderingMethods/Eigen_Colamd.h	115;"	d
AMDOrdering	src/OrderingMethods/Ordering.h	/^class AMDOrdering$/;"	c	namespace:Eigen
AccPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef ResPacket AccPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
AccPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::AccPacket AccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
AccPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type AccPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
AccessorLevels	src/Core/util/Constants.h	/^enum AccessorLevels {$/;"	g	namespace:Eigen
Action	src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	g	namespace:Eigen
ActualCols	src/Core/products/GeneralMatrixMatrix.h	/^      ActualCols = Transpose ? MaxRows : MaxCols$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon41
ActualIndex	src/Core/BandMatrix.h	/^        ActualIndex = ReturnOpposite ? -Index : Index,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon143
ActualLhsType	src/Core/ProductBase.h	/^    typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	class:Eigen::ProductBase	access:public
ActualLhsType	src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
ActualLhsType	src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::ExtractType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
ActualPacketAccessBit	src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = 0x0;$/;"	m	namespace:Eigen
ActualPacketAccessBit	src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = PacketAccessBit;$/;"	m	namespace:Eigen
ActualRhsType	src/Core/ProductBase.h	/^    typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	class:Eigen::ProductBase	access:public
ActualRows	src/Core/products/GeneralMatrixMatrix.h	/^      ActualRows = Transpose ? MaxCols : MaxRows,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon41
AddCost	src/Core/NumTraits.h	/^    AddCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
AdjointReturnType	src/Core/MatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
AdjointReturnType	src/SparseCore/SparseMatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Affine	src/Core/util/Constants.h	/^  Affine        = 0x2,$/;"	e	enum:Eigen::TransformTraits
Affine2d	src/Geometry/Transform.h	/^typedef Transform<double,2,Affine> Affine2d;$/;"	t	namespace:Eigen
Affine2f	src/Geometry/Transform.h	/^typedef Transform<float,2,Affine> Affine2f;$/;"	t	namespace:Eigen
Affine3d	src/Geometry/Transform.h	/^typedef Transform<double,3,Affine> Affine3d;$/;"	t	namespace:Eigen
Affine3f	src/Geometry/Transform.h	/^typedef Transform<float,3,Affine> Affine3f;$/;"	t	namespace:Eigen
AffineCompact	src/Core/util/Constants.h	/^  AffineCompact = 0x10 | Affine,$/;"	e	enum:Eigen::TransformTraits
AffineCompact2d	src/Geometry/Transform.h	/^typedef Transform<double,2,AffineCompact> AffineCompact2d;$/;"	t	namespace:Eigen
AffineCompact2f	src/Geometry/Transform.h	/^typedef Transform<float,2,AffineCompact> AffineCompact2f;$/;"	t	namespace:Eigen
AffineCompact3d	src/Geometry/Transform.h	/^typedef Transform<double,3,AffineCompact> AffineCompact3d;$/;"	t	namespace:Eigen
AffineCompact3f	src/Geometry/Transform.h	/^typedef Transform<float,3,AffineCompact> AffineCompact3f;$/;"	t	namespace:Eigen
AffinePart	src/Geometry/Transform.h	/^                              Block<MatrixType,Dim,HDim> >::type AffinePart;$/;"	t	class:Eigen::Transform	access:public
AffinePart	src/Geometry/Transform.h	/^  typedef typename TransformType::AffinePart AffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
AffineTransformType	src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Affine> AffineTransformType;$/;"	t	class:Eigen::Translation	access:public
Aligned	src/Core/util/Constants.h	/^  Aligned=1 $/;"	e	enum:Eigen::__anon62
AlignedBit	src/Core/util/Constants.h	/^const unsigned int AlignedBit = 0x80;$/;"	m	namespace:Eigen
AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox(const VectorType& _min, const VectorType& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& _min, const VectorType& _max)
AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)
AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const VectorType& p) : m_min(p), m_max(p) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p)
AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(int _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(int _dim)
AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedBox	src/Eigen2Support/Geometry/All.h	110;"	d
AlignedBox	src/Eigen2Support/Geometry/All.h	55;"	d
AlignedBox	src/Geometry/AlignedBox.h	/^  inline AlignedBox()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
AlignedBox	src/Geometry/AlignedBox.h	/^  inline AlignedBox(const OtherVectorType1& _min, const OtherVectorType2& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const OtherVectorType1& _min, const OtherVectorType2& _max)
AlignedBox	src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(Index _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(Index _dim)
AlignedBox	src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)
AlignedBox	src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const MatrixBase<Derived>& p) : m_min(p), m_max(m_min)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p)
AlignedBox	src/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedMapType	src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Aligned> AlignedMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
AlignedOnScalar	src/Core/GenericPacketMath.h	/^    AlignedOnScalar = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon270
AlignedOnScalar	src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
AlignedOnScalar	src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
AlignedOnScalar	src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
AlignedOnScalar	src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
AlignedOnScalar	src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
AlignedOnScalar	src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
AlignedOnScalar	src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
AlignedOnScalar	src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
AlignedOnScalar	src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
AlignedOnScalar	src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
AlignedOnScalar	src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon26
AlignedScaling2d	src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,2> AlignedScaling2d;$/;"	t	namespace:Eigen
AlignedScaling2f	src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 2> AlignedScaling2f;$/;"	t	namespace:Eigen
AlignedScaling3d	src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,3> AlignedScaling3d;$/;"	t	namespace:Eigen
AlignedScaling3f	src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 3> AlignedScaling3f;$/;"	t	namespace:Eigen
AlignmentMask	src/Cholesky/LLT.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::LLT::__anon3
AlignmentMask	src/Eigen2Support/SVD.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::SVD::__anon359
AlignmentMatch	src/Core/Ref.h	/^      AlignmentMatch = (_Options!=Aligned) || ((PlainObjectType::Flags&AlignedBit)==0) || ((traits<Derived>::Flags&AlignedBit)==AlignedBit),$/;"	e	enum:Eigen::internal::traits::match::__anon307
AllAtOnceTraversal	src/Core/util/Constants.h	/^  AllAtOnceTraversal$/;"	e	enum:Eigen::__anon63
AltiVec	src/Core/util/Constants.h	/^    AltiVec = 0x2,$/;"	e	enum:Eigen::Architecture::Type
AmbiVector	src/SparseCore/AmbiVector.h	/^    AmbiVector(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index size)
AmbiVector	src/SparseCore/AmbiVector.h	/^class AmbiVector$/;"	c	namespace:Eigen::internal
AmbientDimAtCompileTime	src/Eigen2Support/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon339
AmbientDimAtCompileTime	src/Eigen2Support/Geometry/Hyperplane.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::Hyperplane::__anon341
AmbientDimAtCompileTime	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::ParametrizedLine::__anon342
AmbientDimAtCompileTime	src/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon369
AmbientDimAtCompileTime	src/Geometry/Hyperplane.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::Hyperplane::__anon373
AmbientDimAtCompileTime	src/Geometry/ParametrizedLine.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::ParametrizedLine::__anon374
Ancestor	src/Core/CwiseBinaryOp.h	/^  typedef typename remove_all<Lhs>::type Ancestor;$/;"	t	struct:Eigen::internal::traits	access:public
AngleAxis	src/Eigen2Support/Geometry/All.h	33;"	d
AngleAxis	src/Eigen2Support/Geometry/All.h	88;"	d
AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(Scalar angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:(Scalar angle, const MatrixBase<Derived>& axis)
AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(const QuaternionType& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& q)
AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis<OtherScalarType>& other)
AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
AngleAxis	src/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
AngleAxis	src/Geometry/AngleAxis.h	/^  inline AngleAxis(const Scalar& angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Scalar& angle, const MatrixBase<Derived>& axis)
AngleAxis	src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis<OtherScalarType>& other)
AngleAxis	src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
AngleAxis	src/Geometry/AngleAxis.h	/^  template<typename QuatDerived> inline explicit AngleAxis(const QuaternionBase<QuatDerived>& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionBase<QuatDerived>& q)
AngleAxis	src/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
AngleAxisType	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::Quaternion	access:public
AngleAxisType	src/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::QuaternionBase	access:public
AngleAxisType	src/Geometry/Quaternion.h	/^  typedef typename Base::AngleAxisType AngleAxisType;$/;"	t	class:Eigen::Quaternion	access:public
AngleAxisd	src/Eigen2Support/Geometry/All.h	35;"	d
AngleAxisd	src/Eigen2Support/Geometry/All.h	90;"	d
AngleAxisd	src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisd	src/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisf	src/Eigen2Support/Geometry/All.h	34;"	d
AngleAxisf	src/Eigen2Support/Geometry/All.h	89;"	d
AngleAxisf	src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
AngleAxisf	src/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
Architecture	src/Core/util/Constants.h	/^namespace Architecture$/;"	n	namespace:Eigen
Array	src/Core/Array.h	/^    Array(Array&& other)$/;"	f	class:Eigen::Array	access:public	signature:(Array&& other)
Array	src/Core/Array.h	/^    Array(Index rows, Index cols);$/;"	p	class:Eigen::Array	access:public	signature:(Index rows, Index cols)
Array	src/Core/Array.h	/^    Array(const Scalar& val0, const Scalar& val1);$/;"	p	class:Eigen::Array	access:public	signature:(const Scalar& val0, const Scalar& val1)
Array	src/Core/Array.h	/^    Array(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Array	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array() : Base()$/;"	f	class:Eigen::Array	access:public	signature:()
Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Array& other)$/;"	f	class:Eigen::Array	access:public	signature:(const Array& other)
Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ArrayBase<OtherDerived>& other)
Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array	access:public	signature:(const EigenBase<OtherDerived> &other)
Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2)$/;"	f	class:Eigen::Array	access:public	signature:(const Scalar& val0, const Scalar& val1, const Scalar& val2)
Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2, const Scalar& val3)$/;"	f	class:Eigen::Array	access:public	signature:(const Scalar& val0, const Scalar& val1, const Scalar& val2, const Scalar& val3)
Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const T0& val0, const T1& val1)$/;"	f	class:Eigen::Array	access:public	signature:(const T0& val0, const T1& val1)
Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array(Index dim)$/;"	f	class:Eigen::Array	access:public	signature:(Index dim)
Array	src/Core/Array.h	/^    explicit Array(const Scalar *data);$/;"	p	class:Eigen::Array	access:public	signature:(const Scalar *data)
Array	src/Core/Array.h	/^class Array$/;"	c	namespace:Eigen	inherits:PlainObjectBase
Array	src/Core/Map.h	/^  ::Array(const Scalar *data)$/;"	f	class:Eigen::Array	signature:(const Scalar *data)
ArrayBase	src/Core/ArrayBase.h	/^    ArrayBase() : Base() {}$/;"	f	class:Eigen::ArrayBase	access:protected	signature:()
ArrayBase	src/Core/ArrayBase.h	/^    ArrayBase(Index,Index);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(Index,Index)
ArrayBase	src/Core/ArrayBase.h	/^    explicit ArrayBase(Index);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(Index)
ArrayBase	src/Core/ArrayBase.h	/^    template<typename OtherDerived> explicit ArrayBase(const ArrayBase<OtherDerived>&);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(const ArrayBase<OtherDerived>&)
ArrayBase	src/Core/ArrayBase.h	/^template<typename Derived> class ArrayBase$/;"	c	namespace:Eigen	inherits:DenseBase
ArrayWrapper	src/Core/ArrayWrapper.h	/^    inline ArrayWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(ExpressionType& matrix)
ArrayWrapper	src/Core/ArrayWrapper.h	/^class ArrayWrapper : public ArrayBase<ArrayWrapper<ExpressionType> >$/;"	c	namespace:Eigen	inherits:ArrayBase
ArrayXpr	src/Core/util/Constants.h	/^struct ArrayXpr {};$/;"	s	namespace:Eigen
AutoAlign	src/Core/util/Constants.h	/^  AutoAlign = 0,$/;"	e	enum:Eigen::__anon66
Ax_lBx	src/Core/util/Constants.h	/^  Ax_lBx              = 0x100,$/;"	e	enum:Eigen::DecompositionOptions
BAx_lx	src/Core/util/Constants.h	/^  BAx_lx              = 0x400,$/;"	e	enum:Eigen::DecompositionOptions
BLASFUNC	src/misc/blas.h	9;"	d
BLASLONG	src/misc/blas.h	/^typedef long BLASLONG;$/;"	t
BLASLONG	src/misc/blas.h	/^typedef long long BLASLONG;$/;"	t
BLASULONG	src/misc/blas.h	/^typedef unsigned long BLASULONG;$/;"	t
BLASULONG	src/misc/blas.h	/^typedef unsigned long long BLASULONG;$/;"	t
BLAS_H	src/misc/blas.h	2;"	d
BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER	src/Core/util/StaticAssert.h	/^        BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
BandMatrix	src/Core/BandMatrix.h	/^    inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)
BandMatrix	src/Core/BandMatrix.h	/^class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >$/;"	c	namespace:Eigen::internal	inherits:BandMatrixBase
BandMatrixBase	src/Core/BandMatrix.h	/^class BandMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen::internal	inherits:EigenBase
BandMatrixWrapper	src/Core/BandMatrix.h	/^    inline BandMatrixWrapper(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)
BandMatrixWrapper	src/Core/BandMatrix.h	/^class BandMatrixWrapper : public BandMatrixBase<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	c	namespace:Eigen::internal	inherits:BandMatrixBase
Base	src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodDecomposition> Base;$/;"	t	class:Eigen::CholmodDecomposition	access:private
Base	src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLDLT	access:private
Base	src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLLT	access:private
Base	src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT> Base;$/;"	t	class:Eigen::CholmodSupernodalLLT	access:private
Base	src/Core/Array.h	/^    typedef PlainObjectBase<Array> Base;$/;"	t	class:Eigen::Array	access:public
Base	src/Core/ArrayBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::ArrayBase	access:public
Base	src/Core/ArrayWrapper.h	/^    typedef ArrayBase<ArrayWrapper> Base;$/;"	t	class:Eigen::ArrayWrapper	access:public
Base	src/Core/ArrayWrapper.h	/^    typedef MatrixBase<MatrixWrapper<ExpressionType> > Base;$/;"	t	class:Eigen::MatrixWrapper	access:public
Base	src/Core/BandMatrix.h	/^    typedef BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor> Base;$/;"	t	class:Eigen::internal::TridiagonalMatrix	access:private
Base	src/Core/BandMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Base	src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::Block	access:public
Base	src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::BlockImpl	access:public
Base	src/Core/Block.h	/^    typedef MapBase<BlockType> Base;$/;"	t	class:Eigen::internal::BlockImpl_dense	access:public
Base	src/Core/Block.h	/^    typedef typename internal::dense_xpr_base<BlockType>::type Base;$/;"	t	class:Eigen::internal::BlockImpl_dense	access:public
Base	src/Core/CwiseBinaryOp.h	/^                                         typename internal::traits<Rhs>::StorageKind>::ret>::Base Base;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Base	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:public
Base	src/Core/CwiseNullaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;$/;"	t	class:Eigen::CwiseNullaryOp	access:public
Base	src/Core/CwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryOp	access:public
Base	src/Core/CwiseUnaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Base	src/Core/CwiseUnaryView.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryView	access:public
Base	src/Core/CwiseUnaryView.h	/^    typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
Base	src/Core/DenseBase.h	/^    typedef internal::special_scalar_op_base<Derived,Scalar,RealScalar, DenseCoeffsBase<Derived> > Base;$/;"	t	class:Eigen::DenseBase	access:public
Base	src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Base	src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, WriteAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Base	src/Core/DenseCoeffsBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Base	src/Core/Diagonal.h	/^    typedef typename internal::dense_xpr_base<Diagonal>::type Base;$/;"	t	class:Eigen::Diagonal	access:public
Base	src/Core/DiagonalProduct.h	/^    typedef MatrixBase<DiagonalProduct> Base;$/;"	t	class:Eigen::DiagonalProduct	access:public
Base	src/Core/Flagged.h	/^    typedef MatrixBase<Flagged> Base;$/;"	t	class:Eigen::Flagged	access:public
Base	src/Core/ForceAlignedAccess.h	/^    typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;$/;"	t	class:Eigen::ForceAlignedAccess	access:public
Base	src/Core/GeneralProduct.h	/^    typedef Matrix<typename internal::scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType,1,1> Base;$/;"	t	class:Eigen::GeneralProduct	access:private
Base	src/Core/Map.h	/^    typedef MapBase<Map> Base;$/;"	t	class:Eigen::Map	access:public
Base	src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::MapBase	access:public
Base	src/Core/MapBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::MapBase	access:public
Base	src/Core/Matrix.h	/^    typedef PlainObjectBase<Matrix> Base;$/;"	t	class:Eigen::Matrix	access:public
Base	src/Core/MatrixBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::MatrixBase	access:public
Base	src/Core/NestByValue.h	/^    typedef typename internal::dense_xpr_base<NestByValue>::type Base;$/;"	t	class:Eigen::NestByValue	access:public
Base	src/Core/PermutationMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::PermutationBase	access:private
Base	src/Core/PermutationMatrix.h	/^    typedef PermutationBase<Map> Base;$/;"	t	class:Eigen::Map	access:private
Base	src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationMatrix> Base;$/;"	t	class:Eigen::PermutationMatrix	access:private
Base	src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationWrapper> Base;$/;"	t	class:Eigen::PermutationWrapper	access:private
Base	src/Core/PlainObjectBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::PlainObjectBase	access:public
Base	src/Core/ProductBase.h	/^                       typename NestedProduct::_RhsNested> Base;$/;"	t	class:ScaledProduct	access:public
Base	src/Core/ProductBase.h	/^    typedef MatrixBase<Derived> Base;$/;"	t	class:Eigen::ProductBase	access:public
Base	src/Core/Ref.h	/^    typedef RefBase<Ref> Base;$/;"	t	class:Eigen::Ref	access:public
Base	src/Core/Ref.h	/^  typedef MapBase<Derived> Base;$/;"	t	class:Eigen::RefBase	access:public
Base	src/Core/Replicate.h	/^    typedef typename internal::dense_xpr_base<Replicate>::type Base;$/;"	t	class:Eigen::Replicate	access:public
Base	src/Core/ReturnByValue.h	/^    typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;$/;"	t	class:Eigen::ReturnByValue	access:public
Base	src/Core/Reverse.h	/^    typedef typename internal::dense_xpr_base<Reverse>::type Base;$/;"	t	class:Eigen::Reverse	access:public
Base	src/Core/Select.h	/^    typedef typename internal::dense_xpr_base<Select>::type Base;$/;"	t	class:Eigen::Select	access:public
Base	src/Core/SelfAdjointView.h	/^    typedef TriangularBase<SelfAdjointView> Base;$/;"	t	class:Eigen::SelfAdjointView	access:public
Base	src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<SelfCwiseBinaryOp>::type Base;$/;"	t	class:Eigen::SelfCwiseBinaryOp	access:public
Base	src/Core/SolveTriangular.h	/^  typedef ReturnByValue<triangular_solve_retval> Base;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Base	src/Core/Stride.h	/^    typedef Stride<0, Value> Base;$/;"	t	class:Eigen::InnerStride	access:private
Base	src/Core/Stride.h	/^    typedef Stride<Value, 0> Base;$/;"	t	class:Eigen::OuterStride	access:private
Base	src/Core/Swap.h	/^    typedef typename internal::dense_xpr_base<SwapWrapper>::type Base;$/;"	t	class:Eigen::SwapWrapper	access:public
Base	src/Core/Transpose.h	/^    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::Transpose	access:public
Base	src/Core/Transpose.h	/^    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;$/;"	t	class:Eigen::TransposeImpl	access:public
Base	src/Core/Transpositions.h	/^    typedef TranspositionsBase<Map> Base;$/;"	t	class:Eigen::Map	access:public
Base	src/Core/Transpositions.h	/^    typedef TranspositionsBase<Transpositions> Base;$/;"	t	class:Eigen::Transpositions	access:public
Base	src/Core/Transpositions.h	/^    typedef TranspositionsBase<TranspositionsWrapper> Base;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Base	src/Core/TriangularMatrix.h	/^    typedef TriangularBase<TriangularView> Base;$/;"	t	class:Eigen::TriangularView	access:public
Base	src/Core/VectorBlock.h	/^                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1> Base;$/;"	t	class:Eigen::VectorBlock	access:private
Base	src/Core/VectorwiseOp.h	/^    typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;$/;"	t	class:Eigen::PartialReduxExpr	access:public
Base	src/Core/products/CoeffBasedProduct.h	/^    typedef MatrixBase<CoeffBasedProduct> Base;$/;"	t	class:Eigen::CoeffBasedProduct	access:public
Base	src/Core/util/BlasUtil.h	/^  typedef blas_traits<NestedXpr> Base;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Base	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis	access:private
Base	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef RotationBase<Quaternion<_Scalar>,3> Base;$/;"	t	class:Eigen::Quaternion	access:private
Base	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D	access:private
Base	src/Eigen2Support/LU.h	/^    typedef FullPivLU<MatrixType> Base;$/;"	t	class:Eigen::LU	access:public
Base	src/Eigen2Support/Minor.h	/^    typedef MatrixBase<Minor> Base;$/;"	t	class:Eigen::Minor	access:public
Base	src/Eigen2Support/QR.h	/^    typedef HouseholderQR<MatrixType> Base;$/;"	t	class:Eigen::QR	access:public
Base	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef SelfAdjointEigenSolver<_MatrixType> Base;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:private
Base	src/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis	access:private
Base	src/Geometry/Homogeneous.h	/^    typedef MatrixBase<Homogeneous> Base;$/;"	t	class:Eigen::Homogeneous	access:public
Base	src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map	access:private
Base	src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<const Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map	access:private
Base	src/Geometry/Quaternion.h	/^  typedef QuaternionBase<Quaternion<_Scalar,_Options> > Base;$/;"	t	class:Eigen::Quaternion	access:private
Base	src/Geometry/Quaternion.h	/^  typedef RotationBase<Derived, 3> Base;$/;"	t	class:Eigen::QuaternionBase	access:private
Base	src/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D	access:private
Base	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef IterativeSolverBase<BiCGSTAB> Base;$/;"	t	class:Eigen::BiCGSTAB	access:private
Base	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef IterativeSolverBase<ConjugateGradient> Base;$/;"	t	class:Eigen::ConjugateGradient	access:private
Base	src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLDLT<MatrixType, _UpLo> > Base; $/;"	t	class:Eigen::PastixLDLT	access:public
Base	src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLLT<MatrixType, _UpLo> > Base;$/;"	t	class:Eigen::PastixLLT	access:public
Base	src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLU<MatrixType> > Base;$/;"	t	class:Eigen::PastixLU	access:public
Base	src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLDLT<MatrixType,Options> > Base;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Base	src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLLT<MatrixType,_UpLo> > Base;$/;"	t	class:Eigen::PardisoLLT	access:protected
Base	src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLU<MatrixType> > Base;$/;"	t	class:Eigen::PardisoLU	access:protected
Base	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialCholesky> Base;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Base	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLDLT> Base;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Base	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLLT> Base;$/;"	t	class:Eigen::SimplicialLLT	access:public
Base	src/SparseCore/SparseBlock.h	/^      typedef typename _MatrixTypeNested::InnerIterator Base;$/;"	t	class:Eigen::BlockImpl::InnerIterator	access:private
Base	src/SparseCore/SparseBlock.h	/^      typedef typename _MatrixTypeNested::ReverseInnerIterator Base;$/;"	t	class:Eigen::BlockImpl::ReverseInnerIterator	access:private
Base	src/SparseCore/SparseCwiseBinaryOp.h	/^      BinaryOp,Lhs,Rhs, InnerIterator> Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public
Base	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private
Base	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private
Base	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:private
Base	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:private
Base	src/SparseCore/SparseDenseProduct.h	/^    typedef SparseMatrixBase<SparseDenseOuterProduct> Base;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:public
Base	src/SparseCore/SparseDenseProduct.h	/^    typedef typename _LhsNested::InnerIterator Base;$/;"	t	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:private
Base	src/SparseCore/SparseDiagonalProduct.h	/^      const Transpose<const typename Rhs::DiagonalVectorType> >::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Base	src/SparseCore/SparseDiagonalProduct.h	/^      const typename Lhs::DiagonalVectorType>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Base	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Lhs::Scalar>,const Rhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Base	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Rhs::Scalar>,const Lhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Base	src/SparseCore/SparseMatrixBase.h	/^    typedef internal::special_scalar_op_base<Derived, Scalar, RealScalar, EigenBase<Derived> > Base;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Base	src/SparseCore/SparseProduct.h	/^    typedef SparseMatrixBase<SparseSparseProduct> Base;$/;"	t	class:Eigen::SparseSparseProduct	access:public
Base	src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::InnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::InnerIterator	access:private
Base	src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::ReverseInnerIterator	access:private
Base	src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::InnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::InnerIterator	access:private
Base	src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::ReverseInnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:private
Base	src/SparseLU/SparseLU.h	/^    typedef internal::SparseLUImpl<Scalar, Index> Base;$/;"	t	class:Eigen::SparseLU	access:public
Base	src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperILU> Base;$/;"	t	class:Eigen::SuperILU	access:public
Base	src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperLU> Base;$/;"	t	class:Eigen::SuperLU	access:public
Base	src/misc/Image.h	/^  typedef ReturnByValue<image_retval_base> Base;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Base	src/misc/Kernel.h	/^  typedef ReturnByValue<kernel_retval_base> Base;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Base	src/misc/Solve.h	/^  typedef ReturnByValue<solve_retval_base> Base;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Base	src/misc/SparseSolve.h	/^  typedef ReturnByValue<sparse_solve_retval_base> Base;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
BasePlainObject	src/Core/ProductBase.h	/^    typedef typename Base::PlainObject BasePlainObject;$/;"	t	class:Eigen::ProductBase	access:public
BasisReturnType	src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
BiCGSTAB	src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB() : Base() {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:()
BiCGSTAB	src/IterativeLinearSolvers/BiCGSTAB.h	/^  explicit BiCGSTAB(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const EigenBase<MatrixDerived>& A)
BiCGSTAB	src/IterativeLinearSolvers/BiCGSTAB.h	/^class BiCGSTAB : public IterativeSolverBase<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen	inherits:IterativeSolverBase
BidiagonalType	src/SVD/UpperBidiagonalization.h	/^    typedef BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0> BidiagonalType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
BinaryFunc	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef scalar_product_op<T> BinaryFunc;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Block	src/Core/Block.h	/^    inline Block(XprType& xpr, Index a_startRow, Index a_startCol)$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol)
Block	src/Core/Block.h	/^    inline Block(XprType& xpr, Index i) : Impl(xpr,i)$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index i)
Block	src/Core/Block.h	/^    inline Block(XprType& xpr,$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)
Block	src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel> class Block$/;"	c	namespace:Eigen	inherits:BlockImpl
BlockImpl	src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol) : Impl(xpr, a_startRow, a_startCol) {}$/;"	f	class:Eigen::BlockImpl	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol)
BlockImpl	src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)
BlockImpl	src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index i) : Impl(xpr,i) {}$/;"	f	class:Eigen::BlockImpl	access:public	signature:(XprType& xpr, Index i)
BlockImpl	src/Core/Block.h	/^class BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Dense>$/;"	c	namespace:Eigen	inherits:internal::BlockImpl_dense
BlockImpl	src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const SparseMatrixType& xpr, int i)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const SparseMatrixType& xpr, int i)
BlockImpl	src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const SparseMatrixType& xpr, int startRow, int startCol, int blockRows, int blockCols)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const SparseMatrixType& xpr, int startRow, int startCol, int blockRows, int blockCols)
BlockImpl	src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const XprType& xpr, int i)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const XprType& xpr, int i)
BlockImpl	src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const XprType& xpr, int startRow, int startCol, int blockRows, int blockCols)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const XprType& xpr, int startRow, int startCol, int blockRows, int blockCols)
BlockImpl	src/SparseCore/SparseBlock.h	/^class BlockImpl<SparseMatrix<_Scalar, _Options, _Index>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
BlockImpl	src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,InnerPanel,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase,internal::no_assignment_operator
BlockImpl	src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
BlockImpl	src/SparseCore/SparseBlock.h	/^class BlockImpl<const SparseMatrix<_Scalar, _Options, _Index>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index a_startRow, Index a_startCol)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol)
BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index i)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index i)
BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index startRow, Index startCol)
BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:protected	signature:(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr,$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)
BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr,$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)
BlockImpl_dense	src/Core/Block.h	/^class BlockImpl_dense<XprType,BlockRows,BlockCols, InnerPanel,true>$/;"	c	namespace:Eigen::internal	inherits:MapBase
BlockImpl_dense	src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class BlockImpl_dense$/;"	c	namespace:Eigen::internal	inherits:internal::dense_xpr_base::type
BlockIndexVector	src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<Index,Dynamic,1> > BlockIndexVector;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
BlockScalarVector	src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<Scalar,Dynamic,1> > BlockScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
BlockSize	src/Core/products/GeneralMatrixMatrixTriangular.h	/^    BlockSize  = EIGEN_PLAIN_ENUM_MAX(mr,nr)$/;"	e	enum:Eigen::internal::tribb_kernel::__anon45
BlockType	src/Core/Block.h	/^    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::internal::BlockImpl_dense	access:private
BlockType	src/LU/PartialPivLU.h	/^  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
BlockType	src/SparseCore/SparseBlock.h	/^    typedef Block<SparseMatrixType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl	access:private
BlockType	src/SparseCore/SparseBlock.h	/^    typedef Block<XprType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl	access:private
BlockType	src/SparseCore/SparseBlock.h	/^    typedef Block<const SparseMatrixType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl	access:private
BlockType	src/SparseCore/SparseBlock.h	/^  typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::BlockImpl	access:private
BothDirections	src/Core/util/Constants.h	/^  BothDirections $/;"	e	enum:Eigen::DirectionType
BottomLeft	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomLeft	src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftCeil	src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftFloor	src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRight	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomRight	src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightCeil	src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightFloor	src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BuildType	src/Core/BandMatrix.h	/^      typedef Block<CoefficientsType,1, DiagonalSize> BuildType;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType	access:public
BuiltIn	src/Core/util/Constants.h	/^  BuiltIn$/;"	e	enum:Eigen::__anon65
CJMADD	src/Core/products/GeneralBlockPanelKernel.h	1101;"	d
COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED	src/Core/util/StaticAssert.h	/^        COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
COLAMDOrdering	src/OrderingMethods/Ordering.h	/^class COLAMDOrdering$/;"	c	namespace:Eigen
COLAMD_ASSERT	src/OrderingMethods/Eigen_Colamd.h	246;"	d
COLAMD_DEBUG0	src/OrderingMethods/Eigen_Colamd.h	240;"	d
COLAMD_DEBUG1	src/OrderingMethods/Eigen_Colamd.h	241;"	d
COLAMD_DEBUG2	src/OrderingMethods/Eigen_Colamd.h	242;"	d
COLAMD_DEBUG3	src/OrderingMethods/Eigen_Colamd.h	243;"	d
COLAMD_DEBUG4	src/OrderingMethods/Eigen_Colamd.h	244;"	d
COLAMD_DEFRAG_COUNT	src/OrderingMethods/Eigen_Colamd.h	76;"	d
COLAMD_DENSE_COL	src/OrderingMethods/Eigen_Colamd.h	73;"	d
COLAMD_DENSE_ROW	src/OrderingMethods/Eigen_Colamd.h	70;"	d
COLAMD_EMPTY	src/OrderingMethods/Eigen_Colamd.h	112;"	d
COLAMD_ERROR_A_not_present	src/OrderingMethods/Eigen_Colamd.h	89;"	d
COLAMD_ERROR_A_too_small	src/OrderingMethods/Eigen_Colamd.h	95;"	d
COLAMD_ERROR_col_length_negative	src/OrderingMethods/Eigen_Colamd.h	96;"	d
COLAMD_ERROR_internal_error	src/OrderingMethods/Eigen_Colamd.h	99;"	d
COLAMD_ERROR_ncol_negative	src/OrderingMethods/Eigen_Colamd.h	92;"	d
COLAMD_ERROR_nnz_negative	src/OrderingMethods/Eigen_Colamd.h	93;"	d
COLAMD_ERROR_nrow_negative	src/OrderingMethods/Eigen_Colamd.h	91;"	d
COLAMD_ERROR_out_of_memory	src/OrderingMethods/Eigen_Colamd.h	98;"	d
COLAMD_ERROR_p0_nonzero	src/OrderingMethods/Eigen_Colamd.h	94;"	d
COLAMD_ERROR_p_not_present	src/OrderingMethods/Eigen_Colamd.h	90;"	d
COLAMD_ERROR_row_index_out_of_bounds	src/OrderingMethods/Eigen_Colamd.h	97;"	d
COLAMD_INFO1	src/OrderingMethods/Eigen_Colamd.h	82;"	d
COLAMD_INFO2	src/OrderingMethods/Eigen_Colamd.h	83;"	d
COLAMD_INFO3	src/OrderingMethods/Eigen_Colamd.h	84;"	d
COLAMD_KNOBS	src/OrderingMethods/Eigen_Colamd.h	64;"	d
COLAMD_MAX	src/OrderingMethods/Eigen_Colamd.h	105;"	d
COLAMD_MIN	src/OrderingMethods/Eigen_Colamd.h	106;"	d
COLAMD_NDEBUG	src/OrderingMethods/Eigen_Colamd.h	57;"	d
COLAMD_OK	src/OrderingMethods/Eigen_Colamd.h	87;"	d
COLAMD_OK_BUT_JUMBLED	src/OrderingMethods/Eigen_Colamd.h	88;"	d
COLAMD_STATS	src/OrderingMethods/Eigen_Colamd.h	67;"	d
COLAMD_STATUS	src/OrderingMethods/Eigen_Colamd.h	79;"	d
COL_IS_ALIVE	src/OrderingMethods/Eigen_Colamd.h	127;"	d
COL_IS_DEAD	src/OrderingMethods/Eigen_Colamd.h	126;"	d
COL_IS_DEAD_PRINCIPAL	src/OrderingMethods/Eigen_Colamd.h	128;"	d
CanVectorizeInner	src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner =    SameType$/;"	e	enum:Eigen::internal::traits::__anon30
CanVectorizeInner	src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner = internal::traits<CoeffBasedProduct>::CanVectorizeInner$/;"	e	enum:Eigen::CoeffBasedProduct::__anon31
CanVectorizeLhs	src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon30
CanVectorizeRhs	src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeRhs = RhsRowMajor && (RhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon30
CholMatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef MatrixType CholMatrixType;$/;"	t	class:Eigen::CholmodBase	access:public
CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLLT	access:public
CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>                   CholMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>               CholMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
CholmodAuto	src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodBase	src/CholmodSupport/CholmodSupport.h	/^    CholmodBase()$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
CholmodBase	src/CholmodSupport/CholmodSupport.h	/^    CholmodBase(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
CholmodBase	src/CholmodSupport/CholmodSupport.h	/^class CholmodBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
CholmodDecomposition	src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition() : Base() { init(); }$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:()
CholmodDecomposition	src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:(const MatrixType& matrix)
CholmodDecomposition	src/CholmodSupport/CholmodSupport.h	/^class CholmodDecomposition : public CholmodBase<_MatrixType, _UpLo, CholmodDecomposition<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
CholmodLDLt	src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodMode	src/CholmodSupport/CholmodSupport.h	/^enum CholmodMode {$/;"	g	namespace:Eigen
CholmodSimplicialLDLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:()
CholmodSimplicialLDLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:(const MatrixType& matrix)
CholmodSimplicialLDLT	src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLDLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
CholmodSimplicialLLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:()
CholmodSimplicialLLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:(const MatrixType& matrix)
CholmodSimplicialLLT	src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
CholmodSimplicialLLt	src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodSupernodalLLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:()
CholmodSupernodalLLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:(const MatrixType& matrix)
CholmodSupernodalLLT	src/CholmodSupport/CholmodSupport.h	/^class CholmodSupernodalLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
CholmodSupernodalLLt	src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CoeffBasedProduct	src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const CoeffBasedProduct& other)$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(const CoeffBasedProduct& other)
CoeffBasedProduct	src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
CoeffBasedProduct	src/Core/products/CoeffBasedProduct.h	/^class CoeffBasedProduct$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
CoeffBasedProductMode	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
CoeffReadCost	src/Core/BandMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
CoeffReadCost	src/Core/BandMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon144
CoeffReadCost	src/Core/BandMatrix.h	/^    CoeffReadCost = internal::traits<_CoefficientsType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon145
CoeffReadCost	src/Core/CwiseBinaryOp.h	/^    CoeffReadCost = EIGEN_ADD_COST(Cost0,functor_traits<BinaryOp>::Cost)$/;"	e	enum:Eigen::internal::traits::__anon151
CoeffReadCost	src/Core/CwiseNullaryOp.h	/^    CoeffReadCost = functor_traits<NullaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon152
CoeffReadCost	src/Core/CwiseUnaryOp.h	/^    CoeffReadCost = EIGEN_ADD_COST(_XprTypeNested::CoeffReadCost, functor_traits<UnaryOp>::Cost)$/;"	e	enum:Eigen::internal::traits::__anon153
CoeffReadCost	src/Core/CwiseUnaryView.h	/^    CoeffReadCost = traits<_MatrixTypeNested>::CoeffReadCost + functor_traits<ViewOp>::Cost,$/;"	e	enum:Eigen::internal::traits::__anon154
CoeffReadCost	src/Core/DenseBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::DenseBase::__anon155
CoeffReadCost	src/Core/Diagonal.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon161
CoeffReadCost	src/Core/DiagonalProduct.h	/^    CoeffReadCost = EIGEN_ADD_COST(Cost0,DiagonalType::DiagonalVectorType::CoeffReadCost)$/;"	e	enum:Eigen::internal::traits::__anon166
CoeffReadCost	src/Core/Matrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon282
CoeffReadCost	src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::PermutationBase::__anon287
CoeffReadCost	src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::Transpose::__anon289
CoeffReadCost	src/Core/PermutationMatrix.h	/^    CoeffReadCost = _IndicesType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon288
CoeffReadCost	src/Core/ProductBase.h	/^    CoeffReadCost = 0 \/\/ FIXME why is it needed ?$/;"	e	enum:Eigen::internal::traits::__anon294
CoeffReadCost	src/Core/Replicate.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon309
CoeffReadCost	src/Core/Reverse.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon311
CoeffReadCost	src/Core/Select.h	/^    CoeffReadCost = traits<typename remove_all<ConditionMatrixNested>::type>::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon313
CoeffReadCost	src/Core/SelfAdjointView.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon314
CoeffReadCost	src/Core/Transpose.h	/^    CoeffReadCost = MatrixTypeNestedPlain::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon323
CoeffReadCost	src/Core/TriangularMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::TriangularBase::__anon326
CoeffReadCost	src/Core/TriangularMatrix.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon327
CoeffReadCost	src/Core/VectorwiseOp.h	/^    CoeffReadCost = TraversalSize==Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon332
CoeffReadCost	src/Core/products/CoeffBasedProduct.h	/^      CoeffReadCost = InnerSize == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon30
CoeffReadCost	src/Eigen2Support/Minor.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost \/\/ minor is used typically on tiny matrices,$/;"	e	enum:Eigen::internal::traits::__anon358
CoeffReadCost	src/Geometry/Homogeneous.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon371
CoeffReadCost	src/SparseCore/SparseDenseProduct.h	/^    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + NumTraits<Scalar>::MulCost$/;"	e	enum:Eigen::internal::traits::__anon441
CoeffReadCost	src/SparseCore/SparseDiagonalProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon442
CoeffReadCost	src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon445
CoeffReadCost	src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost*10$/;"	e	enum:Eigen::internal::traits::__anon446
CoeffReadCost	src/SparseCore/SparseMatrixBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
CoeffReadCost	src/SparseCore/SparseProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon452
CoeffReadCost	src/SparseCore/SparseVector.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon456
CoeffReturnType	src/Core/ArrayBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::ArrayBase	access:public
CoeffReturnType	src/Core/DenseBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::DenseBase	access:public
CoeffReturnType	src/Core/DenseCoeffsBase.h	/^                     >::type CoeffReturnType;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
CoeffReturnType	src/Core/MapBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MapBase	access:public
CoeffReturnType	src/Core/MatrixBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
CoeffReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::conditional<_HasDirectAccess, const Scalar&, Scalar>::type CoeffReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
CoeffVectorType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
CoeffVectorType	src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::Tridiagonalization	access:public
CoeffVectorType	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Coefficients	src/Eigen2Support/Geometry/Hyperplane.h	/^                        : int(AmbientDimAtCompileTime)+1,1> Coefficients;$/;"	t	class:Eigen::Hyperplane	access:public
Coefficients	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar, 4, 1> Coefficients;$/;"	t	class:Eigen::Quaternion	access:public
Coefficients	src/Geometry/Hyperplane.h	/^                        : Index(AmbientDimAtCompileTime)+1,1,Options> Coefficients;$/;"	t	class:Eigen::Hyperplane	access:public
Coefficients	src/Geometry/Quaternion.h	/^    typedef Map<Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Coefficients	src/Geometry/Quaternion.h	/^    typedef Map<const Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Coefficients	src/Geometry/Quaternion.h	/^    typedef typename internal::traits<Map>::Coefficients Coefficients;$/;"	t	class:Eigen::Map	access:public
Coefficients	src/Geometry/Quaternion.h	/^  typedef Matrix<_Scalar,4,1,_Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Coefficients	src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Coefficients Coefficients;$/;"	t	class:Eigen::QuaternionBase	access:public
Coefficients	src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Quaternion>::Coefficients Coefficients;$/;"	t	class:Eigen::Quaternion	access:public
CoefficientsType	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrix	access:public
CoefficientsType	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
CoefficientsType	src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
CoefficientsType	src/Core/BandMatrix.h	/^  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;$/;"	t	struct:Eigen::internal::traits	access:public
CoefficientsType	src/Core/BandMatrix.h	/^  typedef _CoefficientsType CoefficientsType;$/;"	t	struct:Eigen::internal::traits	access:public
CoherentAccessPattern	src/SparseCore/SparseUtil.h	/^const int CoherentAccessPattern     = 0x1;$/;"	m	namespace:Eigen
ColMajor	src/Core/util/Constants.h	/^  ColMajor = 0,$/;"	e	enum:Eigen::__anon66
ColPivHouseholderQR	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR()$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:()
ColPivHouseholderQR	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(Index rows, Index cols)
ColPivHouseholderQR	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
ColPivHouseholderQR	src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> class ColPivHouseholderQR$/;"	c	namespace:Eigen
ColPivHouseholderQRPreconditioner	src/Core/util/Constants.h	/^  ColPivHouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
ColSpMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor> ColSpMatrix;$/;"	t	class:Eigen::PastixBase	access:public
ColSpMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLDLT	access:public
ColSpMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLLT	access:public
ColSpMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLU	access:public
ColType	src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColType;$/;"	t	class:Eigen::JacobiSVD	access:public
ColVector	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> ColVector;$/;"	t	class:Eigen::SVD	access:private
ColVectorType	src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::LU	access:public
ColVectorType	src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
ColVectorType	src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
ColXpr	src/Core/MatrixBase.h	/^    typedef typename Base::ColXpr ColXpr;$/;"	t	class:Eigen::MatrixBase	access:public
ColXpr	src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ColXpr;$/;"	t
Colamd_Row	src/OrderingMethods/Eigen_Colamd.h	/^struct Colamd_Row$/;"	s	namespace:internal
Cols	src/Core/GeneralProduct.h	/^    Cols  = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
ColsAtCompileTime	src/Cholesky/LDLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon1
ColsAtCompileTime	src/Cholesky/LLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon2
ColsAtCompileTime	src/Core/BandMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
ColsAtCompileTime	src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon144
ColsAtCompileTime	src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon145
ColsAtCompileTime	src/Core/Block.h	/^    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,$/;"	e	enum:Eigen::internal::traits::__anon146
ColsAtCompileTime	src/Core/CwiseBinaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon150
ColsAtCompileTime	src/Core/DenseBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
ColsAtCompileTime	src/Core/Diagonal.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon161
ColsAtCompileTime	src/Core/DiagonalMatrix.h	/^      ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon163
ColsAtCompileTime	src/Core/DiagonalMatrix.h	/^    ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
ColsAtCompileTime	src/Core/DiagonalProduct.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon166
ColsAtCompileTime	src/Core/MapBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon276
ColsAtCompileTime	src/Core/Matrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon282
ColsAtCompileTime	src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon287
ColsAtCompileTime	src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon289
ColsAtCompileTime	src/Core/PermutationMatrix.h	/^    ColsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
ColsAtCompileTime	src/Core/ProductBase.h	/^    ColsAtCompileTime = traits<Rhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon294
ColsAtCompileTime	src/Core/Replicate.h	/^    ColsAtCompileTime = ColFactor==Dynamic || int(MatrixType::ColsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon309
ColsAtCompileTime	src/Core/Reverse.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon311
ColsAtCompileTime	src/Core/Select.h	/^    ColsAtCompileTime = ConditionMatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
ColsAtCompileTime	src/Core/Transpose.h	/^    ColsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon323
ColsAtCompileTime	src/Core/TriangularMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon326
ColsAtCompileTime	src/Core/VectorwiseOp.h	/^    ColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon331
ColsAtCompileTime	src/Core/products/CoeffBasedProduct.h	/^      ColsAtCompileTime = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon30
ColsAtCompileTime	src/Eigen2Support/Minor.h	/^    ColsAtCompileTime = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon358
ColsAtCompileTime	src/Eigenvalues/ComplexEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
ColsAtCompileTime	src/Eigenvalues/ComplexSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon361
ColsAtCompileTime	src/Eigenvalues/EigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon362
ColsAtCompileTime	src/Eigenvalues/GeneralizedEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
ColsAtCompileTime	src/Eigenvalues/RealQZ.h	/^        ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon365
ColsAtCompileTime	src/Eigenvalues/RealSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon366
ColsAtCompileTime	src/Eigenvalues/SelfAdjointEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon367
ColsAtCompileTime	src/Geometry/Homogeneous.h	/^    ColsAtCompileTime = Direction==Horizontal ? ColsPlusOne : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon371
ColsAtCompileTime	src/Householder/HouseholderSequence.h	/^      ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon394
ColsAtCompileTime	src/Householder/HouseholderSequence.h	/^    ColsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon393
ColsAtCompileTime	src/LU/FullPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon398
ColsAtCompileTime	src/LU/PartialPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon401
ColsAtCompileTime	src/QR/ColPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
ColsAtCompileTime	src/QR/FullPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
ColsAtCompileTime	src/QR/HouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon415
ColsAtCompileTime	src/SVD/JacobiSVD.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon422
ColsAtCompileTime	src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
ColsAtCompileTime	src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
ColsAtCompileTime	src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
ColsAtCompileTime	src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon423
ColsAtCompileTime	src/SparseCore/SparseDenseProduct.h	/^    ColsAtCompileTime    = Tr ? int(traits<Lhs>::ColsAtCompileTime)     : int(traits<Rhs>::ColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon441
ColsAtCompileTime	src/SparseCore/SparseDiagonalProduct.h	/^    ColsAtCompileTime = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon442
ColsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon446
ColsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon445
ColsAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
ColsAtCompileTime	src/SparseCore/SparseProduct.h	/^    ColsAtCompileTime    = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
ColsAtCompileTime	src/SparseCore/SparseVector.h	/^    ColsAtCompileTime = IsColVector ? 1 : Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon456
ColsAtCompileTimeMinusOne	src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTimeMinusOne = internal::decrement_size<ColsAtCompileTime>::ret$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon423
ColsBlockXpr	src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ColsBlockXpr;$/;"	t
ColsPlusOne	src/Geometry/Homogeneous.h	/^    ColsPlusOne = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon371
ColumnVectorType	src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::EigenSolver	access:protected
ColumnVectorType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:protected
ColumnVectorType	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealQZ	access:public
ColumnVectorType	src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealSchur	access:public
ColwiseReturnType	src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
CommaInitializer	src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(XprType& xpr, const DenseBase<OtherDerived>& other)
CommaInitializer	src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(XprType& xpr, const Scalar& s)
CommaInitializer	src/Core/CommaInitializer.h	/^  inline CommaInitializer(const CommaInitializer& o)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const CommaInitializer& o)
CommaInitializer	src/Core/CommaInitializer.h	/^struct CommaInitializer$/;"	s	namespace:Eigen
ComparisonName	src/Core/util/Constants.h	/^  enum ComparisonName {$/;"	g	namespace:Eigen::internal
CompleteUnrolling	src/Core/util/Constants.h	/^  CompleteUnrolling$/;"	e	enum:Eigen::__anon64
ComplexEigenSolver	src/Eigenvalues/ComplexEigenSolver.h	/^      ComplexEigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
ComplexEigenSolver	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver()$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:()
ComplexEigenSolver	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver(Index size)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(Index size)
ComplexEigenSolver	src/Eigenvalues/ComplexEigenSolver.h	/^template<typename _MatrixType> class ComplexEigenSolver$/;"	c	namespace:Eigen
ComplexMatrixType	src/Eigenvalues/ComplexSchur.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> ComplexMatrixType;$/;"	t	class:Eigen::ComplexSchur	access:public
ComplexScalar	src/Core/util/ForwardDeclarations.h	/^  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	struct:Eigen::internal::stem_function	access:public
ComplexScalar	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
ComplexScalar	src/Eigenvalues/ComplexSchur.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexSchur	access:public
ComplexScalar	src/Eigenvalues/EigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::EigenSolver	access:public
ComplexScalar	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
ComplexScalar	src/Eigenvalues/RealQZ.h	/^      typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealQZ	access:public
ComplexScalar	src/Eigenvalues/RealSchur.h	/^    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealSchur	access:public
ComplexSchur	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
ComplexSchur	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
ComplexSchur	src/Eigenvalues/ComplexSchur.h	/^template<typename _MatrixType> class ComplexSchur$/;"	c	namespace:Eigen
ComplexVectorType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ComplexVectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
CompressedStorage	src/SparseCore/CompressedStorage.h	/^    CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
CompressedStorage	src/SparseCore/CompressedStorage.h	/^    CompressedStorage(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const CompressedStorage& other)
CompressedStorage	src/SparseCore/CompressedStorage.h	/^    CompressedStorage(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size)
CompressedStorage	src/SparseCore/CompressedStorage.h	/^class CompressedStorage$/;"	c	namespace:Eigen::internal
ComputationInfo	src/Core/util/Constants.h	/^enum ComputationInfo {$/;"	g	namespace:Eigen
ComputeEigenvectors	src/Core/util/Constants.h	/^  ComputeEigenvectors = 0x80,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullU	src/Core/util/Constants.h	/^  ComputeFullU        = 0x04,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullV	src/Core/util/Constants.h	/^  ComputeFullV        = 0x10,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinU	src/Core/util/Constants.h	/^  ComputeThinU        = 0x08,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinV	src/Core/util/Constants.h	/^  ComputeThinV        = 0x20,$/;"	e	enum:Eigen::DecompositionOptions
ConditionMatrixNested	src/Core/Select.h	/^  typedef typename ConditionMatrixType::Nested ConditionMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
Conj	src/Core/Functors.h	/^    Conj = NumTraits<LhsScalar>::IsComplex$/;"	e	enum:Eigen::internal::scalar_conj_product_op::__anon171
ConjLhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
ConjLhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
ConjLhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
ConjLhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
ConjRhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
ConjRhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
ConjRhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
ConjRhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Conjugate	src/Core/BandMatrix.h	/^        Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon143
ConjugateGradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient() : Base() {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:()
ConjugateGradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^  explicit ConjugateGradient(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const EigenBase<MatrixDerived>& A)
ConjugateGradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^class ConjugateGradient : public IterativeSolverBase<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	c	namespace:Eigen	inherits:IterativeSolverBase
ConjugateReturnType	src/Householder/HouseholderSequence.h	/^    > ConjugateReturnType;$/;"	t	class:Eigen::HouseholderSequence	access:public
ConjugateReturnType	src/plugins/CommonCwiseUnaryOps.h	/^                  >::type ConjugateReturnType;$/;"	t
ConstAffinePart	src/Geometry/Transform.h	/^                              const Block<const MatrixType,Dim,HDim> >::type ConstAffinePart;$/;"	t	class:Eigen::Transform	access:public
ConstAffinePart	src/Geometry/Transform.h	/^  typedef typename TransformType::ConstAffinePart ConstAffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
ConstAlignedMapType	src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
ConstBlockType	src/SparseCore/SparseBlock.h	/^    typedef Block<const SparseMatrixType, BlockRows, BlockCols, true> ConstBlockType;$/;"	t	class:Eigen::BlockImpl	access:private
ConstColXpr	src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ConstColXpr;$/;"	t
ConstColsBlockXpr	src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ConstColsBlockXpr;$/;"	t
ConstColwiseReturnType	src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstDiagonalDynamicIndexReturnType	src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived,DynamicIndex> >::type ConstDiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
ConstDiagonalIndexReturnType	src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
ConstDiagonalReturnType	src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived> >::type ConstDiagonalReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
ConstFixedSegmentReturnType	src/plugins/BlockMethods.h	/^template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	s
ConstFixedSegmentReturnType::Type	src/plugins/BlockMethods.h	/^template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	t	struct:ConstFixedSegmentReturnType	access:public
ConstInnerVectorReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true> ConstInnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
ConstInnerVectorsReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,Dynamic,Dynamic,true> ConstInnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
ConstLinearPart	src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,Dim> ConstLinearPart;$/;"	t	class:Eigen::Transform	access:public
ConstLinearPart	src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> ConstLinearPart;$/;"	t	class:Eigen::Transform	access:public
ConstMapType	src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
ConstMatrixType	src/Geometry/Transform.h	/^  typedef const MatrixType ConstMatrixType;$/;"	t	class:Eigen::Transform	access:public
ConstNColsBlockXpr	src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
ConstNColsBlockXpr::Type	src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:ConstNColsBlockXpr	access:public
ConstNRowsBlockXpr	src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
ConstNRowsBlockXpr::Type	src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:ConstNRowsBlockXpr	access:public
ConstNormalReturnType	src/Geometry/Hyperplane.h	/^  typedef const Block<const Coefficients,AmbientDimAtCompileTime,1> ConstNormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
ConstReverseReturnType	src/Core/DenseBase.h	/^    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstRowXpr	src/plugins/BlockMethods.h	/^typedef const Block<const Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowXpr;$/;"	t
ConstRowsBlockXpr	src/plugins/BlockMethods.h	/^typedef const Block<const Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowsBlockXpr;$/;"	t
ConstRowwiseReturnType	src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstSegmentReturnType	src/plugins/BlockMethods.h	/^typedef const VectorBlock<const Derived> ConstSegmentReturnType;$/;"	t
ConstSelfAdjointViewReturnType	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
ConstStartMinusOne	src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;$/;"	t	class:Eigen::MatrixBase	access:public
ConstTranslationPart	src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,1> ConstTranslationPart;$/;"	t	class:Eigen::Transform	access:public
ConstTranslationPart	src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,1,int(Mode)==(AffineCompact)> ConstTranslationPart;$/;"	t	class:Eigen::Transform	access:public
ConstTransposeReturnType	src/Core/DenseBase.h	/^	typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstTransposeReturnType	src/Core/MatrixBase.h	/^    typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
ConstTriangularViewReturnType	src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Constant	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index nbRows, Index nbCols, const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(Index nbRows, Index nbCols, const Scalar& value)
Constant	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index size, const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& value)
Constant	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value)
Constant	src/Core/DenseBase.h	/^    Constant(Index rows, Index cols, const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols, const Scalar& value)
Constant	src/Core/DenseBase.h	/^    Constant(Index size, const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& value)
Constant	src/Core/DenseBase.h	/^    Constant(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
ConstantReturnType	src/Core/ArrayBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::ArrayBase	access:public
ConstantReturnType	src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstantReturnType	src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
ConstantReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Matrix<Scalar,Dynamic,Dynamic> > ConstantReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
CornerType	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	g	namespace:Eigen
CornerType	src/Geometry/AlignedBox.h	/^  enum CornerType$/;"	g	class:Eigen::AlignedBox	access:public
Cost	src/Core/Functors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost), \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon179
Cost	src/Core/Functors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon170
Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon207
Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon208
Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon209
Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon210
Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon211
Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon212
Cost	src/Core/Functors.h	/^    Cost = NumTraits<LhsScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon172
Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon168
Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon173
Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon174
Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon177
Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon182
Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon183
Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon184
Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,$/;"	e	enum:Eigen::internal::functor_traits::__anon186
Cost	src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon180
Cost	src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon181
Cost	src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon176
Cost	src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon175
Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon188
Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon189
Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon190
Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon191
Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon235
Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon236
Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon237
Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon238
Cost	src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon233
Cost	src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon234
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon222
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon223
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon224
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon225
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon226
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon227
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon228
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon229
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon230
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon199
Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon197
Cost	src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon196
Cost	src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon216
Cost	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon213
Cost	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon192
Cost	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon193
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon195
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon198
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon206
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon185
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon214
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon194
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon215
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon219
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon220
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon221
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon217
Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon218
Cost	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon240
Cost	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon239
Cost	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon231
Cost	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon232
Cost	src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon187
Cost	src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon295
Cost	src/Core/Redux.h	/^    Cost = (  Derived::SizeAtCompileTime == Dynamic$/;"	e	enum:Eigen::internal::redux_traits::__anon299
Cost	src/Core/VectorwiseOp.h	/^  template<typename _Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_redux	access:public
Cost	src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon337
Cost	src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon338
Cost0	src/Core/CwiseBinaryOp.h	/^    Cost0 = EIGEN_ADD_COST(LhsCoeffReadCost,RhsCoeffReadCost),$/;"	e	enum:Eigen::internal::traits::__anon151
Cost0	src/Core/DiagonalProduct.h	/^    Cost0 = EIGEN_ADD_COST(NumTraits<Scalar>::MulCost, MatrixType::CoeffReadCost),$/;"	e	enum:Eigen::internal::traits::__anon166
CostOpType	src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,TraversalSize> CostOpType;$/;"	t	struct:Eigen::internal::traits	access:public
CostOpType	src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;$/;"	t	struct:Eigen::internal::traits	access:public
CrossReturnType	src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::PlainObject CrossReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
Cwise	src/Eigen2Support/Cwise.h	/^    inline Cwise(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Cwise	access:public	signature:(const ExpressionType& matrix)
Cwise	src/Eigen2Support/Cwise.h	/^template<typename ExpressionType> class Cwise$/;"	c	namespace:Eigen
CwiseBinaryOp	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE CwiseBinaryOp(const Lhs& aLhs, const Rhs& aRhs, const BinaryOp& func = BinaryOp())$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:(const Lhs& aLhs, const Rhs& aRhs, const BinaryOp& func = BinaryOp())
CwiseBinaryOp	src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseBinaryOpImpl
CwiseBinaryOpImpl	src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
CwiseBinaryOpImpl	src/SparseCore/SparseCwiseBinaryOp.h	/^    CwiseBinaryOpImpl()$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:()
CwiseBinaryOpImpl	src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
CwiseBinaryXpr	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryFunc, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
CwiseBinaryXpr	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
CwiseNullaryOp	src/Core/CwiseNullaryOp.h	/^    CwiseNullaryOp(Index nbRows, Index nbCols, const NullaryOp& func = NullaryOp())$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index nbRows, Index nbCols, const NullaryOp& func = NullaryOp())
CwiseNullaryOp	src/Core/CwiseNullaryOp.h	/^class CwiseNullaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
CwiseProductDenseReturnType	src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> struct CwiseProductDenseReturnType {$/;"	s	class:Eigen::SparseMatrixBase	access:public
CwiseScalarEqualReturnType	src/plugins/MatrixCwiseBinaryOps.h	/^typedef CwiseBinaryOp<internal::scalar_cmp_op<Scalar,internal::cmp_EQ>, const Derived, const ConstantReturnType> CwiseScalarEqualReturnType;$/;"	t
CwiseUnaryOp	src/Core/CwiseUnaryOp.h	/^    inline CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:(const XprType& xpr, const UnaryOp& func = UnaryOp())
CwiseUnaryOp	src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseUnaryOpImpl
CwiseUnaryOpImpl	src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,XprType,Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
CwiseUnaryOpImpl	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
CwiseUnaryView	src/Core/CwiseUnaryView.h	/^    inline CwiseUnaryView(const MatrixType& mat, const ViewOp& func = ViewOp())$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:(const MatrixType& mat, const ViewOp& func = ViewOp())
CwiseUnaryView	src/Core/CwiseUnaryView.h	/^class CwiseUnaryView : public CwiseUnaryViewImpl<ViewOp, MatrixType, typename internal::traits<MatrixType>::StorageKind>$/;"	c	namespace:Eigen	inherits:CwiseUnaryViewImpl
CwiseUnaryViewImpl	src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
CwiseUnaryViewImpl	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
DEAD	src/OrderingMethods/Eigen_Colamd.h	116;"	d
DEAD_NON_PRINCIPAL	src/OrderingMethods/Eigen_Colamd.h	120;"	d
DEAD_PRINCIPAL	src/OrderingMethods/Eigen_Colamd.h	119;"	d
DECL_GSISX	src/SuperLUSupport/SuperLUSupport.h	51;"	d
DECL_GSSVX	src/SuperLUSupport/SuperLUSupport.h	15;"	d
DST_CHAN	src/Core/arch/AltiVec/PacketMath.h	55;"	d
DST_CTRL	src/Core/arch/AltiVec/PacketMath.h	56;"	d
DataRowsAtCompileTime	src/Core/BandMatrix.h	/^      DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon142
DataRowsAtCompileTime	src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon144
DataRowsAtCompileTime	src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon145
Dec	src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	src/IterativeLinearSolvers/BasicPreconditioners.h	/^  typedef DiagonalPreconditioner<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef BiCGSTAB<_MatrixType, _Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/IterativeLinearSolvers/IncompleteLUT.h	/^  typedef IncompleteLUT<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef IterativeSolverBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<_Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef SPQR<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	src/SparseLU/SparseLU.h	/^  typedef SparseLU<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/SparseLU/SparseLU.h	/^  typedef SparseLU<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	src/SparseQR/SparseQR.h	/^  typedef SparseQR<_MatrixType, OrderingType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	src/SparseQR/SparseQR.h	/^  typedef SparseQR<_MatrixType,OrderingType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
DecompositionOptions	src/Core/util/Constants.h	/^enum DecompositionOptions {$/;"	g	namespace:Eigen
DecompositionType	src/misc/Image.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
DecompositionType	src/misc/Kernel.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
DecompositionType	src/misc/Solve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
DecompositionType	src/misc/SparseSolve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Default	src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	e	enum:Eigen::Default_t
DefaultTraversal	src/Core/util/Constants.h	/^  DefaultTraversal,$/;"	e	enum:Eigen::__anon63
Default_t	src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	g	namespace:Eigen
Defined	src/Core/util/Meta.h	/^    Defined = 1$/;"	e	enum:Eigen::scalar_product_traits::__anon119
Defined	src/Core/util/Meta.h	/^    Defined = 1$/;"	e	enum:Eigen::scalar_product_traits::__anon120
Defined	src/Core/util/Meta.h	/^    Defined = 1$/;"	e	enum:Eigen::scalar_product_traits::__anon121
Defined	src/Core/util/Meta.h	/^  enum { Defined = 0 };$/;"	e	enum:Eigen::scalar_product_traits::__anon118
Dense	src/Core/util/Constants.h	/^struct Dense {};$/;"	s	namespace:Eigen
DenseBase	src/Core/DenseBase.h	/^    DenseBase()$/;"	f	class:Eigen::DenseBase	access:protected	signature:()
DenseBase	src/Core/DenseBase.h	/^    DenseBase(int,int);$/;"	p	class:Eigen::DenseBase	access:private	signature:(int,int)
DenseBase	src/Core/DenseBase.h	/^    explicit DenseBase(int);$/;"	p	class:Eigen::DenseBase	access:private	signature:(int)
DenseBase	src/Core/DenseBase.h	/^    template<typename OtherDerived> explicit DenseBase(const DenseBase<OtherDerived>&);$/;"	p	class:Eigen::DenseBase	access:private	signature:(const DenseBase<OtherDerived>&)
DenseBase	src/Core/DenseBase.h	/^template<typename Derived> class DenseBase$/;"	c	namespace:Eigen	inherits:internal::special_scalar_op_base
DenseCoeffsBase	src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
DenseCoeffsBase	src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectWriteAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
DenseCoeffsBase	src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
DenseCoeffsBase	src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
DenseIndex	src/Core/util/XprHelper.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;$/;"	t	namespace:Eigen
DenseMatrix	src/SparseQR/SparseQR.h	/^  typedef Matrix<Scalar,Dynamic,Dynamic> DenseMatrix;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType	access:public
DenseMatrixType	src/Core/BandMatrix.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
DenseMatrixType	src/Core/DiagonalMatrix.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime, 0, MaxRowsAtCompileTime, MaxColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::DiagonalBase	access:public
DenseMatrixType	src/Core/PermutationMatrix.h	/^            DenseMatrixType;$/;"	t	class:Eigen::PermutationBase	access:public
DenseMatrixType	src/Core/PermutationMatrix.h	/^    typedef typename Derived::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::Transpose	access:public
DenseMatrixType	src/Core/SelfAdjointView.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
DenseMatrixType	src/Core/TriangularMatrix.h	/^      typedef typename TriangularView<MatrixType,Mode>::DenseMatrixType DenseMatrixType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
DenseMatrixType	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularBase	access:public
DenseMatrixType	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularView	access:public
DenseMatrixType	src/Core/TriangularMatrix.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
DenseSparseProductReturnType	src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct DenseSparseProductReturnType$/;"	s	namespace:Eigen
DenseSparseProductReturnType	src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct DenseSparseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex size, DenseIndex nbRows, DenseIndex) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(nbRows)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex size, DenseIndex, DenseIndex nbCols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex nbCols)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex, DenseIndex nbRows, DenseIndex nbCols) : m_rows(nbRows), m_cols(nbCols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex nbCols)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex, DenseIndex nbRows, DenseIndex) : m_rows(nbRows) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex, DenseIndex, DenseIndex nbCols) : m_cols(nbCols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex nbCols)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseStorage&& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage&& other)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage&) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage&)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage&);$/;"	p	class:Eigen::DenseStorage	access:private	signature:(const DenseStorage&)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage$/;"	c	namespace:Eigen
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, 0, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, 0, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, 0, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseTimeSparseProduct	src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
DenseTimeSparseProduct	src/SparseCore/SparseDenseProduct.h	/^class DenseTimeSparseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
DenseTimeSparseSelfAdjointProduct	src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
DenseTimeSparseSelfAdjointProduct	src/SparseCore/SparseSelfAdjointView.h	/^class DenseTimeSparseSelfAdjointProduct$/;"	c	namespace:Eigen	inherits:ProductBase
DenseType	src/Core/DiagonalMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::DiagonalBase	access:public
DenseType	src/Core/PlainObjectBase.h	/^    typedef Derived DenseType;$/;"	t	class:Eigen::PlainObjectBase	access:public
DenseType	src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::TriangularBase	access:public
Depth	src/Core/GeneralProduct.h	/^    Depth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
Derived	src/Core/CwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:private
Derived	src/Core/CwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, XprType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Derived	src/Core/CwiseUnaryView.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
Derived	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:public
Derived	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Derived	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
DiagIndex	src/Core/Diagonal.h	/^    enum { DiagIndex = _DiagIndex };$/;"	e	enum:Eigen::Diagonal::__anon162
DiagSizeAtCompileTime	src/SVD/JacobiSVD.h	/^      DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon422
DiagVectorType	src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1> DiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Diagonal	src/Core/Diagonal.h	/^    inline Diagonal(MatrixType& matrix, Index a_index = DiagIndex) : m_matrix(matrix), m_index(a_index) {}$/;"	f	class:Eigen::Diagonal	access:public	signature:(MatrixType& matrix, Index a_index = DiagIndex)
Diagonal	src/Core/Diagonal.h	/^template<typename MatrixType, int _DiagIndex> class Diagonal$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
DiagonalBase	src/Core/DiagonalMatrix.h	/^class DiagonalBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
DiagonalDynamicIndexReturnType	src/Core/MatrixBase.h	/^    typedef Diagonal<Derived,DynamicIndex> DiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
DiagonalIndexReturnType	src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
DiagonalIntReturnType	src/Core/BandMatrix.h	/^    template<int Index> struct DiagonalIntReturnType {$/;"	s	class:Eigen::internal::BandMatrixBase	access:public
DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(const MatrixBase<OtherDerived>& other) : m_diagonal(other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix() {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(Index dim) : m_diagonal(dim) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index dim)
DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalBase<OtherDerived>& other)
DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalMatrix& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalMatrix& other)
DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const Scalar& x, const Scalar& y)
DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
DiagonalMatrix	src/Core/DiagonalMatrix.h	/^class DiagonalMatrix$/;"	c	namespace:Eigen	inherits:DiagonalBase
DiagonalPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner() : m_isInitialized(false) {}$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:()
DiagonalPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner(const MatType& mat) : m_invdiag(mat.cols())$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatType& mat)
DiagonalPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^class DiagonalPreconditioner$/;"	c	namespace:Eigen
DiagonalProduct	src/Core/DiagonalProduct.h	/^    inline DiagonalProduct(const MatrixType& matrix, const DiagonalType& diagonal)$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(const MatrixType& matrix, const DiagonalType& diagonal)
DiagonalProduct	src/Core/DiagonalProduct.h	/^class DiagonalProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
DiagonalReturnType	src/Core/MatrixBase.h	/^    typedef Diagonal<Derived> DiagonalReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
DiagonalReturnType	src/Eigenvalues/Tridiagonalization.h	/^            >::type DiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
DiagonalSize	src/Core/BandMatrix.h	/^        DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon143
DiagonalType	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type DiagonalType;$/;"	t	class:Eigen::Tridiagonalization	access:public
DiagonalVectorType	src/Core/DiagonalMatrix.h	/^    typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalWrapper	access:public
DiagonalVectorType	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalBase	access:public
DiagonalVectorType	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalMatrix	access:public
DiagonalVectorType	src/Core/DiagonalMatrix.h	/^  typedef Matrix<_Scalar,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits	access:public
DiagonalVectorType	src/Core/DiagonalMatrix.h	/^  typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits	access:public
DiagonalWrapper	src/Core/DiagonalMatrix.h	/^    inline DiagonalWrapper(DiagonalVectorType& a_diagonal) : m_diagonal(a_diagonal) {}$/;"	f	class:Eigen::DiagonalWrapper	access:public	signature:(DiagonalVectorType& a_diagonal)
DiagonalWrapper	src/Core/DiagonalMatrix.h	/^class DiagonalWrapper$/;"	c	namespace:Eigen	inherits:DiagonalBase,internal::no_assignment_operator
Dim	src/Eigen2Support/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon340
Dim	src/Eigen2Support/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon343
Dim	src/Eigen2Support/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon344
Dim	src/Eigen2Support/Geometry/Scaling.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Scaling::__anon345
Dim	src/Eigen2Support/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon346
Dim	src/Eigen2Support/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon347
Dim	src/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon370
Dim	src/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon379
Dim	src/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon380
Dim	src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon381
Dim	src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon382
Dim	src/Geometry/Transform.h	/^    Dim = Transform::Dim,$/;"	e	enum:Eigen::internal::transform_traits::__anon383
Dim	src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon387
Dim	src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon388
Dim	src/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon384
Dim	src/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon390
DirectAccessBit	src/Core/util/Constants.h	/^const unsigned int DirectAccessBit = 0x40;$/;"	m	namespace:Eigen
DirectAccessors	src/Core/util/Constants.h	/^  DirectAccessors, $/;"	e	enum:Eigen::AccessorLevels
DirectLinearAccessType	src/Core/util/BlasUtil.h	/^    >::type DirectLinearAccessType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
DirectWriteAccessors	src/Core/util/Constants.h	/^  DirectWriteAccessors$/;"	e	enum:Eigen::AccessorLevels
Direction	src/Geometry/Homogeneous.h	/^    enum { Direction = _Direction };$/;"	e	enum:Eigen::Homogeneous::__anon372
DirectionType	src/Core/util/Constants.h	/^enum DirectionType { $/;"	g	namespace:Eigen
DontAlign	src/Core/util/Constants.h	/^  DontAlign = 0x2$/;"	e	enum:Eigen::__anon66
DontAlignCols	src/Core/IO.h	/^enum { DontAlignCols = 1 };$/;"	e	enum:Eigen::__anon272
DoublePacket	src/Core/products/GeneralBlockPanelKernel.h	/^  struct DoublePacket$/;"	s	class:Eigen::internal::gebp_traits	access:public
DstHasDirectAccess	src/Core/Assign.h	/^    DstHasDirectAccess = Derived::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon130
DstHasDirectAccess	src/Core/Assign_MKL.h	/^      DstHasDirectAccess = Dst::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
DstIsAligned	src/Core/Assign.h	/^    DstIsAligned = Derived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon130
DynPlainObject	src/Core/ProductBase.h	/^    typedef Matrix<Scalar,RowsAtCompileTime==1?1:Dynamic,ColsAtCompileTime==1?1:Dynamic,BasePlainObject::Options> DynPlainObject;$/;"	t	class:Eigen::ProductBase	access:public
Dynamic	src/Core/util/Constants.h	/^const int Dynamic = -1;$/;"	m	namespace:Eigen
DynamicIndex	src/Core/util/Constants.h	/^const int DynamicIndex = 0xffffff;$/;"	m	namespace:Eigen
EIGEN2_GEOMETRY_MODULE_H	src/Eigen2Support/Geometry/All.h	2;"	d
EIGEN2_LEASTSQUARES_H	src/Eigen2Support/LeastSquares.h	11;"	d
EIGEN2_LU_H	src/Eigen2Support/LU.h	11;"	d
EIGEN2_MACROS_H	src/Eigen2Support/Macros.h	11;"	d
EIGEN2_MATH_FUNCTIONS_H	src/Eigen2Support/MathFunctions.h	11;"	d
EIGEN2_MEMORY_H	src/Eigen2Support/Memory.h	11;"	d
EIGEN2_META_H	src/Eigen2Support/Meta.h	11;"	d
EIGEN2_QR_H	src/Eigen2Support/QR.h	12;"	d
EIGEN2_SVD_H	src/Eigen2Support/SVD.h	11;"	d
EIGEN2_VECTORBLOCK_H	src/Eigen2Support/VectorBlock.h	12;"	d
EIGEN_ADD_COST	src/Core/util/Macros.h	426;"	d
EIGEN_ALIGN	src/Core/util/Macros.h	73;"	d
EIGEN_ALIGN	src/Core/util/Macros.h	75;"	d
EIGEN_ALIGN16	src/Core/util/Macros.h	296;"	d
EIGEN_ALIGN8	src/Core/util/Macros.h	295;"	d
EIGEN_ALIGNEDBOX_H	src/Geometry/AlignedBox.h	11;"	d
EIGEN_ALIGNED_ALLOCA	src/Core/util/Memory.h	583;"	d
EIGEN_ALIGNED_ALLOCATOR	src/StlSupport/details.h	15;"	d
EIGEN_ALIGN_128	src/Eigen2Support/Macros.h	16;"	d
EIGEN_ALIGN_STATICALLY	src/Core/util/Macros.h	81;"	d
EIGEN_ALIGN_STATICALLY	src/Core/util/Macros.h	83;"	d
EIGEN_ALIGN_TO_BOUNDARY	src/Core/util/Macros.h	285;"	d
EIGEN_ALLANDANY_H	src/Core/BooleanRedux.h	11;"	d
EIGEN_ALLOCA	src/Core/util/Memory.h	527;"	d
EIGEN_ALLOCA	src/Core/util/Memory.h	529;"	d
EIGEN_ALWAYS_INLINE	src/Core/util/Macros.h	156;"	d
EIGEN_ALWAYS_INLINE	src/Core/util/Macros.h	158;"	d
EIGEN_AMBIVECTOR_H	src/SparseCore/AmbiVector.h	11;"	d
EIGEN_ANGLEAXIS_H	src/Geometry/AngleAxis.h	11;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	src/Core/arch/AltiVec/PacketMath.h	27;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	src/Core/arch/Default/Settings.h	46;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	src/Core/arch/NEON/PacketMath.h	26;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	src/Core/arch/SSE/PacketMath.h	22;"	d
EIGEN_ARCH_WANTS_ALIGNMENT	src/Eigen2Support/Macros.h	18;"	d
EIGEN_ARCH_WANTS_STACK_ALIGNMENT	src/Core/util/Macros.h	64;"	d
EIGEN_ARCH_WANTS_STACK_ALIGNMENT	src/Core/util/Macros.h	66;"	d
EIGEN_ARM_PREFETCH	src/Core/arch/NEON/PacketMath.h	55;"	d
EIGEN_ARM_PREFETCH	src/Core/arch/NEON/PacketMath.h	57;"	d
EIGEN_ARM_PREFETCH	src/Core/arch/NEON/PacketMath.h	59;"	d
EIGEN_ARM_PREFETCH	src/Core/arch/NEON/PacketMath.h	62;"	d
EIGEN_ARRAYBASE_H	src/Core/ArrayBase.h	11;"	d
EIGEN_ARRAYWRAPPER_H	src/Core/ArrayWrapper.h	11;"	d
EIGEN_ARRAY_CWISE_OPERATORS_H	src/Eigen2Support/CwiseOperators.h	11;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY	src/Core/GlobalFunctions.h	21;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_UNARY	src/Core/GlobalFunctions.h	14;"	d
EIGEN_ARRAY_H	src/Core/Array.h	11;"	d
EIGEN_ASM_COMMENT	src/Core/util/Macros.h	271;"	d
EIGEN_ASSIGN_H	src/Core/Assign.h	13;"	d
EIGEN_ASSIGN_VML_H	src/Core/Assign_MKL.h	34;"	d
EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS	src/Core/arch/SSE/PacketMath.h	250;"	d
EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS	src/Core/arch/SSE/PacketMath.h	253;"	d
EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS	src/Core/arch/SSE/PacketMath.h	255;"	d
EIGEN_BANDMATRIX_H	src/Core/BandMatrix.h	11;"	d
EIGEN_BASIC_PRECONDITIONERS_H	src/IterativeLinearSolvers/BasicPreconditioners.h	11;"	d
EIGEN_BICGSTAB_H	src/IterativeLinearSolvers/BiCGSTAB.h	12;"	d
EIGEN_BIDIAGONALIZATION_H	src/SVD/UpperBidiagonalization.h	11;"	d
EIGEN_BLASUTIL_H	src/Core/util/BlasUtil.h	11;"	d
EIGEN_BLOCK2_H	src/Eigen2Support/Block.h	12;"	d
EIGEN_BLOCK_H	src/Core/Block.h	12;"	d
EIGEN_BLOCK_HOUSEHOLDER_H	src/Householder/BlockHouseholder.h	12;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	src/Core/arch/AltiVec/PacketMath.h	18;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	src/Core/arch/Default/Settings.h	31;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	src/Core/arch/NEON/PacketMath.h	20;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	src/Core/arch/SSE/PacketMath.h	18;"	d
EIGEN_CAT	src/Core/util/Macros.h	133;"	d
EIGEN_CAT2	src/Core/util/Macros.h	132;"	d
EIGEN_CHECK_BINARY_COMPATIBILIY	src/Core/CwiseBinaryOp.h	97;"	d
EIGEN_CHOLMODSUPPORT_H	src/CholmodSupport/CholmodSupport.h	11;"	d
EIGEN_COEFFBASED_PRODUCT_H	src/Core/products/CoeffBasedProduct.h	12;"	d
EIGEN_COLAMD_H	src/OrderingMethods/Eigen_Colamd.h	52;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_H	src/QR/ColPivHouseholderQR.h	12;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_MKL_H	src/QR/ColPivHouseholderQR_MKL.h	35;"	d
EIGEN_COMMAINITIALIZER_H	src/Core/CommaInitializer.h	12;"	d
EIGEN_COMPLEX_ALTIVEC_H	src/Core/arch/AltiVec/Complex.h	11;"	d
EIGEN_COMPLEX_EIGEN_SOLVER_H	src/Eigenvalues/ComplexEigenSolver.h	13;"	d
EIGEN_COMPLEX_NEON_H	src/Core/arch/NEON/Complex.h	11;"	d
EIGEN_COMPLEX_SCHUR_H	src/Eigenvalues/ComplexSchur.h	13;"	d
EIGEN_COMPLEX_SCHUR_MKL_H	src/Eigenvalues/ComplexSchur_MKL.h	34;"	d
EIGEN_COMPLEX_SSE_H	src/Core/arch/SSE/Complex.h	11;"	d
EIGEN_COMPRESSED_STORAGE_H	src/SparseCore/CompressedStorage.h	11;"	d
EIGEN_CONJUGATE_GRADIENT_H	src/IterativeLinearSolvers/ConjugateGradient.h	11;"	d
EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H	src/SparseCore/ConservativeSparseSparseProduct.h	11;"	d
EIGEN_CONSTANTS_H	src/Core/util/Constants.h	12;"	d
EIGEN_COREITERATORS_H	src/Core/CoreIterators.h	11;"	d
EIGEN_CPUID	src/Core/util/Memory.h	757;"	d
EIGEN_CPUID	src/Core/util/Memory.h	762;"	d
EIGEN_CPUID	src/Core/util/Memory.h	766;"	d
EIGEN_CPUID	src/Core/util/Memory.h	771;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	src/Core/ArrayBase.h	104;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	src/Core/ArrayBase.h	114;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	src/Core/DenseBase.h	474;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	src/Core/DenseBase.h	479;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	src/Core/MatrixBase.h	135;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	src/Core/MatrixBase.h	143;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	src/SparseCore/SparseMatrixBase.h	146;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	src/SparseCore/SparseMatrixBase.h	155;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	src/SparseCore/SparseMatrixBase.h	156;"	d
EIGEN_CWISE_BINARY_OP_H	src/Core/CwiseBinaryOp.h	12;"	d
EIGEN_CWISE_BINOP_RETURN_TYPE	src/Eigen2Support/Cwise.h	18;"	d
EIGEN_CWISE_COMP_TO_SCALAR_RETURN_TYPE	src/Eigen2Support/Cwise.h	28;"	d
EIGEN_CWISE_H	src/Eigen2Support/Cwise.h	12;"	d
EIGEN_CWISE_NULLARY_OP_H	src/Core/CwiseNullaryOp.h	11;"	d
EIGEN_CWISE_PRODUCT_RETURN_TYPE	src/Core/util/Macros.h	441;"	d
EIGEN_CWISE_UNARY_OP_H	src/Core/CwiseUnaryOp.h	12;"	d
EIGEN_CWISE_UNARY_VIEW_H	src/Core/CwiseUnaryView.h	11;"	d
EIGEN_CWISE_UNOP_RETURN_TYPE	src/Eigen2Support/Cwise.h	23;"	d
EIGEN_DBG_SPARSE	src/SparseCore/SparseUtil.h	16;"	d
EIGEN_DEBUG_ALIGNED_LOAD	src/Core/GenericPacketMath.h	27;"	d
EIGEN_DEBUG_ALIGNED_STORE	src/Core/GenericPacketMath.h	35;"	d
EIGEN_DEBUG_UNALIGNED_LOAD	src/Core/GenericPacketMath.h	31;"	d
EIGEN_DEBUG_UNALIGNED_STORE	src/Core/GenericPacketMath.h	39;"	d
EIGEN_DEBUG_VAR	src/Core/util/Macros.h	129;"	d
EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	src/Core/util/Macros.h	179;"	d
EIGEN_DEFAULT_DENSE_INDEX_TYPE	src/Core/util/Macros.h	96;"	d
EIGEN_DEFAULT_IO_FORMAT	src/Core/util/Macros.h	322;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	src/Core/util/Macros.h	90;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	src/Core/util/Macros.h	92;"	d
EIGEN_DEFAULT_SETTINGS_H	src/Core/arch/Default/Settings.h	17;"	d
EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	src/Core/util/Macros.h	180;"	d
EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION	src/StlSupport/StdDeque.h	28;"	d
EIGEN_DEFINE_STL_LIST_SPECIALIZATION	src/StlSupport/StdList.h	27;"	d
EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION	src/StlSupport/StdVector.h	21;"	d
EIGEN_DENSEBASE_H	src/Core/DenseBase.h	12;"	d
EIGEN_DENSECOEFFSBASE_H	src/Core/DenseCoeffsBase.h	11;"	d
EIGEN_DENSESTORAGEBASE_H	src/Core/PlainObjectBase.h	12;"	d
EIGEN_DENSE_PUBLIC_INTERFACE	src/Core/util/Macros.h	380;"	d
EIGEN_DEPRECATED	src/Core/util/Macros.h	245;"	d
EIGEN_DETERMINANT_H	src/LU/Determinant.h	11;"	d
EIGEN_DIAGONALMATRIX_H	src/Core/DiagonalMatrix.h	12;"	d
EIGEN_DIAGONALPRODUCT_H	src/Core/DiagonalProduct.h	12;"	d
EIGEN_DIAGONAL_H	src/Core/Diagonal.h	12;"	d
EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT	src/Core/util/Macros.h	85;"	d
EIGEN_DONT_ALIGN_STATICALLY	src/Core/util/Macros.h	71;"	d
EIGEN_DONT_INLINE	src/Core/util/Macros.h	162;"	d
EIGEN_DONT_INLINE	src/Core/util/Macros.h	164;"	d
EIGEN_DONT_INLINE	src/Core/util/Macros.h	166;"	d
EIGEN_DOT_H	src/Core/Dot.h	11;"	d
EIGEN_EIGENBASE_H	src/Core/EigenBase.h	12;"	d
EIGEN_EIGENSOLVER_H	src/Eigenvalues/EigenSolver.h	12;"	d
EIGEN_EMPTY	src/Core/util/Macros.h	329;"	d
EIGEN_EMPTY_STRUCT_CTOR	src/Core/util/XprHelper.h	18;"	d
EIGEN_EMPTY_STRUCT_CTOR	src/Core/util/XprHelper.h	22;"	d
EIGEN_EULERANGLES_H	src/Geometry/EulerAngles.h	11;"	d
EIGEN_EXPLICIT_STL_DEQUE_INSTANTIATION	src/StlSupport/StdDeque.h	18;"	d
EIGEN_EXPLICIT_STL_DEQUE_INSTANTIATION	src/StlSupport/StdDeque.h	20;"	d
EIGEN_EXPLICIT_STL_LIST_INSTANTIATION	src/StlSupport/StdList.h	17;"	d
EIGEN_EXPLICIT_STL_LIST_INSTANTIATION	src/StlSupport/StdList.h	19;"	d
EIGEN_FAST_MATH	src/Core/util/Macros.h	126;"	d
EIGEN_FLAGGED_H	src/Core/Flagged.h	11;"	d
EIGEN_FORCEALIGNEDACCESS_H	src/Core/ForceAlignedAccess.h	11;"	d
EIGEN_FORWARDDECLARATIONS_H	src/Core/util/ForwardDeclarations.h	12;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	src/Core/util/Memory.h	45;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	src/Core/util/Memory.h	47;"	d
EIGEN_FULLPIVOTINGHOUSEHOLDERQR_H	src/QR/FullPivHouseholderQR.h	12;"	d
EIGEN_FUNCTORS_H	src/Core/Functors.h	11;"	d
EIGEN_FUZZY_H	src/Core/Fuzzy.h	12;"	d
EIGEN_GCC3_OR_OLDER	src/Core/util/Macros.h	41;"	d
EIGEN_GCC3_OR_OLDER	src/Core/util/Macros.h	43;"	d
EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT	src/Core/util/Macros.h	54;"	d
EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT	src/Core/util/Macros.h	56;"	d
EIGEN_GENERALIZEDEIGENSOLVER_H	src/Eigenvalues/GeneralizedEigenSolver.h	12;"	d
EIGEN_GENERALIZEDSELFADJOINTEIGENSOLVER_H	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	12;"	d
EIGEN_GENERAL_BLOCK_PANEL_H	src/Core/products/GeneralBlockPanelKernel.h	11;"	d
EIGEN_GENERAL_MATRIX_MATRIX_H	src/Core/products/GeneralMatrixMatrix.h	11;"	d
EIGEN_GENERAL_MATRIX_MATRIX_MKL_H	src/Core/products/GeneralMatrixMatrix_MKL.h	34;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_H	src/Core/products/GeneralMatrixMatrixTriangular.h	11;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_MKL_H	src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	34;"	d
EIGEN_GENERAL_MATRIX_VECTOR_H	src/Core/products/GeneralMatrixVector.h	11;"	d
EIGEN_GENERAL_MATRIX_VECTOR_MKL_H	src/Core/products/GeneralMatrixVector_MKL.h	34;"	d
EIGEN_GENERAL_PRODUCT_H	src/Core/GeneralProduct.h	12;"	d
EIGEN_GENERIC_PACKET_MATH_H	src/Core/GenericPacketMath.h	12;"	d
EIGEN_GENERIC_PUBLIC_INTERFACE	src/Core/util/Macros.h	364;"	d
EIGEN_GEOMETRY_SSE_H	src/Geometry/arch/Geometry_SSE.h	12;"	d
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	src/Core/util/Memory.h	35;"	d
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	src/Core/util/Memory.h	37;"	d
EIGEN_GLOBAL_FUNCTIONS_H	src/Core/GlobalFunctions.h	12;"	d
EIGEN_GNUC_AT_LEAST	src/Core/util/Macros.h	22;"	d
EIGEN_GNUC_AT_LEAST	src/Core/util/Macros.h	24;"	d
EIGEN_GNUC_AT_MOST	src/Core/util/Macros.h	28;"	d
EIGEN_GNUC_AT_MOST	src/Core/util/Macros.h	30;"	d
EIGEN_HAS_BUILTIN	src/Core/util/Macros.h	115;"	d
EIGEN_HAS_BUILTIN	src/Core/util/Macros.h	117;"	d
EIGEN_HAS_FUSE_CJMADD	src/Core/arch/AltiVec/PacketMath.h	22;"	d
EIGEN_HAS_MM_MALLOC	src/Core/util/Memory.h	76;"	d
EIGEN_HAS_MM_MALLOC	src/Core/util/Memory.h	78;"	d
EIGEN_HAS_POSIX_MEMALIGN	src/Core/util/Memory.h	67;"	d
EIGEN_HAS_POSIX_MEMALIGN	src/Core/util/Memory.h	72;"	d
EIGEN_HAVE_RVALUE_REFERENCES	src/Core/util/Macros.h	109;"	d
EIGEN_HESSENBERGDECOMPOSITION_H	src/Eigenvalues/HessenbergDecomposition.h	12;"	d
EIGEN_HOMOGENEOUS_H	src/Geometry/Homogeneous.h	11;"	d
EIGEN_HOUSEHOLDER_H	src/Householder/Householder.h	12;"	d
EIGEN_HOUSEHOLDER_SEQUENCE_H	src/Householder/HouseholderSequence.h	12;"	d
EIGEN_HYPERPLANE_H	src/Geometry/Hyperplane.h	12;"	d
EIGEN_IMPLIES	src/Core/util/Macros.h	430;"	d
EIGEN_INCOMPLETE_LUT_H	src/IterativeLinearSolvers/IncompleteLUT.h	11;"	d
EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR	src/Core/util/Macros.h	332;"	d
EIGEN_INHERIT_ASSIGNMENT_OPERATORS	src/Core/util/Macros.h	354;"	d
EIGEN_INITIALIZE_COEFFS	src/Core/PlainObjectBase.h	15;"	d
EIGEN_INITIALIZE_COEFFS	src/Core/PlainObjectBase.h	18;"	d
EIGEN_INITIALIZE_COEFFS	src/Core/PlainObjectBase.h	21;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	src/Core/PlainObjectBase.h	16;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	src/Core/PlainObjectBase.h	19;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	src/Core/PlainObjectBase.h	22;"	d
EIGEN_INIT_NEON_PACKET2	src/Core/arch/NEON/PacketMath.h	44;"	d
EIGEN_INIT_NEON_PACKET2	src/Core/arch/NEON/PacketMath.h	48;"	d
EIGEN_INIT_NEON_PACKET4	src/Core/arch/NEON/PacketMath.h	45;"	d
EIGEN_INIT_NEON_PACKET4	src/Core/arch/NEON/PacketMath.h	49;"	d
EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE	src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	src/Core/DenseStorage.h	16;"	d
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	src/Core/DenseStorage.h	18;"	d
EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT	src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
EIGEN_INVERSE_H	src/LU/Inverse.h	11;"	d
EIGEN_INVERSE_SSE_H	src/LU/arch/Inverse_SSE.h	28;"	d
EIGEN_IO_H	src/Core/IO.h	12;"	d
EIGEN_ITERATIVE_SOLVER_BASE_H	src/IterativeLinearSolvers/IterativeSolverBase.h	11;"	d
EIGEN_JACOBISVD_H	src/SVD/JacobiSVD.h	11;"	d
EIGEN_JACOBISVD_MKL_H	src/SVD/JacobiSVD_MKL.h	34;"	d
EIGEN_JACOBI_H	src/Jacobi/Jacobi.h	12;"	d
EIGEN_LAZY_H	src/Eigen2Support/Lazy.h	11;"	d
EIGEN_LDLT_H	src/Cholesky/LDLT.h	14;"	d
EIGEN_LLT_H	src/Cholesky/LLT.h	11;"	d
EIGEN_LLT_MKL_H	src/Cholesky/LLT_MKL.h	34;"	d
EIGEN_LOGICAL_XOR	src/Core/util/Macros.h	428;"	d
EIGEN_LU_H	src/LU/FullPivLU.h	11;"	d
EIGEN_LU_STRUCTS	src/SparseLU/SparseLU_Structs.h	70;"	d
EIGEN_MACROS_H	src/Core/util/Macros.h	12;"	d
EIGEN_MAJOR_VERSION	src/Core/util/Macros.h	15;"	d
EIGEN_MAKESTRING	src/Core/util/Macros.h	137;"	d
EIGEN_MAKESTRING2	src/Core/util/Macros.h	136;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	src/Core/util/Memory.h	650;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF	src/Core/util/Memory.h	624;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE	src/Core/util/Memory.h	651;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW	src/Core/util/Memory.h	612;"	d
EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS	src/Core/Array.h	277;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	src/Core/Array.h	271;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	src/Core/Array.h	299;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	src/Core/Array.h	283;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	src/Core/Array.h	298;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_LARGE	src/Core/Array.h	301;"	d
EIGEN_MAKE_CWISE_BINARY_OP	src/Core/util/Macros.h	432;"	d
EIGEN_MAKE_CWISE_COMP_OP	src/plugins/ArrayCwiseBinaryOps.h	174;"	d
EIGEN_MAKE_CWISE_COMP_OP	src/plugins/ArrayCwiseBinaryOps.h	74;"	d
EIGEN_MAKE_CWISE_COMP_R_OP	src/plugins/ArrayCwiseBinaryOps.h	175;"	d
EIGEN_MAKE_CWISE_COMP_R_OP	src/plugins/ArrayCwiseBinaryOps.h	92;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	src/Core/Matrix.h	393;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	src/Core/Matrix.h	416;"	d
EIGEN_MAKE_IMAGE_HELPERS	src/misc/Image.h	68;"	d
EIGEN_MAKE_KERNEL_HELPERS	src/misc/Kernel.h	67;"	d
EIGEN_MAKE_SOLVE_HELPERS	src/misc/Solve.h	61;"	d
EIGEN_MAKE_SPARSE_SOLVE_HELPERS	src/misc/SparseSolve.h	71;"	d
EIGEN_MAKE_TYPEDEFS	src/Core/Matrix.h	385;"	d
EIGEN_MAKE_TYPEDEFS	src/Core/Matrix.h	415;"	d
EIGEN_MAKE_TYPEDEFS	src/Geometry/AlignedBox.h	372;"	d
EIGEN_MAKE_TYPEDEFS	src/Geometry/AlignedBox.h	388;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	src/Core/Matrix.h	399;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	src/Core/Matrix.h	414;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	src/Geometry/AlignedBox.h	376;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	src/Geometry/AlignedBox.h	387;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	src/Core/DenseStorage.h	59;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	src/Core/DenseStorage.h	66;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	src/Core/DenseStorage.h	72;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	src/Core/util/Memory.h	54;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	src/Core/util/Memory.h	56;"	d
EIGEN_MAPBASE_H	src/Core/MapBase.h	12;"	d
EIGEN_MAPPED_SPARSEMATRIX_H	src/SparseCore/MappedSparseMatrix.h	11;"	d
EIGEN_MAP_H	src/Core/Map.h	12;"	d
EIGEN_MATHFUNCTIONS_H	src/Core/MathFunctions.h	11;"	d
EIGEN_MATHFUNC_IMPL	src/Core/MathFunctions.h	54;"	d
EIGEN_MATHFUNC_RETVAL	src/Core/MathFunctions.h	55;"	d
EIGEN_MATH_FUNCTIONS_SSE_H	src/Core/arch/SSE/MathFunctions.h	16;"	d
EIGEN_MATRIXBASEEIGENVALUES_H	src/Eigenvalues/MatrixBaseEigenvalues.h	12;"	d
EIGEN_MATRIXBASE_H	src/Core/MatrixBase.h	12;"	d
EIGEN_MATRIXSTORAGE_H	src/Core/DenseStorage.h	13;"	d
EIGEN_MATRIX_H	src/Core/Matrix.h	12;"	d
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(all, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(all, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(any, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(any, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(blueNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(blueNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(count, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(count, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(hypotNorm, (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost );$/;"	p	namespace:Eigen::internal	signature:(hypotNorm, (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost )
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(mean, (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost);$/;"	p	namespace:Eigen::internal	signature:(mean, (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(norm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(norm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(prod, (Size-1)*NumTraits<Scalar>::MulCost);$/;"	p	namespace:Eigen::internal	signature:(prod, (Size-1)*NumTraits<Scalar>::MulCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(squaredNorm, Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(squaredNorm, Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(stableNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(stableNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(sum, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(sum, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	105;"	d
EIGEN_MEMORY_H	src/Core/util/Memory.h	20;"	d
EIGEN_META_H	src/Core/util/Meta.h	12;"	d
EIGEN_MINOR_H	src/Eigen2Support/Minor.h	11;"	d
EIGEN_MINOR_VERSION	src/Core/util/Macros.h	16;"	d
EIGEN_MISC_IMAGE_H	src/misc/Image.h	11;"	d
EIGEN_MISC_KERNEL_H	src/misc/Kernel.h	11;"	d
EIGEN_MISC_SOLVE_H	src/misc/Solve.h	11;"	d
EIGEN_MKL_DOMAIN_ALL	src/Core/util/MKL_support.h	82;"	d
EIGEN_MKL_DOMAIN_ALL	src/Core/util/MKL_support.h	84;"	d
EIGEN_MKL_DOMAIN_BLAS	src/Core/util/MKL_support.h	88;"	d
EIGEN_MKL_DOMAIN_BLAS	src/Core/util/MKL_support.h	90;"	d
EIGEN_MKL_DOMAIN_FFT	src/Core/util/MKL_support.h	94;"	d
EIGEN_MKL_DOMAIN_FFT	src/Core/util/MKL_support.h	96;"	d
EIGEN_MKL_DOMAIN_PARDISO	src/Core/util/MKL_support.h	106;"	d
EIGEN_MKL_DOMAIN_PARDISO	src/Core/util/MKL_support.h	108;"	d
EIGEN_MKL_DOMAIN_VML	src/Core/util/MKL_support.h	100;"	d
EIGEN_MKL_DOMAIN_VML	src/Core/util/MKL_support.h	102;"	d
EIGEN_MKL_EIG_SELFADJ	src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	42;"	d
EIGEN_MKL_GEMV_SPECIALIZATION	src/Core/products/GeneralMatrixVector_MKL.h	89;"	d
EIGEN_MKL_GEMV_SPECIALIZE	src/Core/products/GeneralMatrixVector_MKL.h	53;"	d
EIGEN_MKL_HEMM_L	src/Core/products/SelfadjointMatrixMatrix_MKL.h	95;"	d
EIGEN_MKL_HEMM_R	src/Core/products/SelfadjointMatrixMatrix_MKL.h	221;"	d
EIGEN_MKL_LLT	src/Cholesky/LLT_MKL.h	45;"	d
EIGEN_MKL_LU_PARTPIV	src/LU/PartialPivLU_MKL.h	44;"	d
EIGEN_MKL_QR_COLPIV	src/QR/ColPivHouseholderQR_MKL.h	43;"	d
EIGEN_MKL_QR_NOPIV	src/QR/HouseholderQR_MKL.h	45;"	d
EIGEN_MKL_RANKUPDATE_C	src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	99;"	d
EIGEN_MKL_RANKUPDATE_R	src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	74;"	d
EIGEN_MKL_RANKUPDATE_SPECIALIZE	src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	47;"	d
EIGEN_MKL_SCHUR_COMPLEX	src/Eigenvalues/ComplexSchur_MKL.h	42;"	d
EIGEN_MKL_SCHUR_REAL	src/Eigenvalues/RealSchur_MKL.h	42;"	d
EIGEN_MKL_SUPPORT_H	src/Core/util/MKL_support.h	34;"	d
EIGEN_MKL_SVD	src/SVD/JacobiSVD_MKL.h	42;"	d
EIGEN_MKL_SYMM_L	src/Core/products/SelfadjointMatrixMatrix_MKL.h	43;"	d
EIGEN_MKL_SYMM_R	src/Core/products/SelfadjointMatrixMatrix_MKL.h	170;"	d
EIGEN_MKL_SYMV_SPECIALIZATION	src/Core/products/SelfadjointMatrixVector_MKL.h	74;"	d
EIGEN_MKL_SYMV_SPECIALIZE	src/Core/products/SelfadjointMatrixVector_MKL.h	50;"	d
EIGEN_MKL_TRMM_L	src/Core/products/TriangularMatrixMatrix_MKL.h	78;"	d
EIGEN_MKL_TRMM_R	src/Core/products/TriangularMatrixMatrix_MKL.h	192;"	d
EIGEN_MKL_TRMM_SPECIALIZE	src/Core/products/TriangularMatrixMatrix_MKL.h	53;"	d
EIGEN_MKL_TRMV_CM	src/Core/products/TriangularMatrixVector_MKL.h	74;"	d
EIGEN_MKL_TRMV_RM	src/Core/products/TriangularMatrixVector_MKL.h	159;"	d
EIGEN_MKL_TRMV_SPECIALIZE	src/Core/products/TriangularMatrixVector_MKL.h	50;"	d
EIGEN_MKL_TRSM_L	src/Core/products/TriangularSolverMatrix_MKL.h	41;"	d
EIGEN_MKL_TRSM_R	src/Core/products/TriangularSolverMatrix_MKL.h	96;"	d
EIGEN_MKL_VML_DECLARE_POW_CALL	src/Core/Assign_MKL.h	162;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL	src/Core/Assign_MKL.h	143;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS	src/Core/Assign_MKL.h	182;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX	src/Core/Assign_MKL.h	178;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX_LA	src/Core/Assign_MKL.h	191;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_LA	src/Core/Assign_MKL.h	195;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL	src/Core/Assign_MKL.h	174;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL_LA	src/Core/Assign_MKL.h	187;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL_LA	src/Core/Assign_MKL.h	152;"	d
EIGEN_MKL_VML_MODE	src/Core/Assign_MKL.h	138;"	d
EIGEN_MKL_VML_SPECIALIZE_ASSIGN	src/Core/Assign_MKL.h	116;"	d
EIGEN_MKL_VML_THRESHOLD	src/Core/util/MKL_support.h	77;"	d
EIGEN_NESTBYVALUE_H	src/Core/NestByValue.h	12;"	d
EIGEN_NOALIAS_H	src/Core/NoAlias.h	11;"	d
EIGEN_NO_DEBUG	src/Core/util/Macros.h	184;"	d
EIGEN_NUMTRAITS_H	src/Core/NumTraits.h	11;"	d
EIGEN_ONLY_USED_FOR_DEBUG	src/Core/util/Macros.h	238;"	d
EIGEN_ORDERING_H	src/OrderingMethods/Ordering.h	12;"	d
EIGEN_ORTHOMETHODS_H	src/Geometry/OrthoMethods.h	12;"	d
EIGEN_PACKET_MATH_ALTIVEC_H	src/Core/arch/AltiVec/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_NEON_H	src/Core/arch/NEON/PacketMath.h	13;"	d
EIGEN_PACKET_MATH_SSE_H	src/Core/arch/SSE/PacketMath.h	11;"	d
EIGEN_PARALLELIZER_H	src/Core/products/Parallelizer.h	11;"	d
EIGEN_PARAMETRIZEDLINE_H	src/Geometry/ParametrizedLine.h	12;"	d
EIGEN_PARDISOSUPPORT_H	src/PardisoSupport/PardisoSupport.h	33;"	d
EIGEN_PARTIALLU_H	src/LU/PartialPivLU.h	12;"	d
EIGEN_PARTIALLU_LAPACK_H	src/LU/PartialPivLU_MKL.h	34;"	d
EIGEN_PARTIAL_REDUX_H	src/Core/VectorwiseOp.h	12;"	d
EIGEN_PASTIXSUPPORT_H	src/PaStiXSupport/PaStiXSupport.h	11;"	d
EIGEN_PERMISSIVE_EXPR	src/Core/util/Macros.h	170;"	d
EIGEN_PERMISSIVE_EXPR	src/Core/util/Macros.h	172;"	d
EIGEN_PERMUTATIONMATRIX_H	src/Core/PermutationMatrix.h	12;"	d
EIGEN_PLAIN_ENUM_MAX	src/Core/util/Macros.h	402;"	d
EIGEN_PLAIN_ENUM_MIN	src/Core/util/Macros.h	401;"	d
EIGEN_PREDICATE_SAME_MATRIX_SIZE	src/Core/util/StaticAssert.h	160;"	d
EIGEN_PRODUCTBASE_H	src/Core/ProductBase.h	11;"	d
EIGEN_PRODUCT_PUBLIC_INTERFACE	src/Core/ProductBase.h	46;"	d
EIGEN_QR_H	src/QR/HouseholderQR.h	13;"	d
EIGEN_QR_MKL_H	src/QR/HouseholderQR_MKL.h	35;"	d
EIGEN_QUATERNION_H	src/Geometry/Quaternion.h	12;"	d
EIGEN_RANDOM_H	src/Core/Random.h	11;"	d
EIGEN_REAL_QZ_H	src/Eigenvalues/RealQZ.h	11;"	d
EIGEN_REAL_SCHUR_H	src/Eigenvalues/RealSchur.h	12;"	d
EIGEN_REAL_SCHUR_MKL_H	src/Eigenvalues/RealSchur_MKL.h	34;"	d
EIGEN_REDUX_H	src/Core/Redux.h	12;"	d
EIGEN_REF_H	src/Core/Ref.h	11;"	d
EIGEN_REPLICATE_H	src/Core/Replicate.h	11;"	d
EIGEN_RESTRICT	src/Core/util/Macros.h	307;"	d
EIGEN_RESTRICT	src/Core/util/Macros.h	310;"	d
EIGEN_RETURNBYVALUE_H	src/Core/ReturnByValue.h	12;"	d
EIGEN_REVERSE_H	src/Core/Reverse.h	13;"	d
EIGEN_ROTATION2D_H	src/Geometry/Rotation2D.h	11;"	d
EIGEN_ROTATIONBASE_H	src/Geometry/RotationBase.h	11;"	d
EIGEN_SAEIGENSOLVER_MKL_H	src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	34;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	src/Core/util/Macros.h	35;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	src/Core/util/Macros.h	37;"	d
EIGEN_SCALING_H	src/Geometry/Scaling.h	11;"	d
EIGEN_SELECT_H	src/Core/Select.h	11;"	d
EIGEN_SELFADJOINTEIGENSOLVER_H	src/Eigenvalues/SelfAdjointEigenSolver.h	12;"	d
EIGEN_SELFADJOINTMATRIX_H	src/Core/SelfAdjointView.h	11;"	d
EIGEN_SELFADJOINTRANK2UPTADE_H	src/Core/products/SelfadjointRank2Update.h	11;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_H	src/Core/products/SelfadjointMatrixMatrix.h	11;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_MKL_H	src/Core/products/SelfadjointMatrixMatrix_MKL.h	34;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_H	src/Core/products/SelfadjointMatrixVector.h	11;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_MKL_H	src/Core/products/SelfadjointMatrixVector_MKL.h	34;"	d
EIGEN_SELFADJOINT_PRODUCT_H	src/Core/products/SelfadjointProduct.h	11;"	d
EIGEN_SELFCWISEBINARYOP_H	src/Core/SelfCwiseBinaryOp.h	11;"	d
EIGEN_SIMPLICIAL_CHOLESKY_H	src/SparseCholesky/SimplicialCholesky.h	11;"	d
EIGEN_SIMPLICIAL_CHOLESKY_IMPL_H	src/SparseCholesky/SimplicialCholesky_impl.h	46;"	d
EIGEN_SIZE_MAX	src/Core/util/Macros.h	423;"	d
EIGEN_SIZE_MIN_PREFER_DYNAMIC	src/Core/util/Macros.h	407;"	d
EIGEN_SIZE_MIN_PREFER_FIXED	src/Core/util/Macros.h	415;"	d
EIGEN_SOLVETRIANGULAR_H	src/Core/SolveTriangular.h	11;"	d
EIGEN_SPARSEDENSEPRODUCT_H	src/SparseCore/SparseDenseProduct.h	11;"	d
EIGEN_SPARSELU_GEMM_KERNEL_H	src/SparseLU/SparseLU_gemm_kernel.h	11;"	d
EIGEN_SPARSELU_MEMORY	src/SparseLU/SparseLU_Memory.h	32;"	d
EIGEN_SPARSELU_SUPERNODAL_MATRIX_H	src/SparseLU/SparseLU_SupernodalMatrix.h	12;"	d
EIGEN_SPARSELU_UTILS_H	src/SparseLU/SparseLU_Utils.h	12;"	d
EIGEN_SPARSEMATRIXBASE_H	src/SparseCore/SparseMatrixBase.h	11;"	d
EIGEN_SPARSEMATRIX_H	src/SparseCore/SparseMatrix.h	11;"	d
EIGEN_SPARSEPRODUCT_H	src/SparseCore/SparseProduct.h	11;"	d
EIGEN_SPARSEREDUX_H	src/SparseCore/SparseRedux.h	11;"	d
EIGEN_SPARSESPARSEPRODUCTWITHPRUNING_H	src/SparseCore/SparseSparseProductWithPruning.h	11;"	d
EIGEN_SPARSETRANSPOSE_H	src/SparseCore/SparseTranspose.h	11;"	d
EIGEN_SPARSETRIANGULARSOLVER_H	src/SparseCore/TriangularSolver.h	11;"	d
EIGEN_SPARSEUTIL_H	src/SparseCore/SparseUtil.h	11;"	d
EIGEN_SPARSEVECTOR_H	src/SparseCore/SparseVector.h	11;"	d
EIGEN_SPARSEVIEW_H	src/SparseCore/SparseView.h	12;"	d
EIGEN_SPARSE_AMD_H	src/OrderingMethods/Amd.h	32;"	d
EIGEN_SPARSE_BLOCK_H	src/SparseCore/SparseBlock.h	11;"	d
EIGEN_SPARSE_CWISE_BINARY_OP_H	src/SparseCore/SparseCwiseBinaryOp.h	11;"	d
EIGEN_SPARSE_CWISE_UNARY_OP_H	src/SparseCore/SparseCwiseUnaryOp.h	11;"	d
EIGEN_SPARSE_DIAGONAL_PRODUCT_H	src/SparseCore/SparseDiagonalProduct.h	11;"	d
EIGEN_SPARSE_DOT_H	src/SparseCore/SparseDot.h	11;"	d
EIGEN_SPARSE_FUZZY_H	src/SparseCore/SparseFuzzy.h	11;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR	src/SparseCore/SparseUtil.h	21;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS	src/SparseCore/SparseUtil.h	39;"	d
EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR	src/SparseCore/SparseUtil.h	32;"	d
EIGEN_SPARSE_LU_H	src/SparseLU/SparseLU.h	13;"	d
EIGEN_SPARSE_PERMUTATION_H	src/SparseCore/SparsePermutation.h	11;"	d
EIGEN_SPARSE_PUBLIC_INTERFACE	src/SparseCore/SparseUtil.h	62;"	d
EIGEN_SPARSE_QR_H	src/SparseQR/SparseQR.h	12;"	d
EIGEN_SPARSE_SELFADJOINTVIEW_H	src/SparseCore/SparseSelfAdjointView.h	11;"	d
EIGEN_SPARSE_SOLVE_H	src/misc/SparseSolve.h	11;"	d
EIGEN_SPARSE_TRIANGULARVIEW_H	src/SparseCore/SparseTriangularView.h	12;"	d
EIGEN_STABLENORM_H	src/Core/StableNorm.h	11;"	d
EIGEN_STACK_ALLOCATION_LIMIT	src/Core/util/Macros.h	315;"	d
EIGEN_STATIC_ASSERT	src/Core/util/StaticAssert.h	108;"	d
EIGEN_STATIC_ASSERT	src/Core/util/StaticAssert.h	32;"	d
EIGEN_STATIC_ASSERT_ARRAYXPR	src/Core/util/StaticAssert.h	197;"	d
EIGEN_STATIC_ASSERT_DYNAMIC_SIZE	src/Core/util/StaticAssert.h	138;"	d
EIGEN_STATIC_ASSERT_FIXED_SIZE	src/Core/util/StaticAssert.h	133;"	d
EIGEN_STATIC_ASSERT_H	src/Core/util/StaticAssert.h	12;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	src/Core/MapBase.h	14;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	src/Core/MapBase.h	243;"	d
EIGEN_STATIC_ASSERT_LVALUE	src/Core/util/StaticAssert.h	193;"	d
EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE	src/Core/util/StaticAssert.h	148;"	d
EIGEN_STATIC_ASSERT_NON_INTEGER	src/Core/util/StaticAssert.h	174;"	d
EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE	src/Core/util/StaticAssert.h	183;"	d
EIGEN_STATIC_ASSERT_SAME_VECTOR_SIZE	src/Core/util/StaticAssert.h	153;"	d
EIGEN_STATIC_ASSERT_SAME_XPR_KIND	src/Core/util/StaticAssert.h	201;"	d
EIGEN_STATIC_ASSERT_SIZE_1x1	src/Core/util/StaticAssert.h	188;"	d
EIGEN_STATIC_ASSERT_VECTOR_ONLY	src/Core/util/StaticAssert.h	128;"	d
EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE	src/Core/util/StaticAssert.h	143;"	d
EIGEN_STDDEQUE_H	src/StlSupport/StdDeque.h	12;"	d
EIGEN_STDLIST_H	src/StlSupport/StdList.h	11;"	d
EIGEN_STDVECTOR_H	src/StlSupport/StdVector.h	12;"	d
EIGEN_STD_DEQUE_SPECIALIZATION_BODY	src/StlSupport/StdDeque.h	60;"	d
EIGEN_STD_LIST_SPECIALIZATION_BODY	src/StlSupport/StdList.h	60;"	d
EIGEN_STD_VECTOR_SPECIALIZATION_BODY	src/StlSupport/StdVector.h	49;"	d
EIGEN_STL_DETAILS_H	src/StlSupport/details.h	12;"	d
EIGEN_STRIDE_H	src/Core/Stride.h	11;"	d
EIGEN_STRONG_INLINE	src/Core/util/Macros.h	143;"	d
EIGEN_STRONG_INLINE	src/Core/util/Macros.h	145;"	d
EIGEN_SUITESPARSEQRSUPPORT_H	src/SPQRSupport/SuiteSparseQRSupport.h	11;"	d
EIGEN_SUPERLUSUPPORT_H	src/SuperLUSupport/SuperLUSupport.h	11;"	d
EIGEN_SUPERLU_HAS_ILU	src/SuperLUSupport/SuperLUSupport.h	45;"	d
EIGEN_SUPERLU_HAS_ILU	src/SuperLUSupport/SuperLUSupport.h	801;"	d
EIGEN_SWAP_H	src/Core/Swap.h	11;"	d
EIGEN_TRANSFORM_H	src/Geometry/Transform.h	13;"	d
EIGEN_TRANSLATION_H	src/Geometry/Translation.h	11;"	d
EIGEN_TRANSPOSE_H	src/Core/Transpose.h	12;"	d
EIGEN_TRANSPOSITIONS_H	src/Core/Transpositions.h	11;"	d
EIGEN_TRIANGULARMATRIXVECTOR_H	src/Core/products/TriangularMatrixVector.h	11;"	d
EIGEN_TRIANGULARMATRIX_H	src/Core/TriangularMatrix.h	12;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_H	src/Core/products/TriangularMatrixMatrix.h	11;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_MKL_H	src/Core/products/TriangularMatrixMatrix_MKL.h	34;"	d
EIGEN_TRIANGULAR_MATRIX_VECTOR_MKL_H	src/Core/products/TriangularMatrixVector_MKL.h	34;"	d
EIGEN_TRIANGULAR_SOLVER2_H	src/Eigen2Support/TriangularSolver.h	11;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_H	src/Core/products/TriangularSolverMatrix.h	11;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_MKL_H	src/Core/products/TriangularSolverMatrix_MKL.h	34;"	d
EIGEN_TRIANGULAR_SOLVER_VECTOR_H	src/Core/products/TriangularSolverVector.h	11;"	d
EIGEN_TRIDIAGONALIZATION_H	src/Eigenvalues/Tridiagonalization.h	12;"	d
EIGEN_TUNE_TRIANGULAR_PANEL_WIDTH	src/Core/arch/Default/Settings.h	38;"	d
EIGEN_UMEYAMA_H	src/Geometry/Umeyama.h	11;"	d
EIGEN_UMFPACKSUPPORT_H	src/UmfPackSupport/UmfPackSupport.h	11;"	d
EIGEN_UNROLLING_LIMIT	src/Core/arch/Default/Settings.h	24;"	d
EIGEN_UNUSED	src/Core/util/Macros.h	256;"	d
EIGEN_UNUSED_VARIABLE	src/Core/util/Macros.h	267;"	d
EIGEN_USER_ALIGN16	src/Core/util/Macros.h	300;"	d
EIGEN_USER_ALIGN_TO_BOUNDARY	src/Core/util/Macros.h	299;"	d
EIGEN_USE_BLAS	src/Core/util/MKL_support.h	38;"	d
EIGEN_USE_BLAS	src/Core/util/MKL_support.h	67;"	d
EIGEN_USE_LAPACKE	src/Core/util/MKL_support.h	41;"	d
EIGEN_USE_LAPACKE	src/Core/util/MKL_support.h	49;"	d
EIGEN_USE_LAPACKE	src/Core/util/MKL_support.h	68;"	d
EIGEN_USE_LAPACKE	src/Core/util/MKL_support.h	71;"	d
EIGEN_USE_LAPACKE_STRICT	src/Core/util/MKL_support.h	70;"	d
EIGEN_USE_MKL	src/Core/util/MKL_support.h	53;"	d
EIGEN_USE_MKL	src/Core/util/MKL_support.h	60;"	d
EIGEN_USE_MKL	src/Core/util/MKL_support.h	62;"	d
EIGEN_USE_MKL_ALL	src/Core/util/MKL_support.h	66;"	d
EIGEN_USE_MKL_VML	src/Core/util/MKL_support.h	44;"	d
EIGEN_USE_MKL_VML	src/Core/util/MKL_support.h	69;"	d
EIGEN_USING_ARRAY_TYPEDEFS	src/Core/Array.h	314;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE	src/Core/Array.h	308;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE_AND_SIZE	src/Core/Array.h	303;"	d
EIGEN_VECTORBLOCK_H	src/Core/VectorBlock.h	12;"	d
EIGEN_VERSION_AT_LEAST	src/Core/util/Macros.h	18;"	d
EIGEN_VISITOR_H	src/Core/Visitor.h	11;"	d
EIGEN_WARNINGS_DISABLED	src/Core/util/DisableStupidWarnings.h	2;"	d
EIGEN_WARNINGS_DISABLED	src/Core/util/ReenableStupidWarnings.h	2;"	d
EIGEN_WORKAROUND_MSVC_STL_SUPPORT	src/StlSupport/details.h	54;"	d
EIGEN_WORLD_VERSION	src/Core/util/Macros.h	14;"	d
EIGEN_XPRHELPER_H	src/Core/util/XprHelper.h	12;"	d
EigVecMask	src/Core/util/Constants.h	/^  EigVecMask = EigenvaluesOnly | ComputeEigenvectors,$/;"	e	enum:Eigen::DecompositionOptions
Eigen	src/Cholesky/LDLT.h	/^namespace Eigen { $/;"	n
Eigen	src/Cholesky/LLT.h	/^namespace Eigen { $/;"	n
Eigen	src/Cholesky/LLT_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/CholmodSupport/CholmodSupport.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Array.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/ArrayBase.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/ArrayWrapper.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Assign.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/Assign_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/BandMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Block.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/BooleanRedux.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/CommaInitializer.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/CoreIterators.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/CwiseBinaryOp.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/CwiseNullaryOp.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/CwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/CwiseUnaryView.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/DenseBase.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/DenseCoeffsBase.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/DenseStorage.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/Diagonal.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/DiagonalMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/DiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Dot.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/EigenBase.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/Flagged.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/ForceAlignedAccess.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/Functors.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/Fuzzy.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/GeneralProduct.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/GenericPacketMath.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/GlobalFunctions.h	/^namespace Eigen$/;"	n
Eigen	src/Core/IO.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Map.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/MapBase.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/Matrix.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/MatrixBase.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/NestByValue.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/NoAlias.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/NumTraits.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/PermutationMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/PlainObjectBase.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/ProductBase.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Random.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Redux.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Ref.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Replicate.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/ReturnByValue.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/Reverse.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Select.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/SelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/SelfCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/SolveTriangular.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/StableNorm.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Stride.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Swap.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Transpose.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Transpositions.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/TriangularMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/VectorwiseOp.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/Visitor.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/arch/AltiVec/Complex.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/arch/AltiVec/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/arch/NEON/Complex.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/arch/NEON/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/arch/SSE/Complex.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/arch/SSE/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/arch/SSE/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/products/CoeffBasedProduct.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/GeneralBlockPanelKernel.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/GeneralMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/GeneralMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/GeneralMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/Parallelizer.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/SelfadjointMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/SelfadjointMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/SelfadjointProduct.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/SelfadjointRank2Update.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/TriangularMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/TriangularMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/TriangularMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/TriangularSolverMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/products/TriangularSolverVector.h	/^namespace Eigen { $/;"	n
Eigen	src/Core/util/BlasUtil.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/util/Constants.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/util/ForwardDeclarations.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/util/MKL_support.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/util/Macros.h	/^    namespace Eigen {$/;"	n
Eigen	src/Core/util/Macros.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/util/Memory.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/util/Meta.h	/^namespace Eigen {$/;"	n
Eigen	src/Core/util/StaticAssert.h	/^    namespace Eigen {$/;"	n
Eigen	src/Core/util/XprHelper.h	/^namespace Eigen {$/;"	n
Eigen	src/Eigen2Support/Block.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Cwise.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/CwiseOperators.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/LU.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Lazy.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/LeastSquares.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/MathFunctions.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Memory.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Meta.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/Minor.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/QR.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/SVD.h	/^namespace Eigen {$/;"	n
Eigen	src/Eigen2Support/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigen2Support/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/ComplexEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/ComplexSchur.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/ComplexSchur_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/EigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/GeneralizedEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/HessenbergDecomposition.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/RealQZ.h	/^namespace Eigen {$/;"	n
Eigen	src/Eigenvalues/RealSchur.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/RealSchur_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/Eigenvalues/Tridiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/EulerAngles.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/Homogeneous.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/OrthoMethods.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/Umeyama.h	/^namespace Eigen { $/;"	n
Eigen	src/Geometry/arch/Geometry_SSE.h	/^namespace Eigen { $/;"	n
Eigen	src/Householder/BlockHouseholder.h	/^namespace Eigen { $/;"	n
Eigen	src/Householder/Householder.h	/^namespace Eigen { $/;"	n
Eigen	src/Householder/HouseholderSequence.h	/^namespace Eigen { $/;"	n
Eigen	src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace Eigen { $/;"	n
Eigen	src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace Eigen { $/;"	n
Eigen	src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace Eigen { $/;"	n
Eigen	src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace Eigen { $/;"	n
Eigen	src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace Eigen { $/;"	n
Eigen	src/Jacobi/Jacobi.h	/^namespace Eigen { $/;"	n
Eigen	src/LU/Determinant.h	/^namespace Eigen { $/;"	n
Eigen	src/LU/FullPivLU.h	/^namespace Eigen { $/;"	n
Eigen	src/LU/Inverse.h	/^namespace Eigen { $/;"	n
Eigen	src/LU/PartialPivLU.h	/^namespace Eigen { $/;"	n
Eigen	src/LU/PartialPivLU_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/LU/arch/Inverse_SSE.h	/^namespace Eigen { $/;"	n
Eigen	src/MetisSupport/MetisSupport.h	/^namespace Eigen {$/;"	n
Eigen	src/OrderingMethods/Amd.h	/^namespace Eigen { $/;"	n
Eigen	src/OrderingMethods/Ordering.h	/^namespace Eigen {$/;"	n
Eigen	src/PaStiXSupport/PaStiXSupport.h	/^namespace Eigen { $/;"	n
Eigen	src/PardisoSupport/PardisoSupport.h	/^namespace Eigen { $/;"	n
Eigen	src/QR/ColPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	src/QR/ColPivHouseholderQR_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/QR/FullPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	src/QR/HouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	src/QR/HouseholderQR_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/SPQRSupport/SuiteSparseQRSupport.h	/^namespace Eigen {$/;"	n
Eigen	src/SVD/JacobiSVD.h	/^namespace Eigen { $/;"	n
Eigen	src/SVD/JacobiSVD_MKL.h	/^namespace Eigen { $/;"	n
Eigen	src/SVD/UpperBidiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCholesky/SimplicialCholesky.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCholesky/SimplicialCholesky_impl.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseCore/AmbiVector.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/CompressedStorage.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/MappedSparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseBlock.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseColEtree.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseCore/SparseCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseCwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseDenseProduct.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseDiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseDot.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseMatrixBase.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparsePermutation.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseRedux.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseSelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseSparseProductWithPruning.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseTranspose.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseTriangularView.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseUtil.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseVector.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/SparseView.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseCore/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	src/SparseLU/SparseLU.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLUImpl.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_Memory.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_Structs.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_SupernodalMatrix.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_Utils.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_column_bmod.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_column_dfs.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_copy_to_ucol.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_gemm_kernel.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_heap_relax_snode.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_kernel_bmod.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_panel_bmod.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_panel_dfs.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_pivotL.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_pruneL.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseLU/SparseLU_relax_snode.h	/^namespace Eigen {$/;"	n
Eigen	src/SparseQR/SparseQR.h	/^namespace Eigen {$/;"	n
Eigen	src/StlSupport/details.h	/^namespace Eigen {$/;"	n
Eigen	src/SuperLUSupport/SuperLUSupport.h	/^namespace Eigen { $/;"	n
Eigen	src/UmfPackSupport/UmfPackSupport.h	/^namespace Eigen { $/;"	n
Eigen	src/misc/Image.h	/^namespace Eigen { $/;"	n
Eigen	src/misc/Kernel.h	/^namespace Eigen { $/;"	n
Eigen	src/misc/Solve.h	/^namespace Eigen { $/;"	n
Eigen	src/misc/SparseSolve.h	/^namespace Eigen { $/;"	n
Eigen::ABx_lx	src/Core/util/Constants.h	/^  ABx_lx              = 0x200,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::AMDOrdering	src/OrderingMethods/Ordering.h	/^class AMDOrdering$/;"	c	namespace:Eigen
Eigen::AMDOrdering::PermutationType	src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::AMDOrdering	access:public
Eigen::AMDOrdering::operator ()	src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering	access:public	signature:(const MatrixType& mat, PermutationType& perm)
Eigen::AMDOrdering::operator ()	src/OrderingMethods/Ordering.h	/^    void operator()(const SparseSelfAdjointView<SrcType, SrcUpLo>& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering	access:public	signature:(const SparseSelfAdjointView<SrcType, SrcUpLo>& mat, PermutationType& perm)
Eigen::AccessorLevels	src/Core/util/Constants.h	/^enum AccessorLevels {$/;"	g	namespace:Eigen
Eigen::Action	src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	g	namespace:Eigen
Eigen::ActualPacketAccessBit	src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = 0x0;$/;"	m	namespace:Eigen
Eigen::ActualPacketAccessBit	src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = PacketAccessBit;$/;"	m	namespace:Eigen
Eigen::Affine	src/Core/util/Constants.h	/^  Affine        = 0x2,$/;"	e	enum:Eigen::TransformTraits
Eigen::Affine2d	src/Geometry/Transform.h	/^typedef Transform<double,2,Affine> Affine2d;$/;"	t	namespace:Eigen
Eigen::Affine2f	src/Geometry/Transform.h	/^typedef Transform<float,2,Affine> Affine2f;$/;"	t	namespace:Eigen
Eigen::Affine3d	src/Geometry/Transform.h	/^typedef Transform<double,3,Affine> Affine3d;$/;"	t	namespace:Eigen
Eigen::Affine3f	src/Geometry/Transform.h	/^typedef Transform<float,3,Affine> Affine3f;$/;"	t	namespace:Eigen
Eigen::AffineCompact	src/Core/util/Constants.h	/^  AffineCompact = 0x10 | Affine,$/;"	e	enum:Eigen::TransformTraits
Eigen::AffineCompact2d	src/Geometry/Transform.h	/^typedef Transform<double,2,AffineCompact> AffineCompact2d;$/;"	t	namespace:Eigen
Eigen::AffineCompact2f	src/Geometry/Transform.h	/^typedef Transform<float,2,AffineCompact> AffineCompact2f;$/;"	t	namespace:Eigen
Eigen::AffineCompact3d	src/Geometry/Transform.h	/^typedef Transform<double,3,AffineCompact> AffineCompact3d;$/;"	t	namespace:Eigen
Eigen::AffineCompact3f	src/Geometry/Transform.h	/^typedef Transform<float,3,AffineCompact> AffineCompact3f;$/;"	t	namespace:Eigen
Eigen::Aligned	src/Core/util/Constants.h	/^  Aligned=1 $/;"	e	enum:Eigen::__anon62
Eigen::AlignedBit	src/Core/util/Constants.h	/^const unsigned int AlignedBit = 0x80;$/;"	m	namespace:Eigen
Eigen::AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
Eigen::AlignedBox	src/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
Eigen::AlignedBox::AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox(const VectorType& _min, const VectorType& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& _min, const VectorType& _max)
Eigen::AlignedBox::AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)
Eigen::AlignedBox::AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const VectorType& p) : m_min(p), m_max(p) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p)
Eigen::AlignedBox::AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(int _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(int _dim)
Eigen::AlignedBox::AlignedBox	src/Geometry/AlignedBox.h	/^  inline AlignedBox()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::AlignedBox	src/Geometry/AlignedBox.h	/^  inline AlignedBox(const OtherVectorType1& _min, const OtherVectorType2& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const OtherVectorType1& _min, const OtherVectorType2& _max)
Eigen::AlignedBox::AlignedBox	src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(Index _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(Index _dim)
Eigen::AlignedBox::AlignedBox	src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)
Eigen::AlignedBox::AlignedBox	src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const MatrixBase<Derived>& p) : m_min(p), m_max(m_min)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p)
Eigen::AlignedBox::AmbientDimAtCompileTime	src/Eigen2Support/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon339
Eigen::AlignedBox::AmbientDimAtCompileTime	src/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon369
Eigen::AlignedBox::BottomLeft	src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomLeftCeil	src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomLeftFloor	src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomRight	src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomRightCeil	src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomRightFloor	src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::CornerType	src/Geometry/AlignedBox.h	/^  enum CornerType$/;"	g	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::Index	src/Geometry/AlignedBox.h	/^  typedef DenseIndex                                Index;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::Max	src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::Min	src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::NonInteger	src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::NonInteger      NonInteger;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::RealScalar	src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::RealScalar	src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::Real               RealScalar;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::Scalar	src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::Scalar	src/Geometry/AlignedBox.h	/^  typedef _Scalar                                   Scalar;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::ScalarTraits	src/Geometry/AlignedBox.h	/^  typedef NumTraits<Scalar>                         ScalarTraits;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::TopLeft	src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopLeftCeil	src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopLeftFloor	src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopRight	src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopRightCeil	src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopRightFloor	src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::VectorType	src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::VectorType	src/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1>  VectorType;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::cast	src/Eigen2Support/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::cast	src/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::center	src/Geometry/AlignedBox.h	/^  center() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::clamp	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
Eigen::AlignedBox::clamp	src/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
Eigen::AlignedBox::contains	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::contains	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
Eigen::AlignedBox::contains	src/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::contains	src/Geometry/AlignedBox.h	/^  inline bool contains(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p) const
Eigen::AlignedBox::corner	src/Geometry/AlignedBox.h	/^  inline VectorType corner(CornerType corner) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(CornerType corner) const
Eigen::AlignedBox::diagonal	src/Geometry/AlignedBox.h	/^  inline CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> diagonal() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::dim	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline int dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size()-1 : AmbientDimAtCompileTime; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::dim	src/Geometry/AlignedBox.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size() : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::extend	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
Eigen::AlignedBox::extend	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const VectorType& p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p)
Eigen::AlignedBox::extend	src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
Eigen::AlignedBox::extend	src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const MatrixBase<Derived>& p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p)
Eigen::AlignedBox::exteriorDistance	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar exteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
Eigen::AlignedBox::exteriorDistance	src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::exteriorDistance	src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p) const
Eigen::AlignedBox::intersection	src/Geometry/AlignedBox.h	/^  inline AlignedBox intersection(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::intersects	src/Geometry/AlignedBox.h	/^  inline bool intersects(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::isApprox	src/Eigen2Support/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::AlignedBox::isApprox	src/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, const RealScalar& prec = ScalarTraits::dummy_precision()) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& other, const RealScalar& prec = ScalarTraits::dummy_precision()) const
Eigen::AlignedBox::isEmpty	src/Geometry/AlignedBox.h	/^  inline bool isEmpty() const { return (m_min.array() > m_max.array()).any(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::isNull	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool isNull() const { return (m_min.cwise() > m_max).any(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::isNull	src/Geometry/AlignedBox.h	/^  inline bool isNull() const { return isEmpty(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::m_max	src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
Eigen::AlignedBox::m_max	src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
Eigen::AlignedBox::m_min	src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
Eigen::AlignedBox::m_min	src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
Eigen::AlignedBox::max	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::max	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::max	src/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::max	src/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::merged	src/Geometry/AlignedBox.h	/^  inline AlignedBox merged(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::min	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::min	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::min	src/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::min	src/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::sample	src/Geometry/AlignedBox.h	/^  inline VectorType sample() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::setEmpty	src/Geometry/AlignedBox.h	/^  inline void setEmpty()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::setNull	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline void setNull()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::setNull	src/Geometry/AlignedBox.h	/^  inline void setNull() { setEmpty(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::sizes	src/Geometry/AlignedBox.h	/^  inline const CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> sizes() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::squaredExteriorDistance	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const VectorType& p) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
Eigen::AlignedBox::squaredExteriorDistance	src/Eigen2Support/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbiantDim>::squaredExteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	signature:(const VectorType& p) const
Eigen::AlignedBox::squaredExteriorDistance	src/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const AlignedBox& b) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::squaredExteriorDistance	src/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const MatrixBase<Derived>& p) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p) const
Eigen::AlignedBox::squaredExteriorDistance	src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	signature:(const AlignedBox& b) const
Eigen::AlignedBox::squaredExteriorDistance	src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox	signature:(const MatrixBase<Derived>& a_p) const
Eigen::AlignedBox::translate	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const VectorType& t)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& t)
Eigen::AlignedBox::translate	src/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const MatrixBase<Derived>& a_t)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_t)
Eigen::AlignedBox::volume	src/Geometry/AlignedBox.h	/^  inline Scalar volume() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::~AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::~AlignedBox	src/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedScaling2d	src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,2> AlignedScaling2d;$/;"	t	namespace:Eigen
Eigen::AlignedScaling2f	src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 2> AlignedScaling2f;$/;"	t	namespace:Eigen
Eigen::AlignedScaling3d	src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,3> AlignedScaling3d;$/;"	t	namespace:Eigen
Eigen::AlignedScaling3f	src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 3> AlignedScaling3f;$/;"	t	namespace:Eigen
Eigen::AllAtOnceTraversal	src/Core/util/Constants.h	/^  AllAtOnceTraversal$/;"	e	enum:Eigen::__anon63
Eigen::AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::AngleAxis	src/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::AngleAxis::AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(Scalar angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:(Scalar angle, const MatrixBase<Derived>& axis)
Eigen::AngleAxis::AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(const QuaternionType& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& q)
Eigen::AngleAxis::AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis<OtherScalarType>& other)
Eigen::AngleAxis::AngleAxis	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::AngleAxis	src/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::AngleAxis	src/Geometry/AngleAxis.h	/^  inline AngleAxis(const Scalar& angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Scalar& angle, const MatrixBase<Derived>& axis)
Eigen::AngleAxis::AngleAxis	src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis<OtherScalarType>& other)
Eigen::AngleAxis::AngleAxis	src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::AngleAxis	src/Geometry/AngleAxis.h	/^  template<typename QuatDerived> inline explicit AngleAxis(const QuaternionBase<QuatDerived>& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionBase<QuatDerived>& q)
Eigen::AngleAxis::Base	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis	access:private
Eigen::AngleAxis::Base	src/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis	access:private
Eigen::AngleAxis::Dim	src/Eigen2Support/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon340
Eigen::AngleAxis::Dim	src/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon370
Eigen::AngleAxis::Identity	src/Geometry/AngleAxis.h	/^  static inline const AngleAxis Identity() { return AngleAxis(Scalar(0), Vector3::UnitX()); }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::Matrix3	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::Matrix3	src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::QuaternionType	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::QuaternionType	src/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::Scalar	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::Scalar	src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::Vector3	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::Vector3	src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::angle	src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::angle	src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::angle	src/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::angle	src/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::axis	src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::axis	src/Eigen2Support/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::axis	src/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::axis	src/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::cast	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::cast	src/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::fromRotationMatrix	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::fromRotationMatrix	src/Geometry/AngleAxis.h	/^  AngleAxis& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::fromRotationMatrix	src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
Eigen::AngleAxis::inverse	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::inverse	src/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::isApprox	src/Eigen2Support/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::AngleAxis::isApprox	src/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::AngleAxis::m_angle	src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis	access:protected
Eigen::AngleAxis::m_angle	src/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis	access:protected
Eigen::AngleAxis::m_axis	src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis	access:protected
Eigen::AngleAxis::m_axis	src/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis	access:protected
Eigen::AngleAxis::operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const QuaternionType& a, const AngleAxis& b)
Eigen::AngleAxis::operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Matrix3 operator* (const Matrix3& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Matrix3& other) const
Eigen::AngleAxis::operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other) const
Eigen::AngleAxis::operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& other) const
Eigen::AngleAxis::operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Vector3 operator* (const Vector3& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Vector3& other) const
Eigen::AngleAxis::operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline friend Matrix3 operator* (const Matrix3& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const Matrix3& a, const AngleAxis& b)
Eigen::AngleAxis::operator *	src/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const QuaternionType& a, const AngleAxis& b)
Eigen::AngleAxis::operator *	src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other) const
Eigen::AngleAxis::operator *	src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& other) const
Eigen::AngleAxis::operator =	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::operator =	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const QuaternionType& q);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& q)
Eigen::AngleAxis::operator =	src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
Eigen::AngleAxis::operator =	src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionType& q)$/;"	f	class:Eigen::AngleAxis	signature:(const QuaternionType& q)
Eigen::AngleAxis::operator =	src/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::operator =	src/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const QuaternionBase<QuatDerived>& q);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const QuaternionBase<QuatDerived>& q)
Eigen::AngleAxis::operator =	src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
Eigen::AngleAxis::operator =	src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionBase<QuatDerived>& q)$/;"	f	class:Eigen::AngleAxis	signature:(const QuaternionBase<QuatDerived>& q)
Eigen::AngleAxis::toRotationMatrix	src/Eigen2Support/Geometry/AngleAxis.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::AngleAxis	access:public	signature:(void) const
Eigen::AngleAxis::toRotationMatrix	src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis	signature:(void) const
Eigen::AngleAxis::toRotationMatrix	src/Geometry/AngleAxis.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::AngleAxis	access:public	signature:(void) const
Eigen::AngleAxis::toRotationMatrix	src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis	signature:(void) const
Eigen::AngleAxisd	src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
Eigen::AngleAxisd	src/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
Eigen::AngleAxisf	src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
Eigen::AngleAxisf	src/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
Eigen::Architecture	src/Core/util/Constants.h	/^namespace Architecture$/;"	n	namespace:Eigen
Eigen::Architecture::AltiVec	src/Core/util/Constants.h	/^    AltiVec = 0x2,$/;"	e	enum:Eigen::Architecture::Type
Eigen::Architecture::Generic	src/Core/util/Constants.h	/^    Generic = 0x0,$/;"	e	enum:Eigen::Architecture::Type
Eigen::Architecture::SSE	src/Core/util/Constants.h	/^    SSE = 0x1,$/;"	e	enum:Eigen::Architecture::Type
Eigen::Architecture::Target	src/Core/util/Constants.h	/^    Target = SSE$/;"	e	enum:Eigen::Architecture::Type
Eigen::Architecture::Type	src/Core/util/Constants.h	/^  enum Type {$/;"	g	namespace:Eigen::Architecture
Eigen::Array	src/Core/Array.h	/^class Array$/;"	c	namespace:Eigen	inherits:PlainObjectBase
Eigen::Array::Array	src/Core/Array.h	/^    Array(Array&& other)$/;"	f	class:Eigen::Array	access:public	signature:(Array&& other)
Eigen::Array::Array	src/Core/Array.h	/^    Array(Index rows, Index cols);$/;"	p	class:Eigen::Array	access:public	signature:(Index rows, Index cols)
Eigen::Array::Array	src/Core/Array.h	/^    Array(const Scalar& val0, const Scalar& val1);$/;"	p	class:Eigen::Array	access:public	signature:(const Scalar& val0, const Scalar& val1)
Eigen::Array::Array	src/Core/Array.h	/^    Array(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Array	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::Array::Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array() : Base()$/;"	f	class:Eigen::Array	access:public	signature:()
Eigen::Array::Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Array& other)$/;"	f	class:Eigen::Array	access:public	signature:(const Array& other)
Eigen::Array::Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::Array::Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::Array::Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::Array::Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2)$/;"	f	class:Eigen::Array	access:public	signature:(const Scalar& val0, const Scalar& val1, const Scalar& val2)
Eigen::Array::Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2, const Scalar& val3)$/;"	f	class:Eigen::Array	access:public	signature:(const Scalar& val0, const Scalar& val1, const Scalar& val2, const Scalar& val3)
Eigen::Array::Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const T0& val0, const T1& val1)$/;"	f	class:Eigen::Array	access:public	signature:(const T0& val0, const T1& val1)
Eigen::Array::Array	src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array(Index dim)$/;"	f	class:Eigen::Array	access:public	signature:(Index dim)
Eigen::Array::Array	src/Core/Array.h	/^    explicit Array(const Scalar *data);$/;"	p	class:Eigen::Array	access:public	signature:(const Scalar *data)
Eigen::Array::Array	src/Core/Map.h	/^  ::Array(const Scalar *data)$/;"	f	class:Eigen::Array	signature:(const Scalar *data)
Eigen::Array::Base	src/Core/Array.h	/^    typedef PlainObjectBase<Array> Base;$/;"	t	class:Eigen::Array	access:public
Eigen::Array::Options	src/Core/Array.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Array::__anon127
Eigen::Array::PlainObject	src/Core/Array.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Array	access:public
Eigen::Array::innerStride	src/Core/Array.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Array	access:public	signature:() const
Eigen::Array::operator =	src/Core/Array.h	/^    Array& operator=(Array&& other)$/;"	f	class:Eigen::Array	access:public	signature:(Array&& other)
Eigen::Array::operator =	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Array& other)$/;"	f	class:Eigen::Array	access:public	signature:(const Array& other)
Eigen::Array::operator =	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::Array::operator =	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::Array::outerStride	src/Core/Array.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Array	access:public	signature:() const
Eigen::Array::swap	src/Core/Array.h	/^    void swap(ArrayBase<OtherDerived> const & other)$/;"	f	class:Eigen::Array	access:public	signature:(ArrayBase<OtherDerived> const & other)
Eigen::ArrayBase	src/Core/ArrayBase.h	/^template<typename Derived> class ArrayBase$/;"	c	namespace:Eigen	inherits:DenseBase
Eigen::ArrayBase::ArrayBase	src/Core/ArrayBase.h	/^    ArrayBase() : Base() {}$/;"	f	class:Eigen::ArrayBase	access:protected	signature:()
Eigen::ArrayBase::ArrayBase	src/Core/ArrayBase.h	/^    ArrayBase(Index,Index);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(Index,Index)
Eigen::ArrayBase::ArrayBase	src/Core/ArrayBase.h	/^    explicit ArrayBase(Index);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(Index)
Eigen::ArrayBase::ArrayBase	src/Core/ArrayBase.h	/^    template<typename OtherDerived> explicit ArrayBase(const ArrayBase<OtherDerived>&);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(const ArrayBase<OtherDerived>&)
Eigen::ArrayBase::Base	src/Core/ArrayBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::CoeffReturnType	src/Core/ArrayBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::ConstantReturnType	src/Core/ArrayBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl	src/Core/ArrayBase.h	/^    typedef ArrayBase Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::Index	src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::PacketScalar	src/Core/ArrayBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::PlainObject	src/Core/ArrayBase.h	/^          > PlainObject;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::RealScalar	src/Core/ArrayBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::Scalar	src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::StorageBaseType	src/Core/ArrayBase.h	/^    typedef ArrayBase StorageBaseType;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::StorageKind	src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::array	src/Core/ArrayBase.h	/^    ArrayBase<Derived>& array() { return *this; }$/;"	f	class:Eigen::ArrayBase	access:public	signature:()
Eigen::ArrayBase::array	src/Core/ArrayBase.h	/^    const ArrayBase<Derived>& array() const { return *this; }$/;"	f	class:Eigen::ArrayBase	access:public	signature:() const
Eigen::ArrayBase::matrix	src/Core/ArrayBase.h	/^    MatrixWrapper<Derived> matrix() { return derived(); }$/;"	f	class:Eigen::ArrayBase	access:public	signature:()
Eigen::ArrayBase::matrix	src/Core/ArrayBase.h	/^    const MatrixWrapper<const Derived> matrix() const { return derived(); }$/;"	f	class:Eigen::ArrayBase	access:public	signature:() const
Eigen::ArrayBase::operator *=	src/Core/ArrayBase.h	/^    Derived& operator*=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator *=	src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator*=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator +=	src/Core/ArrayBase.h	/^    Derived& operator+=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator +=	src/Core/ArrayBase.h	/^    Derived& operator+=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const Scalar& scalar)
Eigen::ArrayBase::operator +=	src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator+=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase	access:protected	signature:(const MatrixBase<OtherDerived>& )
Eigen::ArrayBase::operator +=	src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator+=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator -=	src/Core/ArrayBase.h	/^    Derived& operator-=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator -=	src/Core/ArrayBase.h	/^    Derived& operator-=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const Scalar& scalar)
Eigen::ArrayBase::operator -=	src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator-=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase	access:protected	signature:(const MatrixBase<OtherDerived>& )
Eigen::ArrayBase::operator -=	src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator-=(const ArrayBase<OtherDerived> &other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived> &other)
Eigen::ArrayBase::operator /=	src/Core/ArrayBase.h	/^    Derived& operator\/=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator /=	src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator\/=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator =	src/Core/ArrayBase.h	/^    Derived& operator=(const ArrayBase& other)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase& other)
Eigen::ArrayWrapper	src/Core/ArrayWrapper.h	/^class ArrayWrapper : public ArrayBase<ArrayWrapper<ExpressionType> >$/;"	c	namespace:Eigen	inherits:ArrayBase
Eigen::ArrayWrapper::ArrayWrapper	src/Core/ArrayWrapper.h	/^    inline ArrayWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(ExpressionType& matrix)
Eigen::ArrayWrapper::Base	src/Core/ArrayWrapper.h	/^    typedef ArrayBase<ArrayWrapper> Base;$/;"	t	class:Eigen::ArrayWrapper	access:public
Eigen::ArrayWrapper::NestedExpressionType	src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::ArrayWrapper	access:public
Eigen::ArrayWrapper::ScalarWithConstIfNotLvalue	src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::ArrayWrapper	access:public
Eigen::ArrayWrapper::coeff	src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
Eigen::ArrayWrapper::coeff	src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId) const
Eigen::ArrayWrapper::coeffRef	src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index)
Eigen::ArrayWrapper::coeffRef	src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId)
Eigen::ArrayWrapper::coeffRef	src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
Eigen::ArrayWrapper::coeffRef	src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId) const
Eigen::ArrayWrapper::cols	src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::data	src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.const_cast_derived().data(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:()
Eigen::ArrayWrapper::data	src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::evalTo	src/Core/ArrayWrapper.h	/^    inline void evalTo(Dest& dst) const { dst = m_expression; }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Dest& dst) const
Eigen::ArrayWrapper::innerStride	src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::m_expression	src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::ArrayWrapper	access:protected
Eigen::ArrayWrapper::nestedExpression	src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::outerStride	src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::packet	src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
Eigen::ArrayWrapper::packet	src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId) const
Eigen::ArrayWrapper::resize	src/Core/ArrayWrapper.h	/^    void resize(Index nbRows, Index nbCols) { m_expression.const_cast_derived().resize(nbRows,nbCols); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index nbRows, Index nbCols)
Eigen::ArrayWrapper::resize	src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.const_cast_derived().resize(newSize); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index newSize)
Eigen::ArrayWrapper::rows	src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::writePacket	src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index, const PacketScalar& val)
Eigen::ArrayWrapper::writePacket	src/Core/ArrayWrapper.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId, const PacketScalar& val)
Eigen::ArrayXpr	src/Core/util/Constants.h	/^struct ArrayXpr {};$/;"	s	namespace:Eigen
Eigen::AutoAlign	src/Core/util/Constants.h	/^  AutoAlign = 0,$/;"	e	enum:Eigen::__anon66
Eigen::Ax_lBx	src/Core/util/Constants.h	/^  Ax_lBx              = 0x100,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::BAx_lx	src/Core/util/Constants.h	/^  BAx_lx              = 0x400,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::BiCGSTAB	src/IterativeLinearSolvers/BiCGSTAB.h	/^class BiCGSTAB : public IterativeSolverBase<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen	inherits:IterativeSolverBase
Eigen::BiCGSTAB::Base	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef IterativeSolverBase<BiCGSTAB> Base;$/;"	t	class:Eigen::BiCGSTAB	access:private
Eigen::BiCGSTAB::BiCGSTAB	src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB() : Base() {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:()
Eigen::BiCGSTAB::BiCGSTAB	src/IterativeLinearSolvers/BiCGSTAB.h	/^  explicit BiCGSTAB(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const EigenBase<MatrixDerived>& A)
Eigen::BiCGSTAB::Index	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::MatrixType	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::Preconditioner	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::RealScalar	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::Scalar	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::_solve	src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::BiCGSTAB::_solveWithGuess	src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::BiCGSTAB::solveWithGuess	src/IterativeLinearSolvers/BiCGSTAB.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const MatrixBase<Rhs>& b, const Guess& x0) const
Eigen::BiCGSTAB::~BiCGSTAB	src/IterativeLinearSolvers/BiCGSTAB.h	/^  ~BiCGSTAB() {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:()
Eigen::Block	src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel> class Block$/;"	c	namespace:Eigen	inherits:BlockImpl
Eigen::Block::Base	src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::Block	access:public
Eigen::Block::Block	src/Core/Block.h	/^    inline Block(XprType& xpr, Index a_startRow, Index a_startCol)$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol)
Eigen::Block::Block	src/Core/Block.h	/^    inline Block(XprType& xpr, Index i) : Impl(xpr,i)$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index i)
Eigen::Block::Block	src/Core/Block.h	/^    inline Block(XprType& xpr,$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)
Eigen::Block::Impl	src/Core/Block.h	/^    typedef BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, typename internal::traits<XprType>::StorageKind> Impl;$/;"	t	class:Eigen::Block	access:private
Eigen::BlockImpl	src/Core/Block.h	/^class BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Dense>$/;"	c	namespace:Eigen	inherits:internal::BlockImpl_dense
Eigen::BlockImpl	src/SparseCore/SparseBlock.h	/^class BlockImpl<SparseMatrix<_Scalar, _Options, _Index>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::BlockImpl	src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,InnerPanel,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase,internal::no_assignment_operator
Eigen::BlockImpl	src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::BlockImpl	src/SparseCore/SparseBlock.h	/^class BlockImpl<const SparseMatrix<_Scalar, _Options, _Index>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::BlockImpl::Base	src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::BlockImpl	access:public
Eigen::BlockImpl::BlockImpl	src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol) : Impl(xpr, a_startRow, a_startCol) {}$/;"	f	class:Eigen::BlockImpl	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol)
Eigen::BlockImpl::BlockImpl	src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)
Eigen::BlockImpl::BlockImpl	src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index i) : Impl(xpr,i) {}$/;"	f	class:Eigen::BlockImpl	access:public	signature:(XprType& xpr, Index i)
Eigen::BlockImpl::BlockImpl	src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const SparseMatrixType& xpr, int i)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const SparseMatrixType& xpr, int i)
Eigen::BlockImpl::BlockImpl	src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const SparseMatrixType& xpr, int startRow, int startCol, int blockRows, int blockCols)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const SparseMatrixType& xpr, int startRow, int startCol, int blockRows, int blockCols)
Eigen::BlockImpl::BlockImpl	src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const XprType& xpr, int i)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const XprType& xpr, int i)
Eigen::BlockImpl::BlockImpl	src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const XprType& xpr, int startRow, int startCol, int blockRows, int blockCols)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const XprType& xpr, int startRow, int startCol, int blockRows, int blockCols)
Eigen::BlockImpl::BlockType	src/SparseCore/SparseBlock.h	/^    typedef Block<SparseMatrixType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::BlockType	src/SparseCore/SparseBlock.h	/^    typedef Block<XprType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::BlockType	src/SparseCore/SparseBlock.h	/^    typedef Block<const SparseMatrixType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::BlockType	src/SparseCore/SparseBlock.h	/^  typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::ConstBlockType	src/SparseCore/SparseBlock.h	/^    typedef Block<const SparseMatrixType, BlockRows, BlockCols, true> ConstBlockType;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::Impl	src/Core/Block.h	/^    typedef internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel> Impl;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::Index	src/Core/Block.h	/^    typedef typename XprType::Index Index;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::InnerIterator	src/SparseCore/SparseBlock.h	/^    class InnerIterator : public _MatrixTypeNested::InnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:_MatrixTypeNested::InnerIterator	access:public
Eigen::BlockImpl::InnerIterator	src/SparseCore/SparseBlock.h	/^    class InnerIterator: public SparseMatrixType::InnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:SparseMatrixType::InnerIterator	access:public
Eigen::BlockImpl::InnerIterator	src/SparseCore/SparseBlock.h	/^    class InnerIterator: public XprType::InnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:XprType::InnerIterator	access:public
Eigen::BlockImpl::InnerIterator::Base	src/SparseCore/SparseBlock.h	/^      typedef typename _MatrixTypeNested::InnerIterator Base;$/;"	t	class:Eigen::BlockImpl::InnerIterator	access:private
Eigen::BlockImpl::InnerIterator::Index	src/SparseCore/SparseBlock.h	/^        typedef typename BlockImpl::Index Index;$/;"	t	class:Eigen::BlockImpl::InnerIterator	access:private
Eigen::BlockImpl::InnerIterator::InnerIterator	src/SparseCore/SparseBlock.h	/^        inline InnerIterator(const BlockType& xpr, Index outer)$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:(const BlockType& xpr, Index outer)
Eigen::BlockImpl::InnerIterator::InnerIterator	src/SparseCore/SparseBlock.h	/^      EIGEN_STRONG_INLINE InnerIterator(const BlockType& block, Index outer)$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:(const BlockType& block, Index outer)
Eigen::BlockImpl::InnerIterator::col	src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
Eigen::BlockImpl::InnerIterator::col	src/SparseCore/SparseBlock.h	/^      inline Index col()    const { return Base::col()   - m_block.m_startCol.value(); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
Eigen::BlockImpl::InnerIterator::index	src/SparseCore/SparseBlock.h	/^      inline Index index()  const { return Base::index() - (IsRowMajor ? m_block.m_startCol.value() : m_block.m_startRow.value()); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
Eigen::BlockImpl::InnerIterator::m_block	src/SparseCore/SparseBlock.h	/^      const BlockType& m_block;$/;"	m	class:Eigen::BlockImpl::InnerIterator	access:private
Eigen::BlockImpl::InnerIterator::m_end	src/SparseCore/SparseBlock.h	/^      Index m_end;$/;"	m	class:Eigen::BlockImpl::InnerIterator	access:private
Eigen::BlockImpl::InnerIterator::m_outer	src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::BlockImpl::InnerIterator	access:protected
Eigen::BlockImpl::InnerIterator::operator bool	src/SparseCore/SparseBlock.h	/^      inline operator bool() const { return Base::operator bool() && Base::index() < m_end; }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
Eigen::BlockImpl::InnerIterator::outer	src/SparseCore/SparseBlock.h	/^      inline Index outer()  const { return Base::outer() - (IsRowMajor ? m_block.m_startRow.value() : m_block.m_startCol.value()); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
Eigen::BlockImpl::InnerIterator::row	src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
Eigen::BlockImpl::InnerIterator::row	src/SparseCore/SparseBlock.h	/^      inline Index row()    const { return Base::row()   - m_block.m_startRow.value(); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
Eigen::BlockImpl::IsRowMajor	src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon432
Eigen::BlockImpl::IsRowMajor	src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon434
Eigen::BlockImpl::IsRowMajor	src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon436
Eigen::BlockImpl::IsRowMajor	src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon438
Eigen::BlockImpl::OuterSize	src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon433
Eigen::BlockImpl::OuterSize	src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon435
Eigen::BlockImpl::OuterSize	src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon437
Eigen::BlockImpl::ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator : public _MatrixTypeNested::ReverseInnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:_MatrixTypeNested::ReverseInnerIterator	access:public
Eigen::BlockImpl::ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator: public SparseMatrixType::ReverseInnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:SparseMatrixType::ReverseInnerIterator	access:public
Eigen::BlockImpl::ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator: public XprType::ReverseInnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:XprType::ReverseInnerIterator	access:public
Eigen::BlockImpl::ReverseInnerIterator::Base	src/SparseCore/SparseBlock.h	/^      typedef typename _MatrixTypeNested::ReverseInnerIterator Base;$/;"	t	class:Eigen::BlockImpl::ReverseInnerIterator	access:private
Eigen::BlockImpl::ReverseInnerIterator::Index	src/SparseCore/SparseBlock.h	/^        typedef typename BlockImpl::Index Index;$/;"	t	class:Eigen::BlockImpl::ReverseInnerIterator	access:private
Eigen::BlockImpl::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^        inline ReverseInnerIterator(const BlockType& xpr, Index outer)$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:(const BlockType& xpr, Index outer)
Eigen::BlockImpl::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^      EIGEN_STRONG_INLINE ReverseInnerIterator(const BlockType& block, Index outer)$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:(const BlockType& block, Index outer)
Eigen::BlockImpl::ReverseInnerIterator::col	src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::BlockImpl::ReverseInnerIterator::col	src/SparseCore/SparseBlock.h	/^      inline Index col()    const { return Base::col()   - m_block.m_startCol.value(); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::BlockImpl::ReverseInnerIterator::index	src/SparseCore/SparseBlock.h	/^      inline Index index()  const { return Base::index() - (IsRowMajor ? m_block.m_startCol.value() : m_block.m_startRow.value()); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::BlockImpl::ReverseInnerIterator::m_begin	src/SparseCore/SparseBlock.h	/^      Index m_begin;$/;"	m	class:Eigen::BlockImpl::ReverseInnerIterator	access:private
Eigen::BlockImpl::ReverseInnerIterator::m_block	src/SparseCore/SparseBlock.h	/^      const BlockType& m_block;$/;"	m	class:Eigen::BlockImpl::ReverseInnerIterator	access:private
Eigen::BlockImpl::ReverseInnerIterator::m_outer	src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::BlockImpl::ReverseInnerIterator	access:protected
Eigen::BlockImpl::ReverseInnerIterator::operator bool	src/SparseCore/SparseBlock.h	/^      inline operator bool() const { return Base::operator bool() && Base::index() >= m_begin; }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::BlockImpl::ReverseInnerIterator::outer	src/SparseCore/SparseBlock.h	/^      inline Index outer()  const { return Base::outer() - (IsRowMajor ? m_block.m_startRow.value() : m_block.m_startCol.value()); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::BlockImpl::ReverseInnerIterator::row	src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::BlockImpl::ReverseInnerIterator::row	src/SparseCore/SparseBlock.h	/^      inline Index row()    const { return Base::row()   - m_block.m_startRow.value(); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::BlockImpl::SparseMatrixType	src/SparseCore/SparseBlock.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> SparseMatrixType;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::_MatrixTypeNested	src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename SparseMatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::_MatrixTypeNested	src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename XprType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::_MatrixTypeNested	src/SparseCore/SparseBlock.h	/^  typedef typename internal::remove_all<typename XprType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl	access:private
Eigen::BlockImpl::coeff	src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(int index) const$/;"	f	class:Eigen::BlockImpl	access:public	signature:(int index) const
Eigen::BlockImpl::coeff	src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(int row, int col) const$/;"	f	class:Eigen::BlockImpl	access:public	signature:(int row, int col) const
Eigen::BlockImpl::coeffRef	src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(int index)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(int index)
Eigen::BlockImpl::coeffRef	src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(int row, int col)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(int row, int col)
Eigen::BlockImpl::cols	src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BlockImpl::cols	src/SparseCore/SparseBlock.h	/^    inline int cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BlockImpl::innerIndexPtr	src/SparseCore/SparseBlock.h	/^    inline Index* innerIndexPtr()$/;"	f	class:Eigen::BlockImpl	access:public	signature:()
Eigen::BlockImpl::innerIndexPtr	src/SparseCore/SparseBlock.h	/^    inline const Index* innerIndexPtr() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BlockImpl::lastCoeff	src/SparseCore/SparseBlock.h	/^    const Scalar& lastCoeff() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BlockImpl::m_blockCols	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::BlockImpl	access:protected
Eigen::BlockImpl::m_blockRows	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::BlockImpl	access:protected
Eigen::BlockImpl::m_matrix	src/SparseCore/SparseBlock.h	/^    typename SparseMatrixType::Nested m_matrix;$/;"	m	class:Eigen::BlockImpl	access:protected
Eigen::BlockImpl::m_matrix	src/SparseCore/SparseBlock.h	/^    typename XprType::Nested m_matrix;$/;"	m	class:Eigen::BlockImpl	access:protected
Eigen::BlockImpl::m_outerSize	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, OuterSize> m_outerSize;$/;"	m	class:Eigen::BlockImpl	access:protected
Eigen::BlockImpl::m_outerStart	src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::BlockImpl	access:protected
Eigen::BlockImpl::m_startCol	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::BlockImpl	access:protected
Eigen::BlockImpl::m_startRow	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::BlockImpl	access:protected
Eigen::BlockImpl::nestedExpression	src/SparseCore/SparseBlock.h	/^    inline const _MatrixTypeNested& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BlockImpl::nonZeros	src/SparseCore/SparseBlock.h	/^    Index nonZeros() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BlockImpl::nonZeros	src/SparseCore/SparseBlock.h	/^    Index nonZeros() const;$/;"	p	class:Eigen::BlockImpl	access:private	signature:() const
Eigen::BlockImpl::operator =	src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const BlockType& other)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const BlockType& other)
Eigen::BlockImpl::operator =	src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::BlockImpl::outerIndexPtr	src/SparseCore/SparseBlock.h	/^    inline Index* outerIndexPtr()$/;"	f	class:Eigen::BlockImpl	access:public	signature:()
Eigen::BlockImpl::outerIndexPtr	src/SparseCore/SparseBlock.h	/^    inline const Index* outerIndexPtr() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BlockImpl::rows	src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BlockImpl::rows	src/SparseCore/SparseBlock.h	/^    inline int rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BlockImpl::valuePtr	src/SparseCore/SparseBlock.h	/^    inline Scalar* valuePtr()$/;"	f	class:Eigen::BlockImpl	access:public	signature:()
Eigen::BlockImpl::valuePtr	src/SparseCore/SparseBlock.h	/^    inline const Scalar* valuePtr() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
Eigen::BothDirections	src/Core/util/Constants.h	/^  BothDirections $/;"	e	enum:Eigen::DirectionType
Eigen::BottomLeft	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
Eigen::BottomRight	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
Eigen::BuiltIn	src/Core/util/Constants.h	/^  BuiltIn$/;"	e	enum:Eigen::__anon65
Eigen::COLAMDOrdering	src/OrderingMethods/Ordering.h	/^class COLAMDOrdering$/;"	c	namespace:Eigen
Eigen::COLAMDOrdering::IndexVector	src/OrderingMethods/Ordering.h	/^    typedef Matrix<Index, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::COLAMDOrdering	access:public
Eigen::COLAMDOrdering::PermutationType	src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType; $/;"	t	class:Eigen::COLAMDOrdering	access:public
Eigen::COLAMDOrdering::operator ()	src/OrderingMethods/Ordering.h	/^    void operator() (const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::COLAMDOrdering	access:public	signature:(const MatrixType& mat, PermutationType& perm)
Eigen::CholmodAuto	src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
Eigen::CholmodBase	src/CholmodSupport/CholmodSupport.h	/^class CholmodBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::CholmodBase::CholMatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef MatrixType CholMatrixType;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::CholmodBase	src/CholmodSupport/CholmodSupport.h	/^    CholmodBase()$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
Eigen::CholmodBase::CholmodBase	src/CholmodSupport/CholmodSupport.h	/^    CholmodBase(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodBase::Index	src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::RealScalar	src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::Scalar	src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::UpLo	src/CholmodSupport/CholmodSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::CholmodBase::__anon4
Eigen::CholmodBase::_solve	src/CholmodSupport/CholmodSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::CholmodBase::_solve	src/CholmodSupport/CholmodSupport.h	/^    void _solve(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
Eigen::CholmodBase::analyzePattern	src/CholmodSupport/CholmodSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodBase::cholmod	src/CholmodSupport/CholmodSupport.h	/^    cholmod_common& cholmod() { return m_cholmod; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
Eigen::CholmodBase::cols	src/CholmodSupport/CholmodSupport.h	/^    inline Index cols() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
Eigen::CholmodBase::compute	src/CholmodSupport/CholmodSupport.h	/^    Derived& compute(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodBase::derived	src/CholmodSupport/CholmodSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
Eigen::CholmodBase::derived	src/CholmodSupport/CholmodSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
Eigen::CholmodBase::dumpMemory	src/CholmodSupport/CholmodSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(Stream& )
Eigen::CholmodBase::factorize	src/CholmodSupport/CholmodSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodBase::info	src/CholmodSupport/CholmodSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
Eigen::CholmodBase::m_analysisIsOk	src/CholmodSupport/CholmodSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_cholmod	src/CholmodSupport/CholmodSupport.h	/^    mutable cholmod_common m_cholmod;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_cholmodFactor	src/CholmodSupport/CholmodSupport.h	/^    cholmod_factor* m_cholmodFactor;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_factorizationIsOk	src/CholmodSupport/CholmodSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_info	src/CholmodSupport/CholmodSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_isInitialized	src/CholmodSupport/CholmodSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_shiftOffset	src/CholmodSupport/CholmodSupport.h	/^    RealScalar m_shiftOffset[2];$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::rows	src/CholmodSupport/CholmodSupport.h	/^    inline Index rows() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
Eigen::CholmodBase::setShift	src/CholmodSupport/CholmodSupport.h	/^    Derived& setShift(const RealScalar& offset)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const RealScalar& offset)
Eigen::CholmodBase::solve	src/CholmodSupport/CholmodSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::CholmodBase::solve	src/CholmodSupport/CholmodSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::CholmodBase::~CholmodBase	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodBase()$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
Eigen::CholmodDecomposition	src/CholmodSupport/CholmodSupport.h	/^class CholmodDecomposition : public CholmodBase<_MatrixType, _UpLo, CholmodDecomposition<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
Eigen::CholmodDecomposition::Base	src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodDecomposition> Base;$/;"	t	class:Eigen::CholmodDecomposition	access:private
Eigen::CholmodDecomposition::CholmodDecomposition	src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition() : Base() { init(); }$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:()
Eigen::CholmodDecomposition::CholmodDecomposition	src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodDecomposition::MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodDecomposition	access:public
Eigen::CholmodDecomposition::init	src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodDecomposition	access:protected	signature:()
Eigen::CholmodDecomposition::setMode	src/CholmodSupport/CholmodSupport.h	/^    void setMode(CholmodMode mode)$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:(CholmodMode mode)
Eigen::CholmodDecomposition::~CholmodDecomposition	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodDecomposition() {}$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:()
Eigen::CholmodLDLt	src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
Eigen::CholmodMode	src/CholmodSupport/CholmodSupport.h	/^enum CholmodMode {$/;"	g	namespace:Eigen
Eigen::CholmodSimplicialLDLT	src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLDLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
Eigen::CholmodSimplicialLDLT::Base	src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLDLT	access:private
Eigen::CholmodSimplicialLDLT::CholmodSimplicialLDLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:()
Eigen::CholmodSimplicialLDLT::CholmodSimplicialLDLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodSimplicialLDLT::MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLDLT	access:public
Eigen::CholmodSimplicialLDLT::init	src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:protected	signature:()
Eigen::CholmodSimplicialLDLT::~CholmodSimplicialLDLT	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLDLT() {}$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:()
Eigen::CholmodSimplicialLLT	src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
Eigen::CholmodSimplicialLLT::Base	src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLLT	access:private
Eigen::CholmodSimplicialLLT::CholmodSimplicialLLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:()
Eigen::CholmodSimplicialLLT::CholmodSimplicialLLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodSimplicialLLT::MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLLT	access:public
Eigen::CholmodSimplicialLLT::init	src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLLT	access:protected	signature:()
Eigen::CholmodSimplicialLLT::~CholmodSimplicialLLT	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLLT() {}$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:()
Eigen::CholmodSimplicialLLt	src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
Eigen::CholmodSupernodalLLT	src/CholmodSupport/CholmodSupport.h	/^class CholmodSupernodalLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
Eigen::CholmodSupernodalLLT::Base	src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT> Base;$/;"	t	class:Eigen::CholmodSupernodalLLT	access:private
Eigen::CholmodSupernodalLLT::CholmodSupernodalLLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:()
Eigen::CholmodSupernodalLLT::CholmodSupernodalLLT	src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodSupernodalLLT::MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSupernodalLLT	access:public
Eigen::CholmodSupernodalLLT::init	src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSupernodalLLT	access:protected	signature:()
Eigen::CholmodSupernodalLLT::~CholmodSupernodalLLT	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSupernodalLLT() {}$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:()
Eigen::CholmodSupernodalLLt	src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
Eigen::CoeffBasedProduct	src/Core/products/CoeffBasedProduct.h	/^class CoeffBasedProduct$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
Eigen::CoeffBasedProduct::Base	src/Core/products/CoeffBasedProduct.h	/^    typedef MatrixBase<CoeffBasedProduct> Base;$/;"	t	class:Eigen::CoeffBasedProduct	access:public
Eigen::CoeffBasedProduct::CanVectorizeInner	src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner = internal::traits<CoeffBasedProduct>::CanVectorizeInner$/;"	e	enum:Eigen::CoeffBasedProduct::__anon31
Eigen::CoeffBasedProduct::CoeffBasedProduct	src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const CoeffBasedProduct& other)$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(const CoeffBasedProduct& other)
Eigen::CoeffBasedProduct::CoeffBasedProduct	src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::CoeffBasedProduct::InnerSize	src/Core/products/CoeffBasedProduct.h	/^      InnerSize  = internal::traits<CoeffBasedProduct>::InnerSize,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon31
Eigen::CoeffBasedProduct::LazyCoeffBasedProductType	src/Core/products/CoeffBasedProduct.h	/^    typedef CoeffBasedProduct<LhsNested,RhsNested,NestByRefBit> LazyCoeffBasedProductType;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
Eigen::CoeffBasedProduct::PacketSize	src/Core/products/CoeffBasedProduct.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon31
Eigen::CoeffBasedProduct::PlainObject	src/Core/products/CoeffBasedProduct.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::CoeffBasedProduct	access:public
Eigen::CoeffBasedProduct::ScalarCoeffImpl	src/Core/products/CoeffBasedProduct.h	/^                                   _LhsNested, _RhsNested, Scalar> ScalarCoeffImpl;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
Eigen::CoeffBasedProduct::Unroll	src/Core/products/CoeffBasedProduct.h	/^      Unroll = CoeffReadCost != Dynamic && CoeffReadCost <= EIGEN_UNROLLING_LIMIT,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon31
Eigen::CoeffBasedProduct::_LhsNested	src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
Eigen::CoeffBasedProduct::_RhsNested	src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
Eigen::CoeffBasedProduct::coeff	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index index) const
Eigen::CoeffBasedProduct::coeff	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index row, Index col) const
Eigen::CoeffBasedProduct::cols	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::diagonal	src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,0> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::diagonal	src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,DiagonalIndex> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::diagonal	src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,Dynamic> diagonal(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index index) const
Eigen::CoeffBasedProduct::lhs	src/Core/products/CoeffBasedProduct.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::m_lhs	src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<LhsNested>::type m_lhs;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
Eigen::CoeffBasedProduct::m_result	src/Core/products/CoeffBasedProduct.h	/^    mutable PlainObject m_result;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
Eigen::CoeffBasedProduct::m_rhs	src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<RhsNested>::type m_rhs;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
Eigen::CoeffBasedProduct::operator const PlainObject&	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE operator const PlainObject& () const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::packet	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index row, Index col) const
Eigen::CoeffBasedProduct::rhs	src/Core/products/CoeffBasedProduct.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::rows	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProductMode	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
Eigen::CoherentAccessPattern	src/SparseCore/SparseUtil.h	/^const int CoherentAccessPattern     = 0x1;$/;"	m	namespace:Eigen
Eigen::ColMajor	src/Core/util/Constants.h	/^  ColMajor = 0,$/;"	e	enum:Eigen::__anon66
Eigen::ColPivHouseholderQR	src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> class ColPivHouseholderQR$/;"	c	namespace:Eigen
Eigen::ColPivHouseholderQR::ColPivHouseholderQR	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR()$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:()
Eigen::ColPivHouseholderQR::ColPivHouseholderQR	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(Index rows, Index cols)
Eigen::ColPivHouseholderQR::ColPivHouseholderQR	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::ColPivHouseholderQR::ColsAtCompileTime	src/QR/ColPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
Eigen::ColPivHouseholderQR::HCoeffsType	src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::HouseholderSequenceType	src/QR/ColPivHouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::Index	src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::IntRowVectorType	src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::MatrixQType	src/QR/ColPivHouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, Options, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::MatrixType	src/QR/ColPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::MaxColsAtCompileTime	src/QR/ColPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
Eigen::ColPivHouseholderQR::MaxRowsAtCompileTime	src/QR/ColPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
Eigen::ColPivHouseholderQR::Options	src/QR/ColPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
Eigen::ColPivHouseholderQR::PermIndexType	src/QR/ColPivHouseholderQR.h	/^    typedef typename PermutationType::Index PermIndexType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:private
Eigen::ColPivHouseholderQR::PermutationType	src/QR/ColPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::RealRowVectorType	src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::RealScalar	src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::RowVectorType	src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::RowsAtCompileTime	src/QR/ColPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
Eigen::ColPivHouseholderQR::Scalar	src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::absDeterminant	src/QR/ColPivHouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::absDeterminant	src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
Eigen::ColPivHouseholderQR::check_template_parameters	src/QR/ColPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ColPivHouseholderQR	access:protected	signature:()
Eigen::ColPivHouseholderQR::cols	src/QR/ColPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::colsPermutation	src/QR/ColPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::compute	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::ColPivHouseholderQR::compute	src/QR/ColPivHouseholderQR.h	/^ColPivHouseholderQR<MatrixType>& ColPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR	signature:(const MatrixType& matrix)
Eigen::ColPivHouseholderQR::dimensionOfKernel	src/QR/ColPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::hCoeffs	src/QR/ColPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::householderQ	src/QR/ColPivHouseholderQR.h	/^    HouseholderSequenceType householderQ(void) const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:(void) const
Eigen::ColPivHouseholderQR::householderQ	src/QR/ColPivHouseholderQR.h	/^  ::householderQ() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
Eigen::ColPivHouseholderQR::info	src/QR/ColPivHouseholderQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::inverse	src/QR/ColPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::isInjective	src/QR/ColPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::isInvertible	src/QR/ColPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::isSurjective	src/QR/ColPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::logAbsDeterminant	src/QR/ColPivHouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::logAbsDeterminant	src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
Eigen::ColPivHouseholderQR::m_colSqNorms	src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colSqNorms;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_colsPermutation	src/QR/ColPivHouseholderQR.h	/^    PermutationType m_colsPermutation;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_colsTranspositions	src/QR/ColPivHouseholderQR.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_det_pq	src/QR/ColPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_hCoeffs	src/QR/ColPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_isInitialized	src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_maxpivot	src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_nonzero_pivots	src/QR/ColPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_prescribedThreshold	src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_qr	src/QR/ColPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_temp	src/QR/ColPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_usePrescribedThreshold	src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::matrixQ	src/QR/ColPivHouseholderQR.h	/^    HouseholderSequenceType matrixQ(void) const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(void) const
Eigen::ColPivHouseholderQR::matrixQR	src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::matrixR	src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixR() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::maxPivot	src/QR/ColPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::nonzeroPivots	src/QR/ColPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::rank	src/QR/ColPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::rows	src/QR/ColPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::setThreshold	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(Default_t)
Eigen::ColPivHouseholderQR::setThreshold	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const RealScalar& threshold)
Eigen::ColPivHouseholderQR::solve	src/QR/ColPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::ColPivHouseholderQR::threshold	src/QR/ColPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQRPreconditioner	src/Core/util/Constants.h	/^  ColPivHouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
Eigen::CommaInitializer	src/Core/CommaInitializer.h	/^struct CommaInitializer$/;"	s	namespace:Eigen
Eigen::CommaInitializer::CommaInitializer	src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(XprType& xpr, const DenseBase<OtherDerived>& other)
Eigen::CommaInitializer::CommaInitializer	src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(XprType& xpr, const Scalar& s)
Eigen::CommaInitializer::CommaInitializer	src/Core/CommaInitializer.h	/^  inline CommaInitializer(const CommaInitializer& o)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const CommaInitializer& o)
Eigen::CommaInitializer::Index	src/Core/CommaInitializer.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::Scalar	src/Core/CommaInitializer.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::finished	src/Core/CommaInitializer.h	/^  inline XprType& finished() { return m_xpr; }$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:()
Eigen::CommaInitializer::m_col	src/Core/CommaInitializer.h	/^  Index m_col;              \/\/ current col id$/;"	m	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::m_currentBlockRows	src/Core/CommaInitializer.h	/^  Index m_currentBlockRows; \/\/ current block height$/;"	m	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::m_row	src/Core/CommaInitializer.h	/^  Index m_row;              \/\/ current row id$/;"	m	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::m_xpr	src/Core/CommaInitializer.h	/^  XprType& m_xpr;   \/\/ target expression$/;"	m	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::operator ,	src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::CommaInitializer::operator ,	src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const Scalar& s)
Eigen::CommaInitializer::~CommaInitializer	src/Core/CommaInitializer.h	/^  inline ~CommaInitializer()$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:()
Eigen::CompleteUnrolling	src/Core/util/Constants.h	/^  CompleteUnrolling$/;"	e	enum:Eigen::__anon64
Eigen::ComplexEigenSolver	src/Eigenvalues/ComplexEigenSolver.h	/^template<typename _MatrixType> class ComplexEigenSolver$/;"	c	namespace:Eigen
Eigen::ComplexEigenSolver::ColsAtCompileTime	src/Eigenvalues/ComplexEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
Eigen::ComplexEigenSolver::ComplexEigenSolver	src/Eigenvalues/ComplexEigenSolver.h	/^      ComplexEigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
Eigen::ComplexEigenSolver::ComplexEigenSolver	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver()$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:()
Eigen::ComplexEigenSolver::ComplexEigenSolver	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver(Index size)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(Index size)
Eigen::ComplexEigenSolver::ComplexScalar	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::EigenvalueType	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options&(~RowMajor), MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::EigenvectorType	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::Index	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::MatrixType	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::MaxColsAtCompileTime	src/Eigenvalues/ComplexEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
Eigen::ComplexEigenSolver::MaxRowsAtCompileTime	src/Eigenvalues/ComplexEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
Eigen::ComplexEigenSolver::Options	src/Eigenvalues/ComplexEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
Eigen::ComplexEigenSolver::RealScalar	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::RowsAtCompileTime	src/Eigenvalues/ComplexEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
Eigen::ComplexEigenSolver::Scalar	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::check_template_parameters	src/Eigenvalues/ComplexEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ComplexEigenSolver	access:protected	signature:()
Eigen::ComplexEigenSolver::compute	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);$/;"	p	class:Eigen::ComplexEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
Eigen::ComplexEigenSolver::compute	src/Eigenvalues/ComplexEigenSolver.h	/^ComplexEigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(const MatrixType& matrix, bool computeEigenvectors)
Eigen::ComplexEigenSolver::doComputeEigenvectors	src/Eigenvalues/ComplexEigenSolver.h	/^    void doComputeEigenvectors(const RealScalar& matrixnorm);$/;"	p	class:Eigen::ComplexEigenSolver	access:private	signature:(const RealScalar& matrixnorm)
Eigen::ComplexEigenSolver::doComputeEigenvectors	src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::doComputeEigenvectors(const RealScalar& matrixnorm)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(const RealScalar& matrixnorm)
Eigen::ComplexEigenSolver::eigenvalues	src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
Eigen::ComplexEigenSolver::eigenvectors	src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvectorType& eigenvectors() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
Eigen::ComplexEigenSolver::getMaxIterations	src/Eigenvalues/ComplexEigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:()
Eigen::ComplexEigenSolver::info	src/Eigenvalues/ComplexEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
Eigen::ComplexEigenSolver::m_eigenvectorsOk	src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_eivalues	src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_eivec	src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_eivec;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_isInitialized	src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_matX	src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_matX;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_schur	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexSchur<MatrixType> m_schur;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::setMaxIterations	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(Index maxIters)
Eigen::ComplexEigenSolver::sortEigenvalues	src/Eigenvalues/ComplexEigenSolver.h	/^    void sortEigenvalues(bool computeEigenvectors);$/;"	p	class:Eigen::ComplexEigenSolver	access:private	signature:(bool computeEigenvectors)
Eigen::ComplexEigenSolver::sortEigenvalues	src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::sortEigenvalues(bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(bool computeEigenvectors)
Eigen::ComplexSchur	src/Eigenvalues/ComplexSchur.h	/^template<typename _MatrixType> class ComplexSchur$/;"	c	namespace:Eigen
Eigen::ComplexSchur::ColsAtCompileTime	src/Eigenvalues/ComplexSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon361
Eigen::ComplexSchur::ComplexMatrixType	src/Eigenvalues/ComplexSchur.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> ComplexMatrixType;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::ComplexScalar	src/Eigenvalues/ComplexSchur.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::ComplexSchur	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
Eigen::ComplexSchur::ComplexSchur	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
Eigen::ComplexSchur::Index	src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::MatrixType	src/Eigenvalues/ComplexSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::MaxColsAtCompileTime	src/Eigenvalues/ComplexSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexSchur::__anon361
Eigen::ComplexSchur::MaxRowsAtCompileTime	src/Eigenvalues/ComplexSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon361
Eigen::ComplexSchur::Options	src/Eigenvalues/ComplexSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexSchur::__anon361
Eigen::ComplexSchur::RealScalar	src/Eigenvalues/ComplexSchur.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::RowsAtCompileTime	src/Eigenvalues/ComplexSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon361
Eigen::ComplexSchur::Scalar	src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::compute	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& compute(const MatrixType& matrix, bool computeU = true);$/;"	p	class:Eigen::ComplexSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
Eigen::ComplexSchur::compute	src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(const MatrixType& matrix, bool computeU)
Eigen::ComplexSchur::computeFromHessenberg	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU=true);$/;"	p	class:Eigen::ComplexSchur	access:public	signature:(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU=true)
Eigen::ComplexSchur::computeFromHessenberg	src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)
Eigen::ComplexSchur::computeShift	src/Eigenvalues/ComplexSchur.h	/^    ComplexScalar computeShift(Index iu, Index iter);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(Index iu, Index iter)
Eigen::ComplexSchur::computeShift	src/Eigenvalues/ComplexSchur.h	/^typename ComplexSchur<MatrixType>::ComplexScalar ComplexSchur<MatrixType>::computeShift(Index iu, Index iter)$/;"	f	class:Eigen::ComplexSchur	signature:(Index iu, Index iter)
Eigen::ComplexSchur::getMaxIterations	src/Eigenvalues/ComplexSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexSchur	access:public	signature:()
Eigen::ComplexSchur::info	src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
Eigen::ComplexSchur::m_hess	src/Eigenvalues/ComplexSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_info	src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_isInitialized	src/Eigenvalues/ComplexSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_matT	src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_matU	src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_matUisUptodate	src/Eigenvalues/ComplexSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_maxIterationsPerRow	src/Eigenvalues/ComplexSchur.h	/^    static const int m_maxIterationsPerRow = 30;$/;"	m	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::m_maxIters	src/Eigenvalues/ComplexSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::matrixT	src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixT() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
Eigen::ComplexSchur::matrixU	src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixU() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
Eigen::ComplexSchur::reduceToTriangularForm	src/Eigenvalues/ComplexSchur.h	/^    void reduceToTriangularForm(bool computeU);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(bool computeU)
Eigen::ComplexSchur::reduceToTriangularForm	src/Eigenvalues/ComplexSchur.h	/^void ComplexSchur<MatrixType>::reduceToTriangularForm(bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(bool computeU)
Eigen::ComplexSchur::setMaxIterations	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(Index maxIters)
Eigen::ComplexSchur::subdiagonalEntryIsNeglegible	src/Eigenvalues/ComplexSchur.h	/^    bool subdiagonalEntryIsNeglegible(Index i);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(Index i)
Eigen::ComplexSchur::subdiagonalEntryIsNeglegible	src/Eigenvalues/ComplexSchur.h	/^inline bool ComplexSchur<MatrixType>::subdiagonalEntryIsNeglegible(Index i)$/;"	f	class:Eigen::ComplexSchur	signature:(Index i)
Eigen::ComputationInfo	src/Core/util/Constants.h	/^enum ComputationInfo {$/;"	g	namespace:Eigen
Eigen::ComputeEigenvectors	src/Core/util/Constants.h	/^  ComputeEigenvectors = 0x80,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ComputeFullU	src/Core/util/Constants.h	/^  ComputeFullU        = 0x04,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ComputeFullV	src/Core/util/Constants.h	/^  ComputeFullV        = 0x10,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ComputeThinU	src/Core/util/Constants.h	/^  ComputeThinU        = 0x08,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ComputeThinV	src/Core/util/Constants.h	/^  ComputeThinV        = 0x20,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ConjugateGradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^class ConjugateGradient : public IterativeSolverBase<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	c	namespace:Eigen	inherits:IterativeSolverBase
Eigen::ConjugateGradient::Base	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef IterativeSolverBase<ConjugateGradient> Base;$/;"	t	class:Eigen::ConjugateGradient	access:private
Eigen::ConjugateGradient::ConjugateGradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient() : Base() {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:()
Eigen::ConjugateGradient::ConjugateGradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^  explicit ConjugateGradient(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const EigenBase<MatrixDerived>& A)
Eigen::ConjugateGradient::Index	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::MatrixType	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::Preconditioner	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::RealScalar	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::Scalar	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::UpLo	src/IterativeLinearSolvers/ConjugateGradient.h	/^    UpLo = _UpLo$/;"	e	enum:Eigen::ConjugateGradient::__anon395
Eigen::ConjugateGradient::_solve	src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::ConjugateGradient::_solveWithGuess	src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::ConjugateGradient::solveWithGuess	src/IterativeLinearSolvers/ConjugateGradient.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const MatrixBase<Rhs>& b, const Guess& x0) const
Eigen::ConjugateGradient::~ConjugateGradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^  ~ConjugateGradient() {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:()
Eigen::CornerType	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	g	namespace:Eigen
Eigen::Cwise	src/Eigen2Support/Cwise.h	/^template<typename ExpressionType> class Cwise$/;"	c	namespace:Eigen
Eigen::Cwise::Cwise	src/Eigen2Support/Cwise.h	/^    inline Cwise(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Cwise	access:public	signature:(const ExpressionType& matrix)
Eigen::Cwise::ExpressionTypeNested	src/Eigen2Support/Cwise.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Cwise	access:public
Eigen::Cwise::Scalar	src/Eigen2Support/Cwise.h	/^    typedef typename internal::traits<ExpressionType>::Scalar Scalar;$/;"	t	class:Eigen::Cwise	access:public
Eigen::Cwise::ScalarAddReturnType	src/Eigen2Support/Cwise.h	/^    typedef CwiseUnaryOp<internal::scalar_add_op<Scalar>, ExpressionType> ScalarAddReturnType;$/;"	t	class:Eigen::Cwise	access:public
Eigen::Cwise::_expression	src/Eigen2Support/Cwise.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::abs	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_abs_op)      abs() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::abs	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::abs2	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_abs2_op)     abs2() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::abs2	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs2() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::cos	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_cos_op)      cos() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::cos	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cos() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::cube	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_cube_op)     cube() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::cube	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cube() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::exp	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_exp_op)      exp() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::exp	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::exp() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::inverse	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_inverse_op)  inverse() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::inverse	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::inverse() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::log	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_log_op)      log() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::log	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::log() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::m_matrix	src/Eigen2Support/Cwise.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Cwise	access:protected
Eigen::Cwise::operator !=	src/Eigen2Support/Cwise.h	/^    operator!=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator !=	src/Eigen2Support/Cwise.h	/^    operator!=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator !=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator !=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator *	src/Eigen2Support/Cwise.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator *	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator *=	src/Eigen2Support/Cwise.h	/^    inline ExpressionType& operator*=(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Cwise::operator *=	src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator*=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Cwise::operator +	src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar) const
Eigen::Cwise::operator +	src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar, const Cwise& mat)$/;"	f	class:Eigen::Cwise	access:friend	signature:(const Scalar& scalar, const Cwise& mat)
Eigen::Cwise::operator +	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator+(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar) const
Eigen::Cwise::operator +=	src/Eigen2Support/Cwise.h	/^    ExpressionType& operator+=(const Scalar& scalar);$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar)
Eigen::Cwise::operator +=	src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator+=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar)
Eigen::Cwise::operator -	src/Eigen2Support/Cwise.h	/^    operator-(const Scalar& scalar) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar) const
Eigen::Cwise::operator -	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator-(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar) const
Eigen::Cwise::operator -=	src/Eigen2Support/Cwise.h	/^    ExpressionType& operator-=(const Scalar& scalar);$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar)
Eigen::Cwise::operator -=	src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator-=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar)
Eigen::Cwise::operator /	src/Eigen2Support/Cwise.h	/^    operator\/(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator /	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator\/(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator /=	src/Eigen2Support/Cwise.h	/^    inline ExpressionType& operator\/=(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Cwise::operator /=	src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator\/=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Cwise::operator <	src/Eigen2Support/Cwise.h	/^    operator<(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator <	src/Eigen2Support/Cwise.h	/^    operator<(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator <	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator <	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator <=	src/Eigen2Support/Cwise.h	/^    operator<=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator <=	src/Eigen2Support/Cwise.h	/^    operator<=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator <=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator <=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator ==	src/Eigen2Support/Cwise.h	/^    operator==(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator ==	src/Eigen2Support/Cwise.h	/^    operator==(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator ==	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator ==	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator >	src/Eigen2Support/Cwise.h	/^    operator>(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator >	src/Eigen2Support/Cwise.h	/^    operator>(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator >	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator >	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator >=	src/Eigen2Support/Cwise.h	/^    operator>=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator >=	src/Eigen2Support/Cwise.h	/^    operator>=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator >=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator >=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::pow	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_pow_op)      pow(const Scalar& exponent) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& exponent) const
Eigen::Cwise::pow	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::pow(const Scalar& exponent) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& exponent) const
Eigen::Cwise::scalar_max_op	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_max_op)$/;"	f	class:Eigen::Cwise	access:public	signature:(max) const
Eigen::Cwise::scalar_min_op	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_min_op)$/;"	f	class:Eigen::Cwise	access:public	signature:(min) const
Eigen::Cwise::sin	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_sin_op)      sin() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::sin	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sin() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::sqrt	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_sqrt_op)     sqrt() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::sqrt	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sqrt() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::square	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_square_op)   square() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::square	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::square() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::CwiseBinaryOp	src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseBinaryOpImpl
Eigen::CwiseBinaryOp::Base	src/Core/CwiseBinaryOp.h	/^                                         typename internal::traits<Rhs>::StorageKind>::ret>::Base Base;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::CwiseBinaryOp	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE CwiseBinaryOp(const Lhs& aLhs, const Rhs& aRhs, const BinaryOp& func = BinaryOp())$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:(const Lhs& aLhs, const Rhs& aRhs, const BinaryOp& func = BinaryOp())
Eigen::CwiseBinaryOp::LhsNested	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Lhs>::type LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::RhsNested	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Rhs>::type RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::_LhsNested	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::_RhsNested	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::cols	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
Eigen::CwiseBinaryOp::functor	src/Core/CwiseBinaryOp.h	/^    const BinaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
Eigen::CwiseBinaryOp::lhs	src/Core/CwiseBinaryOp.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
Eigen::CwiseBinaryOp::m_functor	src/Core/CwiseBinaryOp.h	/^    const BinaryOp m_functor;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
Eigen::CwiseBinaryOp::m_lhs	src/Core/CwiseBinaryOp.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
Eigen::CwiseBinaryOp::m_rhs	src/Core/CwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
Eigen::CwiseBinaryOp::rhs	src/Core/CwiseBinaryOp.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
Eigen::CwiseBinaryOp::rows	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
Eigen::CwiseBinaryOpImpl	src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::CwiseBinaryOpImpl	src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::CwiseBinaryOpImpl::Base	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:public
Eigen::CwiseBinaryOpImpl::CwiseBinaryOpImpl	src/SparseCore/SparseCwiseBinaryOp.h	/^    CwiseBinaryOpImpl()$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:()
Eigen::CwiseBinaryOpImpl::Derived	src/Core/CwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:private
Eigen::CwiseBinaryOpImpl::Derived	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:public
Eigen::CwiseBinaryOpImpl::InnerIterator	src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp,Lhs,Rhs,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseBinaryOpImpl	inherits:internal::sparse_cwise_binary_op_inner_iterator_selector
Eigen::CwiseBinaryOpImpl::InnerIterator::Base	src/SparseCore/SparseCwiseBinaryOp.h	/^      BinaryOp,Lhs,Rhs, InnerIterator> Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public
Eigen::CwiseBinaryOpImpl::InnerIterator::Index	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public
Eigen::CwiseBinaryOpImpl::InnerIterator::InnerIterator	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseBinaryOpImpl& binOp, typename Lhs::Index outer)$/;"	f	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public	signature:(const CwiseBinaryOpImpl& binOp, typename Lhs::Index outer)
Eigen::CwiseBinaryOpImpl::coeff	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index index) const
Eigen::CwiseBinaryOpImpl::coeff	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index rowId, Index colId) const
Eigen::CwiseBinaryOpImpl::packet	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index index) const
Eigen::CwiseBinaryOpImpl::packet	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index rowId, Index colId) const
Eigen::CwiseNullaryOp	src/Core/CwiseNullaryOp.h	/^class CwiseNullaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
Eigen::CwiseNullaryOp::Base	src/Core/CwiseNullaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;$/;"	t	class:Eigen::CwiseNullaryOp	access:public
Eigen::CwiseNullaryOp::CwiseNullaryOp	src/Core/CwiseNullaryOp.h	/^    CwiseNullaryOp(Index nbRows, Index nbCols, const NullaryOp& func = NullaryOp())$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index nbRows, Index nbCols, const NullaryOp& func = NullaryOp())
Eigen::CwiseNullaryOp::coeff	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index index) const
Eigen::CwiseNullaryOp::coeff	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index rowId, Index colId) const
Eigen::CwiseNullaryOp::cols	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
Eigen::CwiseNullaryOp::functor	src/Core/CwiseNullaryOp.h	/^    const NullaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
Eigen::CwiseNullaryOp::m_cols	src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
Eigen::CwiseNullaryOp::m_functor	src/Core/CwiseNullaryOp.h	/^    const NullaryOp m_functor;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
Eigen::CwiseNullaryOp::m_rows	src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
Eigen::CwiseNullaryOp::packet	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index index) const
Eigen::CwiseNullaryOp::packet	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index rowId, Index colId) const
Eigen::CwiseNullaryOp::rows	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
Eigen::CwiseUnaryOp	src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseUnaryOpImpl
Eigen::CwiseUnaryOp::Base	src/Core/CwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryOp	access:public
Eigen::CwiseUnaryOp::CwiseUnaryOp	src/Core/CwiseUnaryOp.h	/^    inline CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:(const XprType& xpr, const UnaryOp& func = UnaryOp())
Eigen::CwiseUnaryOp::cols	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
Eigen::CwiseUnaryOp::functor	src/Core/CwiseUnaryOp.h	/^    const UnaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
Eigen::CwiseUnaryOp::m_functor	src/Core/CwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOp	access:protected
Eigen::CwiseUnaryOp::m_xpr	src/Core/CwiseUnaryOp.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::CwiseUnaryOp	access:protected
Eigen::CwiseUnaryOp::nestedExpression	src/Core/CwiseUnaryOp.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
Eigen::CwiseUnaryOp::nestedExpression	src/Core/CwiseUnaryOp.h	/^    nestedExpression() { return m_xpr.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:()
Eigen::CwiseUnaryOp::rows	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
Eigen::CwiseUnaryOpImpl	src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,XprType,Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::CwiseUnaryOpImpl	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::CwiseUnaryOpImpl::Base	src/Core/CwiseUnaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Eigen::CwiseUnaryOpImpl::Derived	src/Core/CwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, XprType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Eigen::CwiseUnaryOpImpl::Derived	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Eigen::CwiseUnaryOpImpl::InnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl	inherits:CwiseUnaryOpImpl::MatrixTypeIterator
Eigen::CwiseUnaryOpImpl::InnerIterator::Base	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private
Eigen::CwiseUnaryOpImpl::InnerIterator::InnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)
Eigen::CwiseUnaryOpImpl::InnerIterator::Scalar	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private
Eigen::CwiseUnaryOpImpl::InnerIterator::m_functor	src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:protected
Eigen::CwiseUnaryOpImpl::InnerIterator::operator ++	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:()
Eigen::CwiseUnaryOpImpl::InnerIterator::value	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:() const
Eigen::CwiseUnaryOpImpl::InnerIterator::valueRef	src/SparseCore/SparseCwiseUnaryOp.h	/^    typename CwiseUnaryOpImpl::Scalar& valueRef();$/;"	p	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private	signature:()
Eigen::CwiseUnaryOpImpl::MatrixTypeIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
Eigen::CwiseUnaryOpImpl::MatrixTypeReverseIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl	inherits:CwiseUnaryOpImpl::MatrixTypeReverseIterator
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::Base	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::Scalar	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::m_functor	src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:protected
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::operator --	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:()
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::value	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::valueRef	src/SparseCore/SparseCwiseUnaryOp.h	/^    typename CwiseUnaryOpImpl::Scalar& valueRef();$/;"	p	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private	signature:()
Eigen::CwiseUnaryOpImpl::_MatrixTypeNested	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_XprTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
Eigen::CwiseUnaryOpImpl::coeff	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index index) const
Eigen::CwiseUnaryOpImpl::coeff	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index rowId, Index colId) const
Eigen::CwiseUnaryOpImpl::packet	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index index) const
Eigen::CwiseUnaryOpImpl::packet	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index rowId, Index colId) const
Eigen::CwiseUnaryView	src/Core/CwiseUnaryView.h	/^class CwiseUnaryView : public CwiseUnaryViewImpl<ViewOp, MatrixType, typename internal::traits<MatrixType>::StorageKind>$/;"	c	namespace:Eigen	inherits:CwiseUnaryViewImpl
Eigen::CwiseUnaryView::Base	src/Core/CwiseUnaryView.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryView	access:public
Eigen::CwiseUnaryView::CwiseUnaryView	src/Core/CwiseUnaryView.h	/^    inline CwiseUnaryView(const MatrixType& mat, const ViewOp& func = ViewOp())$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:(const MatrixType& mat, const ViewOp& func = ViewOp())
Eigen::CwiseUnaryView::cols	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
Eigen::CwiseUnaryView::functor	src/Core/CwiseUnaryView.h	/^    const ViewOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
Eigen::CwiseUnaryView::m_functor	src/Core/CwiseUnaryView.h	/^    ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryView	access:protected
Eigen::CwiseUnaryView::m_matrix	src/Core/CwiseUnaryView.h	/^    typename internal::nested<MatrixType>::type m_matrix;$/;"	m	class:Eigen::CwiseUnaryView	access:protected
Eigen::CwiseUnaryView::nestedExpression	src/Core/CwiseUnaryView.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
Eigen::CwiseUnaryView::nestedExpression	src/Core/CwiseUnaryView.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:()
Eigen::CwiseUnaryView::rows	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
Eigen::CwiseUnaryViewImpl	src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::CwiseUnaryViewImpl	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::CwiseUnaryViewImpl::Base	src/Core/CwiseUnaryView.h	/^    typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
Eigen::CwiseUnaryViewImpl::Derived	src/Core/CwiseUnaryView.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
Eigen::CwiseUnaryViewImpl::Derived	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
Eigen::CwiseUnaryViewImpl::InnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl	inherits:CwiseUnaryViewImpl::MatrixTypeIterator
Eigen::CwiseUnaryViewImpl::InnerIterator::Base	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:private
Eigen::CwiseUnaryViewImpl::InnerIterator::InnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)
Eigen::CwiseUnaryViewImpl::InnerIterator::Scalar	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:private
Eigen::CwiseUnaryViewImpl::InnerIterator::m_functor	src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:protected
Eigen::CwiseUnaryViewImpl::InnerIterator::operator ++	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:()
Eigen::CwiseUnaryViewImpl::InnerIterator::value	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:() const
Eigen::CwiseUnaryViewImpl::InnerIterator::valueRef	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:()
Eigen::CwiseUnaryViewImpl::MatrixTypeIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
Eigen::CwiseUnaryViewImpl::MatrixTypeReverseIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl	inherits:CwiseUnaryViewImpl::MatrixTypeReverseIterator
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::Base	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:private
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::Scalar	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:private
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::m_functor	src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:protected
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::operator --	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:()
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::value	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::valueRef	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:()
Eigen::CwiseUnaryViewImpl::_MatrixTypeNested	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
Eigen::CwiseUnaryViewImpl::coeff	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index index) const
Eigen::CwiseUnaryViewImpl::coeff	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index row, Index col) const
Eigen::CwiseUnaryViewImpl::coeffRef	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index index)
Eigen::CwiseUnaryViewImpl::coeffRef	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index row, Index col)
Eigen::CwiseUnaryViewImpl::data	src/Core/CwiseUnaryView.h	/^    inline Scalar* data() { return &coeffRef(0); }$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:()
Eigen::CwiseUnaryViewImpl::data	src/Core/CwiseUnaryView.h	/^    inline const Scalar* data() const { return &coeff(0); }$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
Eigen::CwiseUnaryViewImpl::innerStride	src/Core/CwiseUnaryView.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
Eigen::CwiseUnaryViewImpl::outerStride	src/Core/CwiseUnaryView.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
Eigen::DecompositionOptions	src/Core/util/Constants.h	/^enum DecompositionOptions {$/;"	g	namespace:Eigen
Eigen::Default	src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	e	enum:Eigen::Default_t
Eigen::DefaultTraversal	src/Core/util/Constants.h	/^  DefaultTraversal,$/;"	e	enum:Eigen::__anon63
Eigen::Default_t	src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	g	namespace:Eigen
Eigen::Dense	src/Core/util/Constants.h	/^struct Dense {};$/;"	s	namespace:Eigen
Eigen::DenseBase	src/Core/DenseBase.h	/^template<typename Derived> class DenseBase$/;"	c	namespace:Eigen	inherits:internal::special_scalar_op_base
Eigen::DenseBase::Base	src/Core/DenseBase.h	/^    typedef internal::special_scalar_op_base<Derived,Scalar,RealScalar, DenseCoeffsBase<Derived> > Base;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::CoeffReadCost	src/Core/DenseBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::CoeffReturnType	src/Core/DenseBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ColsAtCompileTime	src/Core/DenseBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::ColwiseReturnType	src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstColwiseReturnType	src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstReverseReturnType	src/Core/DenseBase.h	/^    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstRowwiseReturnType	src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstTransposeReturnType	src/Core/DenseBase.h	/^	typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::Constant	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index nbRows, Index nbCols, const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(Index nbRows, Index nbCols, const Scalar& value)
Eigen::DenseBase::Constant	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index size, const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& value)
Eigen::DenseBase::Constant	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value)
Eigen::DenseBase::Constant	src/Core/DenseBase.h	/^    Constant(Index rows, Index cols, const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols, const Scalar& value)
Eigen::DenseBase::Constant	src/Core/DenseBase.h	/^    Constant(Index size, const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& value)
Eigen::DenseBase::Constant	src/Core/DenseBase.h	/^    Constant(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
Eigen::DenseBase::ConstantReturnType	src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::DenseBase	src/Core/DenseBase.h	/^    DenseBase()$/;"	f	class:Eigen::DenseBase	access:protected	signature:()
Eigen::DenseBase::DenseBase	src/Core/DenseBase.h	/^    DenseBase(int,int);$/;"	p	class:Eigen::DenseBase	access:private	signature:(int,int)
Eigen::DenseBase::DenseBase	src/Core/DenseBase.h	/^    explicit DenseBase(int);$/;"	p	class:Eigen::DenseBase	access:private	signature:(int)
Eigen::DenseBase::DenseBase	src/Core/DenseBase.h	/^    template<typename OtherDerived> explicit DenseBase(const DenseBase<OtherDerived>&);$/;"	p	class:Eigen::DenseBase	access:private	signature:(const DenseBase<OtherDerived>&)
Eigen::DenseBase::EigenvaluesReturnType	src/Core/DenseBase.h	/^    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::EvalReturnType	src/Core/DenseBase.h	/^    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::Flags	src/Core/DenseBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::Index	src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Index Index; $/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::InnerIterator	src/Core/CoreIterators.h	/^template<typename Derived> class DenseBase<Derived>::InnerIterator$/;"	c	class:Eigen::DenseBase
Eigen::DenseBase::InnerIterator::Index	src/Core/CoreIterators.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::InnerIterator	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator(const Derived& expr, Index outer)$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:(const Derived& expr, Index outer)
Eigen::DenseBase::InnerIterator::IsRowMajor	src/Core/CoreIterators.h	/^    enum { IsRowMajor = (Derived::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::DenseBase::InnerIterator::__anon149
Eigen::DenseBase::InnerIterator::Scalar	src/Core/CoreIterators.h	/^    typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::col	src/Core/CoreIterators.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerIterator::index	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_inner; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerIterator::m_end	src/Core/CoreIterators.h	/^    const Index m_end;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::m_expression	src/Core/CoreIterators.h	/^    const Derived& m_expression;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::m_inner	src/Core/CoreIterators.h	/^    Index m_inner;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::m_outer	src/Core/CoreIterators.h	/^    const Index m_outer;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::operator ++	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++() { m_inner++; return *this; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:()
Eigen::DenseBase::InnerIterator::operator bool	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerIterator::row	src/Core/CoreIterators.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerIterator::value	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerSizeAtCompileTime	src/Core/DenseBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::InnerStrideAtCompileTime	src/Core/DenseBase.h	/^      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::IsRowMajor	src/Core/DenseBase.h	/^      IsRowMajor = int(Flags) & RowMajorBit, \/**< True if this expression has row-major storage order. *\/$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::IsVectorAtCompileTime	src/Core/DenseBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::LinSpaced	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Sequential_t, Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Sequential_t, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	src/Core/DenseBase.h	/^    LinSpaced(Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	src/Core/DenseBase.h	/^    LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Sequential_t, Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	src/Core/DenseBase.h	/^    LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Sequential_t, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	src/Core/DenseBase.h	/^    LinSpaced(const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& low, const Scalar& high)
Eigen::DenseBase::MaxColsAtCompileTime	src/Core/DenseBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::MaxRowsAtCompileTime	src/Core/DenseBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::MaxSizeAtCompileTime	src/Core/DenseBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::NullaryExpr	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols, const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	src/Core/DenseBase.h	/^    NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols, const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	src/Core/DenseBase.h	/^    NullaryExpr(Index size, const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	src/Core/DenseBase.h	/^    NullaryExpr(const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const CustomNullaryOp& func)
Eigen::DenseBase::Ones	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::Ones	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index nbRows, Index nbCols)$/;"	f	class:Eigen::DenseBase	signature:(Index nbRows, Index nbCols)
Eigen::DenseBase::Ones	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index newSize)$/;"	f	class:Eigen::DenseBase	signature:(Index newSize)
Eigen::DenseBase::Ones	src/Core/DenseBase.h	/^    static const ConstantReturnType Ones();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::Ones	src/Core/DenseBase.h	/^    static const ConstantReturnType Ones(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Eigen::DenseBase::Ones	src/Core/DenseBase.h	/^    static const ConstantReturnType Ones(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Eigen::DenseBase::OuterStrideAtCompileTime	src/Core/DenseBase.h	/^      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::PacketScalar	src/Core/DenseBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::Random	src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::Random	src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Eigen::DenseBase::Random	src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Eigen::DenseBase::Random	src/Core/Random.h	/^DenseBase<Derived>::Random()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::Random	src/Core/Random.h	/^DenseBase<Derived>::Random(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols)
Eigen::DenseBase::Random	src/Core/Random.h	/^DenseBase<Derived>::Random(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
Eigen::DenseBase::RandomAccessLinSpacedReturnType	src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,true>,Derived> RandomAccessLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::RealScalar	src/Core/DenseBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ReplicateReturnType	src/Core/DenseBase.h	/^    typedef Replicate<Derived,Dynamic,Dynamic> ReplicateReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ReverseReturnType	src/Core/DenseBase.h	/^    typedef Reverse<Derived, BothDirections> ReverseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::RowsAtCompileTime	src/Core/DenseBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::RowwiseReturnType	src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::Scalar	src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::SequentialLinSpacedReturnType	src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,false>,Derived> SequentialLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::SizeAtCompileTime	src/Core/DenseBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
Eigen::DenseBase::StorageKind	src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ThisConstantIsPrivateInPlainObjectBase	src/Core/DenseBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::DenseBase::__anon156
Eigen::DenseBase::Zero	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::Zero	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index nbRows, Index nbCols)$/;"	f	class:Eigen::DenseBase	signature:(Index nbRows, Index nbCols)
Eigen::DenseBase::Zero	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
Eigen::DenseBase::Zero	src/Core/DenseBase.h	/^    static const ConstantReturnType Zero();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::Zero	src/Core/DenseBase.h	/^    static const ConstantReturnType Zero(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Eigen::DenseBase::Zero	src/Core/DenseBase.h	/^    static const ConstantReturnType Zero(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Eigen::DenseBase::all	src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::all() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::all	src/Core/DenseBase.h	/^    bool all(void) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(void) const
Eigen::DenseBase::allFinite	src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::allFinite() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::allFinite	src/Core/DenseBase.h	/^    inline bool allFinite() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::any	src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::any() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::any	src/Core/DenseBase.h	/^    bool any(void) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(void) const
Eigen::DenseBase::checkTransposeAliasing	src/Core/DenseBase.h	/^    void checkTransposeAliasing(const OtherDerived& other) const;$/;"	p	class:Eigen::DenseBase	access:protected	signature:(const OtherDerived& other) const
Eigen::DenseBase::checkTransposeAliasing	src/Core/Transpose.h	/^void DenseBase<Derived>::checkTransposeAliasing(const OtherDerived& other) const$/;"	f	class:Eigen::DenseBase	signature:(const OtherDerived& other) const
Eigen::DenseBase::colwise	src/Core/DenseBase.h	/^    ColwiseReturnType colwise();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::colwise	src/Core/DenseBase.h	/^    ConstColwiseReturnType colwise() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::colwise	src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::colwise	src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::corner	src/Core/DenseBase.h	/^    Block<Derived, CRows, CCols> corner(CornerType type);$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type)
Eigen::DenseBase::corner	src/Core/DenseBase.h	/^    Block<Derived> corner(CornerType type, Index cRows, Index cCols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type, Index cRows, Index cCols)
Eigen::DenseBase::corner	src/Core/DenseBase.h	/^    const Block<Derived, CRows, CCols> corner(CornerType type) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type) const
Eigen::DenseBase::corner	src/Core/DenseBase.h	/^    const Block<Derived> corner(CornerType type, Index cRows, Index cCols) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type, Index cRows, Index cCols) const
Eigen::DenseBase::corner	src/Eigen2Support/Block.h	/^  ::corner(CornerType type, Index cRows, Index cCols)$/;"	f	class:Eigen::DenseBase	signature:(CornerType type, Index cRows, Index cCols)
Eigen::DenseBase::corner	src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type) const$/;"	f	class:Eigen::DenseBase	signature:(CornerType type) const
Eigen::DenseBase::corner	src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type)$/;"	f	class:Eigen::DenseBase	signature:(CornerType type)
Eigen::DenseBase::corner	src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type, Index cRows, Index cCols) const$/;"	f	class:Eigen::DenseBase	signature:(CornerType type, Index cRows, Index cCols) const
Eigen::DenseBase::count	src/Core/BooleanRedux.h	/^inline typename DenseBase<Derived>::Index DenseBase<Derived>::count() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::count	src/Core/DenseBase.h	/^    Index count() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::eval	src/Core/DenseBase.h	/^    EIGEN_STRONG_INLINE EvalReturnType eval() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::evalTo	src/Core/DenseBase.h	/^    template<typename Dest> inline void evalTo(Dest& ) const$/;"	f	class:Eigen::DenseBase	access:public	signature:(Dest& ) const
Eigen::DenseBase::fill	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE void DenseBase<Derived>::fill(const Scalar& val)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& val)
Eigen::DenseBase::fill	src/Core/DenseBase.h	/^    void fill(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
Eigen::DenseBase::flagged	src/Core/DenseBase.h	/^    const Flagged<Derived, Added, Removed> flagged() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::flagged	src/Core/Flagged.h	/^DenseBase<Derived>::flagged() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::forceAlignedAccess	src/Core/DenseBase.h	/^    inline ForceAlignedAccess<Derived> forceAlignedAccess();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::forceAlignedAccess	src/Core/DenseBase.h	/^    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::forceAlignedAccessIf	src/Core/DenseBase.h	/^    template<bool Enable> inline const typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::forceAlignedAccessIf	src/Core/DenseBase.h	/^    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::format	src/Core/DenseBase.h	/^    inline const WithFormat<Derived> format(const IOFormat& fmt) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const IOFormat& fmt) const
Eigen::DenseBase::format	src/Core/IO.h	/^DenseBase<Derived>::format(const IOFormat& fmt) const$/;"	f	class:Eigen::DenseBase	signature:(const IOFormat& fmt) const
Eigen::DenseBase::hasNaN	src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::hasNaN() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::hasNaN	src/Core/DenseBase.h	/^    inline bool hasNaN() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::innerSize	src/Core/DenseBase.h	/^    Index innerSize() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::isApprox	src/Core/DenseBase.h	/^    bool isApprox(const DenseBase<OtherDerived>& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isApprox	src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isApprox($/;"	f	class:Eigen::DenseBase	signature:( const DenseBase<OtherDerived>& other, const RealScalar& prec ) const
Eigen::DenseBase::isApproxToConstant	src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isApproxToConstant$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& val, const RealScalar& prec) const
Eigen::DenseBase::isApproxToConstant	src/Core/DenseBase.h	/^    bool isApproxToConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isConstant	src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isConstant$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& val, const RealScalar& prec) const
Eigen::DenseBase::isConstant	src/Core/DenseBase.h	/^    bool isConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isMuchSmallerThan	src/Core/DenseBase.h	/^    bool isMuchSmallerThan(const DenseBase<OtherDerived>& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isMuchSmallerThan	src/Core/DenseBase.h	/^    bool isMuchSmallerThan(const RealScalar& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const RealScalar& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isMuchSmallerThan	src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase	signature:( const DenseBase<OtherDerived>& other, const RealScalar& prec ) const
Eigen::DenseBase::isMuchSmallerThan	src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase	signature:( const typename NumTraits<Scalar>::Real& other, const RealScalar& prec ) const
Eigen::DenseBase::isOnes	src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isOnes$/;"	f	class:Eigen::DenseBase	signature:(const RealScalar& prec) const
Eigen::DenseBase::isOnes	src/Core/DenseBase.h	/^    bool isOnes(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isZero	src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isZero(const RealScalar& prec) const$/;"	f	class:Eigen::DenseBase	signature:(const RealScalar& prec) const
Eigen::DenseBase::isZero	src/Core/DenseBase.h	/^    bool isZero(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::lazyAssign	src/Core/Assign.h	/^  ::lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::lazyAssign	src/Core/DenseBase.h	/^    Derived& lazyAssign(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::lazyAssign	src/Core/DenseBase.h	/^    Derived& lazyAssign(const ReturnByValue<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::DenseBase::lazyAssign	src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::lazyAssign(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::DenseBase::lpNorm	src/Core/DenseBase.h	/^    template<int p> RealScalar lpNorm() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::maxCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::maxCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* index) const
Eigen::DenseBase::maxCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* row, IndexType* col) const
Eigen::DenseBase::maxCoeff	src/Core/Redux.h	/^DenseBase<Derived>::maxCoeff() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::maxCoeff	src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* index) const
Eigen::DenseBase::maxCoeff	src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* rowPtr, IndexType* colPtr) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* rowPtr, IndexType* colPtr) const
Eigen::DenseBase::mean	src/Core/DenseBase.h	/^    Scalar mean() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::mean	src/Core/Redux.h	/^DenseBase<Derived>::mean() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::minCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::minCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* index) const
Eigen::DenseBase::minCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* row, IndexType* col) const
Eigen::DenseBase::minCoeff	src/Core/Redux.h	/^DenseBase<Derived>::minCoeff() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::minCoeff	src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* index) const
Eigen::DenseBase::minCoeff	src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* rowId, IndexType* colId) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* rowId, IndexType* colId) const
Eigen::DenseBase::nestByValue	src/Core/DenseBase.h	/^    inline const NestByValue<Derived> nestByValue() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::nestByValue	src/Core/NestByValue.h	/^DenseBase<Derived>::nestByValue() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::nonZeros	src/Core/DenseBase.h	/^    inline Index nonZeros() const { return size(); }$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::operator *=	src/Core/DenseBase.h	/^    inline Derived& operator*=(const Scalar& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& other)
Eigen::DenseBase::operator *=	src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& other)
Eigen::DenseBase::operator +=	src/Core/DenseBase.h	/^    Derived& operator+=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator +=	src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator -=	src/Core/DenseBase.h	/^    Derived& operator-=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator -=	src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator /=	src/Core/DenseBase.h	/^    inline Derived& operator\/=(const Scalar& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& other)
Eigen::DenseBase::operator /=	src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& other)
Eigen::DenseBase::operator <<	src/Core/CommaInitializer.h	/^DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::operator <<	src/Core/CommaInitializer.h	/^inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& s)
Eigen::DenseBase::operator <<	src/Core/DenseBase.h	/^    CommaInitializer<Derived> operator<< (const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::operator <<	src/Core/DenseBase.h	/^    CommaInitializer<Derived> operator<< (const Scalar& s);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& s)
Eigen::DenseBase::operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase& other)
Eigen::DenseBase::operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::operator =	src/Core/DenseBase.h	/^    Derived& operator=(const DenseBase& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase& other)
Eigen::DenseBase::operator =	src/Core/DenseBase.h	/^    Derived& operator=(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::operator =	src/Core/DenseBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator =	src/Core/DenseBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const ReturnByValue<OtherDerived>& func)
Eigen::DenseBase::operator =	src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator =	src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::DenseBase::outerSize	src/Core/DenseBase.h	/^    Index outerSize() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::prod	src/Core/DenseBase.h	/^    Scalar prod() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::prod	src/Core/Redux.h	/^DenseBase<Derived>::prod() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::redux	src/Core/DenseBase.h	/^    redux(const BinaryOp& func) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const BinaryOp& func) const
Eigen::DenseBase::redux	src/Core/Redux.h	/^DenseBase<Derived>::redux(const Func& func) const$/;"	f	class:Eigen::DenseBase	signature:(const Func& func) const
Eigen::DenseBase::replicate	src/Core/DenseBase.h	/^    inline const Replicate<Derived,RowFactor,ColFactor> replicate() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::replicate	src/Core/DenseBase.h	/^    inline const ReplicateReturnType replicate(Index rowFacor,Index colFactor) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rowFacor,Index colFactor) const
Eigen::DenseBase::replicate	src/Core/Replicate.h	/^DenseBase<Derived>::replicate() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::replicate	src/Core/Replicate.h	/^DenseBase<Derived>::replicate(Index rowFactor,Index colFactor) const$/;"	f	class:Eigen::DenseBase	signature:(Index rowFactor,Index colFactor) const
Eigen::DenseBase::resize	src/Core/DenseBase.h	/^    void resize(Index nbRows, Index nbCols)$/;"	f	class:Eigen::DenseBase	access:public	signature:(Index nbRows, Index nbCols)
Eigen::DenseBase::resize	src/Core/DenseBase.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::DenseBase	access:public	signature:(Index newSize)
Eigen::DenseBase::reverse	src/Core/DenseBase.h	/^    ConstReverseReturnType reverse() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::reverse	src/Core/DenseBase.h	/^    ReverseReturnType reverse();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::reverse	src/Core/Reverse.h	/^DenseBase<Derived>::reverse() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::reverse	src/Core/Reverse.h	/^DenseBase<Derived>::reverse()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::reverseInPlace	src/Core/DenseBase.h	/^    void reverseInPlace();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::reverseInPlace	src/Core/Reverse.h	/^inline void DenseBase<Derived>::reverseInPlace()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::rowwise	src/Core/DenseBase.h	/^    ConstRowwiseReturnType rowwise() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::rowwise	src/Core/DenseBase.h	/^    RowwiseReturnType rowwise();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::rowwise	src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::rowwise	src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::select	src/Core/DenseBase.h	/^    select(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar) const
Eigen::DenseBase::select	src/Core/DenseBase.h	/^    select(const DenseBase<ThenDerived>& thenMatrix,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<ThenDerived>& thenMatrix, const DenseBase<ElseDerived>& elseMatrix) const
Eigen::DenseBase::select	src/Core/DenseBase.h	/^    select(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix) const
Eigen::DenseBase::select	src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<ThenDerived>& thenMatrix, const DenseBase<ElseDerived>& elseMatrix) const
Eigen::DenseBase::select	src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar) const
Eigen::DenseBase::select	src/Core/Select.h	/^DenseBase<Derived>::select(const typename ElseDerived::Scalar& thenScalar,$/;"	f	class:Eigen::DenseBase	signature:(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix) const
Eigen::DenseBase::setConstant	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setConstant(const Scalar& val)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& val)
Eigen::DenseBase::setConstant	src/Core/DenseBase.h	/^    Derived& setConstant(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
Eigen::DenseBase::setLinSpaced	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(Index newSize, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Index newSize, const Scalar& low, const Scalar& high)
Eigen::DenseBase::setLinSpaced	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& low, const Scalar& high)
Eigen::DenseBase::setLinSpaced	src/Core/DenseBase.h	/^    Derived& setLinSpaced(Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::setLinSpaced	src/Core/DenseBase.h	/^    Derived& setLinSpaced(const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& low, const Scalar& high)
Eigen::DenseBase::setOnes	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setOnes()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::setOnes	src/Core/DenseBase.h	/^    Derived& setOnes();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::setRandom	src/Core/DenseBase.h	/^    Derived& setRandom();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::setRandom	src/Core/Random.h	/^inline Derived& DenseBase<Derived>::setRandom()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::setZero	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setZero()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::setZero	src/Core/DenseBase.h	/^    Derived& setZero();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::sum	src/Core/DenseBase.h	/^    Scalar sum() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::sum	src/Core/Redux.h	/^DenseBase<Derived>::sum() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::swap	src/Core/DenseBase.h	/^    void swap(PlainObjectBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	access:public	signature:(PlainObjectBase<OtherDerived>& other)
Eigen::DenseBase::swap	src/Core/DenseBase.h	/^    void swap(const DenseBase<OtherDerived>& other,$/;"	f	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, int = OtherDerived::ThisConstantIsPrivateInPlainObjectBase)
Eigen::DenseBase::trace	src/Core/DenseBase.h	/^    Scalar trace() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::transpose	src/Core/DenseBase.h	/^    ConstTransposeReturnType transpose() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::transpose	src/Core/DenseBase.h	/^    Eigen::Transpose<Derived> transpose();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::transpose	src/Core/Transpose.h	/^DenseBase<Derived>::transpose() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::transpose	src/Core/Transpose.h	/^DenseBase<Derived>::transpose()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::transposeInPlace	src/Core/DenseBase.h	/^    void transposeInPlace();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::transposeInPlace	src/Core/Transpose.h	/^inline void DenseBase<Derived>::transposeInPlace()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::value	src/Core/DenseBase.h	/^    CoeffReturnType value() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::visit	src/Core/DenseBase.h	/^    void visit(Visitor& func) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Visitor& func) const
Eigen::DenseBase::visit	src/Core/Visitor.h	/^void DenseBase<Derived>::visit(Visitor& visitor) const$/;"	f	class:Eigen::DenseBase	signature:(Visitor& visitor) const
Eigen::DenseCoeffsBase	src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
Eigen::DenseCoeffsBase	src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectWriteAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
Eigen::DenseCoeffsBase	src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
Eigen::DenseCoeffsBase	src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::DenseCoeffsBase::Base	src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::Base	src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, WriteAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::Base	src/Core/DenseCoeffsBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::CoeffReturnType	src/Core/DenseCoeffsBase.h	/^                     >::type CoeffReturnType;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::Index	src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::PacketReturnType	src/Core/DenseCoeffsBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::PacketScalar	src/Core/DenseCoeffsBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::RealScalar	src/Core/DenseCoeffsBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::Scalar	src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::StorageKind	src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::coeff	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
Eigen::DenseCoeffsBase::coeff	src/Core/DenseCoeffsBase.h	/^    coeff(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
Eigen::DenseCoeffsBase::coeffByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
Eigen::DenseCoeffsBase::coeffRef	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col)
Eigen::DenseCoeffsBase::coeffRef	src/Core/DenseCoeffsBase.h	/^    coeffRef(Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
Eigen::DenseCoeffsBase::coeffRef	src/Core/DenseCoeffsBase.h	/^    void coeffRef();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::coeffRefByOuterInner	src/Core/DenseCoeffsBase.h	/^    coeffRefByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner)
Eigen::DenseCoeffsBase::coeffRefByOuterInner	src/Core/DenseCoeffsBase.h	/^    void coeffRefByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::colIndexByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
Eigen::DenseCoeffsBase::colStride	src/Core/DenseCoeffsBase.h	/^    inline Index colStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::colStride	src/Core/DenseCoeffsBase.h	/^    void colStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::copyCoeff	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyCoeff	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyCoeff	src/Core/DenseCoeffsBase.h	/^    void copyCoeff();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::copyCoeffByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeffByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyCoeffByOuterInner	src/Core/DenseCoeffsBase.h	/^    void copyCoeffByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::copyPacket	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyPacket	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyPacket	src/Core/DenseCoeffsBase.h	/^    void copyPacket();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::copyPacketByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacketByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyPacketByOuterInner	src/Core/DenseCoeffsBase.h	/^    void copyPacketByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::innerStride	src/Core/DenseCoeffsBase.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::innerStride	src/Core/DenseCoeffsBase.h	/^    void innerStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::operator ()	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType operator()(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
Eigen::DenseCoeffsBase::operator ()	src/Core/DenseCoeffsBase.h	/^    operator()(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
Eigen::DenseCoeffsBase::operator ()	src/Core/DenseCoeffsBase.h	/^    operator()(Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
Eigen::DenseCoeffsBase::operator ()	src/Core/DenseCoeffsBase.h	/^    operator()(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col)
Eigen::DenseCoeffsBase::operator []	src/Core/DenseCoeffsBase.h	/^    operator[](Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
Eigen::DenseCoeffsBase::operator []	src/Core/DenseCoeffsBase.h	/^    operator[](Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
Eigen::DenseCoeffsBase::outerStride	src/Core/DenseCoeffsBase.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::outerStride	src/Core/DenseCoeffsBase.h	/^    void outerStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::packet	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
Eigen::DenseCoeffsBase::packet	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
Eigen::DenseCoeffsBase::packetByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
Eigen::DenseCoeffsBase::rowIndexByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
Eigen::DenseCoeffsBase::rowStride	src/Core/DenseCoeffsBase.h	/^    inline Index rowStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::rowStride	src/Core/DenseCoeffsBase.h	/^    void rowStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::stride	src/Core/DenseCoeffsBase.h	/^    inline Index stride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::stride	src/Core/DenseCoeffsBase.h	/^    void stride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::w	src/Core/DenseCoeffsBase.h	/^    w() const { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::w	src/Core/DenseCoeffsBase.h	/^    w() { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
Eigen::DenseCoeffsBase::writePacket	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const typename internal::packet_traits<Scalar>::type& val)
Eigen::DenseCoeffsBase::writePacket	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const typename internal::packet_traits<Scalar>::type& val)
Eigen::DenseCoeffsBase::writePacket	src/Core/DenseCoeffsBase.h	/^    void writePacket();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::writePacketByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacketByOuterInner$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const typename internal::packet_traits<Scalar>::type& val)
Eigen::DenseCoeffsBase::writePacketByOuterInner	src/Core/DenseCoeffsBase.h	/^    void writePacketByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::x	src/Core/DenseCoeffsBase.h	/^    x() const { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::x	src/Core/DenseCoeffsBase.h	/^    x() { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
Eigen::DenseCoeffsBase::y	src/Core/DenseCoeffsBase.h	/^    y() const { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::y	src/Core/DenseCoeffsBase.h	/^    y() { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
Eigen::DenseCoeffsBase::z	src/Core/DenseCoeffsBase.h	/^    z() const { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::z	src/Core/DenseCoeffsBase.h	/^    z() { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
Eigen::DenseIndex	src/Core/util/XprHelper.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;$/;"	t	namespace:Eigen
Eigen::DenseSparseProductReturnType	src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct DenseSparseProductReturnType$/;"	s	namespace:Eigen
Eigen::DenseSparseProductReturnType	src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct DenseSparseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
Eigen::DenseSparseProductReturnType::Type	src/SparseCore/SparseDenseProduct.h	/^    SparseDenseOuterProduct<Lhs,Rhs,false> >::type Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType	access:public
Eigen::DenseSparseProductReturnType::Type	src/SparseCore/SparseDenseProduct.h	/^  typedef DenseTimeSparseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType	access:public
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage$/;"	c	namespace:Eigen
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, 0, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, 0, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, 0, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
Eigen::DenseStorage	src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() : m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage() {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex size, DenseIndex nbRows, DenseIndex) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(nbRows)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex size, DenseIndex, DenseIndex nbCols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex nbCols)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex, DenseIndex nbRows, DenseIndex nbCols) : m_rows(nbRows), m_cols(nbCols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex nbCols)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex, DenseIndex nbRows, DenseIndex) : m_rows(nbRows) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex, DenseIndex, DenseIndex nbCols) : m_cols(nbCols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex nbCols)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(DenseStorage&& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage&& other)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage&) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage&)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage&);$/;"	p	class:Eigen::DenseStorage	access:private	signature:(const DenseStorage&)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::DenseStorage::DenseStorage	src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::DenseStorage::cols	src/Core/DenseStorage.h	/^    DenseIndex cols() const {return m_cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
Eigen::DenseStorage::cols	src/Core/DenseStorage.h	/^    DenseIndex cols(void) const {return _Cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
Eigen::DenseStorage::cols	src/Core/DenseStorage.h	/^    DenseIndex cols(void) const {return m_cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
Eigen::DenseStorage::cols	src/Core/DenseStorage.h	/^    static DenseIndex cols(void) {return _Cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void)
Eigen::DenseStorage::conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)
Eigen::DenseStorage::conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex size, DenseIndex nbRows, DenseIndex)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex)
Eigen::DenseStorage::conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex size, DenseIndex, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex nbCols)
Eigen::DenseStorage::conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex, DenseIndex nbRows, DenseIndex nbCols) { m_rows = nbRows; m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex nbCols)
Eigen::DenseStorage::conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex, DenseIndex nbRows, DenseIndex) { m_rows = nbRows; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex)
Eigen::DenseStorage::conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex, DenseIndex, DenseIndex nbCols) { m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex nbCols)
Eigen::DenseStorage::conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
Eigen::DenseStorage::data	src/Core/DenseStorage.h	/^    T *data() { return 0; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::data	src/Core/DenseStorage.h	/^    T *data() { return m_data.array; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::data	src/Core/DenseStorage.h	/^    T *data() { return m_data; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::data	src/Core/DenseStorage.h	/^    const T *data() const { return 0; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
Eigen::DenseStorage::data	src/Core/DenseStorage.h	/^    const T *data() const { return m_data.array; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
Eigen::DenseStorage::data	src/Core/DenseStorage.h	/^    const T *data() const { return m_data; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
Eigen::DenseStorage::m_cols	src/Core/DenseStorage.h	/^    DenseIndex m_cols;$/;"	m	class:Eigen::DenseStorage	access:private
Eigen::DenseStorage::m_data	src/Core/DenseStorage.h	/^    T *m_data;$/;"	m	class:Eigen::DenseStorage	access:private
Eigen::DenseStorage::m_data	src/Core/DenseStorage.h	/^    internal::plain_array<T,Size,_Options> m_data;$/;"	m	class:Eigen::DenseStorage	access:private
Eigen::DenseStorage::m_rows	src/Core/DenseStorage.h	/^    DenseIndex m_rows;$/;"	m	class:Eigen::DenseStorage	access:private
Eigen::DenseStorage::operator =	src/Core/DenseStorage.h	/^    DenseStorage& operator=(DenseStorage&& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage&& other)
Eigen::DenseStorage::operator =	src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
Eigen::DenseStorage::operator =	src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage&) { return *this; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage&)
Eigen::DenseStorage::operator =	src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage&);$/;"	p	class:Eigen::DenseStorage	access:private	signature:(const DenseStorage&)
Eigen::DenseStorage::resize	src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex nbRows, DenseIndex)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex)
Eigen::DenseStorage::resize	src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex nbCols)
Eigen::DenseStorage::resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)
Eigen::DenseStorage::resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex, DenseIndex nbRows, DenseIndex nbCols) { m_rows = nbRows; m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex nbCols)
Eigen::DenseStorage::resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex, DenseIndex nbRows, DenseIndex) { m_rows = nbRows; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex)
Eigen::DenseStorage::resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex, DenseIndex, DenseIndex nbCols) { m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex nbCols)
Eigen::DenseStorage::resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
Eigen::DenseStorage::rows	src/Core/DenseStorage.h	/^    DenseIndex rows() const {return m_rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
Eigen::DenseStorage::rows	src/Core/DenseStorage.h	/^    DenseIndex rows(void) const {return _Rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
Eigen::DenseStorage::rows	src/Core/DenseStorage.h	/^    DenseIndex rows(void) const {return m_rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
Eigen::DenseStorage::rows	src/Core/DenseStorage.h	/^    static DenseIndex rows(void) {return _Rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void)
Eigen::DenseStorage::swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& ) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& )
Eigen::DenseStorage::swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
Eigen::DenseStorage::swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
Eigen::DenseStorage::swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
Eigen::DenseStorage::swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
Eigen::DenseStorage::~DenseStorage	src/Core/DenseStorage.h	/^    ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::~DenseStorage	src/Core/DenseStorage.h	/^    ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::~DenseStorage	src/Core/DenseStorage.h	/^    ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseTimeSparseProduct	src/SparseCore/SparseDenseProduct.h	/^class DenseTimeSparseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::DenseTimeSparseProduct::DenseTimeSparseProduct	src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::DenseTimeSparseProduct::operator =	src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct& operator=(const DenseTimeSparseProduct&);$/;"	p	class:Eigen::DenseTimeSparseProduct	access:private	signature:(const DenseTimeSparseProduct&)
Eigen::DenseTimeSparseProduct::scaleAndAddTo	src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::DenseTimeSparseProduct	access:public	signature:(Dest& dest, const Scalar& alpha) const
Eigen::DenseTimeSparseSelfAdjointProduct	src/SparseCore/SparseSelfAdjointView.h	/^class DenseTimeSparseSelfAdjointProduct$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::DenseTimeSparseSelfAdjointProduct::DenseTimeSparseSelfAdjointProduct	src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::DenseTimeSparseSelfAdjointProduct::operator =	src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct& operator=(const DenseTimeSparseSelfAdjointProduct&);$/;"	p	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:private	signature:(const DenseTimeSparseSelfAdjointProduct&)
Eigen::DenseTimeSparseSelfAdjointProduct::scaleAndAddTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& \/*dest*\/, const Scalar& \/*alpha*\/) const$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:public	signature:(Dest& , const Scalar& ) const
Eigen::Diagonal	src/Core/Diagonal.h	/^template<typename MatrixType, int _DiagIndex> class Diagonal$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::Diagonal::Base	src/Core/Diagonal.h	/^    typedef typename internal::dense_xpr_base<Diagonal>::type Base;$/;"	t	class:Eigen::Diagonal	access:public
Eigen::Diagonal::DiagIndex	src/Core/Diagonal.h	/^    enum { DiagIndex = _DiagIndex };$/;"	e	enum:Eigen::Diagonal::__anon162
Eigen::Diagonal::Diagonal	src/Core/Diagonal.h	/^    inline Diagonal(MatrixType& matrix, Index a_index = DiagIndex) : m_matrix(matrix), m_index(a_index) {}$/;"	f	class:Eigen::Diagonal	access:public	signature:(MatrixType& matrix, Index a_index = DiagIndex)
Eigen::Diagonal::ScalarWithConstIfNotLvalue	src/Core/Diagonal.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::Diagonal	access:public
Eigen::Diagonal::absDiagIndex	src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index absDiagIndex() const { return m_index.value()>0 ? m_index.value() : -m_index.value(); }$/;"	f	class:Eigen::Diagonal	access:private	signature:() const
Eigen::Diagonal::coeff	src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index idx) const$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index idx) const
Eigen::Diagonal::coeff	src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index row, Index) const$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index row, Index) const
Eigen::Diagonal::coeffRef	src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index idx)$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index idx)
Eigen::Diagonal::coeffRef	src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index row, Index)$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index row, Index)
Eigen::Diagonal::coeffRef	src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index idx) const$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index idx) const
Eigen::Diagonal::coeffRef	src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index row, Index) const$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index row, Index) const
Eigen::Diagonal::colOffset	src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }$/;"	f	class:Eigen::Diagonal	access:private	signature:() const
Eigen::Diagonal::cols	src/Core/Diagonal.h	/^    inline Index cols() const { return 1; }$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
Eigen::Diagonal::data	src/Core/Diagonal.h	/^    inline ScalarWithConstIfNotLvalue* data() { return &(m_matrix.const_cast_derived().coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal	access:public	signature:()
Eigen::Diagonal::data	src/Core/Diagonal.h	/^    inline const Scalar* data() const { return &(m_matrix.const_cast_derived().coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
Eigen::Diagonal::index	src/Core/Diagonal.h	/^    int index() const$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
Eigen::Diagonal::innerStride	src/Core/Diagonal.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
Eigen::Diagonal::m_index	src/Core/Diagonal.h	/^    const internal::variable_if_dynamicindex<Index, DiagIndex> m_index;$/;"	m	class:Eigen::Diagonal	access:protected
Eigen::Diagonal::m_matrix	src/Core/Diagonal.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Diagonal	access:protected
Eigen::Diagonal::nestedExpression	src/Core/Diagonal.h	/^    nestedExpression() const $/;"	f	class:Eigen::Diagonal	access:public	signature:() const
Eigen::Diagonal::outerStride	src/Core/Diagonal.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
Eigen::Diagonal::packet	src/Core/Diagonal.h	/^    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index) const;$/;"	p	class:Eigen::Diagonal	access:private	signature:(Index) const
Eigen::Diagonal::packet	src/Core/Diagonal.h	/^    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index,Index) const;$/;"	p	class:Eigen::Diagonal	access:private	signature:(Index,Index) const
Eigen::Diagonal::rowOffset	src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value()>0 ? 0 : -m_index.value(); }$/;"	f	class:Eigen::Diagonal	access:private	signature:() const
Eigen::Diagonal::rows	src/Core/Diagonal.h	/^    inline Index rows() const$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
Eigen::DiagonalBase	src/Core/DiagonalMatrix.h	/^class DiagonalBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::DiagonalBase::ColsAtCompileTime	src/Core/DiagonalMatrix.h	/^      ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon163
Eigen::DiagonalBase::DenseMatrixType	src/Core/DiagonalMatrix.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime, 0, MaxRowsAtCompileTime, MaxColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::DenseType	src/Core/DiagonalMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::DiagonalVectorType	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::Flags	src/Core/DiagonalMatrix.h	/^      Flags = 0$/;"	e	enum:Eigen::DiagonalBase::__anon163
Eigen::DiagonalBase::Index	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::IsVectorAtCompileTime	src/Core/DiagonalMatrix.h	/^      IsVectorAtCompileTime = 0,$/;"	e	enum:Eigen::DiagonalBase::__anon163
Eigen::DiagonalBase::MaxColsAtCompileTime	src/Core/DiagonalMatrix.h	/^      MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon163
Eigen::DiagonalBase::MaxRowsAtCompileTime	src/Core/DiagonalMatrix.h	/^      MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon163
Eigen::DiagonalBase::PlainObject	src/Core/DiagonalMatrix.h	/^    typedef DiagonalMatrix<Scalar,DiagonalVectorType::SizeAtCompileTime,DiagonalVectorType::MaxSizeAtCompileTime> PlainObject;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::RealScalar	src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::RealScalar RealScalar;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::RowsAtCompileTime	src/Core/DiagonalMatrix.h	/^      RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon163
Eigen::DiagonalBase::Scalar	src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::StorageKind	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::addTo	src/Core/DiagonalMatrix.h	/^    void addTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::DiagonalBase::cols	src/Core/DiagonalMatrix.h	/^    inline Index cols() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::derived	src/Core/DiagonalMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:()
Eigen::DiagonalBase::derived	src/Core/DiagonalMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::diagonal	src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:()
Eigen::DiagonalBase::diagonal	src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::evalTo	src/Core/DiagonalMatrix.h	/^    void evalTo(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::DiagonalBase::evalTo	src/Core/DiagonalMatrix.h	/^void DiagonalBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	signature:(MatrixBase<DenseDerived> &other) const
Eigen::DiagonalBase::inverse	src/Core/DiagonalMatrix.h	/^    inverse() const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::isApprox	src/Core/DiagonalMatrix.h	/^    bool isApprox(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
Eigen::DiagonalBase::isApprox	src/Core/DiagonalMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
Eigen::DiagonalBase::operator *	src/Core/DiagonalMatrix.h	/^    operator*(const MatrixBase<MatrixDerived> &matrix) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const MatrixBase<MatrixDerived> &matrix) const
Eigen::DiagonalBase::operator *	src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const Scalar& scalar) const
Eigen::DiagonalBase::operator *	src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar, const DiagonalBase& other)$/;"	f	class:Eigen::DiagonalBase	access:friend	signature:(const Scalar& scalar, const DiagonalBase& other)
Eigen::DiagonalBase::rows	src/Core/DiagonalMatrix.h	/^    inline Index rows() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::subTo	src/Core/DiagonalMatrix.h	/^    void subTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::DiagonalBase::toDenseMatrix	src/Core/DiagonalMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalMatrix	src/Core/DiagonalMatrix.h	/^class DiagonalMatrix$/;"	c	namespace:Eigen	inherits:DiagonalBase
Eigen::DiagonalMatrix::DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(const MatrixBase<OtherDerived>& other) : m_diagonal(other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::DiagonalMatrix::DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix() {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
Eigen::DiagonalMatrix::DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(Index dim) : m_diagonal(dim) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index dim)
Eigen::DiagonalMatrix::DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalBase<OtherDerived>& other)
Eigen::DiagonalMatrix::DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalMatrix& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalMatrix& other)
Eigen::DiagonalMatrix::DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::DiagonalMatrix::DiagonalMatrix	src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
Eigen::DiagonalMatrix::DiagonalVectorType	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Eigen::DiagonalMatrix::Index	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::Index Index;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Eigen::DiagonalMatrix::Nested	src/Core/DiagonalMatrix.h	/^    typedef const DiagonalMatrix& Nested;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Eigen::DiagonalMatrix::Scalar	src/Core/DiagonalMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Eigen::DiagonalMatrix::StorageKind	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Eigen::DiagonalMatrix::diagonal	src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
Eigen::DiagonalMatrix::diagonal	src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:() const
Eigen::DiagonalMatrix::m_diagonal	src/Core/DiagonalMatrix.h	/^    DiagonalVectorType m_diagonal;$/;"	m	class:Eigen::DiagonalMatrix	access:protected
Eigen::DiagonalMatrix::operator =	src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalBase<OtherDerived>& other)
Eigen::DiagonalMatrix::operator =	src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalMatrix& other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalMatrix& other)
Eigen::DiagonalMatrix::resize	src/Core/DiagonalMatrix.h	/^    inline void resize(Index size) { m_diagonal.resize(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
Eigen::DiagonalMatrix::setIdentity	src/Core/DiagonalMatrix.h	/^    inline void setIdentity() { m_diagonal.setOnes(); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
Eigen::DiagonalMatrix::setIdentity	src/Core/DiagonalMatrix.h	/^    inline void setIdentity(Index size) { m_diagonal.setOnes(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
Eigen::DiagonalMatrix::setZero	src/Core/DiagonalMatrix.h	/^    inline void setZero() { m_diagonal.setZero(); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
Eigen::DiagonalMatrix::setZero	src/Core/DiagonalMatrix.h	/^    inline void setZero(Index size) { m_diagonal.setZero(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
Eigen::DiagonalPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^class DiagonalPreconditioner$/;"	c	namespace:Eigen
Eigen::DiagonalPreconditioner::DiagonalPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner() : m_isInitialized(false) {}$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:()
Eigen::DiagonalPreconditioner::DiagonalPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner(const MatType& mat) : m_invdiag(mat.cols())$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatType& mat)
Eigen::DiagonalPreconditioner::Index	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename Vector::Index Index;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Eigen::DiagonalPreconditioner::MatrixType	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::DiagonalPreconditioner	access:public
Eigen::DiagonalPreconditioner::Scalar	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Eigen::DiagonalPreconditioner::Vector	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Eigen::DiagonalPreconditioner::_solve	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::DiagonalPreconditioner::analyzePattern	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& analyzePattern(const MatType& )$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatType& )
Eigen::DiagonalPreconditioner::cols	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index cols() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:() const
Eigen::DiagonalPreconditioner::compute	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& compute(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatType& mat)
Eigen::DiagonalPreconditioner::factorize	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& factorize(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatType& mat)
Eigen::DiagonalPreconditioner::m_invdiag	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Vector m_invdiag;$/;"	m	class:Eigen::DiagonalPreconditioner	access:protected
Eigen::DiagonalPreconditioner::m_isInitialized	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::DiagonalPreconditioner	access:protected
Eigen::DiagonalPreconditioner::rows	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index rows() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:() const
Eigen::DiagonalPreconditioner::solve	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::DiagonalProduct	src/Core/DiagonalProduct.h	/^class DiagonalProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
Eigen::DiagonalProduct::Base	src/Core/DiagonalProduct.h	/^    typedef MatrixBase<DiagonalProduct> Base;$/;"	t	class:Eigen::DiagonalProduct	access:public
Eigen::DiagonalProduct::DiagonalProduct	src/Core/DiagonalProduct.h	/^    inline DiagonalProduct(const MatrixType& matrix, const DiagonalType& diagonal)$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(const MatrixType& matrix, const DiagonalType& diagonal)
Eigen::DiagonalProduct::coeff	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index idx) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index idx) const
Eigen::DiagonalProduct::coeff	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index row, Index col) const
Eigen::DiagonalProduct::cols	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:() const
Eigen::DiagonalProduct::m_diagonal	src/Core/DiagonalProduct.h	/^    typename DiagonalType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalProduct	access:protected
Eigen::DiagonalProduct::m_matrix	src/Core/DiagonalProduct.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::DiagonalProduct	access:protected
Eigen::DiagonalProduct::packet	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index idx) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index idx) const
Eigen::DiagonalProduct::packet	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index row, Index col) const
Eigen::DiagonalProduct::packet_impl	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::false_type) const$/;"	f	class:Eigen::DiagonalProduct	access:protected	signature:(Index row, Index col, Index id, internal::false_type) const
Eigen::DiagonalProduct::packet_impl	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::true_type) const$/;"	f	class:Eigen::DiagonalProduct	access:protected	signature:(Index row, Index col, Index id, internal::true_type) const
Eigen::DiagonalProduct::rows	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:() const
Eigen::DiagonalWrapper	src/Core/DiagonalMatrix.h	/^class DiagonalWrapper$/;"	c	namespace:Eigen	inherits:DiagonalBase,internal::no_assignment_operator
Eigen::DiagonalWrapper::DiagonalVectorType	src/Core/DiagonalMatrix.h	/^    typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalWrapper	access:public
Eigen::DiagonalWrapper::DiagonalWrapper	src/Core/DiagonalMatrix.h	/^    inline DiagonalWrapper(DiagonalVectorType& a_diagonal) : m_diagonal(a_diagonal) {}$/;"	f	class:Eigen::DiagonalWrapper	access:public	signature:(DiagonalVectorType& a_diagonal)
Eigen::DiagonalWrapper::Nested	src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper Nested;$/;"	t	class:Eigen::DiagonalWrapper	access:public
Eigen::DiagonalWrapper::diagonal	src/Core/DiagonalMatrix.h	/^    const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalWrapper	access:public	signature:() const
Eigen::DiagonalWrapper::m_diagonal	src/Core/DiagonalMatrix.h	/^    typename DiagonalVectorType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalWrapper	access:protected
Eigen::DirectAccessBit	src/Core/util/Constants.h	/^const unsigned int DirectAccessBit = 0x40;$/;"	m	namespace:Eigen
Eigen::DirectAccessors	src/Core/util/Constants.h	/^  DirectAccessors, $/;"	e	enum:Eigen::AccessorLevels
Eigen::DirectWriteAccessors	src/Core/util/Constants.h	/^  DirectWriteAccessors$/;"	e	enum:Eigen::AccessorLevels
Eigen::DirectionType	src/Core/util/Constants.h	/^enum DirectionType { $/;"	g	namespace:Eigen
Eigen::DontAlign	src/Core/util/Constants.h	/^  DontAlign = 0x2$/;"	e	enum:Eigen::__anon66
Eigen::DontAlignCols	src/Core/IO.h	/^enum { DontAlignCols = 1 };$/;"	e	enum:Eigen::__anon272
Eigen::Dynamic	src/Core/util/Constants.h	/^const int Dynamic = -1;$/;"	m	namespace:Eigen
Eigen::DynamicIndex	src/Core/util/Constants.h	/^const int DynamicIndex = 0xffffff;$/;"	m	namespace:Eigen
Eigen::EigVecMask	src/Core/util/Constants.h	/^  EigVecMask = EigenvaluesOnly | ComputeEigenvectors,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::EigenBase	src/Core/EigenBase.h	/^template<typename Derived> struct EigenBase$/;"	s	namespace:Eigen
Eigen::EigenBase::Index	src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::Index Index;$/;"	t	struct:Eigen::EigenBase	access:public
Eigen::EigenBase::StorageKind	src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	struct:Eigen::EigenBase	access:public
Eigen::EigenBase::addTo	src/Core/EigenBase.h	/^  template<typename Dest> inline void addTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
Eigen::EigenBase::applyThisOnTheLeft	src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
Eigen::EigenBase::applyThisOnTheRight	src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
Eigen::EigenBase::cols	src/Core/EigenBase.h	/^  inline Index cols() const { return derived().cols(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::const_cast_derived	src/Core/EigenBase.h	/^  inline Derived& const_cast_derived() const$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::const_derived	src/Core/EigenBase.h	/^  inline const Derived& const_derived() const$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::derived	src/Core/EigenBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:()
Eigen::EigenBase::derived	src/Core/EigenBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::evalTo	src/Core/EigenBase.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
Eigen::EigenBase::rows	src/Core/EigenBase.h	/^  inline Index rows() const { return derived().rows(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::size	src/Core/EigenBase.h	/^  inline Index size() const { return rows() * cols(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::subTo	src/Core/EigenBase.h	/^  template<typename Dest> inline void subTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
Eigen::EigenSolver	src/Eigenvalues/EigenSolver.h	/^template<typename _MatrixType> class EigenSolver$/;"	c	namespace:Eigen
Eigen::EigenSolver::ColsAtCompileTime	src/Eigenvalues/EigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon362
Eigen::EigenSolver::ColumnVectorType	src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::ComplexScalar	src/Eigenvalues/EigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::EigenSolver	src/Eigenvalues/EigenSolver.h	/^    EigenSolver(Index size)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(Index size)
Eigen::EigenSolver::EigenSolver	src/Eigenvalues/EigenSolver.h	/^    EigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
Eigen::EigenSolver::EigenSolver	src/Eigenvalues/EigenSolver.h	/^ EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}$/;"	f	class:Eigen::EigenSolver	access:public	signature:()
Eigen::EigenSolver::EigenvalueType	src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::EigenvectorsType	src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::Index	src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::MatrixType	src/Eigenvalues/EigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::MaxColsAtCompileTime	src/Eigenvalues/EigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::EigenSolver::__anon362
Eigen::EigenSolver::MaxRowsAtCompileTime	src/Eigenvalues/EigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon362
Eigen::EigenSolver::Options	src/Eigenvalues/EigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::EigenSolver::__anon362
Eigen::EigenSolver::RealScalar	src/Eigenvalues/EigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::RowsAtCompileTime	src/Eigenvalues/EigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon362
Eigen::EigenSolver::Scalar	src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::check_template_parameters	src/Eigenvalues/EigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::EigenSolver	access:protected	signature:()
Eigen::EigenSolver::compute	src/Eigenvalues/EigenSolver.h	/^    EigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);$/;"	p	class:Eigen::EigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
Eigen::EigenSolver::compute	src/Eigenvalues/EigenSolver.h	/^EigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::EigenSolver	signature:(const MatrixType& matrix, bool computeEigenvectors)
Eigen::EigenSolver::doComputeEigenvectors	src/Eigenvalues/EigenSolver.h	/^    void doComputeEigenvectors();$/;"	p	class:Eigen::EigenSolver	access:private	signature:()
Eigen::EigenSolver::doComputeEigenvectors	src/Eigenvalues/EigenSolver.h	/^void EigenSolver<MatrixType>::doComputeEigenvectors()$/;"	f	class:Eigen::EigenSolver	signature:()
Eigen::EigenSolver::eigenvalues	src/Eigenvalues/EigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::eigenvectors	src/Eigenvalues/EigenSolver.h	/^    EigenvectorsType eigenvectors() const;$/;"	p	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::eigenvectors	src/Eigenvalues/EigenSolver.h	/^typename EigenSolver<MatrixType>::EigenvectorsType EigenSolver<MatrixType>::eigenvectors() const$/;"	f	class:Eigen::EigenSolver	signature:() const
Eigen::EigenSolver::getMaxIterations	src/Eigenvalues/EigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::EigenSolver	access:public	signature:()
Eigen::EigenSolver::info	src/Eigenvalues/EigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::m_eigenvectorsOk	src/Eigenvalues/EigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_eivalues	src/Eigenvalues/EigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_eivec	src/Eigenvalues/EigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_isInitialized	src/Eigenvalues/EigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_matT	src/Eigenvalues/EigenSolver.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_realSchur	src/Eigenvalues/EigenSolver.h	/^    RealSchur<MatrixType> m_realSchur;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_tmp	src/Eigenvalues/EigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::pseudoEigenvalueMatrix	src/Eigenvalues/EigenSolver.h	/^    MatrixType pseudoEigenvalueMatrix() const;$/;"	p	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::pseudoEigenvalueMatrix	src/Eigenvalues/EigenSolver.h	/^MatrixType EigenSolver<MatrixType>::pseudoEigenvalueMatrix() const$/;"	f	class:Eigen::EigenSolver	signature:() const
Eigen::EigenSolver::pseudoEigenvectors	src/Eigenvalues/EigenSolver.h	/^    const MatrixType& pseudoEigenvectors() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::setMaxIterations	src/Eigenvalues/EigenSolver.h	/^    EigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(Index maxIters)
Eigen::EigenvaluesOnly	src/Core/util/Constants.h	/^  EigenvaluesOnly     = 0x40,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::EvalBeforeAssigningBit	src/Core/util/Constants.h	/^const unsigned int EvalBeforeAssigningBit = 0x4;$/;"	m	namespace:Eigen
Eigen::EvalBeforeNestingBit	src/Core/util/Constants.h	/^const unsigned int EvalBeforeNestingBit = 0x2;$/;"	m	namespace:Eigen
Eigen::Flagged	src/Core/Flagged.h	/^template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged$/;"	c	namespace:Eigen	inherits:MatrixBase
Eigen::Flagged::Base	src/Core/Flagged.h	/^    typedef MatrixBase<Flagged> Base;$/;"	t	class:Eigen::Flagged	access:public
Eigen::Flagged::ExpressionTypeNested	src/Core/Flagged.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Flagged	access:public
Eigen::Flagged::Flagged	src/Core/Flagged.h	/^    inline Flagged(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Flagged	access:public	signature:(const ExpressionType& matrix)
Eigen::Flagged::InnerIterator	src/Core/Flagged.h	/^    typedef typename ExpressionType::InnerIterator InnerIterator;$/;"	t	class:Eigen::Flagged	access:public
Eigen::Flagged::_expression	src/Core/Flagged.h	/^    const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::coeff	src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
Eigen::Flagged::coeff	src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
Eigen::Flagged::coeffRef	src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index)
Eigen::Flagged::coeffRef	src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col)
Eigen::Flagged::coeffRef	src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
Eigen::Flagged::coeffRef	src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
Eigen::Flagged::cols	src/Core/Flagged.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::innerStride	src/Core/Flagged.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::m_matrix	src/Core/Flagged.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Flagged	access:protected
Eigen::Flagged::outerStride	src/Core/Flagged.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::packet	src/Core/Flagged.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
Eigen::Flagged::packet	src/Core/Flagged.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
Eigen::Flagged::rows	src/Core/Flagged.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::solveTriangular	src/Core/Flagged.h	/^    typename ExpressionType::PlainObject solveTriangular(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Flagged	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Flagged::solveTriangular	src/Eigen2Support/TriangularSolver.h	/^Flagged<ExpressionType,Added,Removed>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Flagged::solveTriangularInPlace	src/Core/Flagged.h	/^    void solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Flagged	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Flagged::solveTriangularInPlace	src/Eigen2Support/TriangularSolver.h	/^void Flagged<ExpressionType,Added,Removed>::solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Flagged::writePacket	src/Core/Flagged.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index, const PacketScalar& x)
Eigen::Flagged::writePacket	src/Core/Flagged.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::ForceAlignedAccess	src/Core/ForceAlignedAccess.h	/^template<typename ExpressionType> class ForceAlignedAccess$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::ForceAlignedAccess::Base	src/Core/ForceAlignedAccess.h	/^    typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;$/;"	t	class:Eigen::ForceAlignedAccess	access:public
Eigen::ForceAlignedAccess::ForceAlignedAccess	src/Core/ForceAlignedAccess.h	/^    inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(const ExpressionType& matrix)
Eigen::ForceAlignedAccess::coeff	src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index) const
Eigen::ForceAlignedAccess::coeff	src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col) const
Eigen::ForceAlignedAccess::coeffRef	src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index)
Eigen::ForceAlignedAccess::coeffRef	src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col)
Eigen::ForceAlignedAccess::cols	src/Core/ForceAlignedAccess.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::innerStride	src/Core/ForceAlignedAccess.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::m_expression	src/Core/ForceAlignedAccess.h	/^    const ExpressionType& m_expression;$/;"	m	class:Eigen::ForceAlignedAccess	access:protected
Eigen::ForceAlignedAccess::operator =	src/Core/ForceAlignedAccess.h	/^    ForceAlignedAccess& operator=(const ForceAlignedAccess&);$/;"	p	class:Eigen::ForceAlignedAccess	access:private	signature:(const ForceAlignedAccess&)
Eigen::ForceAlignedAccess::operator const ExpressionType&	src/Core/ForceAlignedAccess.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::outerStride	src/Core/ForceAlignedAccess.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::packet	src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index) const
Eigen::ForceAlignedAccess::packet	src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col) const
Eigen::ForceAlignedAccess::rows	src/Core/ForceAlignedAccess.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::writePacket	src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index, const PacketScalar& x)
Eigen::ForceAlignedAccess::writePacket	src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::FullPivHouseholderQR	src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> class FullPivHouseholderQR$/;"	c	namespace:Eigen
Eigen::FullPivHouseholderQR::ColVectorType	src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::ColsAtCompileTime	src/QR/FullPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
Eigen::FullPivHouseholderQR::FullPivHouseholderQR	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR()$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:()
Eigen::FullPivHouseholderQR::FullPivHouseholderQR	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(Index rows, Index cols)
Eigen::FullPivHouseholderQR::FullPivHouseholderQR	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::FullPivHouseholderQR::HCoeffsType	src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::Index	src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::IntDiagSizeVectorType	src/QR/FullPivHouseholderQR.h	/^                   EIGEN_SIZE_MIN_PREFER_FIXED(MaxColsAtCompileTime,MaxRowsAtCompileTime)> IntDiagSizeVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::MatrixQReturnType	src/QR/FullPivHouseholderQR.h	/^    typedef internal::FullPivHouseholderQRMatrixQReturnType<MatrixType> MatrixQReturnType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::MatrixType	src/QR/FullPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::MaxColsAtCompileTime	src/QR/FullPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
Eigen::FullPivHouseholderQR::MaxRowsAtCompileTime	src/QR/FullPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
Eigen::FullPivHouseholderQR::Options	src/QR/FullPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
Eigen::FullPivHouseholderQR::PermutationType	src/QR/FullPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::RealScalar	src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::RowVectorType	src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::RowsAtCompileTime	src/QR/FullPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
Eigen::FullPivHouseholderQR::Scalar	src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::absDeterminant	src/QR/FullPivHouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::absDeterminant	src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
Eigen::FullPivHouseholderQR::check_template_parameters	src/QR/FullPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivHouseholderQR	access:protected	signature:()
Eigen::FullPivHouseholderQR::cols	src/QR/FullPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::colsPermutation	src/QR/FullPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::compute	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::FullPivHouseholderQR::compute	src/QR/FullPivHouseholderQR.h	/^FullPivHouseholderQR<MatrixType>& FullPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR	signature:(const MatrixType& matrix)
Eigen::FullPivHouseholderQR::dimensionOfKernel	src/QR/FullPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::hCoeffs	src/QR/FullPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::inverse	src/QR/FullPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::isInjective	src/QR/FullPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::isInvertible	src/QR/FullPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::isSurjective	src/QR/FullPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::logAbsDeterminant	src/QR/FullPivHouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::logAbsDeterminant	src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
Eigen::FullPivHouseholderQR::m_cols_permutation	src/QR/FullPivHouseholderQR.h	/^    PermutationType m_cols_permutation;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_cols_transpositions	src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_cols_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_det_pq	src/QR/FullPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_hCoeffs	src/QR/FullPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_isInitialized	src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_maxpivot	src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_nonzero_pivots	src/QR/FullPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_precision	src/QR/FullPivHouseholderQR.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_prescribedThreshold	src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_qr	src/QR/FullPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_rows_transpositions	src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_rows_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_temp	src/QR/FullPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_usePrescribedThreshold	src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::matrixQ	src/QR/FullPivHouseholderQR.h	/^    MatrixQReturnType matrixQ(void) const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:(void) const
Eigen::FullPivHouseholderQR::matrixQ	src/QR/FullPivHouseholderQR.h	/^inline typename FullPivHouseholderQR<MatrixType>::MatrixQReturnType FullPivHouseholderQR<MatrixType>::matrixQ() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
Eigen::FullPivHouseholderQR::matrixQR	src/QR/FullPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::maxPivot	src/QR/FullPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::nonzeroPivots	src/QR/FullPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::rank	src/QR/FullPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::rows	src/QR/FullPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::rowsTranspositions	src/QR/FullPivHouseholderQR.h	/^    const IntDiagSizeVectorType& rowsTranspositions() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::setThreshold	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(Default_t)
Eigen::FullPivHouseholderQR::setThreshold	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const RealScalar& threshold)
Eigen::FullPivHouseholderQR::solve	src/QR/FullPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::FullPivHouseholderQR::threshold	src/QR/FullPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQRPreconditioner	src/Core/util/Constants.h	/^  FullPivHouseholderQRPreconditioner$/;"	e	enum:Eigen::QRPreconditioners
Eigen::FullPivLU	src/LU/FullPivLU.h	/^template<typename _MatrixType> class FullPivLU$/;"	c	namespace:Eigen
Eigen::FullPivLU::ColsAtCompileTime	src/LU/FullPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon398
Eigen::FullPivLU::FullPivLU	src/LU/FullPivLU.h	/^    FullPivLU();$/;"	p	class:Eigen::FullPivLU	access:public	signature:()
Eigen::FullPivLU::FullPivLU	src/LU/FullPivLU.h	/^    FullPivLU(Index rows, Index cols);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(Index rows, Index cols)
Eigen::FullPivLU::FullPivLU	src/LU/FullPivLU.h	/^    FullPivLU(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& matrix)
Eigen::FullPivLU::FullPivLU	src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU()$/;"	f	class:Eigen::FullPivLU	signature:()
Eigen::FullPivLU::FullPivLU	src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(Index rows, Index cols)$/;"	f	class:Eigen::FullPivLU	signature:(Index rows, Index cols)
Eigen::FullPivLU::FullPivLU	src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU	signature:(const MatrixType& matrix)
Eigen::FullPivLU::Index	src/LU/FullPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::IntColVectorType	src/LU/FullPivLU.h	/^    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::IntRowVectorType	src/LU/FullPivLU.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::MatrixType	src/LU/FullPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::MaxColsAtCompileTime	src/LU/FullPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivLU::__anon398
Eigen::FullPivLU::MaxRowsAtCompileTime	src/LU/FullPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon398
Eigen::FullPivLU::Options	src/LU/FullPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivLU::__anon398
Eigen::FullPivLU::PermutationPType	src/LU/FullPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationPType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::PermutationQType	src/LU/FullPivLU.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::RealScalar	src/LU/FullPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::RowsAtCompileTime	src/LU/FullPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon398
Eigen::FullPivLU::Scalar	src/LU/FullPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::StorageKind	src/LU/FullPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::check_template_parameters	src/LU/FullPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivLU	access:protected	signature:()
Eigen::FullPivLU::cols	src/LU/FullPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::compute	src/LU/FullPivLU.h	/^    FullPivLU& compute(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& matrix)
Eigen::FullPivLU::compute	src/LU/FullPivLU.h	/^FullPivLU<MatrixType>& FullPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU	signature:(const MatrixType& matrix)
Eigen::FullPivLU::determinant	src/LU/FullPivLU.h	/^    typename internal::traits<MatrixType>::Scalar determinant() const;$/;"	p	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::determinant	src/LU/FullPivLU.h	/^typename internal::traits<MatrixType>::Scalar FullPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::FullPivLU	signature:() const
Eigen::FullPivLU::dimensionOfKernel	src/LU/FullPivLU.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::image	src/LU/FullPivLU.h	/^      image(const MatrixType& originalMatrix) const$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& originalMatrix) const
Eigen::FullPivLU::inverse	src/LU/FullPivLU.h	/^    inline const internal::solve_retval<FullPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::isInjective	src/LU/FullPivLU.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::isInvertible	src/LU/FullPivLU.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::isSurjective	src/LU/FullPivLU.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::kernel	src/LU/FullPivLU.h	/^    inline const internal::kernel_retval<FullPivLU> kernel() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::m_colsTranspositions	src/LU/FullPivLU.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_det_pq	src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_isInitialized	src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_lu	src/LU/FullPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_maxpivot	src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_nonzero_pivots	src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_p	src/LU/FullPivLU.h	/^    PermutationPType m_p;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_prescribedThreshold	src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_q	src/LU/FullPivLU.h	/^    PermutationQType m_q;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_rowsTranspositions	src/LU/FullPivLU.h	/^    IntColVectorType m_rowsTranspositions;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_usePrescribedThreshold	src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::matrixLU	src/LU/FullPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::maxPivot	src/LU/FullPivLU.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::nonzeroPivots	src/LU/FullPivLU.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::permutationP	src/LU/FullPivLU.h	/^    inline const PermutationPType& permutationP() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::permutationQ	src/LU/FullPivLU.h	/^    inline const PermutationQType& permutationQ() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::rank	src/LU/FullPivLU.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::reconstructedMatrix	src/LU/FullPivLU.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::reconstructedMatrix	src/LU/FullPivLU.h	/^MatrixType FullPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::FullPivLU	signature:() const
Eigen::FullPivLU::rows	src/LU/FullPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::setThreshold	src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivLU	access:public	signature:(Default_t)
Eigen::FullPivLU::setThreshold	src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const RealScalar& threshold)
Eigen::FullPivLU::solve	src/LU/FullPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::FullPivLU::threshold	src/LU/FullPivLU.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPrecision	src/Core/IO.h	/^       FullPrecision = -2 };$/;"	e	enum:Eigen::__anon273
Eigen::GemmProduct	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
Eigen::GemvProduct	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
Eigen::GenEigMask	src/Core/util/Constants.h	/^  GenEigMask = Ax_lBx | ABx_lx | BAx_lx$/;"	e	enum:Eigen::DecompositionOptions
Eigen::GeneralProduct	src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, GemvProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::GeneralProduct	src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, InnerProduct>$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,Matrix
Eigen::GeneralProduct	src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, OuterProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::GeneralProduct	src/Core/products/GeneralMatrixMatrix.h	/^class GeneralProduct<Lhs, Rhs, GemmProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::GeneralProduct::Base	src/Core/GeneralProduct.h	/^    typedef Matrix<typename internal::scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType,1,1> Base;$/;"	t	class:Eigen::GeneralProduct	access:private
Eigen::GeneralProduct::GeneralProduct	src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& a_lhs, const Rhs& a_rhs) : Base(a_lhs,a_rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& a_lhs, const Rhs& a_rhs)
Eigen::GeneralProduct::GeneralProduct	src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::GeneralProduct::GeneralProduct	src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::GeneralProduct::GeneralProduct	src/Core/products/GeneralMatrixMatrix.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::GeneralProduct::LhsScalar	src/Core/GeneralProduct.h	/^    typedef typename Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::LhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::MatrixType	src/Core/GeneralProduct.h	/^    typedef typename internal::conditional<int(Side)==OnTheRight,_LhsNested,_RhsNested>::type MatrixType;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::MaxDepthAtCompileTime	src/Core/products/GeneralMatrixMatrix.h	/^      MaxDepthAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime)$/;"	e	enum:Eigen::GeneralProduct::__anon44
Eigen::GeneralProduct::ResScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef           Scalar      ResScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::RhsScalar	src/Core/GeneralProduct.h	/^    typedef typename Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::RhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::Side	src/Core/GeneralProduct.h	/^    enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };$/;"	e	enum:Eigen::GeneralProduct::__anon268
Eigen::GeneralProduct::add	src/Core/GeneralProduct.h	/^    struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	s	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::add::operator ()	src/Core/GeneralProduct.h	/^    struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	f	struct:Eigen::GeneralProduct::add	access:public	signature:(const Dst& dst, const Src& src) const
Eigen::GeneralProduct::addTo	src/Core/GeneralProduct.h	/^    inline void addTo(Dest& dest) const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest) const
Eigen::GeneralProduct::adds	src/Core/GeneralProduct.h	/^    struct adds {$/;"	s	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::adds::adds	src/Core/GeneralProduct.h	/^      adds(const Scalar& s) : m_scale(s) {}$/;"	f	struct:Eigen::GeneralProduct::adds	access:public	signature:(const Scalar& s)
Eigen::GeneralProduct::adds::m_scale	src/Core/GeneralProduct.h	/^      Scalar m_scale;$/;"	m	struct:Eigen::GeneralProduct::adds	access:public
Eigen::GeneralProduct::adds::operator ()	src/Core/GeneralProduct.h	/^      template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const {$/;"	f	struct:Eigen::GeneralProduct::adds	access:public	signature:(const Dst& dst, const Src& src) const
Eigen::GeneralProduct::evalTo	src/Core/GeneralProduct.h	/^    inline void evalTo(Dest& dest) const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest) const
Eigen::GeneralProduct::is_row_major	src/Core/GeneralProduct.h	/^    template<typename T> struct is_row_major : internal::conditional<(int(T::Flags)&RowMajorBit), internal::true_type, internal::false_type>::type {};$/;"	s	class:Eigen::GeneralProduct	inherits:internal::conditional::type	access:private
Eigen::GeneralProduct::operator const typename Base::Scalar	src/Core/GeneralProduct.h	/^    operator const typename Base::Scalar() const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:() const
Eigen::GeneralProduct::scaleAndAddTo	src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest, const Scalar& alpha) const
Eigen::GeneralProduct::scaleAndAddTo	src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dst, const Scalar& alpha) const
Eigen::GeneralProduct::scaleAndAddTo	src/Core/products/GeneralMatrixMatrix.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dst, const Scalar& alpha) const
Eigen::GeneralProduct::set	src/Core/GeneralProduct.h	/^    struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	s	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::set::operator ()	src/Core/GeneralProduct.h	/^    struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	f	struct:Eigen::GeneralProduct::set	access:public	signature:(const Dst& dst, const Src& src) const
Eigen::GeneralProduct::sub	src/Core/GeneralProduct.h	/^    struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	s	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::sub::operator ()	src/Core/GeneralProduct.h	/^    struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	f	struct:Eigen::GeneralProduct::sub	access:public	signature:(const Dst& dst, const Src& src) const
Eigen::GeneralProduct::subTo	src/Core/GeneralProduct.h	/^    inline void subTo(Dest& dest) const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest) const
Eigen::GeneralizedEigenSolver	src/Eigenvalues/GeneralizedEigenSolver.h	/^template<typename _MatrixType> class GeneralizedEigenSolver$/;"	c	namespace:Eigen
Eigen::GeneralizedEigenSolver::ColsAtCompileTime	src/Eigenvalues/GeneralizedEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
Eigen::GeneralizedEigenSolver::ColumnVectorType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:protected
Eigen::GeneralizedEigenSolver::ComplexScalar	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Eigen::GeneralizedEigenSolver::ComplexVectorType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ComplexVectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Eigen::GeneralizedEigenSolver::EigenvalueType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef CwiseBinaryOp<internal::scalar_quotient_op<ComplexScalar,Scalar>,ComplexVectorType,VectorType> EigenvalueType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Eigen::GeneralizedEigenSolver::EigenvectorsType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Eigen::GeneralizedEigenSolver::GeneralizedEigenSolver	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver() : m_eivec(), m_alphas(), m_betas(), m_isInitialized(false), m_realQZ(), m_matS(), m_tmp() {}$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:()
Eigen::GeneralizedEigenSolver::GeneralizedEigenSolver	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:(Index size)
Eigen::GeneralizedEigenSolver::GeneralizedEigenSolver	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true)$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true)
Eigen::GeneralizedEigenSolver::Index	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Eigen::GeneralizedEigenSolver::MatrixType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Eigen::GeneralizedEigenSolver::MaxColsAtCompileTime	src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
Eigen::GeneralizedEigenSolver::MaxRowsAtCompileTime	src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
Eigen::GeneralizedEigenSolver::Options	src/Eigenvalues/GeneralizedEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
Eigen::GeneralizedEigenSolver::RealScalar	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Eigen::GeneralizedEigenSolver::RowsAtCompileTime	src/Eigenvalues/GeneralizedEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
Eigen::GeneralizedEigenSolver::Scalar	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Eigen::GeneralizedEigenSolver::VectorType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> VectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Eigen::GeneralizedEigenSolver::alphas	src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType alphas() const$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:() const
Eigen::GeneralizedEigenSolver::betas	src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType betas() const$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:() const
Eigen::GeneralizedEigenSolver::check_template_parameters	src/Eigenvalues/GeneralizedEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::GeneralizedEigenSolver	access:protected	signature:()
Eigen::GeneralizedEigenSolver::compute	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver& compute(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true);$/;"	p	class:Eigen::GeneralizedEigenSolver	access:public	signature:(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true)
Eigen::GeneralizedEigenSolver::compute	src/Eigenvalues/GeneralizedEigenSolver.h	/^GeneralizedEigenSolver<MatrixType>::compute(const MatrixType& A, const MatrixType& B, bool computeEigenvectors)$/;"	f	class:Eigen::GeneralizedEigenSolver	signature:(const MatrixType& A, const MatrixType& B, bool computeEigenvectors)
Eigen::GeneralizedEigenSolver::eigenvalues	src/Eigenvalues/GeneralizedEigenSolver.h	/^    EigenvalueType eigenvalues() const$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:() const
Eigen::GeneralizedEigenSolver::info	src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:() const
Eigen::GeneralizedEigenSolver::m_alphas	src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType m_alphas;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
Eigen::GeneralizedEigenSolver::m_betas	src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType m_betas;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
Eigen::GeneralizedEigenSolver::m_eigenvectorsOk	src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
Eigen::GeneralizedEigenSolver::m_eivec	src/Eigenvalues/GeneralizedEigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
Eigen::GeneralizedEigenSolver::m_isInitialized	src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
Eigen::GeneralizedEigenSolver::m_matS	src/Eigenvalues/GeneralizedEigenSolver.h	/^    MatrixType m_matS;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
Eigen::GeneralizedEigenSolver::m_realQZ	src/Eigenvalues/GeneralizedEigenSolver.h	/^    RealQZ<MatrixType> m_realQZ;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
Eigen::GeneralizedEigenSolver::m_tmp	src/Eigenvalues/GeneralizedEigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
Eigen::GeneralizedEigenSolver::setMaxIterations	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:(Index maxIters)
Eigen::GeneralizedSelfAdjointEigenSolver	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^class GeneralizedSelfAdjointEigenSolver : public SelfAdjointEigenSolver<_MatrixType>$/;"	c	namespace:Eigen	inherits:SelfAdjointEigenSolver
Eigen::GeneralizedSelfAdjointEigenSolver::Base	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef SelfAdjointEigenSolver<_MatrixType> Base;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:private
Eigen::GeneralizedSelfAdjointEigenSolver::GeneralizedSelfAdjointEigenSolver	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver() : Base() {}$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:()
Eigen::GeneralizedSelfAdjointEigenSolver::GeneralizedSelfAdjointEigenSolver	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(Index size)
Eigen::GeneralizedSelfAdjointEigenSolver::GeneralizedSelfAdjointEigenSolver	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB,$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, int options = ComputeEigenvectors|Ax_lBx)
Eigen::GeneralizedSelfAdjointEigenSolver::Index	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public
Eigen::GeneralizedSelfAdjointEigenSolver::MatrixType	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public
Eigen::GeneralizedSelfAdjointEigenSolver::compute	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver& compute(const MatrixType& matA, const MatrixType& matB,$/;"	p	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, int options = ComputeEigenvectors|Ax_lBx)
Eigen::GeneralizedSelfAdjointEigenSolver::compute	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^compute(const MatrixType& matA, const MatrixType& matB, int options)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	signature:(const MatrixType& matA, const MatrixType& matB, int options)
Eigen::GenericNumTraits	src/Core/NumTraits.h	/^template<typename T> struct GenericNumTraits$/;"	s	namespace:Eigen
Eigen::GenericNumTraits::AddCost	src/Core/NumTraits.h	/^    AddCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
Eigen::GenericNumTraits::IsComplex	src/Core/NumTraits.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
Eigen::GenericNumTraits::IsInteger	src/Core/NumTraits.h	/^    IsInteger = std::numeric_limits<T>::is_integer,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
Eigen::GenericNumTraits::IsSigned	src/Core/NumTraits.h	/^    IsSigned = std::numeric_limits<T>::is_signed,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
Eigen::GenericNumTraits::MulCost	src/Core/NumTraits.h	/^    MulCost = 1$/;"	e	enum:Eigen::GenericNumTraits::__anon286
Eigen::GenericNumTraits::ReadCost	src/Core/NumTraits.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
Eigen::GenericNumTraits::Real	src/Core/NumTraits.h	/^  typedef T Real;$/;"	t	struct:Eigen::GenericNumTraits	access:public
Eigen::GenericNumTraits::RequireInitialization	src/Core/NumTraits.h	/^    RequireInitialization = internal::is_arithmetic<T>::value ? 0 : 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
Eigen::GetAction	src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
Eigen::HereditaryBits	src/Core/util/Constants.h	/^const unsigned int HereditaryBits = RowMajorBit$/;"	m	namespace:Eigen
Eigen::HessenbergDecomposition	src/Eigenvalues/HessenbergDecomposition.h	/^template<typename _MatrixType> class HessenbergDecomposition$/;"	c	namespace:Eigen
Eigen::HessenbergDecomposition::CoeffVectorType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::HessenbergDecomposition	src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(Index size = Size==Dynamic ? 2 : Size)
Eigen::HessenbergDecomposition::HessenbergDecomposition	src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(const MatrixType& matrix)
Eigen::HessenbergDecomposition::HouseholderSequenceType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::Index	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::MatrixHReturnType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef internal::HessenbergDecompositionMatrixHReturnType<MatrixType> MatrixHReturnType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::MatrixType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::MaxSize	src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
Eigen::HessenbergDecomposition::MaxSizeMinusOne	src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : MaxSize - 1$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
Eigen::HessenbergDecomposition::Options	src/Eigenvalues/HessenbergDecomposition.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
Eigen::HessenbergDecomposition::RealScalar	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::HessenbergDecomposition	access:private
Eigen::HessenbergDecomposition::Scalar	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::Size	src/Eigenvalues/HessenbergDecomposition.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
Eigen::HessenbergDecomposition::SizeMinusOne	src/Eigenvalues/HessenbergDecomposition.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : Size - 1,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
Eigen::HessenbergDecomposition::VectorType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;$/;"	t	class:Eigen::HessenbergDecomposition	access:private
Eigen::HessenbergDecomposition::_compute	src/Eigenvalues/HessenbergDecomposition.h	/^    static void _compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp);$/;"	p	class:Eigen::HessenbergDecomposition	access:private	signature:(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)
Eigen::HessenbergDecomposition::_compute	src/Eigenvalues/HessenbergDecomposition.h	/^void HessenbergDecomposition<MatrixType>::_compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)$/;"	f	class:Eigen::HessenbergDecomposition	signature:(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)
Eigen::HessenbergDecomposition::compute	src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition& compute(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(const MatrixType& matrix)
Eigen::HessenbergDecomposition::householderCoefficients	src/Eigenvalues/HessenbergDecomposition.h	/^    const CoeffVectorType& householderCoefficients() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
Eigen::HessenbergDecomposition::m_hCoeffs	src/Eigenvalues/HessenbergDecomposition.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
Eigen::HessenbergDecomposition::m_isInitialized	src/Eigenvalues/HessenbergDecomposition.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
Eigen::HessenbergDecomposition::m_matrix	src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
Eigen::HessenbergDecomposition::m_temp	src/Eigenvalues/HessenbergDecomposition.h	/^    VectorType m_temp;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
Eigen::HessenbergDecomposition::matrixH	src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixHReturnType matrixH() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
Eigen::HessenbergDecomposition::matrixQ	src/Eigenvalues/HessenbergDecomposition.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
Eigen::HessenbergDecomposition::packedMatrix	src/Eigenvalues/HessenbergDecomposition.h	/^    const MatrixType& packedMatrix() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
Eigen::Homogeneous	src/Geometry/Homogeneous.h	/^template<typename MatrixType,int _Direction> class Homogeneous$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
Eigen::Homogeneous::Base	src/Geometry/Homogeneous.h	/^    typedef MatrixBase<Homogeneous> Base;$/;"	t	class:Eigen::Homogeneous	access:public
Eigen::Homogeneous::Direction	src/Geometry/Homogeneous.h	/^    enum { Direction = _Direction };$/;"	e	enum:Eigen::Homogeneous::__anon372
Eigen::Homogeneous::Homogeneous	src/Geometry/Homogeneous.h	/^    inline Homogeneous(const MatrixType& matrix)$/;"	f	class:Eigen::Homogeneous	access:public	signature:(const MatrixType& matrix)
Eigen::Homogeneous::coeff	src/Geometry/Homogeneous.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Homogeneous	access:public	signature:(Index row, Index col) const
Eigen::Homogeneous::cols	src/Geometry/Homogeneous.h	/^    inline Index cols() const { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous	access:public	signature:() const
Eigen::Homogeneous::m_matrix	src/Geometry/Homogeneous.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Homogeneous	access:protected
Eigen::Homogeneous::operator *	src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous	access:friend	signature:(const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)
Eigen::Homogeneous::operator *	src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Rhs>& rhs) const$/;"	f	class:Eigen::Homogeneous	access:public	signature:(const MatrixBase<Rhs>& rhs) const
Eigen::Homogeneous::operator *	src/Geometry/Homogeneous.h	/^    operator* (const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous	access:friend	signature:(const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)
Eigen::Homogeneous::rows	src/Geometry/Homogeneous.h	/^    inline Index rows() const { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous	access:public	signature:() const
Eigen::Horizontal	src/Core/util/Constants.h	/^  Horizontal, $/;"	e	enum:Eigen::DirectionType
Eigen::HouseholderQR	src/QR/HouseholderQR.h	/^template<typename _MatrixType> class HouseholderQR$/;"	c	namespace:Eigen
Eigen::HouseholderQR::ColsAtCompileTime	src/QR/HouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon415
Eigen::HouseholderQR::HCoeffsType	src/QR/HouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::HouseholderQR	src/QR/HouseholderQR.h	/^    HouseholderQR() : m_qr(), m_hCoeffs(), m_temp(), m_isInitialized(false) {}$/;"	f	class:Eigen::HouseholderQR	access:public	signature:()
Eigen::HouseholderQR::HouseholderQR	src/QR/HouseholderQR.h	/^    HouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(Index rows, Index cols)
Eigen::HouseholderQR::HouseholderQR	src/QR/HouseholderQR.h	/^    HouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::HouseholderQR::HouseholderSequenceType	src/QR/HouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::Index	src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::MatrixQType	src/QR/HouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::MatrixType	src/QR/HouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::MaxColsAtCompileTime	src/QR/HouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderQR::__anon415
Eigen::HouseholderQR::MaxRowsAtCompileTime	src/QR/HouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon415
Eigen::HouseholderQR::Options	src/QR/HouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HouseholderQR::__anon415
Eigen::HouseholderQR::RealScalar	src/QR/HouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::RowVectorType	src/QR/HouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::RowsAtCompileTime	src/QR/HouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon415
Eigen::HouseholderQR::Scalar	src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::absDeterminant	src/QR/HouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::absDeterminant	src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::HouseholderQR	signature:() const
Eigen::HouseholderQR::check_template_parameters	src/QR/HouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::HouseholderQR	access:protected	signature:()
Eigen::HouseholderQR::cols	src/QR/HouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::compute	src/QR/HouseholderQR.h	/^    HouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::HouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::HouseholderQR::compute	src/QR/HouseholderQR.h	/^HouseholderQR<MatrixType>& HouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR	signature:(const MatrixType& matrix)
Eigen::HouseholderQR::hCoeffs	src/QR/HouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::householderQ	src/QR/HouseholderQR.h	/^    HouseholderSequenceType householderQ() const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::logAbsDeterminant	src/QR/HouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::logAbsDeterminant	src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::HouseholderQR	signature:() const
Eigen::HouseholderQR::m_hCoeffs	src/QR/HouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::HouseholderQR	access:protected
Eigen::HouseholderQR::m_isInitialized	src/QR/HouseholderQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HouseholderQR	access:protected
Eigen::HouseholderQR::m_qr	src/QR/HouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::HouseholderQR	access:protected
Eigen::HouseholderQR::m_temp	src/QR/HouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::HouseholderQR	access:protected
Eigen::HouseholderQR::matrixQR	src/QR/HouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::rows	src/QR/HouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::solve	src/QR/HouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::HouseholderQRPreconditioner	src/Core/util/Constants.h	/^  HouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
Eigen::HouseholderSequence	src/Householder/HouseholderSequence.h	/^template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::HouseholderSequence::ColsAtCompileTime	src/Householder/HouseholderSequence.h	/^      ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon394
Eigen::HouseholderSequence::ConjugateReturnType	src/Householder/HouseholderSequence.h	/^    > ConjugateReturnType;$/;"	t	class:Eigen::HouseholderSequence	access:public
Eigen::HouseholderSequence::EssentialVectorType	src/Householder/HouseholderSequence.h	/^    typedef typename internal::hseq_side_dependent_impl<VectorsType,CoeffsType,Side>::EssentialVectorType EssentialVectorType;$/;"	t	class:Eigen::HouseholderSequence	access:private
Eigen::HouseholderSequence::HouseholderSequence	src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const HouseholderSequence& other)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const HouseholderSequence& other)
Eigen::HouseholderSequence::HouseholderSequence	src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const VectorsType& v, const CoeffsType& h)
Eigen::HouseholderSequence::Index	src/Householder/HouseholderSequence.h	/^    typedef typename VectorsType::Index Index;$/;"	t	class:Eigen::HouseholderSequence	access:public
Eigen::HouseholderSequence::MaxColsAtCompileTime	src/Householder/HouseholderSequence.h	/^      MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderSequence::__anon394
Eigen::HouseholderSequence::MaxRowsAtCompileTime	src/Householder/HouseholderSequence.h	/^      MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon394
Eigen::HouseholderSequence::RowsAtCompileTime	src/Householder/HouseholderSequence.h	/^      RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon394
Eigen::HouseholderSequence::Scalar	src/Householder/HouseholderSequence.h	/^    typedef typename internal::traits<HouseholderSequence>::Scalar Scalar;$/;"	t	class:Eigen::HouseholderSequence	access:public
Eigen::HouseholderSequence::adjoint	src/Householder/HouseholderSequence.h	/^    ConjugateReturnType adjoint() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::applyThisOnTheLeft	src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
Eigen::HouseholderSequence::applyThisOnTheLeft	src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst) const
Eigen::HouseholderSequence::applyThisOnTheRight	src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheRight(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
Eigen::HouseholderSequence::applyThisOnTheRight	src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst) const
Eigen::HouseholderSequence::cols	src/Householder/HouseholderSequence.h	/^    Index cols() const { return rows(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::conjugate	src/Householder/HouseholderSequence.h	/^    ConjugateReturnType conjugate() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::essentialVector	src/Householder/HouseholderSequence.h	/^    const EssentialVectorType essentialVector(Index k) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index k) const
Eigen::HouseholderSequence::evalTo	src/Householder/HouseholderSequence.h	/^    template<typename DestType> inline void evalTo(DestType& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(DestType& dst) const
Eigen::HouseholderSequence::evalTo	src/Householder/HouseholderSequence.h	/^    void evalTo(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
Eigen::HouseholderSequence::inverse	src/Householder/HouseholderSequence.h	/^    ConjugateReturnType inverse() const { return adjoint(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::length	src/Householder/HouseholderSequence.h	/^    Index length() const { return m_length; }  \/**< \\brief Returns the length of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::m_coeffs	src/Householder/HouseholderSequence.h	/^    typename CoeffsType::Nested m_coeffs;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::m_length	src/Householder/HouseholderSequence.h	/^    Index m_length;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::m_shift	src/Householder/HouseholderSequence.h	/^    Index m_shift;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::m_trans	src/Householder/HouseholderSequence.h	/^    bool m_trans;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::m_vectors	src/Householder/HouseholderSequence.h	/^    typename VectorsType::Nested m_vectors;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::operator *	src/Householder/HouseholderSequence.h	/^    typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::HouseholderSequence::rows	src/Householder/HouseholderSequence.h	/^    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::setLength	src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setLength(Index length)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index length)
Eigen::HouseholderSequence::setShift	src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setShift(Index shift)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index shift)
Eigen::HouseholderSequence::setTrans	src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setTrans(bool trans)$/;"	f	class:Eigen::HouseholderSequence	access:protected	signature:(bool trans)
Eigen::HouseholderSequence::shift	src/Householder/HouseholderSequence.h	/^    Index shift() const { return m_shift; }    \/**< \\brief Returns the shift of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::trans	src/Householder/HouseholderSequence.h	/^    bool trans() const { return m_trans; }     \/**< \\brief Returns the transpose flag. *\/$/;"	f	class:Eigen::HouseholderSequence	access:protected	signature:() const
Eigen::HouseholderSequence::transpose	src/Householder/HouseholderSequence.h	/^    HouseholderSequence transpose() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
Eigen::Hyperplane	src/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
Eigen::Hyperplane::AmbientDimAtCompileTime	src/Eigen2Support/Geometry/Hyperplane.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::Hyperplane::__anon341
Eigen::Hyperplane::AmbientDimAtCompileTime	src/Geometry/Hyperplane.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::Hyperplane::__anon373
Eigen::Hyperplane::Coefficients	src/Eigen2Support/Geometry/Hyperplane.h	/^                        : int(AmbientDimAtCompileTime)+1,1> Coefficients;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::Coefficients	src/Geometry/Hyperplane.h	/^                        : Index(AmbientDimAtCompileTime)+1,1,Options> Coefficients;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::ConstNormalReturnType	src/Geometry/Hyperplane.h	/^  typedef const Block<const Coefficients,AmbientDimAtCompileTime,1> ConstNormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)
Eigen::Hyperplane::Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, Scalar d)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, Scalar d)
Eigen::Hyperplane::Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const VectorType& e)
Eigen::Hyperplane::Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)
Eigen::Hyperplane::Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(int _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:(int _dim)
Eigen::Hyperplane::Hyperplane	src/Geometry/Hyperplane.h	/^  Hyperplane(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)
Eigen::Hyperplane::Hyperplane	src/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)
Eigen::Hyperplane::Hyperplane	src/Geometry/Hyperplane.h	/^  inline Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::Hyperplane	src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const Scalar& d)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const Scalar& d)
Eigen::Hyperplane::Hyperplane	src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const VectorType& e)
Eigen::Hyperplane::Hyperplane	src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(Index _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:(Index _dim)
Eigen::Hyperplane::Hyperplane	src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)
Eigen::Hyperplane::Index	src/Geometry/Hyperplane.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::NormalReturnType	src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::NormalReturnType	src/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::Options	src/Geometry/Hyperplane.h	/^    Options = _Options$/;"	e	enum:Eigen::Hyperplane::__anon373
Eigen::Hyperplane::RealScalar	src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::RealScalar	src/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::Scalar	src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::Scalar	src/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::Through	src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1)
Eigen::Hyperplane::Through	src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1, const VectorType& p2)
Eigen::Hyperplane::Through	src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1)
Eigen::Hyperplane::Through	src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1, const VectorType& p2)
Eigen::Hyperplane::VectorType	src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::VectorType	src/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::absDistance	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { return ei_abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::absDistance	src/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { using std::abs; return abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::cast	src/Eigen2Support/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::cast	src/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::coeffs	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::coeffs	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::coeffs	src/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::coeffs	src/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::dim	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline int dim() const { return int(AmbientDimAtCompileTime)==Dynamic ? m_coeffs.size()-1 : int(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::dim	src/Geometry/Hyperplane.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_coeffs.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::intersection	src/Eigen2Support/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other)
Eigen::Hyperplane::intersection	src/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other) const
Eigen::Hyperplane::isApprox	src/Eigen2Support/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Hyperplane::isApprox	src/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::Hyperplane::m_coeffs	src/Eigen2Support/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane	access:protected
Eigen::Hyperplane::m_coeffs	src/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane	access:protected
Eigen::Hyperplane::normal	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::normal	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const NormalReturnType normal() const { return NormalReturnType(*const_cast<Coefficients*>(&m_coeffs),0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::normal	src/Geometry/Hyperplane.h	/^  inline ConstNormalReturnType normal() const { return ConstNormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::normal	src/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::normalize	src/Eigen2Support/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(void)
Eigen::Hyperplane::normalize	src/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(void)
Eigen::Hyperplane::offset	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::offset	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::offset	src/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::offset	src/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::projection	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::projection	src/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::signedDistance	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return p.eigen2_dot(normal()) + offset(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::signedDistance	src/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return normal().dot(p) + offset(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::transform	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)
Eigen::Hyperplane::transform	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime>& t,$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Transform<Scalar,AmbientDimAtCompileTime>& t, TransformTraits traits = Affine)
Eigen::Hyperplane::transform	src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)
Eigen::Hyperplane::transform	src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t,$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t, TransformTraits traits = Affine)
Eigen::Hyperplane::~Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::~Hyperplane	src/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::IOFormat	src/Core/IO.h	/^struct IOFormat$/;"	s	namespace:Eigen
Eigen::IOFormat::IOFormat	src/Core/IO.h	/^  IOFormat(int _precision = StreamPrecision, int _flags = 0,$/;"	f	struct:Eigen::IOFormat	access:public	signature:(int _precision = StreamPrecision, int _flags = 0, const std::string& _coeffSeparator = , const std::string& _rowSeparator = , const std::string& _rowPrefix=, const std::string& _rowSuffix=, const std::string& _matPrefix=, const std::string& _matSuffix=)
Eigen::IOFormat::coeffSeparator	src/Core/IO.h	/^  std::string coeffSeparator;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::flags	src/Core/IO.h	/^  int flags;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::matPrefix	src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::matSuffix	src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::precision	src/Core/IO.h	/^  int precision;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::rowPrefix	src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::rowSeparator	src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::rowSpacer	src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::rowSuffix	src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IdentityPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^class IdentityPreconditioner$/;"	c	namespace:Eigen
Eigen::IdentityPreconditioner::IdentityPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner() {}$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:()
Eigen::IdentityPreconditioner::IdentityPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner(const MatrixType& ) {}$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
Eigen::IdentityPreconditioner::analyzePattern	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& analyzePattern(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
Eigen::IdentityPreconditioner::compute	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& compute(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
Eigen::IdentityPreconditioner::factorize	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& factorize(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
Eigen::IdentityPreconditioner::solve	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    inline const Rhs& solve(const Rhs& b) const { return b; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const Rhs& b) const
Eigen::IncompleteLUT	src/IterativeLinearSolvers/IncompleteLUT.h	/^class IncompleteLUT : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::IncompleteLUT::FactorType	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,RowMajor> FactorType;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::IncompleteLUT	src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT()$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:()
Eigen::IncompleteLUT::IncompleteLUT	src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT(const MatrixType& mat, const RealScalar& droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& mat, const RealScalar& droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)
Eigen::IncompleteLUT::Index	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename FactorType::Index Index;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::MatrixType	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::IncompleteLUT	access:public
Eigen::IncompleteLUT::PermutType	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,ColMajor> PermutType;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::RealScalar	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::Scalar	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::Vector	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::_solve	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::IncompleteLUT::analyzePattern	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void analyzePattern(const MatrixType& amat);$/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
Eigen::IncompleteLUT::analyzePattern	src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::analyzePattern(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	signature:(const _MatrixType& amat)
Eigen::IncompleteLUT::cols	src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
Eigen::IncompleteLUT::compute	src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT<Scalar>& compute(const MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
Eigen::IncompleteLUT::factorize	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void factorize(const MatrixType& amat);$/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
Eigen::IncompleteLUT::factorize	src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::factorize(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	signature:(const _MatrixType& amat)
Eigen::IncompleteLUT::info	src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
Eigen::IncompleteLUT::keep_diag	src/IterativeLinearSolvers/IncompleteLUT.h	/^    struct keep_diag {$/;"	s	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::keep_diag::operator ()	src/IterativeLinearSolvers/IncompleteLUT.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::IncompleteLUT::keep_diag	access:public	signature:(const Index& row, const Index& col, const Scalar&) const
Eigen::IncompleteLUT::m_P	src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ Fill-reducing permutation$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_Pinv	src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ Inverse permutation$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_analysisIsOk	src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_droptol	src/IterativeLinearSolvers/IncompleteLUT.h	/^    RealScalar m_droptol;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_factorizationIsOk	src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_fillfactor	src/IterativeLinearSolvers/IncompleteLUT.h	/^    int m_fillfactor;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_info	src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_isInitialized	src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_lu	src/IterativeLinearSolvers/IncompleteLUT.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::rows	src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
Eigen::IncompleteLUT::setDroptol	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void setDroptol(const RealScalar& droptol); $/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const RealScalar& droptol)
Eigen::IncompleteLUT::setDroptol	src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setDroptol(const RealScalar& droptol)$/;"	f	class:Eigen::IncompleteLUT	signature:(const RealScalar& droptol)
Eigen::IncompleteLUT::setFillfactor	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void setFillfactor(int fillfactor); $/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(int fillfactor)
Eigen::IncompleteLUT::setFillfactor	src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setFillfactor(int fillfactor)$/;"	f	class:Eigen::IncompleteLUT	signature:(int fillfactor)
Eigen::IncompleteLUT::solve	src/IterativeLinearSolvers/IncompleteLUT.h	/^     solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::Infinity	src/Core/util/Constants.h	/^const int Infinity = -1;$/;"	m	namespace:Eigen
Eigen::InnerProduct	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
Eigen::InnerRandomAccessPattern	src/SparseCore/SparseUtil.h	/^const int InnerRandomAccessPattern  = 0x2 | CoherentAccessPattern;$/;"	m	namespace:Eigen
Eigen::InnerStride	src/Core/Stride.h	/^class InnerStride : public Stride<0, Value>$/;"	c	namespace:Eigen	inherits:Stride
Eigen::InnerStride::Base	src/Core/Stride.h	/^    typedef Stride<0, Value> Base;$/;"	t	class:Eigen::InnerStride	access:private
Eigen::InnerStride::Index	src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::InnerStride	access:public
Eigen::InnerStride::InnerStride	src/Core/Stride.h	/^    InnerStride() : Base() {}$/;"	f	class:Eigen::InnerStride	access:public	signature:()
Eigen::InnerStride::InnerStride	src/Core/Stride.h	/^    InnerStride(Index v) : Base(0, v) {}$/;"	f	class:Eigen::InnerStride	access:public	signature:(Index v)
Eigen::InnerUnrolling	src/Core/util/Constants.h	/^  InnerUnrolling,$/;"	e	enum:Eigen::__anon64
Eigen::InnerVectorizedTraversal	src/Core/util/Constants.h	/^  InnerVectorizedTraversal,$/;"	e	enum:Eigen::__anon63
Eigen::InvalidInput	src/Core/util/Constants.h	/^  InvalidInput = 3$/;"	e	enum:Eigen::ComputationInfo
Eigen::InvalidTraversal	src/Core/util/Constants.h	/^  InvalidTraversal,$/;"	e	enum:Eigen::__anon63
Eigen::IsDense	src/Core/util/Constants.h	/^  IsDense         = 0,$/;"	e	enum:Eigen::__anon68
Eigen::IsSparse	src/Core/util/Constants.h	/^  IsSparse$/;"	e	enum:Eigen::__anon68
Eigen::Isometry	src/Core/util/Constants.h	/^  Isometry      = 0x1,$/;"	e	enum:Eigen::TransformTraits
Eigen::Isometry2d	src/Geometry/Transform.h	/^typedef Transform<double,2,Isometry> Isometry2d;$/;"	t	namespace:Eigen
Eigen::Isometry2f	src/Geometry/Transform.h	/^typedef Transform<float,2,Isometry> Isometry2f;$/;"	t	namespace:Eigen
Eigen::Isometry3d	src/Geometry/Transform.h	/^typedef Transform<double,3,Isometry> Isometry3d;$/;"	t	namespace:Eigen
Eigen::Isometry3f	src/Geometry/Transform.h	/^typedef Transform<float,3,Isometry> Isometry3f;$/;"	t	namespace:Eigen
Eigen::IterativeSolverBase	src/IterativeLinearSolvers/IterativeSolverBase.h	/^class IterativeSolverBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::IterativeSolverBase::Index	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::IterativeSolverBase	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase()$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Eigen::IterativeSolverBase::IterativeSolverBase	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const EigenBase<InputDerived>& A)
Eigen::IterativeSolverBase::MatrixType	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::Preconditioner	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::Preconditioner Preconditioner;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::RealScalar	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::Scalar	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::_solve_sparse	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
Eigen::IterativeSolverBase::analyzePattern	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& analyzePattern(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const EigenBase<InputDerived>& A)
Eigen::IterativeSolverBase::cols	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index cols() const { return mp_matrix ? mp_matrix->cols() : 0; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::compute	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& compute(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const EigenBase<InputDerived>& A)
Eigen::IterativeSolverBase::derived	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Eigen::IterativeSolverBase::derived	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::error	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar error() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::factorize	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& factorize(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const EigenBase<InputDerived>& A)
Eigen::IterativeSolverBase::grabInput	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grabInput(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:(const EigenBase<InputDerived>& A)
Eigen::IterativeSolverBase::grabInput_impl	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grabInput_impl(MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:(MatrixType& A)
Eigen::IterativeSolverBase::grabInput_impl	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grabInput_impl(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:(const EigenBase<InputDerived>& A)
Eigen::IterativeSolverBase::info	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ComputationInfo info() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::init	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void init()$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:()
Eigen::IterativeSolverBase::iterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int iterations() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::m_analysisIsOk	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_copyMatrix	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  MatrixType m_copyMatrix;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_error	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable RealScalar m_error;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_factorizationIsOk	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_info	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable ComputationInfo m_info;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_isInitialized	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_iterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable int m_iterations;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_maxIterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int m_maxIterations;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_preconditioner	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner m_preconditioner;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_tolerance	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar m_tolerance;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::maxIterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int maxIterations() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::mp_matrix	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const MatrixType* mp_matrix;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::preconditioner	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner& preconditioner() { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Eigen::IterativeSolverBase::preconditioner	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Preconditioner& preconditioner() const { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::rows	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index rows() const { return mp_matrix ? mp_matrix->rows() : 0; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::setMaxIterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setMaxIterations(int maxIters)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(int maxIters)
Eigen::IterativeSolverBase::setTolerance	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setTolerance(const RealScalar& tolerance)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const RealScalar& tolerance)
Eigen::IterativeSolverBase::solve	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::IterativeSolverBase::solve	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::IterativeSolverBase::tolerance	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar tolerance() const { return m_tolerance; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::~IterativeSolverBase	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ~IterativeSolverBase() {}$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Eigen::JacobiRotation	src/Jacobi/Jacobi.h	/^template<typename Scalar> class JacobiRotation$/;"	c	namespace:Eigen
Eigen::JacobiRotation::JacobiRotation	src/Jacobi/Jacobi.h	/^    JacobiRotation() {}$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
Eigen::JacobiRotation::JacobiRotation	src/Jacobi/Jacobi.h	/^    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}$/;"	f	class:Eigen::JacobiRotation	access:public	signature:(const Scalar& c, const Scalar& s)
Eigen::JacobiRotation::RealScalar	src/Jacobi/Jacobi.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiRotation	access:public
Eigen::JacobiRotation::adjoint	src/Jacobi/Jacobi.h	/^    JacobiRotation adjoint() const { using numext::conj; return JacobiRotation(conj(m_c), -m_s); }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
Eigen::JacobiRotation::c	src/Jacobi/Jacobi.h	/^    Scalar c() const { return m_c; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
Eigen::JacobiRotation::c	src/Jacobi/Jacobi.h	/^    Scalar& c() { return m_c; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
Eigen::JacobiRotation::m_c	src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation	access:protected
Eigen::JacobiRotation::m_s	src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation	access:protected
Eigen::JacobiRotation::makeGivens	src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::false_type);$/;"	p	class:Eigen::JacobiRotation	access:protected	signature:(const Scalar& p, const Scalar& q, Scalar* z, internal::false_type)
Eigen::JacobiRotation::makeGivens	src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::true_type);$/;"	p	class:Eigen::JacobiRotation	access:protected	signature:(const Scalar& p, const Scalar& q, Scalar* z, internal::true_type)
Eigen::JacobiRotation::makeGivens	src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z=0);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const Scalar& p, const Scalar& q, Scalar* z=0)
Eigen::JacobiRotation::makeGivens	src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)
Eigen::JacobiRotation::makeGivens	src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)
Eigen::JacobiRotation::makeGivens	src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* z)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* z)
Eigen::JacobiRotation::makeJacobi	src/Jacobi/Jacobi.h	/^    bool makeJacobi(const MatrixBase<Derived>&, typename Derived::Index p, typename Derived::Index q);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const MatrixBase<Derived>&, typename Derived::Index p, typename Derived::Index q)
Eigen::JacobiRotation::makeJacobi	src/Jacobi/Jacobi.h	/^    bool makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const RealScalar& x, const Scalar& y, const RealScalar& z)
Eigen::JacobiRotation::makeJacobi	src/Jacobi/Jacobi.h	/^bool JacobiRotation<Scalar>::makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z)$/;"	f	class:Eigen::JacobiRotation	signature:(const RealScalar& x, const Scalar& y, const RealScalar& z)
Eigen::JacobiRotation::makeJacobi	src/Jacobi/Jacobi.h	/^inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)$/;"	f	class:Eigen::JacobiRotation	signature:(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)
Eigen::JacobiRotation::operator *	src/Jacobi/Jacobi.h	/^    JacobiRotation operator*(const JacobiRotation& other)$/;"	f	class:Eigen::JacobiRotation	access:public	signature:(const JacobiRotation& other)
Eigen::JacobiRotation::s	src/Jacobi/Jacobi.h	/^    Scalar s() const { return m_s; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
Eigen::JacobiRotation::s	src/Jacobi/Jacobi.h	/^    Scalar& s() { return m_s; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
Eigen::JacobiRotation::transpose	src/Jacobi/Jacobi.h	/^    JacobiRotation transpose() const { using numext::conj; return JacobiRotation(m_c, -conj(m_s)); }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
Eigen::JacobiSVD	src/SVD/JacobiSVD.h	/^template<typename _MatrixType, int QRPreconditioner> class JacobiSVD$/;"	c	namespace:Eigen
Eigen::JacobiSVD::ColType	src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::ColsAtCompileTime	src/SVD/JacobiSVD.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon422
Eigen::JacobiSVD::DiagSizeAtCompileTime	src/SVD/JacobiSVD.h	/^      DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon422
Eigen::JacobiSVD::Index	src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::JacobiSVD	src/SVD/JacobiSVD.h	/^    JacobiSVD()$/;"	f	class:Eigen::JacobiSVD	access:public	signature:()
Eigen::JacobiSVD::JacobiSVD	src/SVD/JacobiSVD.h	/^    JacobiSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(Index rows, Index cols, unsigned int computationOptions = 0)
Eigen::JacobiSVD::JacobiSVD	src/SVD/JacobiSVD.h	/^    JacobiSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix, unsigned int computationOptions = 0)
Eigen::JacobiSVD::MatrixOptions	src/SVD/JacobiSVD.h	/^      MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::JacobiSVD::__anon422
Eigen::JacobiSVD::MatrixType	src/SVD/JacobiSVD.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::MatrixUType	src/SVD/JacobiSVD.h	/^            MatrixUType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::MatrixVType	src/SVD/JacobiSVD.h	/^            MatrixVType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::MaxColsAtCompileTime	src/SVD/JacobiSVD.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon422
Eigen::JacobiSVD::MaxDiagSizeAtCompileTime	src/SVD/JacobiSVD.h	/^      MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon422
Eigen::JacobiSVD::MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon422
Eigen::JacobiSVD::RealScalar	src/SVD/JacobiSVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::RowType	src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::RowsAtCompileTime	src/SVD/JacobiSVD.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon422
Eigen::JacobiSVD::Scalar	src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::SingularValuesType	src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_diag_type<MatrixType, RealScalar>::type SingularValuesType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::WorkMatrixType	src/SVD/JacobiSVD.h	/^            WorkMatrixType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::allocate	src/SVD/JacobiSVD.h	/^    void allocate(Index rows, Index cols, unsigned int computationOptions);$/;"	p	class:Eigen::JacobiSVD	access:private	signature:(Index rows, Index cols, unsigned int computationOptions)
Eigen::JacobiSVD::allocate	src/SVD/JacobiSVD.h	/^void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD	signature:(Index rows, Index cols, unsigned int computationOptions)
Eigen::JacobiSVD::check_template_parameters	src/SVD/JacobiSVD.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::JacobiSVD	access:private	signature:()
Eigen::JacobiSVD::cols	src/SVD/JacobiSVD.h	/^    inline Index cols() const { return m_cols; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::compute	src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix)
Eigen::JacobiSVD::compute	src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix, unsigned int computationOptions);$/;"	p	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix, unsigned int computationOptions)
Eigen::JacobiSVD::compute	src/SVD/JacobiSVD.h	/^JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType& matrix, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD	signature:(const MatrixType& matrix, unsigned int computationOptions)
Eigen::JacobiSVD::computeU	src/SVD/JacobiSVD.h	/^    inline bool computeU() const { return m_computeFullU || m_computeThinU; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::computeV	src/SVD/JacobiSVD.h	/^    inline bool computeV() const { return m_computeFullV || m_computeThinV; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::m_cols	src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computationOptions	src/SVD/JacobiSVD.h	/^    unsigned int m_computationOptions;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computeFullU	src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computeFullV	src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computeThinU	src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computeThinV	src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_diagSize	src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_isAllocated	src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_isInitialized	src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_matrixU	src/SVD/JacobiSVD.h	/^    MatrixUType m_matrixU;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_matrixV	src/SVD/JacobiSVD.h	/^    MatrixVType m_matrixV;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_nonzeroSingularValues	src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_prescribedThreshold	src/SVD/JacobiSVD.h	/^    RealScalar m_prescribedThreshold;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_qr_precond_morecols	src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows> m_qr_precond_morecols;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_qr_precond_morerows	src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols> m_qr_precond_morerows;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_rows	src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_scaledMatrix	src/SVD/JacobiSVD.h	/^    MatrixType m_scaledMatrix;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_singularValues	src/SVD/JacobiSVD.h	/^    SingularValuesType m_singularValues;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_usePrescribedThreshold	src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_workMatrix	src/SVD/JacobiSVD.h	/^    WorkMatrixType m_workMatrix;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::matrixU	src/SVD/JacobiSVD.h	/^    const MatrixUType& matrixU() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::matrixV	src/SVD/JacobiSVD.h	/^    const MatrixVType& matrixV() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::nonzeroSingularValues	src/SVD/JacobiSVD.h	/^    Index nonzeroSingularValues() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::rank	src/SVD/JacobiSVD.h	/^    inline Index rank() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::rows	src/SVD/JacobiSVD.h	/^    inline Index rows() const { return m_rows; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::setThreshold	src/SVD/JacobiSVD.h	/^    JacobiSVD& setThreshold(Default_t)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(Default_t)
Eigen::JacobiSVD::setThreshold	src/SVD/JacobiSVD.h	/^    JacobiSVD& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const RealScalar& threshold)
Eigen::JacobiSVD::singularValues	src/SVD/JacobiSVD.h	/^    const SingularValuesType& singularValues() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::solve	src/SVD/JacobiSVD.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::JacobiSVD::threshold	src/SVD/JacobiSVD.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::LDLT	src/Cholesky/LDLT.h	/^template<typename _MatrixType, int _UpLo> class LDLT$/;"	c	namespace:Eigen
Eigen::LDLT::ColsAtCompileTime	src/Cholesky/LDLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon1
Eigen::LDLT::Index	src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::LDLT	src/Cholesky/LDLT.h	/^    LDLT() $/;"	f	class:Eigen::LDLT	access:public	signature:()
Eigen::LDLT::LDLT	src/Cholesky/LDLT.h	/^    LDLT(Index size)$/;"	f	class:Eigen::LDLT	access:public	signature:(Index size)
Eigen::LDLT::LDLT	src/Cholesky/LDLT.h	/^    LDLT(const MatrixType& matrix)$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixType& matrix)
Eigen::LDLT::MatrixType	src/Cholesky/LDLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::MaxColsAtCompileTime	src/Cholesky/LDLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon1
Eigen::LDLT::MaxRowsAtCompileTime	src/Cholesky/LDLT.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon1
Eigen::LDLT::Options	src/Cholesky/LDLT.h	/^      Options = MatrixType::Options & ~RowMajorBit, \/\/ these are the options for the TmpMatrixType, we need a ColMajor matrix here!$/;"	e	enum:Eigen::LDLT::__anon1
Eigen::LDLT::PermutationType	src/Cholesky/LDLT.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::RealScalar	src/Cholesky/LDLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::RowsAtCompileTime	src/Cholesky/LDLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon1
Eigen::LDLT::Scalar	src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::TmpMatrixType	src/Cholesky/LDLT.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1, Options, MaxRowsAtCompileTime, 1> TmpMatrixType;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::Traits	src/Cholesky/LDLT.h	/^    typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::TranspositionType	src/Cholesky/LDLT.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::UpLo	src/Cholesky/LDLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LDLT::__anon1
Eigen::LDLT::check_template_parameters	src/Cholesky/LDLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LDLT	access:protected	signature:()
Eigen::LDLT::cols	src/Cholesky/LDLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::compute	src/Cholesky/LDLT.h	/^    LDLT& compute(const MatrixType& matrix);$/;"	p	class:Eigen::LDLT	access:public	signature:(const MatrixType& matrix)
Eigen::LDLT::compute	src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LDLT	signature:(const MatrixType& a)
Eigen::LDLT::info	src/Cholesky/LDLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::isNegative	src/Cholesky/LDLT.h	/^    inline bool isNegative(void) const$/;"	f	class:Eigen::LDLT	access:public	signature:(void) const
Eigen::LDLT::isPositive	src/Cholesky/LDLT.h	/^    inline bool isPositive() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::isPositiveDefinite	src/Cholesky/LDLT.h	/^    inline bool isPositiveDefinite() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::m_isInitialized	src/Cholesky/LDLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::m_matrix	src/Cholesky/LDLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::m_sign	src/Cholesky/LDLT.h	/^    internal::SignMatrix m_sign;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::m_temporary	src/Cholesky/LDLT.h	/^    TmpMatrixType m_temporary;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::m_transpositions	src/Cholesky/LDLT.h	/^    TranspositionType m_transpositions;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::matrixL	src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::matrixLDLT	src/Cholesky/LDLT.h	/^    inline const MatrixType& matrixLDLT() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::matrixU	src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::rankUpdate	src/Cholesky/LDLT.h	/^    LDLT& rankUpdate(const MatrixBase<Derived>& w, const RealScalar& alpha=1);$/;"	p	class:Eigen::LDLT	access:public	signature:(const MatrixBase<Derived>& w, const RealScalar& alpha=1)
Eigen::LDLT::rankUpdate	src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::rankUpdate(const MatrixBase<Derived>& w, const typename LDLT<MatrixType,_UpLo>::RealScalar& sigma)$/;"	f	class:Eigen::LDLT	signature:(const MatrixBase<Derived>& w, const typename LDLT<MatrixType,_UpLo>::RealScalar& sigma)
Eigen::LDLT::reconstructedMatrix	src/Cholesky/LDLT.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::reconstructedMatrix	src/Cholesky/LDLT.h	/^MatrixType LDLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LDLT	signature:() const
Eigen::LDLT::rows	src/Cholesky/LDLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::setZero	src/Cholesky/LDLT.h	/^    void setZero()$/;"	f	class:Eigen::LDLT	access:public	signature:()
Eigen::LDLT::solve	src/Cholesky/LDLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
Eigen::LDLT::solve	src/Cholesky/LDLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::LDLT::solveInPlace	src/Cholesky/LDLT.h	/^    bool solveInPlace(MatrixBase<Derived> &bAndX) const;$/;"	p	class:Eigen::LDLT	access:public	signature:(MatrixBase<Derived> &bAndX) const
Eigen::LDLT::solveInPlace	src/Cholesky/LDLT.h	/^bool LDLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LDLT	signature:(MatrixBase<Derived> &bAndX) const
Eigen::LDLT::transpositionsP	src/Cholesky/LDLT.h	/^    inline const TranspositionType& transpositionsP() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::vectorD	src/Cholesky/LDLT.h	/^    inline Diagonal<const MatrixType> vectorD() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LLT	src/Cholesky/LLT.h	/^template<typename _MatrixType, int _UpLo> class LLT$/;"	c	namespace:Eigen
Eigen::LLT::AlignmentMask	src/Cholesky/LLT.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::LLT::__anon3
Eigen::LLT::ColsAtCompileTime	src/Cholesky/LLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon2
Eigen::LLT::Index	src/Cholesky/LLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::LLT	src/Cholesky/LLT.h	/^    LLT() : m_matrix(), m_isInitialized(false) {}$/;"	f	class:Eigen::LLT	access:public	signature:()
Eigen::LLT::LLT	src/Cholesky/LLT.h	/^    LLT(Index size) : m_matrix(size, size),$/;"	f	class:Eigen::LLT	access:public	signature:(Index size)
Eigen::LLT::LLT	src/Cholesky/LLT.h	/^    LLT(const MatrixType& matrix)$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixType& matrix)
Eigen::LLT::MatrixType	src/Cholesky/LLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::MaxColsAtCompileTime	src/Cholesky/LLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::LLT::__anon2
Eigen::LLT::Options	src/Cholesky/LLT.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::LLT::__anon2
Eigen::LLT::PacketSize	src/Cholesky/LLT.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::LLT::__anon3
Eigen::LLT::RealScalar	src/Cholesky/LLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::RowsAtCompileTime	src/Cholesky/LLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon2
Eigen::LLT::Scalar	src/Cholesky/LLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::Traits	src/Cholesky/LLT.h	/^    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::UpLo	src/Cholesky/LLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LLT::__anon3
Eigen::LLT::check_template_parameters	src/Cholesky/LLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LLT	access:protected	signature:()
Eigen::LLT::cols	src/Cholesky/LLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::compute	src/Cholesky/LLT.h	/^    LLT& compute(const MatrixType& matrix);$/;"	p	class:Eigen::LLT	access:public	signature:(const MatrixType& matrix)
Eigen::LLT::compute	src/Cholesky/LLT.h	/^LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LLT	signature:(const MatrixType& a)
Eigen::LLT::info	src/Cholesky/LLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::isPositiveDefinite	src/Cholesky/LLT.h	/^    bool isPositiveDefinite() const { return true; }$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::m_info	src/Cholesky/LLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LLT	access:protected
Eigen::LLT::m_isInitialized	src/Cholesky/LLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LLT	access:protected
Eigen::LLT::m_matrix	src/Cholesky/LLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LLT	access:protected
Eigen::LLT::matrixL	src/Cholesky/LLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::matrixLLT	src/Cholesky/LLT.h	/^    inline const MatrixType& matrixLLT() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::matrixU	src/Cholesky/LLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::rankUpdate	src/Cholesky/LLT.h	/^    LLT rankUpdate(const VectorType& vec, const RealScalar& sigma = 1);$/;"	p	class:Eigen::LLT	access:public	signature:(const VectorType& vec, const RealScalar& sigma = 1)
Eigen::LLT::rankUpdate	src/Cholesky/LLT.h	/^LLT<_MatrixType,_UpLo> LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)$/;"	f	class:Eigen::LLT	signature:(const VectorType& v, const RealScalar& sigma)
Eigen::LLT::reconstructedMatrix	src/Cholesky/LLT.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::reconstructedMatrix	src/Cholesky/LLT.h	/^MatrixType LLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LLT	signature:() const
Eigen::LLT::rows	src/Cholesky/LLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::solve	src/Cholesky/LLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
Eigen::LLT::solve	src/Cholesky/LLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::LLT::solveInPlace	src/Cholesky/LLT.h	/^    void solveInPlace(MatrixBase<Derived> &bAndX) const;$/;"	p	class:Eigen::LLT	access:public	signature:(MatrixBase<Derived> &bAndX) const
Eigen::LLT::solveInPlace	src/Cholesky/LLT.h	/^void LLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LLT	signature:(MatrixBase<Derived> &bAndX) const
Eigen::LU	src/Eigen2Support/LU.h	/^class LU : public FullPivLU<MatrixType>$/;"	c	namespace:Eigen	inherits:FullPivLU
Eigen::LU::Base	src/Eigen2Support/LU.h	/^    typedef FullPivLU<MatrixType> Base;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::ColVectorType	src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::ImageResultType	src/Eigen2Support/LU.h	/^    > ImageResultType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::IntColVectorType	src/Eigen2Support/LU.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::IntRowVectorType	src/Eigen2Support/LU.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::KernelResultType	src/Eigen2Support/LU.h	/^    > KernelResultType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::LU	src/Eigen2Support/LU.h	/^    explicit LU(const T& t) : Base(t), m_originalMatrix(t) {}$/;"	f	class:Eigen::LU	access:public	signature:(const T& t)
Eigen::LU::RealScalar	src/Eigen2Support/LU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::RowVectorType	src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::Scalar	src/Eigen2Support/LU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::computeImage	src/Eigen2Support/LU.h	/^    void computeImage(ImageMatrixType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(ImageMatrixType *result) const
Eigen::LU::computeInverse	src/Eigen2Support/LU.h	/^    inline void computeInverse(ResultType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(ResultType *result) const
Eigen::LU::computeKernel	src/Eigen2Support/LU.h	/^    void computeKernel(KernelMatrixType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(KernelMatrixType *result) const
Eigen::LU::image	src/Eigen2Support/LU.h	/^    const ImageResultType image() const$/;"	f	class:Eigen::LU	access:public	signature:() const
Eigen::LU::m_originalMatrix	src/Eigen2Support/LU.h	/^    const MatrixType& m_originalMatrix;$/;"	m	class:Eigen::LU	access:public
Eigen::LU::solve	src/Eigen2Support/LU.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
Eigen::Large	src/Core/GeneralProduct.h	/^  Large = 2,$/;"	e	enum:Eigen::__anon241
Eigen::LazyCoeffBasedProductMode	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
Eigen::LazyProductReturnType	src/Core/GeneralProduct.h	/^struct LazyProductReturnType : public ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen	inherits:ProductReturnType
Eigen::LinearAccessBit	src/Core/util/Constants.h	/^const unsigned int LinearAccessBit = 0x10;$/;"	m	namespace:Eigen
Eigen::LinearTraversal	src/Core/util/Constants.h	/^  LinearTraversal,$/;"	e	enum:Eigen::__anon63
Eigen::LinearVectorizedTraversal	src/Core/util/Constants.h	/^  LinearVectorizedTraversal,$/;"	e	enum:Eigen::__anon63
Eigen::Lower	src/Core/util/Constants.h	/^  Lower=0x1,                      $/;"	e	enum:Eigen::__anon61
Eigen::LowerTriangular	src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangular = Lower;$/;"	m	namespace:Eigen
Eigen::LowerTriangularBit	src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangularBit = Lower;$/;"	m	namespace:Eigen
Eigen::LvalueBit	src/Core/util/Constants.h	/^const unsigned int LvalueBit = 0x20;$/;"	m	namespace:Eigen
Eigen::Map	src/Core/Map.h	/^template<typename PlainObjectType, int MapOptions, typename StrideType> class Map$/;"	c	namespace:Eigen	inherits:MapBase
Eigen::Map	src/Core/PermutationMatrix.h	/^class Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess>$/;"	c	namespace:Eigen	inherits:PermutationBase
Eigen::Map	src/Core/Transpositions.h	/^class Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,PacketAccess>$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Eigen::Map	src/Geometry/Quaternion.h	/^class Map<Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Eigen::Map	src/Geometry/Quaternion.h	/^class Map<const Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Eigen::Map::Base	src/Core/Map.h	/^    typedef MapBase<Map> Base;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Base	src/Core/PermutationMatrix.h	/^    typedef PermutationBase<Map> Base;$/;"	t	class:Eigen::Map	access:private
Eigen::Map::Base	src/Core/Transpositions.h	/^    typedef TranspositionsBase<Map> Base;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Base	src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map	access:private
Eigen::Map::Base	src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<const Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map	access:private
Eigen::Map::Coefficients	src/Geometry/Quaternion.h	/^    typedef typename internal::traits<Map>::Coefficients Coefficients;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Index	src/Core/PermutationMatrix.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Index	src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::IndicesType	src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Map	src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index a_size, const StrideType& a_stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType dataPtr, Index a_size, const StrideType& a_stride = StrideType())
Eigen::Map::Map	src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index nbRows, Index nbCols, const StrideType& a_stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType dataPtr, Index nbRows, Index nbCols, const StrideType& a_stride = StrideType())
Eigen::Map::Map	src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, const StrideType& a_stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType dataPtr, const StrideType& a_stride = StrideType())
Eigen::Map::Map	src/Core/PermutationMatrix.h	/^    inline Map(const Index* indicesPtr)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indicesPtr)
Eigen::Map::Map	src/Core/PermutationMatrix.h	/^    inline Map(const Index* indicesPtr, Index size)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indicesPtr, Index size)
Eigen::Map::Map	src/Core/Transpositions.h	/^    inline Map(const Index* indicesPtr)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indicesPtr)
Eigen::Map::Map	src/Core/Transpositions.h	/^    inline Map(const Index* indicesPtr, Index size)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indicesPtr, Index size)
Eigen::Map::Map	src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map	access:public	signature:(Scalar* coeffs)
Eigen::Map::Map	src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(const Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map	access:public	signature:(const Scalar* coeffs)
Eigen::Map::PointerArgType	src/Core/Map.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::PointerArgType	src/Core/Map.h	/^    typedef const Scalar* PointerArgType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::PointerType	src/Core/Map.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Scalar	src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map	access:private
Eigen::Map::Traits	src/Core/Transpositions.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map	access:private
Eigen::Map::cast_to_pointer_type	src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return const_cast<PointerType>(ptr); }$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType ptr)
Eigen::Map::cast_to_pointer_type	src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType ptr)
Eigen::Map::coeffs	src/Geometry/Quaternion.h	/^    inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Map	access:public	signature:()
Eigen::Map::coeffs	src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::Map::coeffs	src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::Map::indices	src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:()
Eigen::Map::indices	src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::Map::indices	src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:()
Eigen::Map::indices	src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::Map::innerStride	src/Core/Map.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::Map::m_coeffs	src/Geometry/Quaternion.h	/^    Coefficients m_coeffs;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::m_coeffs	src/Geometry/Quaternion.h	/^    const Coefficients m_coeffs;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::m_indices	src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::m_indices	src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::m_stride	src/Core/Map.h	/^    StrideType m_stride;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::operator =	src/Core/PermutationMatrix.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map	access:public	signature:(const Map& other)
Eigen::Map::operator =	src/Core/PermutationMatrix.h	/^    Map& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::Map	access:public	signature:(const PermutationBase<Other>& other)
Eigen::Map::operator =	src/Core/PermutationMatrix.h	/^    Map& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::Map	access:public	signature:(const TranspositionsBase<Other>& tr)
Eigen::Map::operator =	src/Core/Transpositions.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map	access:public	signature:(const Map& other)
Eigen::Map::operator =	src/Core/Transpositions.h	/^    Map& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Map	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::Map::outerStride	src/Core/Map.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::MapBase	src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::MapBase	src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, WriteAccessors>$/;"	c	namespace:Eigen	inherits:MapBase
Eigen::MapBase::Base	src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::Base	src/Core/MapBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::CoeffReturnType	src/Core/MapBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::ColsAtCompileTime	src/Core/MapBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon276
Eigen::MapBase::Index	src/Core/MapBase.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::Index	src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::MapBase	src/Core/MapBase.h	/^    explicit inline MapBase(PointerType dataPtr) : Base(dataPtr) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr)
Eigen::MapBase::MapBase	src/Core/MapBase.h	/^    explicit inline MapBase(PointerType dataPtr) : m_data(dataPtr), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr)
Eigen::MapBase::MapBase	src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols) : Base(dataPtr, nbRows, nbCols) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr, Index nbRows, Index nbCols)
Eigen::MapBase::MapBase	src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr, Index nbRows, Index nbCols)
Eigen::MapBase::MapBase	src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index vecSize) : Base(dataPtr, vecSize) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr, Index vecSize)
Eigen::MapBase::MapBase	src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index vecSize)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr, Index vecSize)
Eigen::MapBase::PacketScalar	src/Core/MapBase.h	/^    typedef typename Base::PacketScalar PacketScalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::PacketScalar	src/Core/MapBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::PointerType	src/Core/MapBase.h	/^                     PointerType;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::PointerType	src/Core/MapBase.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::ReadOnlyMapBase	src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> ReadOnlyMapBase;$/;"	t	class:Eigen::MapBase	access:private
Eigen::MapBase::RealScalar	src/Core/MapBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::RowsAtCompileTime	src/Core/MapBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon276
Eigen::MapBase::Scalar	src/Core/MapBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::Scalar	src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::ScalarWithConstIfNotLvalue	src/Core/MapBase.h	/^                  >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::SizeAtCompileTime	src/Core/MapBase.h	/^      SizeAtCompileTime = Base::SizeAtCompileTime$/;"	e	enum:Eigen::MapBase::__anon276
Eigen::MapBase::StorageKind	src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::checkSanity	src/Core/MapBase.h	/^    void checkSanity() const$/;"	f	class:Eigen::MapBase	access:protected	signature:() const
Eigen::MapBase::coeff	src/Core/MapBase.h	/^    inline const Scalar& coeff(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
Eigen::MapBase::coeff	src/Core/MapBase.h	/^    inline const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index rowId, Index colId) const
Eigen::MapBase::coeffRef	src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index)
Eigen::MapBase::coeffRef	src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col)
Eigen::MapBase::coeffRef	src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
Eigen::MapBase::coeffRef	src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index rowId, Index colId) const
Eigen::MapBase::cols	src/Core/MapBase.h	/^    inline Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
Eigen::MapBase::data	src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; } \/\/ no const-cast here so non-const-correct code will give a compile error$/;"	f	class:Eigen::MapBase	access:public	signature:()
Eigen::MapBase::data	src/Core/MapBase.h	/^    inline const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
Eigen::MapBase::data	src/Core/MapBase.h	/^    inline const Scalar* data() const { return this->m_data; }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
Eigen::MapBase::m_cols	src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::MapBase	access:protected
Eigen::MapBase::m_data	src/Core/MapBase.h	/^    PointerType m_data;$/;"	m	class:Eigen::MapBase	access:protected
Eigen::MapBase::m_rows	src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::MapBase	access:protected
Eigen::MapBase::operator =	src/Core/MapBase.h	/^    Derived& operator=(const MapBase& other)$/;"	f	class:Eigen::MapBase	access:public	signature:(const MapBase& other)
Eigen::MapBase::packet	src/Core/MapBase.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
Eigen::MapBase::packet	src/Core/MapBase.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index rowId, Index colId) const
Eigen::MapBase::rows	src/Core/MapBase.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
Eigen::MapBase::writePacket	src/Core/MapBase.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index, const PacketScalar& val)
Eigen::MapBase::writePacket	src/Core/MapBase.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& val)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col, const PacketScalar& val)
Eigen::MappedSparseMatrix	src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::MappedSparseMatrix::InnerIterator	src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::InnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
Eigen::MappedSparseMatrix::InnerIterator::InnerIterator	src/SparseCore/MappedSparseMatrix.h	/^    InnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:(const MappedSparseMatrix& mat, Index outer)
Eigen::MappedSparseMatrix::InnerIterator::col	src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator::index	src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator::m_end	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::m_id	src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::m_matrix	src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::m_outer	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::m_start	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::operator ++	src/SparseCore/MappedSparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:()
Eigen::MappedSparseMatrix::InnerIterator::operator bool	src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end) && (m_id>=m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator::row	src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator::value	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator::valueRef	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id]); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:()
Eigen::MappedSparseMatrix::IsRowMajor	src/SparseCore/MappedSparseMatrix.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::MappedSparseMatrix::__anon431
Eigen::MappedSparseMatrix::MappedSparseMatrix	src/SparseCore/MappedSparseMatrix.h	/^    inline MappedSparseMatrix(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)
Eigen::MappedSparseMatrix::ReverseInnerIterator	src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
Eigen::MappedSparseMatrix::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/MappedSparseMatrix.h	/^    ReverseInnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:(const MappedSparseMatrix& mat, Index outer)
Eigen::MappedSparseMatrix::ReverseInnerIterator::col	src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::index	src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_end	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_id	src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_matrix	src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_outer	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_start	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::operator --	src/SparseCore/MappedSparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:()
Eigen::MappedSparseMatrix::ReverseInnerIterator::operator bool	src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id <= m_end) && (m_id>m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::row	src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::value	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::valueRef	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id-1]); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:()
Eigen::MappedSparseMatrix::coeff	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index row, Index col) const
Eigen::MappedSparseMatrix::coeffRef	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index row, Index col)
Eigen::MappedSparseMatrix::cols	src/SparseCore/MappedSparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::innerIndexPtr	src/SparseCore/MappedSparseMatrix.h	/^    inline Index* innerIndexPtr() { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
Eigen::MappedSparseMatrix::innerIndexPtr	src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::innerSize	src/SparseCore/MappedSparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::isCompressed	src/SparseCore/MappedSparseMatrix.h	/^    bool isCompressed() const { return true; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::m_innerIndices	src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_innerIndices;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_innerSize	src/SparseCore/MappedSparseMatrix.h	/^    Index   m_innerSize;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_nnz	src/SparseCore/MappedSparseMatrix.h	/^    Index   m_nnz;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_outerIndex	src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_outerIndex;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_outerSize	src/SparseCore/MappedSparseMatrix.h	/^    Index   m_outerSize;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_values	src/SparseCore/MappedSparseMatrix.h	/^    Scalar* m_values;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::nonZeros	src/SparseCore/MappedSparseMatrix.h	/^    inline Index nonZeros() const  { return m_nnz; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::outerIndexPtr	src/SparseCore/MappedSparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
Eigen::MappedSparseMatrix::outerIndexPtr	src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::outerSize	src/SparseCore/MappedSparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::rows	src/SparseCore/MappedSparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::valuePtr	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar* valuePtr() { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
Eigen::MappedSparseMatrix::valuePtr	src/SparseCore/MappedSparseMatrix.h	/^    inline const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::~MappedSparseMatrix	src/SparseCore/MappedSparseMatrix.h	/^    inline ~MappedSparseMatrix() {}$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
Eigen::Matrix	src/Core/Matrix.h	/^class Matrix$/;"	c	namespace:Eigen	inherits:PlainObjectBase
Eigen::Matrix::Base	src/Core/Matrix.h	/^    typedef PlainObjectBase<Matrix> Base;$/;"	t	class:Eigen::Matrix	access:public
Eigen::Matrix::Matrix	src/Core/Map.h	/^  ::Matrix(const Scalar *data)$/;"	f	class:Eigen::Matrix	signature:(const Scalar *data)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix() : Base()$/;"	f	class:Eigen::Matrix	access:public	signature:()
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Matrix& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Matrix& other)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)$/;"	f	class:Eigen::Matrix	access:public	signature:(const T0& x, const T1& y)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix(Index dim)$/;"	f	class:Eigen::Matrix	access:public	signature:(Index dim)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    Matrix(Index rows, Index cols);$/;"	p	class:Eigen::Matrix	access:public	signature:(Index rows, Index cols)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    Matrix(Matrix&& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(Matrix&& other)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    Matrix(const Scalar& x, const Scalar& y);$/;"	p	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    Matrix(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Matrix	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    explicit Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    explicit Matrix(const Scalar *data);$/;"	p	class:Eigen::Matrix	access:public	signature:(const Scalar *data)
Eigen::Matrix::Matrix	src/Core/Matrix.h	/^    explicit Matrix(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::Matrix	src/Eigen2Support/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::Matrix	src/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::Options	src/Core/Matrix.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Matrix::__anon283
Eigen::Matrix::PlainObject	src/Core/Matrix.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Matrix	access:public
Eigen::Matrix::innerStride	src/Core/Matrix.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Matrix	access:public	signature:() const
Eigen::Matrix::operator =	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::Matrix::operator =	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Matrix& other)
Eigen::Matrix::operator =	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::Matrix::operator =	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::Matrix	access:public	signature:(const ReturnByValue<OtherDerived>& func)
Eigen::Matrix::operator =	src/Core/Matrix.h	/^    Matrix& operator=(Matrix&& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(Matrix&& other)
Eigen::Matrix::operator =	src/Core/Matrix.h	/^    Matrix& operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::operator =	src/Core/Matrix.h	/^    Matrix& operator=(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::operator =	src/Eigen2Support/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::operator =	src/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::outerStride	src/Core/Matrix.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Matrix	access:public	signature:() const
Eigen::Matrix::swap	src/Core/Matrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::Matrix	access:public	signature:(MatrixBase<OtherDerived> const & other)
Eigen::MatrixBase	src/Core/MatrixBase.h	/^template<typename Derived> class MatrixBase$/;"	c	namespace:Eigen	inherits:DenseBase
Eigen::MatrixBase::AdjointReturnType	src/Core/MatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::Base	src/Core/MatrixBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::BasisReturnType	src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::CoeffReturnType	src/Core/MatrixBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ColXpr	src/Core/MatrixBase.h	/^    typedef typename Base::ColXpr ColXpr;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstDiagonalDynamicIndexReturnType	src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived,DynamicIndex> >::type ConstDiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstDiagonalIndexReturnType	src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstDiagonalIndexReturnType::Type	src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstDiagonalIndexReturnType	access:public
Eigen::MatrixBase::ConstDiagonalReturnType	src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived> >::type ConstDiagonalReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstSelfAdjointViewReturnType	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstSelfAdjointViewReturnType::Type	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstSelfAdjointViewReturnType	access:public
Eigen::MatrixBase::ConstStartMinusOne	src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstTransposeReturnType	src/Core/MatrixBase.h	/^    typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstTriangularViewReturnType	src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstTriangularViewReturnType::Type	src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstTriangularViewReturnType	access:public
Eigen::MatrixBase::ConstantReturnType	src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::DiagonalDynamicIndexReturnType	src/Core/MatrixBase.h	/^    typedef Diagonal<Derived,DynamicIndex> DiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::DiagonalIndexReturnType	src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::DiagonalIndexReturnType::Type	src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::DiagonalIndexReturnType	access:public
Eigen::MatrixBase::DiagonalReturnType	src/Core/MatrixBase.h	/^    typedef Diagonal<Derived> DiagonalReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::EigenvaluesReturnType	src/Core/MatrixBase.h	/^    typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMajor> EigenvaluesReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::HNormalizedReturnType	src/Core/MatrixBase.h	/^                const ConstStartMinusOne > HNormalizedReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::HomogeneousReturnType	src/Core/MatrixBase.h	/^    typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::HomogeneousReturnTypeDirection	src/Core/MatrixBase.h	/^    enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1?Vertical:Horizontal };$/;"	e	enum:Eigen::MatrixBase::__anon284
Eigen::MatrixBase::Identity	src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::Identity	src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity(Index nbRows, Index nbCols)$/;"	f	class:Eigen::MatrixBase	signature:(Index nbRows, Index nbCols)
Eigen::MatrixBase::Identity	src/Core/MatrixBase.h	/^    static const IdentityReturnType Identity();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::Identity	src/Core/MatrixBase.h	/^    static const IdentityReturnType Identity(Index rows, Index cols);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index rows, Index cols)
Eigen::MatrixBase::IdentityReturnType	src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,Derived> IdentityReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::Index	src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::MatrixBase	src/Core/MatrixBase.h	/^    MatrixBase() : Base() {}$/;"	f	class:Eigen::MatrixBase	access:protected	signature:()
Eigen::MatrixBase::MatrixBase	src/Core/MatrixBase.h	/^    MatrixBase(int,int);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(int,int)
Eigen::MatrixBase::MatrixBase	src/Core/MatrixBase.h	/^    explicit MatrixBase(int);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(int)
Eigen::MatrixBase::MatrixBase	src/Core/MatrixBase.h	/^    template<typename OtherDerived> explicit MatrixBase(const MatrixBase<OtherDerived>&);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(const MatrixBase<OtherDerived>&)
Eigen::MatrixBase::PacketScalar	src/Core/MatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::PlainObject	src/Core/MatrixBase.h	/^          > PlainObject;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::RealScalar	src/Core/MatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::RowXpr	src/Core/MatrixBase.h	/^    typedef typename Base::RowXpr RowXpr;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::Scalar	src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::SelfAdjointViewReturnType	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::SelfAdjointViewReturnType::Type	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::SelfAdjointViewReturnType	access:public
Eigen::MatrixBase::SizeMinusOne	src/Core/MatrixBase.h	/^      SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1$/;"	e	enum:Eigen::MatrixBase::__anon285
Eigen::MatrixBase::SquareMatrixType	src/Core/MatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::StemFunction	src/Core/MatrixBase.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::StorageBaseType	src/Core/MatrixBase.h	/^    typedef MatrixBase StorageBaseType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::StorageKind	src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::TriangularViewReturnType	src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::TriangularViewReturnType::Type	src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::TriangularViewReturnType	access:public
Eigen::MatrixBase::Unit	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index i)$/;"	f	class:Eigen::MatrixBase	signature:(Index i)
Eigen::MatrixBase::Unit	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index newSize, Index i)$/;"	f	class:Eigen::MatrixBase	signature:(Index newSize, Index i)
Eigen::MatrixBase::Unit	src/Core/MatrixBase.h	/^    static const BasisReturnType Unit(Index i);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index i)
Eigen::MatrixBase::Unit	src/Core/MatrixBase.h	/^    static const BasisReturnType Unit(Index size, Index i);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size, Index i)
Eigen::MatrixBase::UnitW	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::UnitW	src/Core/MatrixBase.h	/^    static const BasisReturnType UnitW();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::UnitX	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitX()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::UnitX	src/Core/MatrixBase.h	/^    static const BasisReturnType UnitX();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::UnitY	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitY()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::UnitY	src/Core/MatrixBase.h	/^    static const BasisReturnType UnitY();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::UnitZ	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitZ()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::UnitZ	src/Core/MatrixBase.h	/^    static const BasisReturnType UnitZ();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::adjoint	src/Core/MatrixBase.h	/^    const AdjointReturnType adjoint() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::adjoint	src/Core/Transpose.h	/^MatrixBase<Derived>::adjoint() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::adjointInPlace	src/Core/MatrixBase.h	/^    void adjointInPlace();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::adjointInPlace	src/Core/Transpose.h	/^inline void MatrixBase<Derived>::adjointInPlace()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::applyHouseholderOnTheLeft	src/Core/MatrixBase.h	/^    void applyHouseholderOnTheLeft(const EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
Eigen::MatrixBase::applyHouseholderOnTheLeft	src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheLeft($/;"	f	class:Eigen::MatrixBase	signature:( const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
Eigen::MatrixBase::applyHouseholderOnTheRight	src/Core/MatrixBase.h	/^    void applyHouseholderOnTheRight(const EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
Eigen::MatrixBase::applyHouseholderOnTheRight	src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheRight($/;"	f	class:Eigen::MatrixBase	signature:( const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
Eigen::MatrixBase::applyOnTheLeft	src/Core/MatrixBase.h	/^    void applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
Eigen::MatrixBase::applyOnTheLeft	src/Core/MatrixBase.h	/^    void applyOnTheLeft(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::applyOnTheLeft	src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::MatrixBase::applyOnTheLeft	src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
Eigen::MatrixBase::applyOnTheRight	src/Core/MatrixBase.h	/^    void applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
Eigen::MatrixBase::applyOnTheRight	src/Core/MatrixBase.h	/^    void applyOnTheRight(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::applyOnTheRight	src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheRight(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::MatrixBase::applyOnTheRight	src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
Eigen::MatrixBase::array	src/Core/MatrixBase.h	/^    ArrayWrapper<Derived> array() { return derived(); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::array	src/Core/MatrixBase.h	/^    const ArrayWrapper<const Derived> array() const { return derived(); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::asDiagonal	src/Core/DiagonalMatrix.h	/^MatrixBase<Derived>::asDiagonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::asDiagonal	src/Core/MatrixBase.h	/^    const DiagonalWrapper<const Derived> asDiagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::asPermutation	src/Core/MatrixBase.h	/^    const PermutationWrapper<const Derived> asPermutation() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::asPermutation	src/Core/PermutationMatrix.h	/^const PermutationWrapper<const Derived> MatrixBase<Derived>::asPermutation() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::blueNorm	src/Core/MatrixBase.h	/^    RealScalar blueNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::blueNorm	src/Core/StableNorm.h	/^MatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::colPivHouseholderQr	src/Core/MatrixBase.h	/^    const ColPivHouseholderQR<PlainObject> colPivHouseholderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::colPivHouseholderQr	src/QR/ColPivHouseholderQR.h	/^MatrixBase<Derived>::colPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::computeInverse	src/Core/MatrixBase.h	/^    void computeInverse(MatrixBase<ResultType> *result) const {$/;"	f	class:Eigen::MatrixBase	access:public	signature:(MatrixBase<ResultType> *result) const
Eigen::MatrixBase::computeInverseAndDetWithCheck	src/Core/MatrixBase.h	/^    void computeInverseAndDetWithCheck($/;"	p	class:Eigen::MatrixBase	access:public	signature:( ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible, const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision() ) const
Eigen::MatrixBase::computeInverseAndDetWithCheck	src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseAndDetWithCheck($/;"	f	class:Eigen::MatrixBase	signature:( ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible, const RealScalar& absDeterminantThreshold ) const
Eigen::MatrixBase::computeInverseWithCheck	src/Core/MatrixBase.h	/^    void computeInverseWithCheck($/;"	p	class:Eigen::MatrixBase	access:public	signature:( ResultType& inverse, bool& invertible, const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision() ) const
Eigen::MatrixBase::computeInverseWithCheck	src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseWithCheck($/;"	f	class:Eigen::MatrixBase	signature:( ResultType& inverse, bool& invertible, const RealScalar& absDeterminantThreshold ) const
Eigen::MatrixBase::cos	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> cos() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::cosh	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> cosh() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::cross	src/Core/MatrixBase.h	/^    cross(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::cross	src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::cross3	src/Core/MatrixBase.h	/^    PlainObject cross3(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::cross3	src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross3(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::cross_product_return_type	src/Core/MatrixBase.h	/^    template<typename OtherDerived> struct cross_product_return_type {$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::cross_product_return_type::Scalar	src/Core/MatrixBase.h	/^      typedef typename internal::scalar_product_traits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type	access:public
Eigen::MatrixBase::cross_product_return_type::type	src/Core/MatrixBase.h	/^      typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type	access:public
Eigen::MatrixBase::cwise	src/Core/MatrixBase.h	/^    inline Cwise<Derived> cwise();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::cwise	src/Core/MatrixBase.h	/^    inline const Cwise<Derived> cwise() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::cwise	src/Eigen2Support/Cwise.h	/^inline Cwise<Derived> MatrixBase<Derived>::cwise()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::cwise	src/Eigen2Support/Cwise.h	/^inline const Cwise<Derived> MatrixBase<Derived>::cwise() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::cwiseProduct	src/Core/MatrixBase.h	/^    cwiseProduct(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived> &other) const
Eigen::MatrixBase::determinant	src/Core/MatrixBase.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::determinant	src/LU/Determinant.h	/^inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::diagonal	src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::diagonal	src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::diagonal	src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index) const$/;"	f	class:Eigen::MatrixBase	signature:(Index index) const
Eigen::MatrixBase::diagonal	src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index)$/;"	f	class:Eigen::MatrixBase	signature:(Index index)
Eigen::MatrixBase::diagonal	src/Core/MatrixBase.h	/^    ConstDiagonalDynamicIndexReturnType diagonal(Index index) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index) const
Eigen::MatrixBase::diagonal	src/Core/MatrixBase.h	/^    ConstDiagonalReturnType diagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::diagonal	src/Core/MatrixBase.h	/^    DiagonalDynamicIndexReturnType diagonal(Index index);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index)
Eigen::MatrixBase::diagonal	src/Core/MatrixBase.h	/^    DiagonalReturnType diagonal();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::diagonal	src/Core/MatrixBase.h	/^    template<int Index> typename ConstDiagonalIndexReturnType<Index>::Type diagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::diagonal	src/Core/MatrixBase.h	/^    template<int Index> typename DiagonalIndexReturnType<Index>::Type diagonal();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::diagonalSize	src/Core/MatrixBase.h	/^    inline Index diagonalSize() const { return (std::min)(rows(),cols()); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::dot	src/Core/Dot.h	/^MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::dot	src/Core/MatrixBase.h	/^    dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::eigen2_dot	src/Core/Dot.h	/^MatrixBase<Derived>::eigen2_dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::eigen2_dot	src/Core/MatrixBase.h	/^      Scalar eigen2_dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::eigen2_lu	src/Core/MatrixBase.h	/^    const LU<PlainObject> eigen2_lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::eigen2_lu	src/Eigen2Support/LU.h	/^MatrixBase<Derived>::eigen2_lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::eigenvalues	src/Core/MatrixBase.h	/^    EigenvaluesReturnType eigenvalues() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::eigenvalues	src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::eigenvalues() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::end	src/Core/MatrixBase.h	/^    VectorBlock<Derived> end(Index size);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size)
Eigen::MatrixBase::end	src/Core/MatrixBase.h	/^    const VectorBlock<const Derived> end(Index size) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size) const
Eigen::MatrixBase::end	src/Core/MatrixBase.h	/^    template<int Size> VectorBlock<Derived,Size> end();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::end	src/Core/MatrixBase.h	/^    template<int Size> const VectorBlock<const Derived,Size> end() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::end	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::end	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::end	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size) const$/;"	f	class:Eigen::MatrixBase	signature:(Index size) const
Eigen::MatrixBase::end	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size)$/;"	f	class:Eigen::MatrixBase	signature:(Index size)
Eigen::MatrixBase::eulerAngles	src/Core/MatrixBase.h	/^    Matrix<Scalar,3,1> eulerAngles(Index a0, Index a1, Index a2) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index a0, Index a1, Index a2) const
Eigen::MatrixBase::eulerAngles	src/Geometry/EulerAngles.h	/^MatrixBase<Derived>::eulerAngles(Index a0, Index a1, Index a2) const$/;"	f	class:Eigen::MatrixBase	signature:(Index a0, Index a1, Index a2) const
Eigen::MatrixBase::exp	src/Core/MatrixBase.h	/^    const MatrixExponentialReturnValue<Derived> exp() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::forceAlignedAccess	src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::forceAlignedAccess	src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::forceAlignedAccess	src/Core/MatrixBase.h	/^    inline ForceAlignedAccess<Derived> forceAlignedAccess();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::forceAlignedAccess	src/Core/MatrixBase.h	/^    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::forceAlignedAccessIf	src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::forceAlignedAccessIf	src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::forceAlignedAccessIf	src/Core/MatrixBase.h	/^    template<bool Enable> inline typename internal::add_const_on_value_type<typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type>::type forceAlignedAccessIf() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::forceAlignedAccessIf	src/Core/MatrixBase.h	/^    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::fullPivHouseholderQr	src/Core/MatrixBase.h	/^    const FullPivHouseholderQR<PlainObject> fullPivHouseholderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::fullPivHouseholderQr	src/QR/FullPivHouseholderQR.h	/^MatrixBase<Derived>::fullPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::fullPivLu	src/Core/MatrixBase.h	/^    const FullPivLU<PlainObject> fullPivLu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::fullPivLu	src/LU/FullPivLU.h	/^MatrixBase<Derived>::fullPivLu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::hnormalized	src/Core/MatrixBase.h	/^    const HNormalizedReturnType hnormalized() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::hnormalized	src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::hnormalized() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::homogeneous	src/Core/MatrixBase.h	/^    HomogeneousReturnType homogeneous() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::homogeneous	src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::homogeneous() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::householderQr	src/Core/MatrixBase.h	/^    const HouseholderQR<PlainObject> householderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::householderQr	src/QR/HouseholderQR.h	/^MatrixBase<Derived>::householderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::hypotNorm	src/Core/MatrixBase.h	/^    RealScalar hypotNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::hypotNorm	src/Core/StableNorm.h	/^MatrixBase<Derived>::hypotNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::inverse	src/Core/MatrixBase.h	/^    const internal::inverse_impl<Derived> inverse() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::inverse	src/LU/Inverse.h	/^inline const internal::inverse_impl<Derived> MatrixBase<Derived>::inverse() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::isDiagonal	src/Core/DiagonalMatrix.h	/^bool MatrixBase<Derived>::isDiagonal(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
Eigen::MatrixBase::isDiagonal	src/Core/MatrixBase.h	/^    bool isDiagonal(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isIdentity	src/Core/CwiseNullaryOp.h	/^bool MatrixBase<Derived>::isIdentity$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
Eigen::MatrixBase::isIdentity	src/Core/MatrixBase.h	/^    bool isIdentity(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isLowerTriangular	src/Core/MatrixBase.h	/^    bool isLowerTriangular(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isLowerTriangular	src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isLowerTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
Eigen::MatrixBase::isOrthogonal	src/Core/Dot.h	/^bool MatrixBase<Derived>::isOrthogonal$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other, const RealScalar& prec) const
Eigen::MatrixBase::isOrthogonal	src/Core/MatrixBase.h	/^    bool isOrthogonal(const MatrixBase<OtherDerived>& other,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isUnitary	src/Core/Dot.h	/^bool MatrixBase<Derived>::isUnitary(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
Eigen::MatrixBase::isUnitary	src/Core/MatrixBase.h	/^    bool isUnitary(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isUpperTriangular	src/Core/MatrixBase.h	/^    bool isUpperTriangular(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isUpperTriangular	src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isUpperTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
Eigen::MatrixBase::jacobiSvd	src/Core/MatrixBase.h	/^    JacobiSVD<PlainObject> jacobiSvd(unsigned int computationOptions = 0) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(unsigned int computationOptions = 0) const
Eigen::MatrixBase::jacobiSvd	src/SVD/JacobiSVD.h	/^MatrixBase<Derived>::jacobiSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase	signature:(unsigned int computationOptions) const
Eigen::MatrixBase::lazy	src/Core/MatrixBase.h	/^    const Flagged<Derived, 0, EvalBeforeAssigningBit> lazy() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lazy	src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::lazy() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::lazyAssign	src/Core/MatrixBase.h	/^    Derived& lazyAssign(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::lazyAssign	src/Core/MatrixBase.h	/^    Derived& lazyAssign(const MatrixPowerProduct<MatrixPower, Lhs,Rhs>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixPowerProduct<MatrixPower, Lhs,Rhs>& other)
Eigen::MatrixBase::lazyAssign	src/Core/MatrixBase.h	/^    Derived& lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::MatrixBase::lazyProduct	src/Core/GeneralProduct.h	/^MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::MatrixBase::lazyProduct	src/Core/MatrixBase.h	/^    lazyProduct(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::MatrixBase::ldlt	src/Cholesky/LDLT.h	/^MatrixBase<Derived>::ldlt() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::ldlt	src/Core/MatrixBase.h	/^    const LDLT<PlainObject> ldlt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::llt	src/Cholesky/LLT.h	/^MatrixBase<Derived>::llt() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::llt	src/Core/MatrixBase.h	/^    const LLT<PlainObject>  llt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::log	src/Core/MatrixBase.h	/^    const MatrixLogarithmReturnValue<Derived> log() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lpNorm	src/Core/Dot.h	/^MatrixBase<Derived>::lpNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::lpNorm	src/Core/MatrixBase.h	/^    template<int p> RealScalar lpNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lu	src/Core/MatrixBase.h	/^    const LU<PlainObject> lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lu	src/Core/MatrixBase.h	/^    const PartialPivLU<PlainObject> lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lu	src/Eigen2Support/LU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::lu	src/LU/PartialPivLU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::makeHouseholder	src/Core/MatrixBase.h	/^    void makeHouseholder(EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(EssentialPart& essential, Scalar& tau, RealScalar& beta) const
Eigen::MatrixBase::makeHouseholder	src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholder($/;"	f	class:Eigen::MatrixBase	signature:( EssentialPart& essential, Scalar& tau, RealScalar& beta) const
Eigen::MatrixBase::makeHouseholderInPlace	src/Core/MatrixBase.h	/^    void makeHouseholderInPlace(Scalar& tau, RealScalar& beta);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Scalar& tau, RealScalar& beta)
Eigen::MatrixBase::makeHouseholderInPlace	src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)$/;"	f	class:Eigen::MatrixBase	signature:(Scalar& tau, RealScalar& beta)
Eigen::MatrixBase::marked	src/Core/MatrixBase.h	/^    const Flagged<Derived, Added, 0> marked() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::marked	src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::marked() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::matrix	src/Core/MatrixBase.h	/^    MatrixBase<Derived>& matrix() { return *this; }$/;"	f	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::matrix	src/Core/MatrixBase.h	/^    const MatrixBase<Derived>& matrix() const { return *this; }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::matrixFunction	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> matrixFunction(StemFunction f) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(StemFunction f) const
Eigen::MatrixBase::minor	src/Core/MatrixBase.h	/^    Minor<Derived> minor(Index row, Index col);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index row, Index col)
Eigen::MatrixBase::minor	src/Core/MatrixBase.h	/^    const Minor<Derived> minor(Index row, Index col) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index row, Index col) const
Eigen::MatrixBase::minor	src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col) const$/;"	f	class:Eigen::MatrixBase	signature:(Index row, Index col) const
Eigen::MatrixBase::minor	src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col)$/;"	f	class:Eigen::MatrixBase	signature:(Index row, Index col)
Eigen::MatrixBase::noalias	src/Core/MatrixBase.h	/^    NoAlias<Derived,Eigen::MatrixBase > noalias();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::noalias	src/Core/NoAlias.h	/^NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::norm	src/Core/Dot.h	/^inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::norm	src/Core/MatrixBase.h	/^    RealScalar norm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::normalize	src/Core/Dot.h	/^inline void MatrixBase<Derived>::normalize()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::normalize	src/Core/MatrixBase.h	/^    void normalize();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::normalized	src/Core/Dot.h	/^MatrixBase<Derived>::normalized() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::normalized	src/Core/MatrixBase.h	/^    const PlainObject normalized() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::operator !=	src/Core/MatrixBase.h	/^    inline bool operator!=(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::operator *	src/Core/DiagonalProduct.h	/^MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &a_diagonal) const$/;"	f	class:Eigen::MatrixBase	signature:(const DiagonalBase<DiagonalDerived> &a_diagonal) const
Eigen::MatrixBase::operator *	src/Core/GeneralProduct.h	/^MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::MatrixBase::operator *	src/Core/MatrixBase.h	/^    ScalarMultipleReturnType operator*(const UniformScaling<Scalar>& s) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const UniformScaling<Scalar>& s) const
Eigen::MatrixBase::operator *	src/Core/MatrixBase.h	/^    operator*(const DiagonalBase<DiagonalDerived> &diagonal) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const DiagonalBase<DiagonalDerived> &diagonal) const
Eigen::MatrixBase::operator *	src/Core/MatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::MatrixBase::operator *	src/Geometry/Scaling.h	/^MatrixBase<Derived>::operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::MatrixBase	signature:(const UniformScaling<Scalar>& s) const
Eigen::MatrixBase::operator *=	src/Core/MatrixBase.h	/^    Derived& operator*=(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::operator *=	src/Core/MatrixBase.h	/^MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::MatrixBase::operator +=	src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other)
Eigen::MatrixBase::operator +=	src/Core/MatrixBase.h	/^    Derived& operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::operator +=	src/Core/MatrixBase.h	/^    Derived& operator+=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::MatrixBase::operator +=	src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase	access:protected	signature:(const ArrayBase<OtherDerived>& )
Eigen::MatrixBase::operator +=	src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::operator -=	src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other)
Eigen::MatrixBase::operator -=	src/Core/MatrixBase.h	/^    Derived& operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::operator -=	src/Core/MatrixBase.h	/^    Derived& operator-=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::MatrixBase::operator -=	src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator-=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase	access:protected	signature:(const ArrayBase<OtherDerived>& )
Eigen::MatrixBase::operator -=	src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const DenseBase<OtherDerived>& other)
Eigen::MatrixBase::operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const MatrixBase& other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase& other)
Eigen::MatrixBase::operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::MatrixBase::operator =	src/Core/MatrixBase.h	/^    Derived& operator=(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::MatrixBase::operator =	src/Core/MatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::operator =	src/Core/MatrixBase.h	/^    Derived& operator=(const MatrixBase& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase& other)
Eigen::MatrixBase::operator =	src/Core/MatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::MatrixBase::operator ==	src/Core/MatrixBase.h	/^    inline bool operator==(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::operatorNorm	src/Core/MatrixBase.h	/^    RealScalar operatorNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::operatorNorm	src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::operatorNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::part	src/Core/MatrixBase.h	/^    const DiagonalWrapper<ConstDiagonalReturnType> part() const$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::part	src/Core/MatrixBase.h	/^    template<unsigned int Mode> const typename internal::eigen2_part_return_type<Derived, Mode>::type part() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::part	src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename internal::eigen2_part_return_type<Derived, Mode>::type part();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::part	src/Core/TriangularMatrix.h	/^const typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::part	src/Core/TriangularMatrix.h	/^typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::partialPivLu	src/Core/MatrixBase.h	/^    const PartialPivLU<PlainObject> partialPivLu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::partialPivLu	src/LU/PartialPivLU.h	/^MatrixBase<Derived>::partialPivLu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::pow	src/Core/MatrixBase.h	/^    const MatrixPowerReturnValue<Derived> pow(const RealScalar& p) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& p) const
Eigen::MatrixBase::qr	src/Core/MatrixBase.h	/^    const QR<PlainObject> qr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::qr	src/Eigen2Support/QR.h	/^MatrixBase<Derived>::qr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::selfadjointView	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> typename ConstSelfAdjointViewReturnType<UpLo>::Type selfadjointView() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::selfadjointView	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> typename SelfAdjointViewReturnType<UpLo>::Type selfadjointView();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::selfadjointView	src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::selfadjointView	src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::setIdentity	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::setIdentity	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity(Index nbRows, Index nbCols)$/;"	f	class:Eigen::MatrixBase	signature:(Index nbRows, Index nbCols)
Eigen::MatrixBase::setIdentity	src/Core/MatrixBase.h	/^    Derived& setIdentity();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::setIdentity	src/Core/MatrixBase.h	/^    Derived& setIdentity(Index rows, Index cols);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index rows, Index cols)
Eigen::MatrixBase::sin	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> sin() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::sinh	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> sinh() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::sparseView	src/Core/MatrixBase.h	/^    const SparseView<Derived> sparseView(const Scalar& m_reference = Scalar(0),$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Scalar& m_reference = Scalar(0), const typename NumTraits<Scalar>::Real& m_epsilon = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::sparseView	src/SparseCore/SparseView.h	/^const SparseView<Derived> MatrixBase<Derived>::sparseView(const Scalar& m_reference,$/;"	f	class:Eigen::MatrixBase	signature:(const Scalar& m_reference, const typename NumTraits<Scalar>::Real& m_epsilon) const
Eigen::MatrixBase::sqrt	src/Core/MatrixBase.h	/^    const MatrixSquareRootReturnValue<Derived> sqrt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::squaredNorm	src/Core/Dot.h	/^EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::squaredNorm	src/Core/MatrixBase.h	/^    RealScalar squaredNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::stableNorm	src/Core/MatrixBase.h	/^    RealScalar stableNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::stableNorm	src/Core/StableNorm.h	/^MatrixBase<Derived>::stableNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::start	src/Core/MatrixBase.h	/^    VectorBlock<Derived> start(Index size);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size)
Eigen::MatrixBase::start	src/Core/MatrixBase.h	/^    const VectorBlock<const Derived> start(Index size) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size) const
Eigen::MatrixBase::start	src/Core/MatrixBase.h	/^    template<int Size> VectorBlock<Derived,Size> start();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::start	src/Core/MatrixBase.h	/^    template<int Size> const VectorBlock<const Derived,Size> start() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::start	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::start	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::start	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size) const$/;"	f	class:Eigen::MatrixBase	signature:(Index size) const
Eigen::MatrixBase::start	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size)$/;"	f	class:Eigen::MatrixBase	signature:(Index size)
Eigen::MatrixBase::svd	src/Core/MatrixBase.h	/^    SVD<PlainObject> svd() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::svd	src/Eigen2Support/SVD.h	/^MatrixBase<Derived>::svd() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::trace	src/Core/MatrixBase.h	/^    Scalar trace() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::trace	src/Core/Redux.h	/^MatrixBase<Derived>::trace() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::triangularView	src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename ConstTriangularViewReturnType<Mode>::Type triangularView() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::triangularView	src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename TriangularViewReturnType<Mode>::Type triangularView();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::triangularView	src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::triangularView	src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::unitOrthogonal	src/Core/MatrixBase.h	/^    PlainObject unitOrthogonal(void) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(void) const
Eigen::MatrixBase::unitOrthogonal	src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::unitOrthogonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixWrapper	src/Core/ArrayWrapper.h	/^class MatrixWrapper : public MatrixBase<MatrixWrapper<ExpressionType> >$/;"	c	namespace:Eigen	inherits:MatrixBase
Eigen::MatrixWrapper::Base	src/Core/ArrayWrapper.h	/^    typedef MatrixBase<MatrixWrapper<ExpressionType> > Base;$/;"	t	class:Eigen::MatrixWrapper	access:public
Eigen::MatrixWrapper::MatrixWrapper	src/Core/ArrayWrapper.h	/^    inline MatrixWrapper(ExpressionType& a_matrix) : m_expression(a_matrix) {}$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(ExpressionType& a_matrix)
Eigen::MatrixWrapper::NestedExpressionType	src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::MatrixWrapper	access:public
Eigen::MatrixWrapper::ScalarWithConstIfNotLvalue	src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MatrixWrapper	access:public
Eigen::MatrixWrapper::coeff	src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
Eigen::MatrixWrapper::coeff	src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId) const
Eigen::MatrixWrapper::coeffRef	src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index)
Eigen::MatrixWrapper::coeffRef	src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId)
Eigen::MatrixWrapper::coeffRef	src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
Eigen::MatrixWrapper::coeffRef	src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId) const
Eigen::MatrixWrapper::cols	src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::data	src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.const_cast_derived().data(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:()
Eigen::MatrixWrapper::data	src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::innerStride	src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::m_expression	src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::MatrixWrapper	access:protected
Eigen::MatrixWrapper::nestedExpression	src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::outerStride	src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::packet	src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
Eigen::MatrixWrapper::packet	src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId) const
Eigen::MatrixWrapper::resize	src/Core/ArrayWrapper.h	/^    void resize(Index nbRows, Index nbCols) { m_expression.const_cast_derived().resize(nbRows,nbCols); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index nbRows, Index nbCols)
Eigen::MatrixWrapper::resize	src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.const_cast_derived().resize(newSize); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index newSize)
Eigen::MatrixWrapper::rows	src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::writePacket	src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index, const PacketScalar& val)
Eigen::MatrixWrapper::writePacket	src/Core/ArrayWrapper.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId, const PacketScalar& val)
Eigen::MatrixXpr	src/Core/util/Constants.h	/^struct MatrixXpr {};$/;"	s	namespace:Eigen
Eigen::MetisOrdering	src/MetisSupport/MetisSupport.h	/^class MetisOrdering$/;"	c	namespace:Eigen
Eigen::MetisOrdering::IndexVector	src/MetisSupport/MetisSupport.h	/^  typedef Matrix<Index,Dynamic,1> IndexVector; $/;"	t	class:Eigen::MetisOrdering	access:public
Eigen::MetisOrdering::PermutationType	src/MetisSupport/MetisSupport.h	/^  typedef PermutationMatrix<Dynamic,Dynamic,Index> PermutationType;$/;"	t	class:Eigen::MetisOrdering	access:public
Eigen::MetisOrdering::get_symmetrized_graph	src/MetisSupport/MetisSupport.h	/^  void get_symmetrized_graph(const MatrixType& A)$/;"	f	class:Eigen::MetisOrdering	access:public	signature:(const MatrixType& A)
Eigen::MetisOrdering::m_indexPtr	src/MetisSupport/MetisSupport.h	/^    IndexVector m_indexPtr; \/\/ Pointer to the adjacenccy list of each row\/column$/;"	m	class:Eigen::MetisOrdering	access:protected
Eigen::MetisOrdering::m_innerIndices	src/MetisSupport/MetisSupport.h	/^    IndexVector m_innerIndices; \/\/ Adjacency list $/;"	m	class:Eigen::MetisOrdering	access:protected
Eigen::MetisOrdering::operator ()	src/MetisSupport/MetisSupport.h	/^  void operator() (const MatrixType& A, PermutationType& matperm)$/;"	f	class:Eigen::MetisOrdering	access:public	signature:(const MatrixType& A, PermutationType& matperm)
Eigen::Minor	src/Eigen2Support/Minor.h	/^template<typename MatrixType> class Minor$/;"	c	namespace:Eigen	inherits:MatrixBase
Eigen::Minor::Base	src/Eigen2Support/Minor.h	/^    typedef MatrixBase<Minor> Base;$/;"	t	class:Eigen::Minor	access:public
Eigen::Minor::Minor	src/Eigen2Support/Minor.h	/^    inline Minor(const MatrixType& matrix,$/;"	f	class:Eigen::Minor	access:public	signature:(const MatrixType& matrix, Index row, Index col)
Eigen::Minor::coeff	src/Eigen2Support/Minor.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Minor	access:public	signature:(Index row, Index col) const
Eigen::Minor::coeffRef	src/Eigen2Support/Minor.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Minor	access:public	signature:(Index row, Index col)
Eigen::Minor::cols	src/Eigen2Support/Minor.h	/^    inline Index cols() const { return m_matrix.cols() - 1; }$/;"	f	class:Eigen::Minor	access:public	signature:() const
Eigen::Minor::m_col	src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor	access:protected
Eigen::Minor::m_matrix	src/Eigen2Support/Minor.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Minor	access:protected
Eigen::Minor::m_row	src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor	access:protected
Eigen::Minor::rows	src/Eigen2Support/Minor.h	/^    inline Index rows() const { return m_matrix.rows() - 1; }$/;"	f	class:Eigen::Minor	access:public	signature:() const
Eigen::NaturalOrdering	src/OrderingMethods/Ordering.h	/^class NaturalOrdering$/;"	c	namespace:Eigen
Eigen::NaturalOrdering::PermutationType	src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::NaturalOrdering	access:public
Eigen::NaturalOrdering::operator ()	src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& \/*mat*\/, PermutationType& perm)$/;"	f	class:Eigen::NaturalOrdering	access:public	signature:(const MatrixType& , PermutationType& perm)
Eigen::NestByRefBit	src/Core/util/Constants.h	/^const unsigned int NestByRefBit = 0x100;$/;"	m	namespace:Eigen
Eigen::NestByValue	src/Core/NestByValue.h	/^template<typename ExpressionType> class NestByValue$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::NestByValue::Base	src/Core/NestByValue.h	/^    typedef typename internal::dense_xpr_base<NestByValue>::type Base;$/;"	t	class:Eigen::NestByValue	access:public
Eigen::NestByValue::NestByValue	src/Core/NestByValue.h	/^    inline NestByValue(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::NestByValue	access:public	signature:(const ExpressionType& matrix)
Eigen::NestByValue::coeff	src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index) const
Eigen::NestByValue::coeff	src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col) const
Eigen::NestByValue::coeffRef	src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index)
Eigen::NestByValue::coeffRef	src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col)
Eigen::NestByValue::cols	src/Core/NestByValue.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
Eigen::NestByValue::innerStride	src/Core/NestByValue.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
Eigen::NestByValue::m_expression	src/Core/NestByValue.h	/^    const ExpressionType m_expression;$/;"	m	class:Eigen::NestByValue	access:protected
Eigen::NestByValue::operator const ExpressionType&	src/Core/NestByValue.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
Eigen::NestByValue::outerStride	src/Core/NestByValue.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
Eigen::NestByValue::packet	src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index) const
Eigen::NestByValue::packet	src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col) const
Eigen::NestByValue::rows	src/Core/NestByValue.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
Eigen::NestByValue::writePacket	src/Core/NestByValue.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index, const PacketScalar& x)
Eigen::NestByValue::writePacket	src/Core/NestByValue.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::NewInf	src/Eigen2Support/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen
Eigen::NewSup	src/Eigen2Support/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen
Eigen::NoAlias	src/Core/NoAlias.h	/^class NoAlias$/;"	c	namespace:Eigen
Eigen::NoAlias::NoAlias	src/Core/NoAlias.h	/^    NoAlias(ExpressionType& expression) : m_expression(expression) {}$/;"	f	class:Eigen::NoAlias	access:public	signature:(ExpressionType& expression)
Eigen::NoAlias::Scalar	src/Core/NoAlias.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::NoAlias	access:private
Eigen::NoAlias::expression	src/Core/NoAlias.h	/^    ExpressionType& expression() const$/;"	f	class:Eigen::NoAlias	access:public	signature:() const
Eigen::NoAlias::m_expression	src/Core/NoAlias.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::NoAlias	access:protected
Eigen::NoAlias::operator +=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
Eigen::NoAlias::operator +=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::NoAlias::operator +=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
Eigen::NoAlias::operator -=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
Eigen::NoAlias::operator -=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::NoAlias::operator -=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
Eigen::NoAlias::operator =	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
Eigen::NoAlias::operator =	src/Core/NoAlias.h	/^    ExpressionType& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ReturnByValue<OtherDerived>& func)
Eigen::NoChange	src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	e	enum:Eigen::NoChange_t
Eigen::NoChange_t	src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	g	namespace:Eigen
Eigen::NoConvergence	src/Core/util/Constants.h	/^  NoConvergence = 2,$/;"	e	enum:Eigen::ComputationInfo
Eigen::NoPivoting	src/Core/util/Constants.h	/^  NoPivoting          = 0x02, $/;"	e	enum:Eigen::DecompositionOptions
Eigen::NoQRPreconditioner	src/Core/util/Constants.h	/^  NoQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
Eigen::NoUnrolling	src/Core/util/Constants.h	/^  NoUnrolling,$/;"	e	enum:Eigen::__anon64
Eigen::NumericalIssue	src/Core/util/Constants.h	/^  NumericalIssue = 1, $/;"	e	enum:Eigen::ComputationInfo
Eigen::OnTheLeft	src/Core/util/Constants.h	/^  OnTheLeft = 1,  $/;"	e	enum:Eigen::__anon67
Eigen::OnTheRight	src/Core/util/Constants.h	/^  OnTheRight = 2  $/;"	e	enum:Eigen::__anon67
Eigen::OuterProduct	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
Eigen::OuterRandomAccessPattern	src/SparseCore/SparseUtil.h	/^const int OuterRandomAccessPattern  = 0x4 | CoherentAccessPattern;$/;"	m	namespace:Eigen
Eigen::OuterStride	src/Core/Stride.h	/^class OuterStride : public Stride<Value, 0>$/;"	c	namespace:Eigen	inherits:Stride
Eigen::OuterStride::Base	src/Core/Stride.h	/^    typedef Stride<Value, 0> Base;$/;"	t	class:Eigen::OuterStride	access:private
Eigen::OuterStride::Index	src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::OuterStride	access:public
Eigen::OuterStride::OuterStride	src/Core/Stride.h	/^    OuterStride() : Base() {}$/;"	f	class:Eigen::OuterStride	access:public	signature:()
Eigen::OuterStride::OuterStride	src/Core/Stride.h	/^    OuterStride(Index v) : Base(v,0) {}$/;"	f	class:Eigen::OuterStride	access:public	signature:(Index v)
Eigen::PacketAccessBit	src/Core/util/Constants.h	/^const unsigned int PacketAccessBit = 0x8;$/;"	m	namespace:Eigen
Eigen::ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
Eigen::ParametrizedLine	src/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
Eigen::ParametrizedLine::AmbientDimAtCompileTime	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::ParametrizedLine::__anon342
Eigen::ParametrizedLine::AmbientDimAtCompileTime	src/Geometry/ParametrizedLine.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::ParametrizedLine::__anon374
Eigen::ParametrizedLine::Index	src/Geometry/ParametrizedLine.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::Options	src/Geometry/ParametrizedLine.h	/^    Options = _Options$/;"	e	enum:Eigen::ParametrizedLine::__anon374
Eigen::ParametrizedLine::ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& origin, const VectorType& direction)
Eigen::ParametrizedLine::ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  explicit ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
Eigen::ParametrizedLine::ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)
Eigen::ParametrizedLine::ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(int _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(int _dim)
Eigen::ParametrizedLine::ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
Eigen::ParametrizedLine::ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)
Eigen::ParametrizedLine::ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& origin, const VectorType& direction)
Eigen::ParametrizedLine::ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  explicit ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane)
Eigen::ParametrizedLine::ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  inline ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(Index _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(Index _dim)
Eigen::ParametrizedLine::ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)
Eigen::ParametrizedLine::ParametrizedLine	src/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim,_Options>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)
Eigen::ParametrizedLine::RealScalar	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::RealScalar	src/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::Scalar	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::Scalar	src/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::Through	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p0, const VectorType& p1)
Eigen::ParametrizedLine::Through	src/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p0, const VectorType& p1)
Eigen::ParametrizedLine::VectorType	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::VectorType	src/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1,Options> VectorType;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::cast	src/Eigen2Support/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::cast	src/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::dim	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline int dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::dim	src/Geometry/ParametrizedLine.h	/^  inline Index dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::direction	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::direction	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::direction	src/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::direction	src/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::distance	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { return ei_sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::distance	src/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { using std::sqrt; return sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::intersection	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  Scalar intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
Eigen::ParametrizedLine::intersection	src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim>::intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
Eigen::ParametrizedLine::intersection	src/Geometry/ParametrizedLine.h	/^  Scalar intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersection	src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersectionParameter	src/Geometry/ParametrizedLine.h	/^  Scalar intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersectionParameter	src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersectionPoint	src/Geometry/ParametrizedLine.h	/^  VectorType intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersectionPoint	src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::isApprox	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::ParametrizedLine::isApprox	src/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::ParametrizedLine::m_direction	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
Eigen::ParametrizedLine::m_direction	src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
Eigen::ParametrizedLine::m_origin	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
Eigen::ParametrizedLine::m_origin	src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
Eigen::ParametrizedLine::origin	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::origin	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::origin	src/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::origin	src/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::pointAt	src/Geometry/ParametrizedLine.h	/^  VectorType pointAt(const Scalar& t) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Scalar& t) const
Eigen::ParametrizedLine::pointAt	src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::pointAt(const _Scalar& t) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const _Scalar& t) const
Eigen::ParametrizedLine::projection	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::projection	src/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::squaredDistance	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::squaredDistance	src/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::~ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::~ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::PardisoImpl	src/PardisoSupport/PardisoSupport.h	/^class PardisoImpl$/;"	c	namespace:Eigen
Eigen::PardisoImpl::Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::IntColVectorType	src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::IntRowVectorType	src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::MatrixType	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::MatrixType MatrixType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::ParameterType	src/PardisoSupport/PardisoSupport.h	/^    typedef Array<Index,64,1,DontAlign> ParameterType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::PardisoImpl	src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
Eigen::PardisoImpl::PardisoImpl	src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl(PardisoImpl &) {}$/;"	f	class:Eigen::PardisoImpl	access:private	signature:(PardisoImpl &)
Eigen::PardisoImpl::RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::ScalarIsComplex	src/PardisoSupport/PardisoSupport.h	/^      ScalarIsComplex = NumTraits<Scalar>::IsComplex$/;"	e	enum:Eigen::PardisoImpl::__anon410
Eigen::PardisoImpl::SparseMatrixType	src/PardisoSupport/PardisoSupport.h	/^    typedef SparseMatrix<Scalar,RowMajor,Index> SparseMatrixType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::Traits	src/PardisoSupport/PardisoSupport.h	/^    typedef internal::pardiso_traits<Derived> Traits;$/;"	t	class:Eigen::PardisoImpl	access:private
Eigen::PardisoImpl::VectorType	src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::_solve	src/PardisoSupport/PardisoSupport.h	/^    bool _solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const;$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const
Eigen::PardisoImpl::_solve	src/PardisoSupport/PardisoSupport.h	/^bool PardisoImpl<Base>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const
Eigen::PardisoImpl::analyzePattern	src/PardisoSupport/PardisoSupport.h	/^    Derived& analyzePattern(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoImpl::analyzePattern	src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
Eigen::PardisoImpl::cols	src/PardisoSupport/PardisoSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
Eigen::PardisoImpl::compute	src/PardisoSupport/PardisoSupport.h	/^    Derived& compute(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoImpl::compute	src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::compute(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
Eigen::PardisoImpl::derived	src/PardisoSupport/PardisoSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
Eigen::PardisoImpl::derived	src/PardisoSupport/PardisoSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
Eigen::PardisoImpl::factorize	src/PardisoSupport/PardisoSupport.h	/^    Derived& factorize(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoImpl::factorize	src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::factorize(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
Eigen::PardisoImpl::info	src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
Eigen::PardisoImpl::m_analysisIsOk	src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_factorizationIsOk	src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_info	src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_initialized	src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_iparm	src/PardisoSupport/PardisoSupport.h	/^    mutable ParameterType m_iparm;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_matrix	src/PardisoSupport/PardisoSupport.h	/^    mutable SparseMatrixType m_matrix;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_msglvl	src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_perm	src/PardisoSupport/PardisoSupport.h	/^    mutable IntColVectorType m_perm;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_pt	src/PardisoSupport/PardisoSupport.h	/^    mutable void *m_pt[64];$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_size	src/PardisoSupport/PardisoSupport.h	/^    Index m_size;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_type	src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::manageErrorCode	src/PardisoSupport/PardisoSupport.h	/^    void manageErrorCode(Index error)$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:(Index error)
Eigen::PardisoImpl::pardisoInit	src/PardisoSupport/PardisoSupport.h	/^    void pardisoInit(int type)$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:(int type)
Eigen::PardisoImpl::pardisoParameterArray	src/PardisoSupport/PardisoSupport.h	/^    ParameterType& pardisoParameterArray()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
Eigen::PardisoImpl::pardisoRelease	src/PardisoSupport/PardisoSupport.h	/^    void pardisoRelease()$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:()
Eigen::PardisoImpl::rows	src/PardisoSupport/PardisoSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
Eigen::PardisoImpl::solve	src/PardisoSupport/PardisoSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::PardisoImpl::solve	src/PardisoSupport/PardisoSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::PardisoImpl::~PardisoImpl	src/PardisoSupport/PardisoSupport.h	/^    ~PardisoImpl()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
Eigen::PardisoLDLT	src/PardisoSupport/PardisoSupport.h	/^class PardisoLDLT : public PardisoImpl< PardisoLDLT<MatrixType,Options> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
Eigen::PardisoLDLT::Base	src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLDLT<MatrixType,Options> > Base;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Eigen::PardisoLDLT::Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Eigen::PardisoLDLT::PardisoLDLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT()$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:()
Eigen::PardisoLDLT::PardisoLDLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(PardisoLDLT& ) {}$/;"	f	class:Eigen::PardisoLDLT	access:private	signature:(PardisoLDLT& )
Eigen::PardisoLDLT::PardisoLDLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoLDLT::RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Eigen::PardisoLDLT::Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Eigen::PardisoLDLT::UpLo	src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = Options&(Upper|Lower) };$/;"	e	enum:Eigen::PardisoLDLT::__anon412
Eigen::PardisoLDLT::getMatrix	src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoLLT	src/PardisoSupport/PardisoSupport.h	/^class PardisoLLT : public PardisoImpl< PardisoLLT<MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
Eigen::PardisoLLT::Base	src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLLT<MatrixType,_UpLo> > Base;$/;"	t	class:Eigen::PardisoLLT	access:protected
Eigen::PardisoLLT::Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLLT	access:protected
Eigen::PardisoLLT::PardisoLLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT()$/;"	f	class:Eigen::PardisoLLT	access:public	signature:()
Eigen::PardisoLLT::PardisoLLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(PardisoLLT& ) {}$/;"	f	class:Eigen::PardisoLLT	access:private	signature:(PardisoLLT& )
Eigen::PardisoLLT::PardisoLLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoLLT::RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLLT	access:protected
Eigen::PardisoLLT::Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLLT	access:protected
Eigen::PardisoLLT::UpLo	src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PardisoLLT::__anon411
Eigen::PardisoLLT::getMatrix	src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT	access:protected	signature:(const MatrixType& matrix)
Eigen::PardisoLU	src/PardisoSupport/PardisoSupport.h	/^class PardisoLU : public PardisoImpl< PardisoLU<MatrixType> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
Eigen::PardisoLU::Base	src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLU<MatrixType> > Base;$/;"	t	class:Eigen::PardisoLU	access:protected
Eigen::PardisoLU::PardisoLU	src/PardisoSupport/PardisoSupport.h	/^    PardisoLU()$/;"	f	class:Eigen::PardisoLU	access:public	signature:()
Eigen::PardisoLU::PardisoLU	src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(PardisoLU& ) {}$/;"	f	class:Eigen::PardisoLU	access:private	signature:(PardisoLU& )
Eigen::PardisoLU::PardisoLU	src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoLU::RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLU	access:protected
Eigen::PardisoLU::Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLU	access:protected
Eigen::PardisoLU::getMatrix	src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU	access:protected	signature:(const MatrixType& matrix)
Eigen::PartialPivLU	src/LU/PartialPivLU.h	/^template<typename _MatrixType> class PartialPivLU$/;"	c	namespace:Eigen
Eigen::PartialPivLU::ColsAtCompileTime	src/LU/PartialPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon401
Eigen::PartialPivLU::Index	src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::MatrixType	src/LU/PartialPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::MaxColsAtCompileTime	src/LU/PartialPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PartialPivLU::__anon401
Eigen::PartialPivLU::MaxRowsAtCompileTime	src/LU/PartialPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon401
Eigen::PartialPivLU::Options	src/LU/PartialPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::PartialPivLU::__anon401
Eigen::PartialPivLU::PartialPivLU	src/LU/PartialPivLU.h	/^    PartialPivLU();$/;"	p	class:Eigen::PartialPivLU	access:public	signature:()
Eigen::PartialPivLU::PartialPivLU	src/LU/PartialPivLU.h	/^    PartialPivLU(Index size);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(Index size)
Eigen::PartialPivLU::PartialPivLU	src/LU/PartialPivLU.h	/^    PartialPivLU(const MatrixType& matrix);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(const MatrixType& matrix)
Eigen::PartialPivLU::PartialPivLU	src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU()$/;"	f	class:Eigen::PartialPivLU	signature:()
Eigen::PartialPivLU::PartialPivLU	src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(Index size)$/;"	f	class:Eigen::PartialPivLU	signature:(Index size)
Eigen::PartialPivLU::PartialPivLU	src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU	signature:(const MatrixType& matrix)
Eigen::PartialPivLU::PermutationType	src/LU/PartialPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::RealScalar	src/LU/PartialPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::RowsAtCompileTime	src/LU/PartialPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon401
Eigen::PartialPivLU::Scalar	src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::StorageKind	src/LU/PartialPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::TranspositionType	src/LU/PartialPivLU.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::check_template_parameters	src/LU/PartialPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::PartialPivLU	access:protected	signature:()
Eigen::PartialPivLU::cols	src/LU/PartialPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::compute	src/LU/PartialPivLU.h	/^    PartialPivLU& compute(const MatrixType& matrix);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(const MatrixType& matrix)
Eigen::PartialPivLU::compute	src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>& PartialPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU	signature:(const MatrixType& matrix)
Eigen::PartialPivLU::determinant	src/LU/PartialPivLU.h	/^    typename internal::traits<MatrixType>::Scalar determinant() const;$/;"	p	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::determinant	src/LU/PartialPivLU.h	/^typename internal::traits<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::PartialPivLU	signature:() const
Eigen::PartialPivLU::inverse	src/LU/PartialPivLU.h	/^    inline const internal::solve_retval<PartialPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::m_det_p	src/LU/PartialPivLU.h	/^    Index m_det_p;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::m_isInitialized	src/LU/PartialPivLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::m_lu	src/LU/PartialPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::m_p	src/LU/PartialPivLU.h	/^    PermutationType m_p;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::m_rowsTranspositions	src/LU/PartialPivLU.h	/^    TranspositionType m_rowsTranspositions;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::matrixLU	src/LU/PartialPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::permutationP	src/LU/PartialPivLU.h	/^    inline const PermutationType& permutationP() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::reconstructedMatrix	src/LU/PartialPivLU.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::reconstructedMatrix	src/LU/PartialPivLU.h	/^MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::PartialPivLU	signature:() const
Eigen::PartialPivLU::rows	src/LU/PartialPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::solve	src/LU/PartialPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::PartialReduxExpr	src/Core/VectorwiseOp.h	/^class PartialReduxExpr : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
Eigen::PartialReduxExpr::Base	src/Core/VectorwiseOp.h	/^    typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;$/;"	t	class:Eigen::PartialReduxExpr	access:public
Eigen::PartialReduxExpr::MatrixTypeNested	src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr	access:public
Eigen::PartialReduxExpr::PartialReduxExpr	src/Core/VectorwiseOp.h	/^    PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(const MatrixType& mat, const MemberOp& func = MemberOp())
Eigen::PartialReduxExpr::_MatrixTypeNested	src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr	access:public
Eigen::PartialReduxExpr::coeff	src/Core/VectorwiseOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(Index i, Index j) const
Eigen::PartialReduxExpr::coeff	src/Core/VectorwiseOp.h	/^    const Scalar coeff(Index index) const$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(Index index) const
Eigen::PartialReduxExpr::cols	src/Core/VectorwiseOp.h	/^    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:() const
Eigen::PartialReduxExpr::m_functor	src/Core/VectorwiseOp.h	/^    const MemberOp m_functor;$/;"	m	class:Eigen::PartialReduxExpr	access:protected
Eigen::PartialReduxExpr::m_matrix	src/Core/VectorwiseOp.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::PartialReduxExpr	access:protected
Eigen::PartialReduxExpr::rows	src/Core/VectorwiseOp.h	/^    Index rows() const { return (Direction==Vertical   ? 1 : m_matrix.rows()); }$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:() const
Eigen::PastixBase	src/PaStiXSupport/PaStiXSupport.h	/^class PastixBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::PastixBase::ColSpMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor> ColSpMatrix;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::Index	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::PastixBase	src/PaStiXSupport/PaStiXSupport.h	/^    PastixBase() : m_initisOk(false), m_analysisIsOk(false), m_factorizationIsOk(false), m_isInitialized(false), m_pastixdata(0), m_size(0)$/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixBase::RealScalar	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::Scalar	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::Vector	src/PaStiXSupport/PaStiXSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::_MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename internal::pastix_traits<Derived>::MatrixType _MatrixType;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::_solve	src/PaStiXSupport/PaStiXSupport.h	/^    bool _solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const;$/;"	p	class:Eigen::PastixBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const
Eigen::PastixBase::_solve	src/PaStiXSupport/PaStiXSupport.h	/^bool PastixBase<Base>::_solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::PastixBase	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const
Eigen::PastixBase::analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
Eigen::PastixBase::analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::analyzePattern(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
Eigen::PastixBase::clean	src/PaStiXSupport/PaStiXSupport.h	/^    void clean()$/;"	f	class:Eigen::PastixBase	access:protected	signature:()
Eigen::PastixBase::cols	src/PaStiXSupport/PaStiXSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
Eigen::PastixBase::compute	src/PaStiXSupport/PaStiXSupport.h	/^    void compute(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
Eigen::PastixBase::compute	src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::compute(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
Eigen::PastixBase::derived	src/PaStiXSupport/PaStiXSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixBase::derived	src/PaStiXSupport/PaStiXSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
Eigen::PastixBase::dparm	src/PaStiXSupport/PaStiXSupport.h	/^    Array<RealScalar,IPARM_SIZE,1>& dparm()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixBase::dparm	src/PaStiXSupport/PaStiXSupport.h	/^    double& dparm(int idxparam)$/;"	f	class:Eigen::PastixBase	access:public	signature:(int idxparam)
Eigen::PastixBase::factorize	src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
Eigen::PastixBase::factorize	src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::factorize(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
Eigen::PastixBase::info	src/PaStiXSupport/PaStiXSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
Eigen::PastixBase::init	src/PaStiXSupport/PaStiXSupport.h	/^    void init(); $/;"	p	class:Eigen::PastixBase	access:protected	signature:()
Eigen::PastixBase::init	src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::init()$/;"	f	class:Eigen::PastixBase	signature:()
Eigen::PastixBase::iparm	src/PaStiXSupport/PaStiXSupport.h	/^    Array<Index,IPARM_SIZE,1>& iparm()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixBase::iparm	src/PaStiXSupport/PaStiXSupport.h	/^    int& iparm(int idxparam)$/;"	f	class:Eigen::PastixBase	access:public	signature:(int idxparam)
Eigen::PastixBase::m_analysisIsOk	src/PaStiXSupport/PaStiXSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_comm	src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_comm; \/\/ The MPI communicator identifier$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_dparm	src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<double,DPARM_SIZE,1> m_dparm; \/\/ Scalar vector for the input parameters$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_factorizationIsOk	src/PaStiXSupport/PaStiXSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_info	src/PaStiXSupport/PaStiXSupport.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_initisOk	src/PaStiXSupport/PaStiXSupport.h	/^    int m_initisOk; $/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_invp	src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_invp;  \/\/ Inverse permutation vector$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_iparm	src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<int,IPARM_SIZE,1> m_iparm; \/\/ integer vector for the input parameters$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_isInitialized	src/PaStiXSupport/PaStiXSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_pastixdata	src/PaStiXSupport/PaStiXSupport.h	/^    mutable pastix_data_t *m_pastixdata; \/\/ Data structure for pastix$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_perm	src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_perm;  \/\/ Permutation vector$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_size	src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_size; \/\/ Size of the matrix $/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::rows	src/PaStiXSupport/PaStiXSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
Eigen::PastixBase::solve	src/PaStiXSupport/PaStiXSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::PastixBase::solve	src/PaStiXSupport/PaStiXSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::PastixBase::~PastixBase	src/PaStiXSupport/PaStiXSupport.h	/^    ~PastixBase() $/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixLDLT	src/PaStiXSupport/PaStiXSupport.h	/^class PastixLDLT : public PastixBase< PastixLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:PastixBase
Eigen::PastixLDLT::Base	src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLDLT<MatrixType, _UpLo> > Base; $/;"	t	class:Eigen::PastixLDLT	access:public
Eigen::PastixLDLT::ColSpMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLDLT	access:public
Eigen::PastixLDLT::MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLDLT	access:public
Eigen::PastixLDLT::PastixLDLT	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT():Base()$/;"	f	class:Eigen::PastixLDLT	access:public	signature:()
Eigen::PastixLDLT::PastixLDLT	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLDLT::UpLo	src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLDLT::__anon409
Eigen::PastixLDLT::analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLDLT::compute	src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLDLT::factorize	src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLDLT::grabMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLDLT	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
Eigen::PastixLDLT::init	src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLDLT	access:protected	signature:()
Eigen::PastixLLT	src/PaStiXSupport/PaStiXSupport.h	/^class PastixLLT : public PastixBase< PastixLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:PastixBase
Eigen::PastixLLT::Base	src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLLT<MatrixType, _UpLo> > Base;$/;"	t	class:Eigen::PastixLLT	access:public
Eigen::PastixLLT::ColSpMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLLT	access:public
Eigen::PastixLLT::MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLLT	access:public
Eigen::PastixLLT::PastixLLT	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT() : Base()$/;"	f	class:Eigen::PastixLLT	access:public	signature:()
Eigen::PastixLLT::PastixLLT	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLLT::UpLo	src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLLT::__anon408
Eigen::PastixLLT::analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLLT::compute	src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLLT::factorize	src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLLT::grabMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLLT	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
Eigen::PastixLLT::init	src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLLT	access:protected	signature:()
Eigen::PastixLU	src/PaStiXSupport/PaStiXSupport.h	/^class PastixLU : public PastixBase< PastixLU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:PastixBase
Eigen::PastixLU::Base	src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLU<MatrixType> > Base;$/;"	t	class:Eigen::PastixLU	access:public
Eigen::PastixLU::ColSpMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLU	access:public
Eigen::PastixLU::Index	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixLU	access:public
Eigen::PastixLU::MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLU	access:public
Eigen::PastixLU::PastixLU	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU() : Base()$/;"	f	class:Eigen::PastixLU	access:public	signature:()
Eigen::PastixLU::PastixLU	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLU::analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLU::compute	src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLU::factorize	src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLU::grabMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLU	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
Eigen::PastixLU::init	src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLU	access:protected	signature:()
Eigen::PastixLU::m_structureIsUptodate	src/PaStiXSupport/PaStiXSupport.h	/^    bool m_structureIsUptodate;$/;"	m	class:Eigen::PastixLU	access:protected
Eigen::PermutationBase	src/Core/PermutationMatrix.h	/^class PermutationBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::PermutationBase::Base	src/Core/PermutationMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::PermutationBase	access:private
Eigen::PermutationBase::CoeffReadCost	src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::PermutationBase::__anon287
Eigen::PermutationBase::ColsAtCompileTime	src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon287
Eigen::PermutationBase::DenseMatrixType	src/Core/PermutationMatrix.h	/^            DenseMatrixType;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::Flags	src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::PermutationBase::__anon287
Eigen::PermutationBase::Index	src/Core/PermutationMatrix.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::MaxColsAtCompileTime	src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::PermutationBase::__anon287
Eigen::PermutationBase::MaxRowsAtCompileTime	src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon287
Eigen::PermutationBase::PlainPermutationType	src/Core/PermutationMatrix.h	/^            PlainPermutationType;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::RowsAtCompileTime	src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon287
Eigen::PermutationBase::Scalar	src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::PermutationBase	access:private
Eigen::PermutationBase::applyTranspositionOnTheLeft	src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheLeft(Index i, Index j)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index i, Index j)
Eigen::PermutationBase::applyTranspositionOnTheRight	src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheRight(Index i, Index j)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index i, Index j)
Eigen::PermutationBase::assignProduct	src/Core/PermutationMatrix.h	/^    void assignProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationBase	access:protected	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::PermutationBase::assignTranspose	src/Core/PermutationMatrix.h	/^    void assignTranspose(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase	access:protected	signature:(const PermutationBase<OtherDerived>& other)
Eigen::PermutationBase::cols	src/Core/PermutationMatrix.h	/^    inline Index cols() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::determinant	src/Core/PermutationMatrix.h	/^    Index determinant() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::evalTo	src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(MatrixBase<DenseDerived>& other) const
Eigen::PermutationBase::indices	src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:()
Eigen::PermutationBase::indices	src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::inverse	src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> inverse() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::operator *	src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const PermutationBase<Other>& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase<Other>& other) const
Eigen::PermutationBase::operator *	src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const Transpose<PermutationBase<Other> >& other) const
Eigen::PermutationBase::operator *	src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)$/;"	f	class:Eigen::PermutationBase	access:friend	signature:(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)
Eigen::PermutationBase::operator =	src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase& other)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase& other)
Eigen::PermutationBase::operator =	src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase<OtherDerived>& other)
Eigen::PermutationBase::operator =	src/Core/PermutationMatrix.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& tr)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const TranspositionsBase<OtherDerived>& tr)
Eigen::PermutationBase::resize	src/Core/PermutationMatrix.h	/^    inline void resize(Index newSize)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index newSize)
Eigen::PermutationBase::rows	src/Core/PermutationMatrix.h	/^    inline Index rows() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::setIdentity	src/Core/PermutationMatrix.h	/^    void setIdentity()$/;"	f	class:Eigen::PermutationBase	access:public	signature:()
Eigen::PermutationBase::setIdentity	src/Core/PermutationMatrix.h	/^    void setIdentity(Index newSize)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index newSize)
Eigen::PermutationBase::size	src/Core/PermutationMatrix.h	/^    inline Index size() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::toDenseMatrix	src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::transpose	src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> transpose() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationMatrix	src/Core/PermutationMatrix.h	/^class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	c	namespace:Eigen	inherits:PermutationBase
Eigen::PermutationMatrix::Base	src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationMatrix> Base;$/;"	t	class:Eigen::PermutationMatrix	access:private
Eigen::PermutationMatrix::IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationMatrix	access:public
Eigen::PermutationMatrix::PermutationMatrix	src/Core/PermutationMatrix.h	/^    PermutationMatrix(const Transpose<PermutationBase<Other> >& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const Transpose<PermutationBase<Other> >& other)
Eigen::PermutationMatrix::PermutationMatrix	src/Core/PermutationMatrix.h	/^    PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)
Eigen::PermutationMatrix::PermutationMatrix	src/Core/PermutationMatrix.h	/^    explicit PermutationMatrix(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const TranspositionsBase<Other>& tr)
Eigen::PermutationMatrix::PermutationMatrix	src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(const MatrixBase<Other>& a_indices) : m_indices(a_indices)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const MatrixBase<Other>& a_indices)
Eigen::PermutationMatrix::PermutationMatrix	src/Core/PermutationMatrix.h	/^    inline PermutationMatrix()$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:()
Eigen::PermutationMatrix::PermutationMatrix	src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationBase<OtherDerived>& other)
Eigen::PermutationMatrix::PermutationMatrix	src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationMatrix& other)
Eigen::PermutationMatrix::PermutationMatrix	src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(int size) : m_indices(size)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(int size)
Eigen::PermutationMatrix::Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationMatrix> Traits;$/;"	t	class:Eigen::PermutationMatrix	access:private
Eigen::PermutationMatrix::indices	src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:()
Eigen::PermutationMatrix::indices	src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:() const
Eigen::PermutationMatrix::m_indices	src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::PermutationMatrix	access:protected
Eigen::PermutationMatrix::operator =	src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationBase<Other>& other)
Eigen::PermutationMatrix::operator =	src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationMatrix& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationMatrix& other)
Eigen::PermutationMatrix::operator =	src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const TranspositionsBase<Other>& tr)
Eigen::PermutationStorage	src/Core/PermutationMatrix.h	/^struct PermutationStorage {};$/;"	s	namespace:Eigen
Eigen::PermutationWrapper	src/Core/PermutationMatrix.h	/^class PermutationWrapper : public PermutationBase<PermutationWrapper<_IndicesType> >$/;"	c	namespace:Eigen	inherits:PermutationBase
Eigen::PermutationWrapper::Base	src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationWrapper> Base;$/;"	t	class:Eigen::PermutationWrapper	access:private
Eigen::PermutationWrapper::IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationWrapper	access:public
Eigen::PermutationWrapper::PermutationWrapper	src/Core/PermutationMatrix.h	/^    inline PermutationWrapper(const IndicesType& a_indices)$/;"	f	class:Eigen::PermutationWrapper	access:public	signature:(const IndicesType& a_indices)
Eigen::PermutationWrapper::Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationWrapper> Traits;$/;"	t	class:Eigen::PermutationWrapper	access:private
Eigen::PermutationWrapper::indices	src/Core/PermutationMatrix.h	/^    indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationWrapper	access:public	signature:() const
Eigen::PermutationWrapper::m_indices	src/Core/PermutationMatrix.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::PermutationWrapper	access:protected
Eigen::Pivoting	src/Core/util/Constants.h	/^  Pivoting            = 0x01, $/;"	e	enum:Eigen::DecompositionOptions
Eigen::PlainObjectBase	src/Core/PlainObjectBase.h	/^class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base_dispatcher_for_doxygen
Eigen::PlainObjectBase::AlignedMapType	src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Aligned> AlignedMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::Base	src/Core/PlainObjectBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::ConstAlignedMapType	src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::ConstMapType	src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::DenseType	src/Core/PlainObjectBase.h	/^    typedef Derived DenseType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::Index	src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapType	src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Unaligned>  MapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::NeedsToAlign	src/Core/PlainObjectBase.h	/^    enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };$/;"	e	enum:Eigen::PlainObjectBase::__anon291
Eigen::PlainObjectBase::Options	src/Core/PlainObjectBase.h	/^    enum { Options = internal::traits<Derived>::Options };$/;"	e	enum:Eigen::PlainObjectBase::__anon290
Eigen::PlainObjectBase::PacketScalar	src/Core/PlainObjectBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase() : m_storage()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
Eigen::PlainObjectBase::PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(Index a_size, Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index a_size, Index nbRows, Index nbCols)
Eigen::PlainObjectBase::PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived> &other)
Eigen::PlainObjectBase::PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::PlainObjectBase::PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const PlainObjectBase& other)
Eigen::PlainObjectBase::PlainObjectBase	src/Core/PlainObjectBase.h	/^    PlainObjectBase(PlainObjectBase&& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(PlainObjectBase&& other)
Eigen::PlainObjectBase::PlainObjectBase	src/Core/PlainObjectBase.h	/^    PlainObjectBase(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::PlainObjectBase::RealScalar	src/Core/PlainObjectBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::Scalar	src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StorageKind	src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedAlignedMapType	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedAlignedMapType::type	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedAlignedMapType	access:public
Eigen::PlainObjectBase::StridedConstAlignedMapType	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedConstAlignedMapType::type	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstAlignedMapType	access:public
Eigen::PlainObjectBase::StridedConstMapType	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedConstMapType::type	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstMapType	access:public
Eigen::PlainObjectBase::StridedMapType	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedMapType::type	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedMapType	access:public
Eigen::PlainObjectBase::ThisConstantIsPrivateInPlainObjectBase	src/Core/PlainObjectBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::PlainObjectBase::__anon292
Eigen::PlainObjectBase::_check_template_params	src/Core/PlainObjectBase.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
Eigen::PlainObjectBase::_init2	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(Index nbRows, Index nbCols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(Index nbRows, Index nbCols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)
Eigen::PlainObjectBase::_init2	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const Scalar& val0, const Scalar& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const Scalar& val0, const Scalar& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)
Eigen::PlainObjectBase::_resize_to_match	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const EigenBase<OtherDerived>& other)
Eigen::PlainObjectBase::_set	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const DenseBase<OtherDerived>& other)
Eigen::PlainObjectBase::_set_noalias	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const DenseBase<OtherDerived>& other)
Eigen::PlainObjectBase::_set_selector	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const OtherDerived& other, const internal::false_type&)
Eigen::PlainObjectBase::_set_selector	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const OtherDerived& other, const internal::true_type&)
Eigen::PlainObjectBase::_swap	src/Core/PlainObjectBase.h	/^    void _swap(DenseBase<OtherDerived> const & other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(DenseBase<OtherDerived> const & other)
Eigen::PlainObjectBase::base	src/Core/PlainObjectBase.h	/^    Base& base() { return *static_cast<Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
Eigen::PlainObjectBase::base	src/Core/PlainObjectBase.h	/^    const Base& base() const { return *static_cast<const Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
Eigen::PlainObjectBase::coeff	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
Eigen::PlainObjectBase::coeff	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId) const
Eigen::PlainObjectBase::coeffRef	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index)
Eigen::PlainObjectBase::coeffRef	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId)
Eigen::PlainObjectBase::coeffRef	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
Eigen::PlainObjectBase::coeffRef	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId) const
Eigen::PlainObjectBase::cols	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
Eigen::PlainObjectBase::conservativeResize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index nbRows, Index nbCols)
Eigen::PlainObjectBase::conservativeResize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index nbRows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index nbRows, NoChange_t)
Eigen::PlainObjectBase::conservativeResize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size)
Eigen::PlainObjectBase::conservativeResize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(NoChange_t, Index nbCols)
Eigen::PlainObjectBase::conservativeResizeLike	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::PlainObjectBase::data	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar *data()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
Eigen::PlainObjectBase::data	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar *data() const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
Eigen::PlainObjectBase::lazyAssign	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::PlainObjectBase::m_storage	src/Core/PlainObjectBase.h	/^    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;$/;"	m	class:Eigen::PlainObjectBase	access:protected
Eigen::PlainObjectBase::operator =	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::PlainObjectBase::operator =	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const PlainObjectBase& other)
Eigen::PlainObjectBase::operator =	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const ReturnByValue<OtherDerived>& func)
Eigen::PlainObjectBase::operator =	src/Core/PlainObjectBase.h	/^    PlainObjectBase& operator=(PlainObjectBase&& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(PlainObjectBase&& other)
Eigen::PlainObjectBase::packet	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
Eigen::PlainObjectBase::packet	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId) const
Eigen::PlainObjectBase::resize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index nbRows, Index nbCols)
Eigen::PlainObjectBase::resize	src/Core/PlainObjectBase.h	/^    inline void resize(Index nbRows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index nbRows, NoChange_t)
Eigen::PlainObjectBase::resize	src/Core/PlainObjectBase.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size)
Eigen::PlainObjectBase::resize	src/Core/PlainObjectBase.h	/^    inline void resize(NoChange_t, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(NoChange_t, Index nbCols)
Eigen::PlainObjectBase::resizeLike	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived>& _other)
Eigen::PlainObjectBase::rows	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
Eigen::PlainObjectBase::setConstant	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index nbRows, Index nbCols, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index nbRows, Index nbCols, const Scalar& val)
Eigen::PlainObjectBase::setConstant	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index size, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size, const Scalar& val)
Eigen::PlainObjectBase::setConstant	src/Core/PlainObjectBase.h	/^    Derived& setConstant(Index rows, Index cols, const Scalar& value);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols, const Scalar& value)
Eigen::PlainObjectBase::setOnes	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index nbRows, Index nbCols)
Eigen::PlainObjectBase::setOnes	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index newSize)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index newSize)
Eigen::PlainObjectBase::setOnes	src/Core/PlainObjectBase.h	/^    Derived& setOnes(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::setRandom	src/Core/PlainObjectBase.h	/^    Derived& setRandom(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::setRandom	src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index nbRows, Index nbCols)
Eigen::PlainObjectBase::setRandom	src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index newSize)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index newSize)
Eigen::PlainObjectBase::setZero	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index nbRows, Index nbCols)
Eigen::PlainObjectBase::setZero	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index newSize)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index newSize)
Eigen::PlainObjectBase::setZero	src/Core/PlainObjectBase.h	/^    Derived& setZero(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::writePacket	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index, const PacketScalar& val)
Eigen::PlainObjectBase::writePacket	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId, const PacketScalar& val)
Eigen::ProductBase	src/Core/ProductBase.h	/^class ProductBase : public MatrixBase<Derived>$/;"	c	namespace:Eigen	inherits:MatrixBase
Eigen::ProductBase::ActualLhsType	src/Core/ProductBase.h	/^    typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::ActualRhsType	src/Core/ProductBase.h	/^    typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::Base	src/Core/ProductBase.h	/^    typedef MatrixBase<Derived> Base;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::BasePlainObject	src/Core/ProductBase.h	/^    typedef typename Base::PlainObject BasePlainObject;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::DynPlainObject	src/Core/ProductBase.h	/^    typedef Matrix<Scalar,RowsAtCompileTime==1?1:Dynamic,ColsAtCompileTime==1?1:Dynamic,BasePlainObject::Options> DynPlainObject;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::FullyLazyCoeffBaseProductType	src/Core/ProductBase.h	/^    typedef CoeffBasedProduct<LhsNested, RhsNested, 0> FullyLazyCoeffBaseProductType;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::LhsBlasTraits	src/Core/ProductBase.h	/^    typedef internal::blas_traits<_LhsNested> LhsBlasTraits;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::LhsNested	src/Core/ProductBase.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::LhsScalar	src/Core/ProductBase.h	/^    typedef typename internal::traits<Lhs>::Scalar LhsScalar;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::RhsBlasTraits	src/Core/ProductBase.h	/^    typedef internal::blas_traits<_RhsNested> RhsBlasTraits;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::RhsNested	src/Core/ProductBase.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::RhsScalar	src/Core/ProductBase.h	/^    typedef typename internal::traits<Rhs>::Scalar RhsScalar;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::_ActualLhsType	src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualLhsType>::type _ActualLhsType;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::_ActualRhsType	src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualRhsType>::type _ActualRhsType;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::_LhsNested	src/Core/ProductBase.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::_RhsNested	src/Core/ProductBase.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::cols	src/Core/ProductBase.h	/^      eigen_assert(this->rows() == 1 && this->cols() == 1);$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::result	src/Core/ProductBase.h	/^      Matrix<Scalar,1,1> result = *this;$/;"	m	class:Eigen::ProductBase	access:public
Eigen::ProductReturnType	src/Core/GeneralProduct.h	/^struct ProductReturnType$/;"	s	namespace:Eigen
Eigen::ProductReturnType	src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,CoeffBasedProductMode>$/;"	s	namespace:Eigen
Eigen::ProductReturnType	src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen
Eigen::ProductReturnType::LhsNested	src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Lhs, Rhs::ColsAtCompileTime, typename internal::plain_matrix_type<Lhs>::type >::type LhsNested;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::ProductReturnType::RhsNested	src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Rhs, Lhs::RowsAtCompileTime, typename internal::plain_matrix_type<Rhs>::type >::type RhsNested;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::ProductReturnType::Type	src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, EvalBeforeAssigningBit | EvalBeforeNestingBit> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::ProductReturnType::Type	src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, NestByRefBit> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::ProductReturnType::Type	src/Core/GeneralProduct.h	/^  typedef GeneralProduct<Lhs\/*Nested*\/, Rhs\/*Nested*\/, ProductType> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::Projective	src/Core/util/Constants.h	/^  Projective    = 0x20$/;"	e	enum:Eigen::TransformTraits
Eigen::Projective2d	src/Geometry/Transform.h	/^typedef Transform<double,2,Projective> Projective2d;$/;"	t	namespace:Eigen
Eigen::Projective2f	src/Geometry/Transform.h	/^typedef Transform<float,2,Projective> Projective2f;$/;"	t	namespace:Eigen
Eigen::Projective3d	src/Geometry/Transform.h	/^typedef Transform<double,3,Projective> Projective3d;$/;"	t	namespace:Eigen
Eigen::Projective3f	src/Geometry/Transform.h	/^typedef Transform<float,3,Projective> Projective3f;$/;"	t	namespace:Eigen
Eigen::QR	src/Eigen2Support/QR.h	/^class QR : public HouseholderQR<MatrixType>$/;"	c	namespace:Eigen	inherits:HouseholderQR
Eigen::QR::Base	src/Eigen2Support/QR.h	/^    typedef HouseholderQR<MatrixType> Base;$/;"	t	class:Eigen::QR	access:public
Eigen::QR::MatrixRBlockType	src/Eigen2Support/QR.h	/^    typedef Block<const MatrixType, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixRBlockType;$/;"	t	class:Eigen::QR	access:public
Eigen::QR::QR	src/Eigen2Support/QR.h	/^    QR() : Base() {}$/;"	f	class:Eigen::QR	access:public	signature:()
Eigen::QR::QR	src/Eigen2Support/QR.h	/^    explicit QR(const T& t) : Base(t) {}$/;"	f	class:Eigen::QR	access:public	signature:(const T& t)
Eigen::QR::isFullRank	src/Eigen2Support/QR.h	/^    bool isFullRank() const {$/;"	f	class:Eigen::QR	access:public	signature:() const
Eigen::QR::matrixQ	src/Eigen2Support/QR.h	/^    MatrixType matrixQ(void) const {$/;"	f	class:Eigen::QR	access:public	signature:(void) const
Eigen::QR::matrixR	src/Eigen2Support/QR.h	/^    matrixR(void) const$/;"	f	class:Eigen::QR	access:public	signature:(void) const
Eigen::QR::solve	src/Eigen2Support/QR.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::QR	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
Eigen::QRPreconditioners	src/Core/util/Constants.h	/^enum QRPreconditioners {$/;"	g	namespace:Eigen
Eigen::Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^class Quaternion : public RotationBase<Quaternion<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::Quaternion	src/Geometry/Quaternion.h	/^class Quaternion : public QuaternionBase<Quaternion<_Scalar,_Options> >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Eigen::Quaternion::AngleAxisType	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::AngleAxisType	src/Geometry/Quaternion.h	/^  typedef typename Base::AngleAxisType AngleAxisType;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::Base	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef RotationBase<Quaternion<_Scalar>,3> Base;$/;"	t	class:Eigen::Quaternion	access:private
Eigen::Quaternion::Base	src/Geometry/Quaternion.h	/^  typedef QuaternionBase<Quaternion<_Scalar,_Options> > Base;$/;"	t	class:Eigen::Quaternion	access:private
Eigen::Quaternion::Coefficients	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar, 4, 1> Coefficients;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::Coefficients	src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Quaternion>::Coefficients Coefficients;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::FromTwoVectors	src/Geometry/Quaternion.h	/^  static Quaternion FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::Quaternion::FromTwoVectors	src/Geometry/Quaternion.h	/^Quaternion<Scalar,Options> Quaternion<Scalar,Options>::FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::Quaternion::Identity	src/Eigen2Support/Geometry/Quaternion.h	/^  static inline Quaternion Identity() { return Quaternion(1, 0, 0, 0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::IsAligned	src/Geometry/Quaternion.h	/^  enum { IsAligned = internal::traits<Quaternion>::IsAligned };$/;"	e	enum:Eigen::Quaternion::__anon377
Eigen::Quaternion::Matrix3	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Eigen::Quaternion::Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& other)
Eigen::Quaternion::Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(Scalar w, Scalar x, Scalar y, Scalar z)$/;"	f	class:Eigen::Quaternion	access:public	signature:(Scalar w, Scalar x, Scalar y, Scalar z)
Eigen::Quaternion::Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(const Quaternion& other) { m_coeffs = other.m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other)
Eigen::Quaternion::Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  inline explicit Quaternion(const Quaternion<OtherScalarType>& other)$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion<OtherScalarType>& other)
Eigen::Quaternion::Quaternion	src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Eigen::Quaternion::Quaternion	src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& other)
Eigen::Quaternion::Quaternion	src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const Quaternion<OtherScalar, OtherOptions>& other)$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion<OtherScalar, OtherOptions>& other)
Eigen::Quaternion::Quaternion	src/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::Quaternion	src/Geometry/Quaternion.h	/^  inline Quaternion(const Scalar& w, const Scalar& x, const Scalar& y, const Scalar& z) : m_coeffs(x, y, z, w){}$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Scalar& w, const Scalar& x, const Scalar& y, const Scalar& z)
Eigen::Quaternion::Quaternion	src/Geometry/Quaternion.h	/^  inline Quaternion(const Scalar* data) : m_coeffs(data) {}$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Scalar* data)
Eigen::Quaternion::Quaternion	src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_STRONG_INLINE Quaternion(const QuaternionBase<Derived>& other) { this->Base::operator=(other); }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const QuaternionBase<Derived>& other)
Eigen::Quaternion::Scalar	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::Scalar	src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::Vector3	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::_check_template_params	src/Geometry/Quaternion.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::Quaternion	access:protected	signature:()
Eigen::Quaternion::angularDistance	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar angularDistance(const Quaternion& other) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other) const
Eigen::Quaternion::angularDistance	src/Eigen2Support/Geometry/Quaternion.h	/^inline Scalar Quaternion<Scalar>::angularDistance(const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other) const
Eigen::Quaternion::cast	src/Eigen2Support/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Quaternion,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::coeffs	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::coeffs	src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::coeffs	src/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs;}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::coeffs	src/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::conjugate	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion conjugate(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
Eigen::Quaternion::conjugate	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::conjugate() const$/;"	f	class:Eigen::Quaternion	signature:() const
Eigen::Quaternion::eigen2_dot	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar eigen2_dot(const Quaternion& other) const { return m_coeffs.eigen2_dot(other.m_coeffs); }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other) const
Eigen::Quaternion::inverse	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion inverse(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
Eigen::Quaternion::inverse	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::inverse() const$/;"	f	class:Eigen::Quaternion	signature:() const
Eigen::Quaternion::isApprox	src/Eigen2Support/Geometry/Quaternion.h	/^  bool isApprox(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Quaternion::m_coeffs	src/Eigen2Support/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion	access:protected
Eigen::Quaternion::m_coeffs	src/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion	access:protected
Eigen::Quaternion::norm	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar norm() const { return m_coeffs.norm(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::normalize	src/Eigen2Support/Geometry/Quaternion.h	/^  inline void normalize() { m_coeffs.normalize(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::normalized	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion normalized() const { return Quaternion(m_coeffs.normalized()); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::operator *	src/Eigen2Support/Geometry/Quaternion.h	/^  Vector3 operator* (const MatrixBase<Derived>& vec) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& vec) const
Eigen::Quaternion::operator *	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion operator* (const Quaternion& q) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& q) const
Eigen::Quaternion::operator *	src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::operator* (const MatrixBase<Derived>& v) const$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived>& v) const
Eigen::Quaternion::operator *	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::operator* (const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other) const
Eigen::Quaternion::operator *=	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& operator*= (const Quaternion& q);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& q)
Eigen::Quaternion::operator *=	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator*= (const Quaternion& other)$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other)
Eigen::Quaternion::operator =	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const AngleAxisType& aa);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Eigen::Quaternion::operator =	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::Quaternion::operator =	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const Quaternion& other);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other)
Eigen::Quaternion::operator =	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::Quaternion	signature:(const AngleAxisType& aa)
Eigen::Quaternion::operator =	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const MatrixBase<Derived>& xpr)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived>& xpr)
Eigen::Quaternion::operator =	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const Quaternion& other)$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other)
Eigen::Quaternion::setFromTwoVectors	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::Quaternion::setFromTwoVectors	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::Quaternion::setIdentity	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& setIdentity() { m_coeffs << 0, 0, 0, 1; return *this; }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::slerp	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion slerp(Scalar t, const Quaternion& other) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(Scalar t, const Quaternion& other) const
Eigen::Quaternion::slerp	src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar> Quaternion<Scalar>::slerp(Scalar t, const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(Scalar t, const Quaternion& other) const
Eigen::Quaternion::squaredNorm	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return m_coeffs.squaredNorm(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::toRotationMatrix	src/Eigen2Support/Geometry/Quaternion.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
Eigen::Quaternion::toRotationMatrix	src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Quaternion	signature:(void) const
Eigen::Quaternion::vec	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Block<Coefficients,3,1> vec() { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::vec	src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Block<const Coefficients,3,1> vec() const { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::w	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar w() const { return m_coeffs.coeff(3); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::w	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& w() { return m_coeffs.coeffRef(3); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::x	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar x() const { return m_coeffs.coeff(0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::x	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& x() { return m_coeffs.coeffRef(0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::y	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar y() const { return m_coeffs.coeff(1); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::y	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& y() { return m_coeffs.coeffRef(1); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::z	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar z() const { return m_coeffs.coeff(2); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::z	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& z() { return m_coeffs.coeffRef(2); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::QuaternionBase	src/Geometry/Quaternion.h	/^class QuaternionBase : public RotationBase<Derived, 3>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::QuaternionBase::AngleAxisType	src/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::Base	src/Geometry/Quaternion.h	/^  typedef RotationBase<Derived, 3> Base;$/;"	t	class:Eigen::QuaternionBase	access:private
Eigen::QuaternionBase::Coefficients	src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Coefficients Coefficients;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::Flags	src/Geometry/Quaternion.h	/^    Flags = Eigen::internal::traits<Derived>::Flags$/;"	e	enum:Eigen::QuaternionBase::__anon375
Eigen::QuaternionBase::Identity	src/Geometry/Quaternion.h	/^  static inline Quaternion<Scalar> Identity() { return Quaternion<Scalar>(Scalar(1), Scalar(0), Scalar(0), Scalar(0)); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::Matrix3	src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::RealScalar	src/Geometry/Quaternion.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::Scalar	src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::Vector3	src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::_transformVector	src/Geometry/Quaternion.h	/^  EIGEN_STRONG_INLINE Vector3 _transformVector(const Vector3& v) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const Vector3& v) const
Eigen::QuaternionBase::_transformVector	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::_transformVector(const Vector3& v) const$/;"	f	class:Eigen::QuaternionBase	signature:(const Vector3& v) const
Eigen::QuaternionBase::angularDistance	src/Geometry/Quaternion.h	/^  template<class OtherDerived> Scalar angularDistance(const QuaternionBase<OtherDerived>& other) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::angularDistance	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::angularDistance(const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::cast	src/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::coeffs	src/Geometry/Quaternion.h	/^  inline const typename internal::traits<Derived>::Coefficients& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::coeffs	src/Geometry/Quaternion.h	/^  inline typename internal::traits<Derived>::Coefficients& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::conjugate	src/Geometry/Quaternion.h	/^  Quaternion<Scalar> conjugate() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::conjugate	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::conjugate() const$/;"	f	class:Eigen::QuaternionBase	signature:() const
Eigen::QuaternionBase::dot	src/Geometry/Quaternion.h	/^  template<class OtherDerived> inline Scalar dot(const QuaternionBase<OtherDerived>& other) const { return coeffs().dot(other.coeffs()); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::inverse	src/Geometry/Quaternion.h	/^  Quaternion<Scalar> inverse() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::inverse	src/Geometry/Quaternion.h	/^inline Quaternion<typename internal::traits<Derived>::Scalar> QuaternionBase<Derived>::inverse() const$/;"	f	class:Eigen::QuaternionBase	signature:() const
Eigen::QuaternionBase::isApprox	src/Geometry/Quaternion.h	/^  bool isApprox(const QuaternionBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::QuaternionBase::norm	src/Geometry/Quaternion.h	/^  inline Scalar norm() const { return coeffs().norm(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::normalize	src/Geometry/Quaternion.h	/^  inline void normalize() { coeffs().normalize(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::normalized	src/Geometry/Quaternion.h	/^  inline Quaternion<Scalar> normalized() const { return Quaternion<Scalar>(coeffs().normalized()); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::operator *	src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Quaternion<Scalar> operator* (const QuaternionBase<OtherDerived>& q) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& q) const
Eigen::QuaternionBase::operator *	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::operator* (const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::operator *=	src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Derived& operator*= (const QuaternionBase<OtherDerived>& q);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& q)
Eigen::QuaternionBase::operator *=	src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator*= (const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other)
Eigen::QuaternionBase::operator =	src/Geometry/Quaternion.h	/^  Derived& operator=(const AngleAxisType& aa);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const AngleAxisType& aa)
Eigen::QuaternionBase::operator =	src/Geometry/Quaternion.h	/^  EIGEN_STRONG_INLINE QuaternionBase<Derived>& operator=(const QuaternionBase<Derived>& other);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<Derived>& other)
Eigen::QuaternionBase::operator =	src/Geometry/Quaternion.h	/^  template<class OtherDerived> Derived& operator=(const MatrixBase<OtherDerived>& m);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const MatrixBase<OtherDerived>& m)
Eigen::QuaternionBase::operator =	src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Derived& operator=(const QuaternionBase<OtherDerived>& other);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other)
Eigen::QuaternionBase::operator =	src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::QuaternionBase	signature:(const AngleAxisType& aa)
Eigen::QuaternionBase::operator =	src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other)
Eigen::QuaternionBase::operator =	src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE QuaternionBase<Derived>& QuaternionBase<Derived>::operator=(const QuaternionBase<Derived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<Derived>& other)
Eigen::QuaternionBase::operator =	src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::operator=(const MatrixBase<MatrixDerived>& xpr)$/;"	f	class:Eigen::QuaternionBase	signature:(const MatrixBase<MatrixDerived>& xpr)
Eigen::QuaternionBase::setFromTwoVectors	src/Geometry/Quaternion.h	/^  Derived& setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::QuaternionBase::setFromTwoVectors	src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::QuaternionBase	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::QuaternionBase::setIdentity	src/Geometry/Quaternion.h	/^  inline QuaternionBase& setIdentity() { coeffs() << Scalar(0), Scalar(0), Scalar(0), Scalar(1); return *this; }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::slerp	src/Geometry/Quaternion.h	/^  template<class OtherDerived> Quaternion<Scalar> slerp(const Scalar& t, const QuaternionBase<OtherDerived>& other) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const Scalar& t, const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::slerp	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::slerp(const Scalar& t, const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const Scalar& t, const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::squaredNorm	src/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return coeffs().squaredNorm(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::toRotationMatrix	src/Geometry/Quaternion.h	/^  Matrix3 toRotationMatrix() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::toRotationMatrix	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::toRotationMatrix(void) const$/;"	f	class:Eigen::QuaternionBase	signature:(void) const
Eigen::QuaternionBase::vec	src/Geometry/Quaternion.h	/^  inline VectorBlock<Coefficients,3> vec() { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::vec	src/Geometry/Quaternion.h	/^  inline const VectorBlock<const Coefficients,3> vec() const { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::w	src/Geometry/Quaternion.h	/^  inline Scalar w() const { return this->derived().coeffs().coeff(3); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::w	src/Geometry/Quaternion.h	/^  inline Scalar& w() { return this->derived().coeffs().coeffRef(3); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::x	src/Geometry/Quaternion.h	/^  inline Scalar x() const { return this->derived().coeffs().coeff(0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::x	src/Geometry/Quaternion.h	/^  inline Scalar& x() { return this->derived().coeffs().coeffRef(0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::y	src/Geometry/Quaternion.h	/^  inline Scalar y() const { return this->derived().coeffs().coeff(1); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::y	src/Geometry/Quaternion.h	/^  inline Scalar& y() { return this->derived().coeffs().coeffRef(1); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::z	src/Geometry/Quaternion.h	/^  inline Scalar z() const { return this->derived().coeffs().coeff(2); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::z	src/Geometry/Quaternion.h	/^  inline Scalar& z() { return this->derived().coeffs().coeffRef(2); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionMapAlignedd	src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, Aligned>  QuaternionMapAlignedd;$/;"	t	namespace:Eigen
Eigen::QuaternionMapAlignedf	src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, Aligned>   QuaternionMapAlignedf;$/;"	t	namespace:Eigen
Eigen::QuaternionMapd	src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, 0>        QuaternionMapd;$/;"	t	namespace:Eigen
Eigen::QuaternionMapf	src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, 0>         QuaternionMapf;$/;"	t	namespace:Eigen
Eigen::Quaterniond	src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Eigen::Quaterniond	src/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Eigen::Quaternionf	src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Eigen::Quaternionf	src/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Eigen::RandomAccessPattern	src/SparseCore/SparseUtil.h	/^const int RandomAccessPattern       = 0x8 | OuterRandomAccessPattern | InnerRandomAccessPattern;$/;"	m	namespace:Eigen
Eigen::ReadOnlyAccessors	src/Core/util/Constants.h	/^  ReadOnlyAccessors, $/;"	e	enum:Eigen::AccessorLevels
Eigen::RealQZ	src/Eigenvalues/RealQZ.h	/^  template<typename _MatrixType> class RealQZ$/;"	c	namespace:Eigen
Eigen::RealQZ::ColsAtCompileTime	src/Eigenvalues/RealQZ.h	/^        ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon365
Eigen::RealQZ::ColumnVectorType	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealQZ	access:public
Eigen::RealQZ::ComplexScalar	src/Eigenvalues/RealQZ.h	/^      typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealQZ	access:public
Eigen::RealQZ::EigenvalueType	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealQZ	access:public
Eigen::RealQZ::Index	src/Eigenvalues/RealQZ.h	/^      typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::RealQZ	access:public
Eigen::RealQZ::JRs	src/Eigenvalues/RealQZ.h	/^      typedef JacobiRotation<Scalar> JRs;$/;"	t	class:Eigen::RealQZ	access:private
Eigen::RealQZ::Matrix2s	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,2> Matrix2s;$/;"	t	class:Eigen::RealQZ	access:private
Eigen::RealQZ::MatrixType	src/Eigenvalues/RealQZ.h	/^      typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealQZ	access:public
Eigen::RealQZ::MaxColsAtCompileTime	src/Eigenvalues/RealQZ.h	/^        MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealQZ::__anon365
Eigen::RealQZ::MaxRowsAtCompileTime	src/Eigenvalues/RealQZ.h	/^        MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon365
Eigen::RealQZ::Options	src/Eigenvalues/RealQZ.h	/^        Options = MatrixType::Options,$/;"	e	enum:Eigen::RealQZ::__anon365
Eigen::RealQZ::RealQZ	src/Eigenvalues/RealQZ.h	/^      RealQZ(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime) : $/;"	f	class:Eigen::RealQZ	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
Eigen::RealQZ::RealQZ	src/Eigenvalues/RealQZ.h	/^      RealQZ(const MatrixType& A, const MatrixType& B, bool computeQZ = true) :$/;"	f	class:Eigen::RealQZ	access:public	signature:(const MatrixType& A, const MatrixType& B, bool computeQZ = true)
Eigen::RealQZ::RowsAtCompileTime	src/Eigenvalues/RealQZ.h	/^        RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon365
Eigen::RealQZ::Scalar	src/Eigenvalues/RealQZ.h	/^      typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealQZ	access:public
Eigen::RealQZ::Vector2s	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,1> Vector2s;$/;"	t	class:Eigen::RealQZ	access:private
Eigen::RealQZ::Vector3s	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealQZ	access:private
Eigen::RealQZ::compute	src/Eigenvalues/RealQZ.h	/^      RealQZ& compute(const MatrixType& A, const MatrixType& B, bool computeQZ = true);$/;"	p	class:Eigen::RealQZ	access:public	signature:(const MatrixType& A, const MatrixType& B, bool computeQZ = true)
Eigen::RealQZ::compute	src/Eigenvalues/RealQZ.h	/^    RealQZ<MatrixType>& RealQZ<MatrixType>::compute(const MatrixType& A_in, const MatrixType& B_in, bool computeQZ)$/;"	f	class:Eigen::RealQZ	signature:(const MatrixType& A_in, const MatrixType& B_in, bool computeQZ)
Eigen::RealQZ::computeNorms	src/Eigenvalues/RealQZ.h	/^      void computeNorms();$/;"	p	class:Eigen::RealQZ	access:private	signature:()
Eigen::RealQZ::computeNorms	src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::computeNorms()$/;"	f	class:Eigen::RealQZ	signature:()
Eigen::RealQZ::findSmallDiagEntry	src/Eigenvalues/RealQZ.h	/^      Index findSmallDiagEntry(Index f, Index l);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index f, Index l)
Eigen::RealQZ::findSmallDiagEntry	src/Eigenvalues/RealQZ.h	/^    inline typename MatrixType::Index RealQZ<MatrixType>::findSmallDiagEntry(Index f, Index l)$/;"	f	class:Eigen::RealQZ	signature:(Index f, Index l)
Eigen::RealQZ::findSmallSubdiagEntry	src/Eigenvalues/RealQZ.h	/^      Index findSmallSubdiagEntry(Index iu);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index iu)
Eigen::RealQZ::findSmallSubdiagEntry	src/Eigenvalues/RealQZ.h	/^    inline typename MatrixType::Index RealQZ<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealQZ	signature:(Index iu)
Eigen::RealQZ::hessenbergTriangular	src/Eigenvalues/RealQZ.h	/^      void hessenbergTriangular();$/;"	p	class:Eigen::RealQZ	access:private	signature:()
Eigen::RealQZ::hessenbergTriangular	src/Eigenvalues/RealQZ.h	/^    void RealQZ<MatrixType>::hessenbergTriangular()$/;"	f	class:Eigen::RealQZ	signature:()
Eigen::RealQZ::info	src/Eigenvalues/RealQZ.h	/^      ComputationInfo info() const$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
Eigen::RealQZ::iterations	src/Eigenvalues/RealQZ.h	/^      Index iterations() const$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
Eigen::RealQZ::m_Q	src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_S	src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_T	src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_Z	src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_computeQZ	src/Eigenvalues/RealQZ.h	/^      bool m_computeQZ;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_global_iter	src/Eigenvalues/RealQZ.h	/^      Index m_global_iter;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_info	src/Eigenvalues/RealQZ.h	/^      ComputationInfo m_info;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_isInitialized	src/Eigenvalues/RealQZ.h	/^      bool m_isInitialized;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_maxIters	src/Eigenvalues/RealQZ.h	/^      Index m_maxIters;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_normOfS	src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_normOfT	src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::m_workspace	src/Eigenvalues/RealQZ.h	/^      Matrix<Scalar,Dynamic,1> m_workspace;$/;"	m	class:Eigen::RealQZ	access:private
Eigen::RealQZ::matrixQ	src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixQ() const {$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
Eigen::RealQZ::matrixS	src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixS() const {$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
Eigen::RealQZ::matrixT	src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixT() const {$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
Eigen::RealQZ::matrixZ	src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixZ() const {$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
Eigen::RealQZ::pushDownZero	src/Eigenvalues/RealQZ.h	/^      void pushDownZero(Index z, Index f, Index l);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index z, Index f, Index l)
Eigen::RealQZ::pushDownZero	src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::pushDownZero(Index z, Index f, Index l)$/;"	f	class:Eigen::RealQZ	signature:(Index z, Index f, Index l)
Eigen::RealQZ::setMaxIterations	src/Eigenvalues/RealQZ.h	/^      RealQZ& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealQZ	access:public	signature:(Index maxIters)
Eigen::RealQZ::splitOffTwoRows	src/Eigenvalues/RealQZ.h	/^      void splitOffTwoRows(Index i);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index i)
Eigen::RealQZ::splitOffTwoRows	src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::splitOffTwoRows(Index i)$/;"	f	class:Eigen::RealQZ	signature:(Index i)
Eigen::RealQZ::step	src/Eigenvalues/RealQZ.h	/^      void step(Index f, Index l, Index iter);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index f, Index l, Index iter)
Eigen::RealQZ::step	src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::step(Index f, Index l, Index iter)$/;"	f	class:Eigen::RealQZ	signature:(Index f, Index l, Index iter)
Eigen::RealSchur	src/Eigenvalues/RealSchur.h	/^template<typename _MatrixType> class RealSchur$/;"	c	namespace:Eigen
Eigen::RealSchur::ColsAtCompileTime	src/Eigenvalues/RealSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon366
Eigen::RealSchur::ColumnVectorType	src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::ComplexScalar	src/Eigenvalues/RealSchur.h	/^    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::EigenvalueType	src/Eigenvalues/RealSchur.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::Index	src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::MatrixType	src/Eigenvalues/RealSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::MaxColsAtCompileTime	src/Eigenvalues/RealSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealSchur::__anon366
Eigen::RealSchur::MaxRowsAtCompileTime	src/Eigenvalues/RealSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon366
Eigen::RealSchur::Options	src/Eigenvalues/RealSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::RealSchur::__anon366
Eigen::RealSchur::RealSchur	src/Eigenvalues/RealSchur.h	/^    RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::RealSchur	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
Eigen::RealSchur::RealSchur	src/Eigenvalues/RealSchur.h	/^    RealSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::RealSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
Eigen::RealSchur::RowsAtCompileTime	src/Eigenvalues/RealSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon366
Eigen::RealSchur::Scalar	src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::Vector3s	src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealSchur	access:private
Eigen::RealSchur::compute	src/Eigenvalues/RealSchur.h	/^    RealSchur& compute(const MatrixType& matrix, bool computeU = true);$/;"	p	class:Eigen::RealSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
Eigen::RealSchur::compute	src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::RealSchur	signature:(const MatrixType& matrix, bool computeU)
Eigen::RealSchur::computeFromHessenberg	src/Eigenvalues/RealSchur.h	/^    RealSchur& computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU);$/;"	p	class:Eigen::RealSchur	access:public	signature:(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)
Eigen::RealSchur::computeFromHessenberg	src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU)$/;"	f	class:Eigen::RealSchur	signature:(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)
Eigen::RealSchur::computeNormOfT	src/Eigenvalues/RealSchur.h	/^    Scalar computeNormOfT();$/;"	p	class:Eigen::RealSchur	access:private	signature:()
Eigen::RealSchur::computeNormOfT	src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()$/;"	f	class:Eigen::RealSchur	signature:()
Eigen::RealSchur::computeShift	src/Eigenvalues/RealSchur.h	/^    void computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)
Eigen::RealSchur::computeShift	src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)
Eigen::RealSchur::findSmallSubdiagEntry	src/Eigenvalues/RealSchur.h	/^    Index findSmallSubdiagEntry(Index iu);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu)
Eigen::RealSchur::findSmallSubdiagEntry	src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealSchur	signature:(Index iu)
Eigen::RealSchur::getMaxIterations	src/Eigenvalues/RealSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::RealSchur	access:public	signature:()
Eigen::RealSchur::info	src/Eigenvalues/RealSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
Eigen::RealSchur::initFrancisQRStep	src/Eigenvalues/RealSchur.h	/^    void initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)
Eigen::RealSchur::initFrancisQRStep	src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)$/;"	f	class:Eigen::RealSchur	signature:(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)
Eigen::RealSchur::m_hess	src/Eigenvalues/RealSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_info	src/Eigenvalues/RealSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_isInitialized	src/Eigenvalues/RealSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_matT	src/Eigenvalues/RealSchur.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_matU	src/Eigenvalues/RealSchur.h	/^    MatrixType m_matU;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_matUisUptodate	src/Eigenvalues/RealSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_maxIterationsPerRow	src/Eigenvalues/RealSchur.h	/^    static const int m_maxIterationsPerRow = 40;$/;"	m	class:Eigen::RealSchur	access:public
Eigen::RealSchur::m_maxIters	src/Eigenvalues/RealSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_workspaceVector	src/Eigenvalues/RealSchur.h	/^    ColumnVectorType m_workspaceVector;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::matrixT	src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixT() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
Eigen::RealSchur::matrixU	src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixU() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
Eigen::RealSchur::performFrancisQRStep	src/Eigenvalues/RealSchur.h	/^    void performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)
Eigen::RealSchur::performFrancisQRStep	src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)$/;"	f	class:Eigen::RealSchur	signature:(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)
Eigen::RealSchur::setMaxIterations	src/Eigenvalues/RealSchur.h	/^    RealSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealSchur	access:public	signature:(Index maxIters)
Eigen::RealSchur::splitOffTwoRows	src/Eigenvalues/RealSchur.h	/^    void splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, bool computeU, const Scalar& exshift)
Eigen::RealSchur::splitOffTwoRows	src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, bool computeU, const Scalar& exshift)
Eigen::Ref	src/Core/Ref.h	/^template<typename PlainObjectType, int Options, typename StrideType> class Ref$/;"	c	namespace:Eigen	inherits:RefBase
Eigen::Ref	src/Core/Ref.h	/^template<typename TPlainObjectType, int Options, typename StrideType> class Ref<const TPlainObjectType, Options, StrideType>$/;"	c	namespace:Eigen	inherits:RefBase
Eigen::Ref::Base	src/Core/Ref.h	/^    typedef RefBase<Ref> Base;$/;"	t	class:Eigen::Ref	access:public
Eigen::Ref::Ref	src/Core/Ref.h	/^    inline Ref(PlainObjectBase<Derived>& expr,$/;"	f	class:Eigen::Ref	access:public	signature:(PlainObjectBase<Derived>& expr, typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
Eigen::Ref::Ref	src/Core/Ref.h	/^    inline Ref(const DenseBase<Derived>& expr,$/;"	f	class:Eigen::Ref	access:public	signature:(const DenseBase<Derived>& expr, typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
Eigen::Ref::Ref	src/Core/Ref.h	/^    inline Ref(const DenseBase<Derived>& expr,$/;"	f	class:Eigen::Ref	access:public	signature:(const DenseBase<Derived>& expr, typename internal::enable_if<bool(Traits::template match<Derived>::ScalarTypeMatch),Derived>::type* = 0)
Eigen::Ref::Ref	src/Core/Ref.h	/^    inline Ref(const PlainObjectBase<Derived>& expr,$/;"	p	class:Eigen::Ref	access:private	signature:(const PlainObjectBase<Derived>& expr, typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
Eigen::Ref::Ref	src/Core/Ref.h	/^    inline Ref(const Ref& other) : Base(other) {$/;"	f	class:Eigen::Ref	access:public	signature:(const Ref& other)
Eigen::Ref::Ref	src/Core/Ref.h	/^    inline Ref(const RefBase<OtherRef>& other) {$/;"	f	class:Eigen::Ref	access:public	signature:(const RefBase<OtherRef>& other)
Eigen::Ref::Traits	src/Core/Ref.h	/^    typedef internal::traits<Ref> Traits;$/;"	t	class:Eigen::Ref	access:private
Eigen::Ref::construct	src/Core/Ref.h	/^    void construct(const Expression& expr, internal::false_type)$/;"	f	class:Eigen::Ref	access:protected	signature:(const Expression& expr, internal::false_type)
Eigen::Ref::construct	src/Core/Ref.h	/^    void construct(const Expression& expr,internal::true_type)$/;"	f	class:Eigen::Ref	access:protected	signature:(const Expression& expr,internal::true_type)
Eigen::Ref::m_object	src/Core/Ref.h	/^    TPlainObjectType m_object;$/;"	m	class:Eigen::Ref	access:protected
Eigen::RefBase	src/Core/Ref.h	/^template<typename Derived> class RefBase$/;"	c	namespace:Eigen	inherits:MapBase
Eigen::RefBase::Base	src/Core/Ref.h	/^  typedef MapBase<Derived> Base;$/;"	t	class:Eigen::RefBase	access:public
Eigen::RefBase::PlainObjectType	src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::PlainObjectType PlainObjectType;$/;"	t	class:Eigen::RefBase	access:private
Eigen::RefBase::RefBase	src/Core/Ref.h	/^  RefBase()$/;"	f	class:Eigen::RefBase	access:public	signature:()
Eigen::RefBase::StrideBase	src/Core/Ref.h	/^  typedef Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime> StrideBase;$/;"	t	class:Eigen::RefBase	access:protected
Eigen::RefBase::StrideType	src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::StrideType StrideType;$/;"	t	class:Eigen::RefBase	access:private
Eigen::RefBase::construct	src/Core/Ref.h	/^  void construct(Expression& expr)$/;"	f	class:Eigen::RefBase	access:protected	signature:(Expression& expr)
Eigen::RefBase::innerStride	src/Core/Ref.h	/^  inline Index innerStride() const$/;"	f	class:Eigen::RefBase	access:public	signature:() const
Eigen::RefBase::m_stride	src/Core/Ref.h	/^  StrideBase m_stride;$/;"	m	class:Eigen::RefBase	access:protected
Eigen::RefBase::outerStride	src/Core/Ref.h	/^  inline Index outerStride() const$/;"	f	class:Eigen::RefBase	access:public	signature:() const
Eigen::Replicate	src/Core/Replicate.h	/^template<typename MatrixType,int RowFactor,int ColFactor> class Replicate$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::Replicate::Base	src/Core/Replicate.h	/^    typedef typename internal::dense_xpr_base<Replicate>::type Base;$/;"	t	class:Eigen::Replicate	access:public
Eigen::Replicate::MatrixTypeNested	src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::Replicate	access:private
Eigen::Replicate::Replicate	src/Core/Replicate.h	/^    inline Replicate(const OriginalMatrixType& a_matrix, Index rowFactor, Index colFactor)$/;"	f	class:Eigen::Replicate	access:public	signature:(const OriginalMatrixType& a_matrix, Index rowFactor, Index colFactor)
Eigen::Replicate::Replicate	src/Core/Replicate.h	/^    inline explicit Replicate(const OriginalMatrixType& a_matrix)$/;"	f	class:Eigen::Replicate	access:public	signature:(const OriginalMatrixType& a_matrix)
Eigen::Replicate::_MatrixTypeNested	src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::Replicate	access:private
Eigen::Replicate::coeff	src/Core/Replicate.h	/^    inline Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::Replicate	access:public	signature:(Index rowId, Index colId) const
Eigen::Replicate::cols	src/Core/Replicate.h	/^    inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }$/;"	f	class:Eigen::Replicate	access:public	signature:() const
Eigen::Replicate::m_colFactor	src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;$/;"	m	class:Eigen::Replicate	access:protected
Eigen::Replicate::m_matrix	src/Core/Replicate.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::Replicate	access:protected
Eigen::Replicate::m_rowFactor	src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;$/;"	m	class:Eigen::Replicate	access:protected
Eigen::Replicate::nestedExpression	src/Core/Replicate.h	/^    const _MatrixTypeNested& nestedExpression() const$/;"	f	class:Eigen::Replicate	access:public	signature:() const
Eigen::Replicate::packet	src/Core/Replicate.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::Replicate	access:public	signature:(Index rowId, Index colId) const
Eigen::Replicate::rows	src/Core/Replicate.h	/^    inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }$/;"	f	class:Eigen::Replicate	access:public	signature:() const
Eigen::ReturnByValue	src/Core/ReturnByValue.h	/^template<typename Derived> class ReturnByValue$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
Eigen::ReturnByValue::Base	src/Core/ReturnByValue.h	/^    typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;$/;"	t	class:Eigen::ReturnByValue	access:public
Eigen::ReturnByValue::ReturnType	src/Core/ReturnByValue.h	/^    typedef typename internal::traits<Derived>::ReturnType ReturnType;$/;"	t	class:Eigen::ReturnByValue	access:public
Eigen::ReturnByValue::Unusable	src/Core/ReturnByValue.h	/^    class Unusable{$/;"	c	class:Eigen::ReturnByValue	access:public
Eigen::ReturnByValue::Unusable::Unusable	src/Core/ReturnByValue.h	/^      Unusable(const Unusable&) {}$/;"	f	class:Eigen::ReturnByValue::Unusable	access:private	signature:(const Unusable&)
Eigen::ReturnByValue::Unusable::operator =	src/Core/ReturnByValue.h	/^      Unusable& operator=(const Unusable&) {return *this;}$/;"	f	class:Eigen::ReturnByValue::Unusable	access:private	signature:(const Unusable&)
Eigen::ReturnByValue::coeff	src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index) const
Eigen::ReturnByValue::coeff	src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index,Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index,Index) const
Eigen::ReturnByValue::coeffRef	src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index)
Eigen::ReturnByValue::coeffRef	src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index,Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index,Index)
Eigen::ReturnByValue::cols	src/Core/ReturnByValue.h	/^    inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:() const
Eigen::ReturnByValue::evalTo	src/Core/ReturnByValue.h	/^    inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Dest& dst) const
Eigen::ReturnByValue::packet	src/Core/ReturnByValue.h	/^    template<int LoadMode>  Unusable& packet(Index) const;$/;"	p	class:Eigen::ReturnByValue	access:public	signature:(Index) const
Eigen::ReturnByValue::packet	src/Core/ReturnByValue.h	/^    template<int LoadMode>  Unusable& packet(Index, Index) const;$/;"	p	class:Eigen::ReturnByValue	access:public	signature:(Index, Index) const
Eigen::ReturnByValue::rows	src/Core/ReturnByValue.h	/^    inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:() const
Eigen::Reverse	src/Core/Reverse.h	/^template<typename MatrixType, int Direction> class Reverse$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::Reverse::Base	src/Core/Reverse.h	/^    typedef typename internal::dense_xpr_base<Reverse>::type Base;$/;"	t	class:Eigen::Reverse	access:public
Eigen::Reverse::IsColMajor	src/Core/Reverse.h	/^      IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::Reverse::__anon312
Eigen::Reverse::OffsetCol	src/Core/Reverse.h	/^      OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon312
Eigen::Reverse::OffsetRow	src/Core/Reverse.h	/^      OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon312
Eigen::Reverse::PacketSize	src/Core/Reverse.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::Reverse::__anon312
Eigen::Reverse::Reverse	src/Core/Reverse.h	/^    inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }$/;"	f	class:Eigen::Reverse	access:public	signature:(const MatrixType& matrix)
Eigen::Reverse::ReverseCol	src/Core/Reverse.h	/^      ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon312
Eigen::Reverse::ReversePacket	src/Core/Reverse.h	/^      ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::Reverse::__anon312
Eigen::Reverse::ReverseRow	src/Core/Reverse.h	/^      ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon312
Eigen::Reverse::coeff	src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index) const
Eigen::Reverse::coeff	src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col) const
Eigen::Reverse::coeffRef	src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index)
Eigen::Reverse::coeffRef	src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col)
Eigen::Reverse::cols	src/Core/Reverse.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Reverse	access:public	signature:() const
Eigen::Reverse::innerStride	src/Core/Reverse.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Reverse	access:public	signature:() const
Eigen::Reverse::m_matrix	src/Core/Reverse.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Reverse	access:protected
Eigen::Reverse::nestedExpression	src/Core/Reverse.h	/^    nestedExpression() const $/;"	f	class:Eigen::Reverse	access:public	signature:() const
Eigen::Reverse::operator ()	src/Core/Reverse.h	/^    inline Scalar& operator()(Index index)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index)
Eigen::Reverse::operator ()	src/Core/Reverse.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col)
Eigen::Reverse::packet	src/Core/Reverse.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index) const
Eigen::Reverse::packet	src/Core/Reverse.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col) const
Eigen::Reverse::reverse_packet	src/Core/Reverse.h	/^    typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;$/;"	t	class:Eigen::Reverse	access:protected
Eigen::Reverse::rows	src/Core/Reverse.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Reverse	access:public	signature:() const
Eigen::Reverse::writePacket	src/Core/Reverse.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index, const PacketScalar& x)
Eigen::Reverse::writePacket	src/Core/Reverse.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::Rotation2D	src/Eigen2Support/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::Rotation2D	src/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::Rotation2D::Base	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D	access:private
Eigen::Rotation2D::Base	src/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D	access:private
Eigen::Rotation2D::Dim	src/Eigen2Support/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon343
Eigen::Rotation2D::Dim	src/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon379
Eigen::Rotation2D::Identity	src/Geometry/Rotation2D.h	/^  static inline Rotation2D Identity() { return Rotation2D(0); }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Eigen::Rotation2D::Matrix2	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::Matrix2	src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::Rotation2D	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D(Scalar a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar a)
Eigen::Rotation2D::Rotation2D	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D<OtherScalarType>& other)
Eigen::Rotation2D::Rotation2D	src/Geometry/Rotation2D.h	/^  Rotation2D() {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Eigen::Rotation2D::Rotation2D	src/Geometry/Rotation2D.h	/^  inline Rotation2D(const Scalar& a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Scalar& a)
Eigen::Rotation2D::Rotation2D	src/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D<OtherScalarType>& other)
Eigen::Rotation2D::Scalar	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::Scalar	src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::Vector2	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::Vector2	src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::angle	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::angle	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Eigen::Rotation2D::angle	src/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::angle	src/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Eigen::Rotation2D::cast	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::cast	src/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::fromRotationMatrix	src/Eigen2Support/Geometry/Rotation2D.h	/^  Rotation2D& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Rotation2D	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::Rotation2D::fromRotationMatrix	src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D	signature:(const MatrixBase<Derived>& mat)
Eigen::Rotation2D::fromRotationMatrix	src/Geometry/Rotation2D.h	/^  Rotation2D& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Rotation2D	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::Rotation2D::fromRotationMatrix	src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D	signature:(const MatrixBase<Derived>& mat)
Eigen::Rotation2D::inverse	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::inverse	src/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::isApprox	src/Eigen2Support/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Rotation2D::isApprox	src/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::Rotation2D::m_angle	src/Eigen2Support/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D	access:protected
Eigen::Rotation2D::m_angle	src/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D	access:protected
Eigen::Rotation2D::operator *	src/Eigen2Support/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Vector2& vec) const
Eigen::Rotation2D::operator *	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other) const
Eigen::Rotation2D::operator *	src/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Vector2& vec) const
Eigen::Rotation2D::operator *	src/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other) const
Eigen::Rotation2D::operator *=	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other)
Eigen::Rotation2D::operator *=	src/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other)
Eigen::Rotation2D::slerp	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(Scalar t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar t, const Rotation2D& other) const
Eigen::Rotation2D::slerp	src/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(const Scalar& t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Scalar& t, const Rotation2D& other) const
Eigen::Rotation2D::toRotationMatrix	src/Eigen2Support/Geometry/Rotation2D.h	/^  Matrix2 toRotationMatrix(void) const;$/;"	p	class:Eigen::Rotation2D	access:public	signature:(void) const
Eigen::Rotation2D::toRotationMatrix	src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D	signature:(void) const
Eigen::Rotation2D::toRotationMatrix	src/Geometry/Rotation2D.h	/^  Matrix2 toRotationMatrix() const;$/;"	p	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::toRotationMatrix	src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D	signature:(void) const
Eigen::Rotation2Dd	src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Eigen::Rotation2Dd	src/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Eigen::Rotation2Df	src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
Eigen::Rotation2Df	src/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
Eigen::RotationBase	src/Eigen2Support/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
Eigen::RotationBase	src/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
Eigen::RotationBase::Dim	src/Eigen2Support/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon344
Eigen::RotationBase::Dim	src/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon380
Eigen::RotationBase::RotationMatrixType	src/Eigen2Support/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RotationBase::RotationMatrixType	src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RotationBase::Scalar	src/Eigen2Support/Geometry/RotationBase.h	/^    typedef typename ei_traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RotationBase::Scalar	src/Geometry/RotationBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RotationBase::VectorType	src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RotationBase::_transformVector	src/Geometry/RotationBase.h	/^    inline VectorType _transformVector(const OtherVectorType& v) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const OtherVectorType& v) const
Eigen::RotationBase::derived	src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:()
Eigen::RotationBase::derived	src/Eigen2Support/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::derived	src/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:()
Eigen::RotationBase::derived	src/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::inverse	src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::inverse	src/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::matrix	src/Geometry/RotationBase.h	/^    inline RotationMatrixType matrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::operator *	src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const Scaling<Scalar,Dim>& s) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Scaling<Scalar,Dim>& s) const
Eigen::RotationBase::operator *	src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Transform<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Transform<Scalar,Dim>& t) const
Eigen::RotationBase::operator *	src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Translation<Scalar,Dim>& t) const
Eigen::RotationBase::operator *	src/Geometry/RotationBase.h	/^    friend inline Transform<Scalar,Dim,Affine> operator*(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase	access:friend	signature:(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)
Eigen::RotationBase::operator *	src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const EigenBase<OtherDerived>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase	access:friend	signature:(const EigenBase<OtherDerived>& l, const Derived& r)
Eigen::RotationBase::operator *	src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const UniformScaling<Scalar>& s) const
Eigen::RotationBase::operator *	src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Isometry> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Translation<Scalar,Dim>& t) const
Eigen::RotationBase::operator *	src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Mode> operator*(const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Transform<Scalar,Dim,Mode,Options>& t) const
Eigen::RotationBase::operator *	src/Geometry/RotationBase.h	/^    operator*(const EigenBase<OtherDerived>& e) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const EigenBase<OtherDerived>& e) const
Eigen::RotationBase::toRotationMatrix	src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::toRotationMatrix	src/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RowMajor	src/Core/util/Constants.h	/^  RowMajor = 0x1,  \/\/ it is only a coincidence that this is equal to RowMajorBit -- don't rely on that$/;"	e	enum:Eigen::__anon66
Eigen::RowMajorBit	src/Core/util/Constants.h	/^const unsigned int RowMajorBit = 0x1;$/;"	m	namespace:Eigen
Eigen::SPQR	src/SPQRSupport/SuiteSparseQRSupport.h	/^class SPQR$/;"	c	namespace:Eigen
Eigen::SPQR::Index	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SuiteSparse_long Index ;$/;"	t	class:Eigen::SPQR	access:public
Eigen::SPQR::MatrixType	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor, Index> MatrixType;$/;"	t	class:Eigen::SPQR	access:public
Eigen::SPQR::PermutationType	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef PermutationMatrix<Dynamic, Dynamic> PermutationType;$/;"	t	class:Eigen::SPQR	access:public
Eigen::SPQR::RealScalar	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SPQR	access:public
Eigen::SPQR::SPQR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQR() $/;"	f	class:Eigen::SPQR	access:public	signature:()
Eigen::SPQR::SPQR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQR(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR	access:public	signature:(const _MatrixType& matrix)
Eigen::SPQR::SPQR_free	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void SPQR_free()$/;"	f	class:Eigen::SPQR	access:public	signature:()
Eigen::SPQR::Scalar	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SPQR	access:public
Eigen::SPQR::_solve	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SPQR	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::SPQR::cholmodCommon	src/SPQRSupport/SuiteSparseQRSupport.h	/^    cholmod_common *cholmodCommon() const { return &m_cc; }$/;"	f	class:Eigen::SPQR	access:public	signature:() const
Eigen::SPQR::cols	src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index cols() const { return m_cR->ncol; }$/;"	f	class:Eigen::SPQR	access:public	signature:() const
Eigen::SPQR::colsPermutation	src/SPQRSupport/SuiteSparseQRSupport.h	/^    PermutationType colsPermutation() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
Eigen::SPQR::compute	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void compute(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR	access:public	signature:(const _MatrixType& matrix)
Eigen::SPQR::info	src/SPQRSupport/SuiteSparseQRSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
Eigen::SPQR::m_E	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index *m_E; \/\/ The permutation applied to columns$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_H	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_H;  \/\/The householder vectors$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_HPinv	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index *m_HPinv; \/\/ The row permutation of H$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_HTau	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_dense *m_HTau; \/\/ The Householder coefficients$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_R	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable MatrixType m_R; \/\/ The sparse matrix R in Eigen format$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_allow_tol	src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_allow_tol; \/\/ Allow to use some tolerance during numerical factorization.$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_analysisIsOk	src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_cR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_cR; \/\/ The sparse R factor in cholmod format$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_cc	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_common m_cc; \/\/ Workspace and parameters$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_factorizationIsOk	src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_info	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_isInitialized	src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_isRUpToDate	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable bool m_isRUpToDate;$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_ordering	src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_ordering; \/\/ Ordering method to use, see SPQR's manual$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_rank	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index m_rank; \/\/ The rank of the matrix$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_tolerance	src/SPQRSupport/SuiteSparseQRSupport.h	/^    RealScalar m_tolerance; \/\/ treat columns with 2-norm below this tolerance as zero$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::m_useDefaultThreshold	src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SPQR	access:protected
Eigen::SPQR::matrixQ	src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQRMatrixQReturnType<SPQR> matrixQ() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
Eigen::SPQR::matrixR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    const MatrixType matrixR() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
Eigen::SPQR::rank	src/SPQRSupport/SuiteSparseQRSupport.h	/^    Index rank() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
Eigen::SPQR::rows	src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index rows() const {return m_cR->nrow; }$/;"	f	class:Eigen::SPQR	access:public	signature:() const
Eigen::SPQR::setPivotThreshold	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setPivotThreshold(const RealScalar& tol)$/;"	f	class:Eigen::SPQR	access:public	signature:(const RealScalar& tol)
Eigen::SPQR::setSPQROrdering	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setSPQROrdering(int ord) { m_ordering = ord;}$/;"	f	class:Eigen::SPQR	access:public	signature:(int ord)
Eigen::SPQR::solve	src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline const internal::solve_retval<SPQR, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SPQR	access:public	signature:(const MatrixBase<Rhs>& B) const
Eigen::SPQR::~SPQR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    ~SPQR()$/;"	f	class:Eigen::SPQR	access:public	signature:()
Eigen::SPQRMatrixQReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQReturnType{$/;"	s	namespace:Eigen
Eigen::SPQRMatrixQReturnType::SPQRMatrixQReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQReturnType	access:public	signature:(const SPQRType& spqr)
Eigen::SPQRMatrixQReturnType::adjoint	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> adjoint() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType	access:public	signature:() const
Eigen::SPQRMatrixQReturnType::m_spqr	src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQReturnType	access:public
Eigen::SPQRMatrixQReturnType::operator *	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQReturnType	access:public	signature:(const MatrixBase<Derived>& other)
Eigen::SPQRMatrixQReturnType::transpose	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> transpose() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType	access:public	signature:() const
Eigen::SPQRMatrixQTransposeReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQTransposeReturnType{$/;"	s	namespace:Eigen
Eigen::SPQRMatrixQTransposeReturnType::SPQRMatrixQTransposeReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType	access:public	signature:(const SPQRType& spqr)
Eigen::SPQRMatrixQTransposeReturnType::m_spqr	src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQTransposeReturnType	access:public
Eigen::SPQRMatrixQTransposeReturnType::operator *	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType	access:public	signature:(const MatrixBase<Derived>& other)
Eigen::SPQR_QProduct	src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQR_QProduct : ReturnByValue<SPQR_QProduct<SPQRType,Derived> >$/;"	s	namespace:Eigen	inherits:ReturnByValue
Eigen::SPQR_QProduct::Index	src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::Index Index;$/;"	t	struct:Eigen::SPQR_QProduct	access:public
Eigen::SPQR_QProduct::SPQR_QProduct	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct(const SPQRType& spqr, const Derived& other, bool transpose) : m_spqr(spqr),m_other(other),m_transpose(transpose) {}$/;"	f	struct:Eigen::SPQR_QProduct	access:public	signature:(const SPQRType& spqr, const Derived& other, bool transpose)
Eigen::SPQR_QProduct::Scalar	src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::Scalar Scalar;$/;"	t	struct:Eigen::SPQR_QProduct	access:public
Eigen::SPQR_QProduct::cols	src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct	access:public	signature:() const
Eigen::SPQR_QProduct::evalTo	src/SPQRSupport/SuiteSparseQRSupport.h	/^  void evalTo(ResType& res) const$/;"	f	struct:Eigen::SPQR_QProduct	access:public	signature:(ResType& res) const
Eigen::SPQR_QProduct::m_other	src/SPQRSupport/SuiteSparseQRSupport.h	/^  const Derived& m_other; $/;"	m	struct:Eigen::SPQR_QProduct	access:public
Eigen::SPQR_QProduct::m_spqr	src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr; $/;"	m	struct:Eigen::SPQR_QProduct	access:public
Eigen::SPQR_QProduct::m_transpose	src/SPQRSupport/SuiteSparseQRSupport.h	/^  bool m_transpose; $/;"	m	struct:Eigen::SPQR_QProduct	access:public
Eigen::SPQR_QProduct::rows	src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index rows() const { return m_transpose ? m_spqr.rows() : m_spqr.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct	access:public	signature:() const
Eigen::SVD	src/Eigen2Support/SVD.h	/^template<typename MatrixType> class SVD$/;"	c	namespace:Eigen
Eigen::SVD::AlignmentMask	src/Eigen2Support/SVD.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::SVD::__anon359
Eigen::SVD::ColVector	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> ColVector;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::MatrixUType	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, MinSize> MatrixUType;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::MatrixVType	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixVType;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::MinSize	src/Eigen2Support/SVD.h	/^      MinSize = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime)$/;"	e	enum:Eigen::SVD::__anon359
Eigen::SVD::PacketSize	src/Eigen2Support/SVD.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::SVD::__anon359
Eigen::SVD::RealScalar	src/Eigen2Support/SVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::RowVector	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, 1> RowVector;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::SVD	src/Eigen2Support/SVD.h	/^    SVD() {} \/\/ a user who relied on compiler-generated default compiler reported problems with MSVC in 2.0.7$/;"	f	class:Eigen::SVD	access:public	signature:()
Eigen::SVD::SVD	src/Eigen2Support/SVD.h	/^    SVD(const MatrixType& matrix)$/;"	f	class:Eigen::SVD	access:public	signature:(const MatrixType& matrix)
Eigen::SVD::Scalar	src/Eigen2Support/SVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::SingularValuesType	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MinSize, 1> SingularValuesType;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::compute	src/Eigen2Support/SVD.h	/^    void compute(const MatrixType& matrix);$/;"	p	class:Eigen::SVD	access:public	signature:(const MatrixType& matrix)
Eigen::SVD::compute	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::SVD	signature:(const MatrixType& matrix)
Eigen::SVD::computePositiveUnitary	src/Eigen2Support/SVD.h	/^    void computePositiveUnitary(PositiveType *positive, UnitaryType *unitary) const;$/;"	p	class:Eigen::SVD	access:public	signature:(PositiveType *positive, UnitaryType *unitary) const
Eigen::SVD::computePositiveUnitary	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computePositiveUnitary(UnitaryType *positive,$/;"	f	class:Eigen::SVD	signature:(UnitaryType *positive, PositiveType *unitary) const
Eigen::SVD::computeRotationScaling	src/Eigen2Support/SVD.h	/^    void computeRotationScaling(RotationType *unitary, ScalingType *positive) const;$/;"	p	class:Eigen::SVD	access:public	signature:(RotationType *unitary, ScalingType *positive) const
Eigen::SVD::computeRotationScaling	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeRotationScaling(RotationType *rotation, ScalingType *scaling) const$/;"	f	class:Eigen::SVD	signature:(RotationType *rotation, ScalingType *scaling) const
Eigen::SVD::computeScalingRotation	src/Eigen2Support/SVD.h	/^    void computeScalingRotation(ScalingType *positive, RotationType *unitary) const;$/;"	p	class:Eigen::SVD	access:public	signature:(ScalingType *positive, RotationType *unitary) const
Eigen::SVD::computeScalingRotation	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeScalingRotation(ScalingType *scaling, RotationType *rotation) const$/;"	f	class:Eigen::SVD	signature:(ScalingType *scaling, RotationType *rotation) const
Eigen::SVD::computeUnitaryPositive	src/Eigen2Support/SVD.h	/^    void computeUnitaryPositive(UnitaryType *unitary, PositiveType *positive) const;$/;"	p	class:Eigen::SVD	access:public	signature:(UnitaryType *unitary, PositiveType *positive) const
Eigen::SVD::computeUnitaryPositive	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeUnitaryPositive(UnitaryType *unitary,$/;"	f	class:Eigen::SVD	signature:(UnitaryType *unitary, PositiveType *positive) const
Eigen::SVD::m_matU	src/Eigen2Support/SVD.h	/^    MatrixUType m_matU;$/;"	m	class:Eigen::SVD	access:protected
Eigen::SVD::m_matV	src/Eigen2Support/SVD.h	/^    MatrixVType m_matV;$/;"	m	class:Eigen::SVD	access:protected
Eigen::SVD::m_sigma	src/Eigen2Support/SVD.h	/^    SingularValuesType m_sigma;$/;"	m	class:Eigen::SVD	access:protected
Eigen::SVD::matrixU	src/Eigen2Support/SVD.h	/^    const MatrixUType& matrixU() const { return m_matU; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
Eigen::SVD::matrixV	src/Eigen2Support/SVD.h	/^    const MatrixVType& matrixV() const { return m_matV; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
Eigen::SVD::singularValues	src/Eigen2Support/SVD.h	/^    const SingularValuesType& singularValues() const { return m_sigma; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
Eigen::SVD::solve	src/Eigen2Support/SVD.h	/^    bool solve(const MatrixBase<OtherDerived> &b, ResultType* result) const;$/;"	p	class:Eigen::SVD	access:public	signature:(const MatrixBase<OtherDerived> &b, ResultType* result) const
Eigen::SVD::solve	src/Eigen2Support/SVD.h	/^bool SVD<MatrixType>::solve(const MatrixBase<OtherDerived> &b, ResultType* result) const$/;"	f	class:Eigen::SVD	signature:(const MatrixBase<OtherDerived> &b, ResultType* result) const
Eigen::SVD::sort	src/Eigen2Support/SVD.h	/^    SVD& sort();$/;"	p	class:Eigen::SVD	access:public	signature:()
Eigen::SVD::sort	src/Eigen2Support/SVD.h	/^SVD<MatrixType>& SVD<MatrixType>::sort()$/;"	f	class:Eigen::SVD	signature:()
Eigen::Scaling	src/Eigen2Support/Geometry/Scaling.h	/^class Scaling$/;"	c	namespace:Eigen
Eigen::Scaling	src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,2> Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	namespace:Eigen	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Scaling	src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,3> Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	namespace:Eigen	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Eigen::Scaling	src/Geometry/Scaling.h	/^static inline UniformScaling<double> Scaling(double s) { return UniformScaling<double>(s); }$/;"	f	namespace:Eigen	signature:(double s)
Eigen::Scaling	src/Geometry/Scaling.h	/^static inline UniformScaling<float> Scaling(float s) { return UniformScaling<float>(s); }$/;"	f	namespace:Eigen	signature:(float s)
Eigen::Scaling	src/Geometry/Scaling.h	/^static inline UniformScaling<std::complex<RealScalar> > Scaling(const std::complex<RealScalar>& s)$/;"	f	namespace:Eigen	signature:(const std::complex<RealScalar>& s)
Eigen::Scaling	src/Geometry/Scaling.h	/^static inline const DiagonalWrapper<const Derived> Scaling(const MatrixBase<Derived>& coeffs)$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& coeffs)
Eigen::Scaling2d	src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,2> Scaling2d;$/;"	t	namespace:Eigen
Eigen::Scaling2f	src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 2> Scaling2f;$/;"	t	namespace:Eigen
Eigen::Scaling3d	src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,3> Scaling3d;$/;"	t	namespace:Eigen
Eigen::Scaling3f	src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 3> Scaling3f;$/;"	t	namespace:Eigen
Eigen::Scaling::Dim	src/Eigen2Support/Geometry/Scaling.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Scaling::__anon345
Eigen::Scaling::LinearMatrixType	src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Scaling	access:public
Eigen::Scaling::Scalar	src/Eigen2Support/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Scaling	access:public
Eigen::Scaling::Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  Scaling() {}$/;"	f	class:Eigen::Scaling	access:public	signature:()
Eigen::Scaling::Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const Scalar& s) { m_coeffs.setConstant(s); }$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& s)
Eigen::Scaling::Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const VectorType& coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Scaling	access:public	signature:(const VectorType& coeffs)
Eigen::Scaling::Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Scaling::Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Eigen::Scaling::Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  inline explicit Scaling(const Scaling<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling<OtherScalarType,Dim>& other)
Eigen::Scaling::TransformType	src/Eigen2Support/Geometry/Scaling.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Scaling	access:public
Eigen::Scaling::TranslationType	src/Eigen2Support/Geometry/Scaling.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Scaling	access:public
Eigen::Scaling::VectorType	src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Scaling	access:public
Eigen::Scaling::cast	src/Eigen2Support/Geometry/Scaling.h	/^  inline typename internal::cast_return_type<Scaling,Scaling<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Scaling	access:public	signature:() const
Eigen::Scaling::coeffs	src/Eigen2Support/Geometry/Scaling.h	/^  VectorType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Scaling	access:public	signature:()
Eigen::Scaling::coeffs	src/Eigen2Support/Geometry/Scaling.h	/^  const VectorType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Scaling	access:public	signature:() const
Eigen::Scaling::inverse	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling inverse() const$/;"	f	class:Eigen::Scaling	access:public	signature:() const
Eigen::Scaling::isApprox	src/Eigen2Support/Geometry/Scaling.h	/^  bool isApprox(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Scaling::m_coeffs	src/Eigen2Support/Geometry/Scaling.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Scaling	access:protected
Eigen::Scaling::operator *	src/Eigen2Support/Geometry/Scaling.h	/^  friend inline LinearMatrixType operator* (const LinearMatrixType& other, const Scaling& s)$/;"	f	class:Eigen::Scaling	access:friend	signature:(const LinearMatrixType& other, const Scaling& s)
Eigen::Scaling::operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator* (const LinearMatrixType& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const LinearMatrixType& other) const
Eigen::Scaling::operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Scaling::operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling operator* (const Scaling& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other) const
Eigen::Scaling::operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline TransformType operator* (const TransformType& t) const;$/;"	p	class:Eigen::Scaling	access:public	signature:(const TransformType& t) const
Eigen::Scaling::operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline TransformType operator* (const TranslationType& t) const;$/;"	p	class:Eigen::Scaling	access:public	signature:(const TranslationType& t) const
Eigen::Scaling::operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const VectorType& other) const
Eigen::Scaling::operator *	src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Scaling	signature:(const TransformType& t) const
Eigen::Scaling::operator *	src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TranslationType& t) const$/;"	f	class:Eigen::Scaling	signature:(const TranslationType& t) const
Eigen::Scaling::operator =	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling& operator=(const Scaling& other)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other)
Eigen::Select	src/Core/Select.h	/^class Select : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
Eigen::Select::Base	src/Core/Select.h	/^    typedef typename internal::dense_xpr_base<Select>::type Base;$/;"	t	class:Eigen::Select	access:public
Eigen::Select::Select	src/Core/Select.h	/^    Select(const ConditionMatrixType& a_conditionMatrix,$/;"	f	class:Eigen::Select	access:public	signature:(const ConditionMatrixType& a_conditionMatrix, const ThenMatrixType& a_thenMatrix, const ElseMatrixType& a_elseMatrix)
Eigen::Select::coeff	src/Core/Select.h	/^    const Scalar coeff(Index i) const$/;"	f	class:Eigen::Select	access:public	signature:(Index i) const
Eigen::Select::coeff	src/Core/Select.h	/^    const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::Select	access:public	signature:(Index i, Index j) const
Eigen::Select::cols	src/Core/Select.h	/^    Index cols() const { return m_condition.cols(); }$/;"	f	class:Eigen::Select	access:public	signature:() const
Eigen::Select::conditionMatrix	src/Core/Select.h	/^    const ConditionMatrixType& conditionMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
Eigen::Select::elseMatrix	src/Core/Select.h	/^    const ElseMatrixType& elseMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
Eigen::Select::m_condition	src/Core/Select.h	/^    typename ConditionMatrixType::Nested m_condition;$/;"	m	class:Eigen::Select	access:protected
Eigen::Select::m_else	src/Core/Select.h	/^    typename ElseMatrixType::Nested m_else;$/;"	m	class:Eigen::Select	access:protected
Eigen::Select::m_then	src/Core/Select.h	/^    typename ThenMatrixType::Nested m_then;$/;"	m	class:Eigen::Select	access:protected
Eigen::Select::rows	src/Core/Select.h	/^    Index rows() const { return m_condition.rows(); }$/;"	f	class:Eigen::Select	access:public	signature:() const
Eigen::Select::thenMatrix	src/Core/Select.h	/^    const ThenMatrixType& thenMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
Eigen::SelfAdjoint	src/Core/util/Constants.h	/^  SelfAdjoint=0x10,$/;"	e	enum:Eigen::__anon61
Eigen::SelfAdjointBit	src/Eigen2Support/TriangularSolver.h	/^const unsigned int SelfAdjointBit = SelfAdjoint;$/;"	m	namespace:Eigen
Eigen::SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename _MatrixType> class SelfAdjointEigenSolver$/;"	c	namespace:Eigen
Eigen::SelfAdjointEigenSolver::ColsAtCompileTime	src/Eigenvalues/SelfAdjointEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon367
Eigen::SelfAdjointEigenSolver::EigenvectorsType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Matrix<Scalar,Size,Size,ColMajor,MaxColsAtCompileTime,MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::Index	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::MatrixType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::MaxColsAtCompileTime	src/Eigenvalues/SelfAdjointEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon367
Eigen::SelfAdjointEigenSolver::Options	src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon367
Eigen::SelfAdjointEigenSolver::RealScalar	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::RealVectorType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::Scalar	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver()$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:()
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(Index size)
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors)
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, int options = ComputeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
Eigen::SelfAdjointEigenSolver::Size	src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon367
Eigen::SelfAdjointEigenSolver::TridiagonalizationType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Tridiagonalization<MatrixType> TridiagonalizationType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::check_template_parameters	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:protected	signature:()
Eigen::SelfAdjointEigenSolver::compute	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver& compute(const MatrixType& matrix, int options = ComputeEigenvectors);$/;"	p	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
Eigen::SelfAdjointEigenSolver::compute	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)
Eigen::SelfAdjointEigenSolver::compute	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors)
Eigen::SelfAdjointEigenSolver::compute	src/Eigenvalues/SelfAdjointEigenSolver.h	/^::compute(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver	signature:(const MatrixType& matrix, int options)
Eigen::SelfAdjointEigenSolver::computeDirect	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver& computeDirect(const MatrixType& matrix, int options = ComputeEigenvectors);$/;"	p	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
Eigen::SelfAdjointEigenSolver::computeDirect	src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeDirect(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver	signature:(const MatrixType& matrix, int options)
Eigen::SelfAdjointEigenSolver::eigenvalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const RealVectorType& eigenvalues() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
Eigen::SelfAdjointEigenSolver::eigenvectors	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const EigenvectorsType& eigenvectors() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
Eigen::SelfAdjointEigenSolver::info	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
Eigen::SelfAdjointEigenSolver::m_eigenvectorsOk	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_eivalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    RealVectorType m_eivalues;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_eivec	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    EigenvectorsType m_eivec;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_info	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_isInitialized	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_maxIterations	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::m_subdiag	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typename TridiagonalizationType::SubDiagonalType m_subdiag;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::operatorInverseSqrt	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorInverseSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
Eigen::SelfAdjointEigenSolver::operatorSqrt	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
Eigen::SelfAdjointView	src/Core/SelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SelfAdjointView$/;"	c	namespace:Eigen	inherits:TriangularBase
Eigen::SelfAdjointView::Base	src/Core/SelfAdjointView.h	/^    typedef TriangularBase<SelfAdjointView> Base;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::EigenvaluesReturnType	src/Core/SelfAdjointView.h	/^    typedef Matrix<RealScalar, internal::traits<MatrixType>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::Index	src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::MatrixTypeNested	src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::MatrixTypeNestedCleaned	src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::Mode	src/Core/SelfAdjointView.h	/^      Mode = internal::traits<SelfAdjointView>::Mode$/;"	e	enum:Eigen::SelfAdjointView::__anon315
Eigen::SelfAdjointView::PlainObject	src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::RealScalar	src/Core/SelfAdjointView.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::Scalar	src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar; $/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::SelfAdjointView	src/Core/SelfAdjointView.h	/^    inline SelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(MatrixType& matrix)
Eigen::SelfAdjointView::_expression	src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& _expression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::coeff	src/Core/SelfAdjointView.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(Index row, Index col) const
Eigen::SelfAdjointView::coeffRef	src/Core/SelfAdjointView.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(Index row, Index col)
Eigen::SelfAdjointView::cols	src/Core/SelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::eigenvalues	src/Core/SelfAdjointView.h	/^    EigenvaluesReturnType eigenvalues() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::eigenvalues	src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::eigenvalues() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
Eigen::SelfAdjointView::innerStride	src/Core/SelfAdjointView.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::ldlt	src/Cholesky/LDLT.h	/^SelfAdjointView<MatrixType, UpLo>::ldlt() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
Eigen::SelfAdjointView::ldlt	src/Core/SelfAdjointView.h	/^    const LDLT<PlainObject, UpLo> ldlt() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::llt	src/Cholesky/LLT.h	/^SelfAdjointView<MatrixType, UpLo>::llt() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
Eigen::SelfAdjointView::llt	src/Core/SelfAdjointView.h	/^    const LLT<PlainObject, UpLo> llt() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::m_matrix	src/Core/SelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SelfAdjointView	access:protected
Eigen::SelfAdjointView::nestedExpression	src/Core/SelfAdjointView.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:()
Eigen::SelfAdjointView::nestedExpression	src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::operator *	src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)$/;"	f	class:Eigen::SelfAdjointView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)
Eigen::SelfAdjointView::operator *	src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
Eigen::SelfAdjointView::operator =	src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::SelfAdjointView::operator =	src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const TriangularView<OtherMatrixType, OtherMode>& other)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const TriangularView<OtherMatrixType, OtherMode>& other)
Eigen::SelfAdjointView::operatorNorm	src/Core/SelfAdjointView.h	/^    RealScalar operatorNorm() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::operatorNorm	src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::operatorNorm() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
Eigen::SelfAdjointView::outerStride	src/Core/SelfAdjointView.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::rankUpdate	src/Core/SelfAdjointView.h	/^    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha = Scalar(1));$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha = Scalar(1))
Eigen::SelfAdjointView::rankUpdate	src/Core/SelfAdjointView.h	/^    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, const Scalar& alpha = Scalar(1));$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<DerivedU>& u, const Scalar& alpha = Scalar(1))
Eigen::SelfAdjointView::rankUpdate	src/Core/products/SelfadjointProduct.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView	signature:(const MatrixBase<DerivedU>& u, const Scalar& alpha)
Eigen::SelfAdjointView::rankUpdate	src/Core/products/SelfadjointRank2Update.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView	signature:(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha)
Eigen::SelfAdjointView::rows	src/Core/SelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfCwiseBinaryOp	src/Core/SelfCwiseBinaryOp.h	/^template<typename BinaryOp, typename Lhs, typename Rhs> class SelfCwiseBinaryOp$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::SelfCwiseBinaryOp::Base	src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<SelfCwiseBinaryOp>::type Base;$/;"	t	class:Eigen::SelfCwiseBinaryOp	access:public
Eigen::SelfCwiseBinaryOp::Packet	src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SelfCwiseBinaryOp	access:public
Eigen::SelfCwiseBinaryOp::SelfCwiseBinaryOp	src/Core/SelfCwiseBinaryOp.h	/^    inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Lhs& xpr, const BinaryOp& func = BinaryOp())
Eigen::SelfCwiseBinaryOp::coeffRef	src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index)
Eigen::SelfCwiseBinaryOp::coeffRef	src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col)
Eigen::SelfCwiseBinaryOp::coeffRef	src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index) const
Eigen::SelfCwiseBinaryOp::coeffRef	src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col) const
Eigen::SelfCwiseBinaryOp::cols	src/Core/SelfCwiseBinaryOp.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::copyCoeff	src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::SelfCwiseBinaryOp::copyCoeff	src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::SelfCwiseBinaryOp::copyPacket	src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::SelfCwiseBinaryOp::copyPacket	src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::SelfCwiseBinaryOp::data	src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::expression	src/Core/SelfCwiseBinaryOp.h	/^    Lhs& expression() const $/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::functor	src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& functor() const $/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::innerStride	src/Core/SelfCwiseBinaryOp.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::lazyAssign	src/Core/SelfCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(const DenseBase<RhsDerived>& rhs)
Eigen::SelfCwiseBinaryOp::m_functor	src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::SelfCwiseBinaryOp	access:protected
Eigen::SelfCwiseBinaryOp::m_matrix	src/Core/SelfCwiseBinaryOp.h	/^    Lhs& m_matrix;$/;"	m	class:Eigen::SelfCwiseBinaryOp	access:protected
Eigen::SelfCwiseBinaryOp::operator =	src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const Rhs& _rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(const Rhs& _rhs)
Eigen::SelfCwiseBinaryOp::operator =	src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const SelfCwiseBinaryOp&);$/;"	p	class:Eigen::SelfCwiseBinaryOp	access:private	signature:(const SelfCwiseBinaryOp&)
Eigen::SelfCwiseBinaryOp::outerStride	src/Core/SelfCwiseBinaryOp.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::rows	src/Core/SelfCwiseBinaryOp.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixMatrix.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::SelfadjointProductMatrix::LhsIsSelfAdjoint	src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsSelfAdjoint = (LhsMode&SelfAdjoint)==SelfAdjoint,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon49
Eigen::SelfadjointProductMatrix::LhsIsUpper	src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsUpper = (LhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon49
Eigen::SelfadjointProductMatrix::LhsUpLo	src/Core/products/SelfadjointMatrixVector.h	/^    LhsUpLo = LhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon50
Eigen::SelfadjointProductMatrix::RhsIsSelfAdjoint	src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsSelfAdjoint = (RhsMode&SelfAdjoint)==SelfAdjoint$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon49
Eigen::SelfadjointProductMatrix::RhsIsUpper	src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsUpper = (RhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon49
Eigen::SelfadjointProductMatrix::RhsUpLo	src/Core/products/SelfadjointMatrixVector.h	/^    RhsUpLo = RhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon51
Eigen::SelfadjointProductMatrix::SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixMatrix.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SelfadjointProductMatrix::SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixVector.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SelfadjointProductMatrix::scaleAndAddTo	src/Core/products/SelfadjointMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(Dest& dst, const Scalar& alpha) const
Eigen::SelfadjointProductMatrix::scaleAndAddTo	src/Core/products/SelfadjointMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(Dest& dest, const Scalar& alpha) const
Eigen::Sequential	src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	e	enum:Eigen::Sequential_t
Eigen::Sequential_t	src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	g	namespace:Eigen
Eigen::SetAction	src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
Eigen::SimplicialCholesky	src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialCholesky : public SimplicialCholeskyBase<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
Eigen::SimplicialCholesky::Base	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialCholesky> Base;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::Index	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::LDLTTraits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT<MatrixType,UpLo> > LDLTTraits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::LLTTraits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT<MatrixType,UpLo>  > LLTTraits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::RealScalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::Scalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::SimplicialCholesky	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky() : Base(), m_LDLT(true) {}$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:()
Eigen::SimplicialCholesky::SimplicialCholesky	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialCholesky::Traits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialCholesky> Traits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::UpLo	src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialCholesky::__anon430
Eigen::SimplicialCholesky::VectorType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::_solve	src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::SimplicialCholesky::analyzePattern	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& a)
Eigen::SimplicialCholesky::compute	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialCholesky::determinant	src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
Eigen::SimplicialCholesky::factorize	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& a)
Eigen::SimplicialCholesky::m_LDLT	src/SparseCholesky/SimplicialCholesky.h	/^    bool m_LDLT;$/;"	m	class:Eigen::SimplicialCholesky	access:protected
Eigen::SimplicialCholesky::rawMatrix	src/SparseCholesky/SimplicialCholesky.h	/^    inline const CholMatrixType rawMatrix() const {$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
Eigen::SimplicialCholesky::setMode	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& setMode(SimplicialCholeskyMode mode)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(SimplicialCholeskyMode mode)
Eigen::SimplicialCholesky::vectorD	src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
Eigen::SimplicialCholeskyBase	src/SparseCholesky/SimplicialCholesky.h	/^class SimplicialCholeskyBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::SimplicialCholeskyBase::CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::Index	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::OrderingType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::OrderingType OrderingType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::RealScalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::Scalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::SimplicialCholeskyBase	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
Eigen::SimplicialCholeskyBase::SimplicialCholeskyBase	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialCholeskyBase::UpLo	src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = internal::traits<Derived>::UpLo };$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon424
Eigen::SimplicialCholeskyBase::VectorType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::_solve	src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::SimplicialCholeskyBase::analyzePattern	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a, bool doLDLT)
Eigen::SimplicialCholeskyBase::analyzePattern_preordered	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern_preordered(const CholMatrixType& a, bool doLDLT);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const CholMatrixType& a, bool doLDLT)
Eigen::SimplicialCholeskyBase::analyzePattern_preordered	src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::analyzePattern_preordered(const CholMatrixType& ap, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const CholMatrixType& ap, bool doLDLT)
Eigen::SimplicialCholeskyBase::cols	src/SparseCholesky/SimplicialCholesky.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::compute	src/SparseCholesky/SimplicialCholesky.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& matrix)
Eigen::SimplicialCholeskyBase::derived	src/SparseCholesky/SimplicialCholesky.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
Eigen::SimplicialCholeskyBase::derived	src/SparseCholesky/SimplicialCholesky.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::dumpMemory	src/SparseCholesky/SimplicialCholesky.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(Stream& s)
Eigen::SimplicialCholeskyBase::factorize	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a)
Eigen::SimplicialCholeskyBase::factorize_preordered	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize_preordered(const CholMatrixType& a);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const CholMatrixType& a)
Eigen::SimplicialCholeskyBase::factorize_preordered	src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::factorize_preordered(const CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const CholMatrixType& ap)
Eigen::SimplicialCholeskyBase::info	src/SparseCholesky/SimplicialCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::keep_diag	src/SparseCholesky/SimplicialCholesky.h	/^    struct keep_diag {$/;"	s	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::keep_diag::operator ()	src/SparseCholesky/SimplicialCholesky.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::SimplicialCholeskyBase::keep_diag	access:public	signature:(const Index& row, const Index& col, const Scalar&) const
Eigen::SimplicialCholeskyBase::m_P	src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ the permutation$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_Pinv	src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ the inverse permutation$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_analysisIsOk	src/SparseCholesky/SimplicialCholesky.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_diag	src/SparseCholesky/SimplicialCholesky.h	/^    VectorType m_diag;                                \/\/ the diagonal coefficients (LDLT mode)$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_factorizationIsOk	src/SparseCholesky/SimplicialCholesky.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_info	src/SparseCholesky/SimplicialCholesky.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_isInitialized	src/SparseCholesky/SimplicialCholesky.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_matrix	src/SparseCholesky/SimplicialCholesky.h	/^    CholMatrixType m_matrix;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_nonZerosPerCol	src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_nonZerosPerCol;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_parent	src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_parent;                                \/\/ elimination tree$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_shiftOffset	src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftOffset;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_shiftScale	src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftScale;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::ordering	src/SparseCholesky/SimplicialCholesky.h	/^    void ordering(const MatrixType& a, CholMatrixType& ap);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a, CholMatrixType& ap)
Eigen::SimplicialCholeskyBase::ordering	src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::ordering(const MatrixType& a, CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const MatrixType& a, CholMatrixType& ap)
Eigen::SimplicialCholeskyBase::permutationP	src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationP() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::permutationPinv	src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationPinv() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::rows	src/SparseCholesky/SimplicialCholesky.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::setShift	src/SparseCholesky/SimplicialCholesky.h	/^    Derived& setShift(const RealScalar& offset, const RealScalar& scale = 1)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const RealScalar& offset, const RealScalar& scale = 1)
Eigen::SimplicialCholeskyBase::solve	src/SparseCholesky/SimplicialCholesky.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::SimplicialCholeskyBase::solve	src/SparseCholesky/SimplicialCholesky.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::SimplicialCholeskyBase::~SimplicialCholeskyBase	src/SparseCholesky/SimplicialCholesky.h	/^    ~SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
Eigen::SimplicialCholeskyLDLT	src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLDLT$/;"	e	enum:Eigen::SimplicialCholeskyMode
Eigen::SimplicialCholeskyLLT	src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLLT,$/;"	e	enum:Eigen::SimplicialCholeskyMode
Eigen::SimplicialCholeskyMode	src/SparseCholesky/SimplicialCholesky.h	/^enum SimplicialCholeskyMode {$/;"	g	namespace:Eigen
Eigen::SimplicialLDLT	src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLDLT : public SimplicialCholeskyBase<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
Eigen::SimplicialLDLT::Base	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLDLT> Base;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::Index	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::MatrixL	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::MatrixU	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::RealScalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::Scalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::SimplicialLDLT	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT() : Base() {}$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:()
Eigen::SimplicialLDLT::SimplicialLDLT	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialLDLT::Traits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT> Traits;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::UpLo	src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLDLT::__anon429
Eigen::SimplicialLDLT::VectorType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::analyzePattern	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& a)
Eigen::SimplicialLDLT::compute	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialLDLT::determinant	src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
Eigen::SimplicialLDLT::factorize	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& a)
Eigen::SimplicialLDLT::matrixL	src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
Eigen::SimplicialLDLT::matrixU	src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
Eigen::SimplicialLDLT::vectorD	src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
Eigen::SimplicialLLT	src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLLT : public SimplicialCholeskyBase<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
Eigen::SimplicialLLT::Base	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLLT> Base;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::Index	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::MatrixL	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::MatrixU	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::RealScalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::Scalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::SimplicialLLT	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT() : Base() {}$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:()
Eigen::SimplicialLLT::SimplicialLLT	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialLLT::Traits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT> Traits;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::UpLo	src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLLT::__anon428
Eigen::SimplicialLLT::VectorType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::analyzePattern	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& a)
Eigen::SimplicialLLT::compute	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialLLT::determinant	src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
Eigen::SimplicialLLT::factorize	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& a)
Eigen::SimplicialLLT::matrixL	src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
Eigen::SimplicialLLT::matrixU	src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
Eigen::SliceVectorizedTraversal	src/Core/util/Constants.h	/^  SliceVectorizedTraversal,$/;"	e	enum:Eigen::__anon63
Eigen::SluMatrix	src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrix : SuperMatrix$/;"	s	namespace:Eigen	inherits:SuperMatrix
Eigen::SluMatrix::Map	src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(MatrixBase<MatrixType>& _mat)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(MatrixBase<MatrixType>& _mat)
Eigen::SluMatrix::Map	src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(SparseMatrixBase<MatrixType>& mat)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(SparseMatrixBase<MatrixType>& mat)
Eigen::SluMatrix::SluMatrix	src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix()$/;"	f	struct:Eigen::SluMatrix	access:public	signature:()
Eigen::SluMatrix::SluMatrix	src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(const SluMatrix& other)
Eigen::SluMatrix::__anon466::__anon467::lda	src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon466::__anon467	access:public
Eigen::SluMatrix::__anon466::__anon467::nnz	src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon466::__anon467	access:public
Eigen::SluMatrix::__anon466::innerInd	src/SuperLUSupport/SuperLUSupport.h	/^    int *innerInd;$/;"	m	struct:Eigen::SluMatrix::__anon466	access:public
Eigen::SluMatrix::__anon466::outerInd	src/SuperLUSupport/SuperLUSupport.h	/^    int *outerInd;$/;"	m	struct:Eigen::SluMatrix::__anon466	access:public
Eigen::SluMatrix::__anon466::values	src/SuperLUSupport/SuperLUSupport.h	/^    void *values;$/;"	m	struct:Eigen::SluMatrix::__anon466	access:public
Eigen::SluMatrix::operator =	src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix& operator=(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(const SluMatrix& other)
Eigen::SluMatrix::setScalarType	src/SuperLUSupport/SuperLUSupport.h	/^  void setScalarType()$/;"	f	struct:Eigen::SluMatrix	access:public	signature:()
Eigen::SluMatrix::setStorageType	src/SuperLUSupport/SuperLUSupport.h	/^  void setStorageType(Stype_t t)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(Stype_t t)
Eigen::SluMatrix::storage	src/SuperLUSupport/SuperLUSupport.h	/^  } storage;$/;"	m	struct:Eigen::SluMatrix	typeref:struct:Eigen::SluMatrix::__anon466	access:public
Eigen::SluMatrixMapHelper	src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<Matrix<Scalar,Rows,Cols,Options,MRows,MCols> >$/;"	s	namespace:Eigen
Eigen::SluMatrixMapHelper	src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<SparseMatrixBase<Derived> >$/;"	s	namespace:Eigen
Eigen::SluMatrixMapHelper::MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^  typedef Derived MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper	access:public
Eigen::SluMatrixMapHelper::MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^  typedef Matrix<Scalar,Rows,Cols,Options,MRows,MCols> MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper	access:public
Eigen::SluMatrixMapHelper::run	src/SuperLUSupport/SuperLUSupport.h	/^  static void run(MatrixType& mat, SluMatrix& res)$/;"	f	struct:Eigen::SluMatrixMapHelper	access:public	signature:(MatrixType& mat, SluMatrix& res)
Eigen::Small	src/Core/GeneralProduct.h	/^  Small = 3$/;"	e	enum:Eigen::__anon241
Eigen::SparseDenseOuterProduct	src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseDenseOuterProduct::Base	src/SparseCore/SparseDenseProduct.h	/^    typedef SparseMatrixBase<SparseDenseOuterProduct> Base;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:public
Eigen::SparseDenseOuterProduct::InnerIterator	src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct<Lhs,Rhs,Transpose>::InnerIterator : public _LhsNested::InnerIterator$/;"	c	class:Eigen::SparseDenseOuterProduct	inherits:_LhsNested::InnerIterator
Eigen::SparseDenseOuterProduct::InnerIterator::Base	src/SparseCore/SparseDenseProduct.h	/^    typedef typename _LhsNested::InnerIterator Base;$/;"	t	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:private
Eigen::SparseDenseOuterProduct::InnerIterator::Index	src/SparseCore/SparseDenseProduct.h	/^    typedef typename SparseDenseOuterProduct::Index Index;$/;"	t	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:private
Eigen::SparseDenseOuterProduct::InnerIterator::InnerIterator	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseDenseOuterProduct& prod, Index outer)$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:(const SparseDenseOuterProduct& prod, Index outer)
Eigen::SparseDenseOuterProduct::InnerIterator::col	src/SparseCore/SparseDenseProduct.h	/^    inline Index col() const { return Transpose ? Base::index() : m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
Eigen::SparseDenseOuterProduct::InnerIterator::get	src/SparseCore/SparseDenseProduct.h	/^    static Scalar get(const _RhsNested &rhs, Index outer, Dense = Dense())$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected	signature:(const _RhsNested &rhs, Index outer, Dense = Dense())
Eigen::SparseDenseOuterProduct::InnerIterator::get	src/SparseCore/SparseDenseProduct.h	/^    static Scalar get(const _RhsNested &rhs, Index outer, Sparse = Sparse())$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected	signature:(const _RhsNested &rhs, Index outer, Sparse = Sparse())
Eigen::SparseDenseOuterProduct::InnerIterator::m_factor	src/SparseCore/SparseDenseProduct.h	/^    Scalar m_factor;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected
Eigen::SparseDenseOuterProduct::InnerIterator::m_outer	src/SparseCore/SparseDenseProduct.h	/^    Index m_outer;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected
Eigen::SparseDenseOuterProduct::InnerIterator::outer	src/SparseCore/SparseDenseProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
Eigen::SparseDenseOuterProduct::InnerIterator::row	src/SparseCore/SparseDenseProduct.h	/^    inline Index row() const { return Transpose ? m_outer : Base::index(); }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
Eigen::SparseDenseOuterProduct::InnerIterator::value	src/SparseCore/SparseDenseProduct.h	/^    inline Scalar value() const { return Base::value() * m_factor; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
Eigen::SparseDenseOuterProduct::LhsNested	src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::LhsNested LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
Eigen::SparseDenseOuterProduct::RhsNested	src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::RhsNested RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
Eigen::SparseDenseOuterProduct::SparseDenseOuterProduct	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SparseDenseOuterProduct::SparseDenseOuterProduct	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Rhs& rhs, const Lhs& lhs)$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:(const Rhs& rhs, const Lhs& lhs)
Eigen::SparseDenseOuterProduct::Traits	src/SparseCore/SparseDenseProduct.h	/^    typedef internal::traits<SparseDenseOuterProduct> Traits;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:public
Eigen::SparseDenseOuterProduct::_LhsNested	src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
Eigen::SparseDenseOuterProduct::_RhsNested	src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
Eigen::SparseDenseOuterProduct::cols	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return Tr ? m_lhs.cols() : m_rhs.cols(); }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Eigen::SparseDenseOuterProduct::lhs	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Eigen::SparseDenseOuterProduct::m_lhs	src/SparseCore/SparseDenseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDenseOuterProduct	access:protected
Eigen::SparseDenseOuterProduct::m_rhs	src/SparseCore/SparseDenseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDenseOuterProduct	access:protected
Eigen::SparseDenseOuterProduct::rhs	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Eigen::SparseDenseOuterProduct::rows	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return Tr ? m_rhs.rows() : m_lhs.rows(); }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Eigen::SparseDenseProductReturnType	src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct SparseDenseProductReturnType$/;"	s	namespace:Eigen
Eigen::SparseDenseProductReturnType	src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct SparseDenseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
Eigen::SparseDenseProductReturnType::Type	src/SparseCore/SparseDenseProduct.h	/^    SparseDenseOuterProduct<Lhs,Rhs,false> >::type Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType	access:public
Eigen::SparseDenseProductReturnType::Type	src/SparseCore/SparseDenseProduct.h	/^  typedef SparseTimeDenseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType	access:public
Eigen::SparseDiagonalProduct	src/SparseCore/SparseDiagonalProduct.h	/^class SparseDiagonalProduct$/;"	c	namespace:Eigen	inherits:SparseMatrixBase,internal::no_assignment_operator
Eigen::SparseDiagonalProduct::InnerIterator	src/SparseCore/SparseDiagonalProduct.h	/^                      <_LhsNested,_RhsNested,SparseDiagonalProduct,LhsMode,RhsMode> InnerIterator;$/;"	t	class:Eigen::SparseDiagonalProduct	access:public
Eigen::SparseDiagonalProduct::LhsMode	src/SparseCore/SparseDiagonalProduct.h	/^      LhsMode = internal::is_diagonal<_LhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon444
Eigen::SparseDiagonalProduct::LhsNested	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
Eigen::SparseDiagonalProduct::RhsMode	src/SparseCore/SparseDiagonalProduct.h	/^      RhsMode = internal::is_diagonal<_RhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon444
Eigen::SparseDiagonalProduct::RhsNested	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
Eigen::SparseDiagonalProduct::SparseDiagonalProduct	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE SparseDiagonalProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SparseDiagonalProduct::_LhsNested	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
Eigen::SparseDiagonalProduct::_RhsNested	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
Eigen::SparseDiagonalProduct::cols	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
Eigen::SparseDiagonalProduct::lhs	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
Eigen::SparseDiagonalProduct::m_lhs	src/SparseCore/SparseDiagonalProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDiagonalProduct	access:protected
Eigen::SparseDiagonalProduct::m_rhs	src/SparseCore/SparseDiagonalProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDiagonalProduct	access:protected
Eigen::SparseDiagonalProduct::rhs	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
Eigen::SparseDiagonalProduct::rows	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
Eigen::SparseLU	src/SparseLU/SparseLU.h	/^class SparseLU : public internal::SparseLUImpl<typename _MatrixType::Scalar, typename _MatrixType::Index>$/;"	c	namespace:Eigen	inherits:internal::SparseLUImpl
Eigen::SparseLU::Base	src/SparseLU/SparseLU.h	/^    typedef internal::SparseLUImpl<Scalar, Index> Base;$/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::Index	src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::Index Index; $/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::IndexVector	src/SparseLU/SparseLU.h	/^    typedef Matrix<Index,Dynamic,1> IndexVector;$/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::MatrixType	src/SparseLU/SparseLU.h	/^    typedef _MatrixType MatrixType; $/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::NCMatrix	src/SparseLU/SparseLU.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> NCMatrix;$/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::OrderingType	src/SparseLU/SparseLU.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::PermutationType	src/SparseLU/SparseLU.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::RealScalar	src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::RealScalar RealScalar; $/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::SCMatrix	src/SparseLU/SparseLU.h	/^    typedef internal::MappedSuperNodalMatrix<Scalar, Index> SCMatrix; $/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::Scalar	src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::Scalar Scalar; $/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::ScalarVector	src/SparseLU/SparseLU.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::SparseLU	access:public
Eigen::SparseLU::SparseLU	src/SparseLU/SparseLU.h	/^    SparseLU (const SparseLU& );$/;"	p	class:Eigen::SparseLU	access:private	signature:(const SparseLU& )
Eigen::SparseLU::SparseLU	src/SparseLU/SparseLU.h	/^    SparseLU():m_isInitialized(true),m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)$/;"	f	class:Eigen::SparseLU	access:public	signature:()
Eigen::SparseLU::SparseLU	src/SparseLU/SparseLU.h	/^    SparseLU(const MatrixType& matrix):m_isInitialized(true),m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)$/;"	f	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
Eigen::SparseLU::_solve	src/SparseLU/SparseLU.h	/^    bool _solve(const MatrixBase<Rhs> &B, MatrixBase<Dest> &X_base) const$/;"	f	class:Eigen::SparseLU	access:public	signature:(const MatrixBase<Rhs> &B, MatrixBase<Dest> &X_base) const
Eigen::SparseLU::absDeterminant	src/SparseLU/SparseLU.h	/^     Scalar absDeterminant()$/;"	f	class:Eigen::SparseLU	access:public	signature:()
Eigen::SparseLU::analyzePattern	src/SparseLU/SparseLU.h	/^    void analyzePattern (const MatrixType& matrix);$/;"	p	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
Eigen::SparseLU::analyzePattern	src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseLU	signature:(const MatrixType& mat)
Eigen::SparseLU::cols	src/SparseLU/SparseLU.h	/^    inline Index cols() const { return m_mat.cols(); }$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
Eigen::SparseLU::colsPermutation	src/SparseLU/SparseLU.h	/^    inline const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
Eigen::SparseLU::compute	src/SparseLU/SparseLU.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
Eigen::SparseLU::determinant	src/SparseLU/SparseLU.h	/^    Scalar determinant()$/;"	f	class:Eigen::SparseLU	access:public	signature:()
Eigen::SparseLU::factorize	src/SparseLU/SparseLU.h	/^    void factorize (const MatrixType& matrix);$/;"	p	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
Eigen::SparseLU::factorize	src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::factorize(const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU	signature:(const MatrixType& matrix)
Eigen::SparseLU::info	src/SparseLU/SparseLU.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
Eigen::SparseLU::initperfvalues	src/SparseLU/SparseLU.h	/^    void initperfvalues()$/;"	f	class:Eigen::SparseLU	access:protected	signature:()
Eigen::SparseLU::isSymmetric	src/SparseLU/SparseLU.h	/^    void isSymmetric(bool sym)$/;"	f	class:Eigen::SparseLU	access:public	signature:(bool sym)
Eigen::SparseLU::lastErrorMessage	src/SparseLU/SparseLU.h	/^    std::string lastErrorMessage() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
Eigen::SparseLU::logAbsDeterminant	src/SparseLU/SparseLU.h	/^     Scalar logAbsDeterminant() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
Eigen::SparseLU::m_Lstore	src/SparseLU/SparseLU.h	/^    SCMatrix m_Lstore; \/\/ The lower triangular matrix (supernodal)$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_Ustore	src/SparseLU/SparseLU.h	/^    MappedSparseMatrix<Scalar,ColMajor,Index> m_Ustore; \/\/ The upper triangular matrix$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_analysisIsOk	src/SparseLU/SparseLU.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_detPermC	src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_detPermR	src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_diagpivotthresh	src/SparseLU/SparseLU.h	/^    RealScalar m_diagpivotthresh; \/\/ Specifies the threshold used for a diagonal entry to be an acceptable pivot$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_etree	src/SparseLU/SparseLU.h	/^    IndexVector m_etree; \/\/ Column elimination tree $/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_factorizationIsOk	src/SparseLU/SparseLU.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_glu	src/SparseLU/SparseLU.h	/^    typename Base::GlobalLU_t m_glu; $/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_info	src/SparseLU/SparseLU.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_isInitialized	src/SparseLU/SparseLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_lastError	src/SparseLU/SparseLU.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_mat	src/SparseLU/SparseLU.h	/^    NCMatrix m_mat; \/\/ The input (permuted ) matrix $/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_nnzL	src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_nnzU	src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_perfv	src/SparseLU/SparseLU.h	/^    internal::perfvalues<Index> m_perfv; $/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_perm_c	src/SparseLU/SparseLU.h	/^    PermutationType m_perm_c; \/\/ Column permutation $/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_perm_r	src/SparseLU/SparseLU.h	/^    PermutationType m_perm_r ; \/\/ Row permutation$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::m_symmetricmode	src/SparseLU/SparseLU.h	/^    bool m_symmetricmode;$/;"	m	class:Eigen::SparseLU	access:protected
Eigen::SparseLU::matrixL	src/SparseLU/SparseLU.h	/^    SparseLUMatrixLReturnType<SCMatrix> matrixL() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
Eigen::SparseLU::matrixU	src/SparseLU/SparseLU.h	/^    SparseLUMatrixUReturnType<SCMatrix,MappedSparseMatrix<Scalar,ColMajor,Index> > matrixU() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
Eigen::SparseLU::rows	src/SparseLU/SparseLU.h	/^    inline Index rows() const { return m_mat.rows(); }$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
Eigen::SparseLU::rowsPermutation	src/SparseLU/SparseLU.h	/^    inline const PermutationType& rowsPermutation() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
Eigen::SparseLU::setPivotThreshold	src/SparseLU/SparseLU.h	/^    void setPivotThreshold(const RealScalar& thresh)$/;"	f	class:Eigen::SparseLU	access:public	signature:(const RealScalar& thresh)
Eigen::SparseLU::signDeterminant	src/SparseLU/SparseLU.h	/^    Scalar signDeterminant()$/;"	f	class:Eigen::SparseLU	access:public	signature:()
Eigen::SparseLU::simplicialfactorize	src/SparseLU/SparseLU.h	/^    void simplicialfactorize(const MatrixType& matrix);$/;"	p	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
Eigen::SparseLU::solve	src/SparseLU/SparseLU.h	/^    inline const internal::solve_retval<SparseLU, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseLU	access:public	signature:(const MatrixBase<Rhs>& B) const
Eigen::SparseLU::solve	src/SparseLU/SparseLU.h	/^    inline const internal::sparse_solve_retval<SparseLU, Rhs> solve(const SparseMatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseLU	access:public	signature:(const SparseMatrixBase<Rhs>& B) const
Eigen::SparseLU::~SparseLU	src/SparseLU/SparseLU.h	/^    ~SparseLU()$/;"	f	class:Eigen::SparseLU	access:public	signature:()
Eigen::SparseLUMatrixLReturnType	src/SparseLU/SparseLU.h	/^struct SparseLUMatrixLReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen	inherits:internal::no_assignment_operator
Eigen::SparseLUMatrixLReturnType::Index	src/SparseLU/SparseLU.h	/^  typedef typename MappedSupernodalType::Index Index;$/;"	t	struct:Eigen::SparseLUMatrixLReturnType	access:public
Eigen::SparseLUMatrixLReturnType::Scalar	src/SparseLU/SparseLU.h	/^  typedef typename MappedSupernodalType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixLReturnType	access:public
Eigen::SparseLUMatrixLReturnType::SparseLUMatrixLReturnType	src/SparseLU/SparseLU.h	/^  SparseLUMatrixLReturnType(const MappedSupernodalType& mapL) : m_mapL(mapL)$/;"	f	struct:Eigen::SparseLUMatrixLReturnType	access:public	signature:(const MappedSupernodalType& mapL)
Eigen::SparseLUMatrixLReturnType::cols	src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType	access:public	signature:()
Eigen::SparseLUMatrixLReturnType::m_mapL	src/SparseLU/SparseLU.h	/^  const MappedSupernodalType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixLReturnType	access:public
Eigen::SparseLUMatrixLReturnType::rows	src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType	access:public	signature:()
Eigen::SparseLUMatrixLReturnType::solveInPlace	src/SparseLU/SparseLU.h	/^  void solveInPlace( MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixLReturnType	access:public	signature:( MatrixBase<Dest> &X) const
Eigen::SparseLUMatrixUReturnType	src/SparseLU/SparseLU.h	/^struct SparseLUMatrixUReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen	inherits:internal::no_assignment_operator
Eigen::SparseLUMatrixUReturnType::Index	src/SparseLU/SparseLU.h	/^  typedef typename MatrixLType::Index Index;$/;"	t	struct:Eigen::SparseLUMatrixUReturnType	access:public
Eigen::SparseLUMatrixUReturnType::Scalar	src/SparseLU/SparseLU.h	/^  typedef typename MatrixLType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixUReturnType	access:public
Eigen::SparseLUMatrixUReturnType::SparseLUMatrixUReturnType	src/SparseLU/SparseLU.h	/^  SparseLUMatrixUReturnType(const MatrixLType& mapL, const MatrixUType& mapU)$/;"	f	struct:Eigen::SparseLUMatrixUReturnType	access:public	signature:(const MatrixLType& mapL, const MatrixUType& mapU)
Eigen::SparseLUMatrixUReturnType::cols	src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType	access:public	signature:()
Eigen::SparseLUMatrixUReturnType::m_mapL	src/SparseLU/SparseLU.h	/^  const MatrixLType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType	access:public
Eigen::SparseLUMatrixUReturnType::m_mapU	src/SparseLU/SparseLU.h	/^  const MatrixUType& m_mapU;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType	access:public
Eigen::SparseLUMatrixUReturnType::rows	src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType	access:public	signature:()
Eigen::SparseLUMatrixUReturnType::solveInPlace	src/SparseLU/SparseLU.h	/^  template<typename Dest>   void solveInPlace(MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixUReturnType	access:public	signature:(MatrixBase<Dest> &X) const
Eigen::SparseMatrix	src/SparseCore/SparseMatrix.h	/^class SparseMatrix$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseMatrix::InnerIterator	src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseMatrix
Eigen::SparseMatrix::InnerIterator::InnerIterator	src/SparseCore/SparseMatrix.h	/^    InnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:(const SparseMatrix& mat, Index outer)
Eigen::SparseMatrix::InnerIterator::col	src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::index	src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::m_end	src/SparseCore/SparseMatrix.h	/^    Index m_end;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::m_id	src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::m_indices	src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::m_outer	src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::m_values	src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::operator ++	src/SparseCore/SparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:()
Eigen::SparseMatrix::InnerIterator::operator bool	src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::outer	src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::row	src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::value	src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::valueRef	src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id]); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:()
Eigen::SparseMatrix::Map	src/SparseCore/SparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::SparseMatrix	access:public
Eigen::SparseMatrix::Options	src/SparseCore/SparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseMatrix::__anon447
Eigen::SparseMatrix::ReverseInnerIterator	src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseMatrix
Eigen::SparseMatrix::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/SparseMatrix.h	/^    ReverseInnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:(const SparseMatrix& mat, Index outer)
Eigen::SparseMatrix::ReverseInnerIterator::col	src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::index	src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::m_id	src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::m_indices	src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::m_outer	src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::m_start	src/SparseCore/SparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::m_values	src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::operator --	src/SparseCore/SparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { --m_id; return *this; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:()
Eigen::SparseMatrix::ReverseInnerIterator::operator bool	src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::outer	src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::row	src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::value	src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::valueRef	src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id-1]); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:()
Eigen::SparseMatrix::SingletonVector	src/SparseCore/SparseMatrix.h	/^    class SingletonVector$/;"	c	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::SingletonVector::SingletonVector	src/SparseCore/SparseMatrix.h	/^        SingletonVector(Index i, Index v)$/;"	f	class:Eigen::SparseMatrix::SingletonVector	access:public	signature:(Index i, Index v)
Eigen::SparseMatrix::SingletonVector::m_index	src/SparseCore/SparseMatrix.h	/^        Index m_index;$/;"	m	class:Eigen::SparseMatrix::SingletonVector	access:private
Eigen::SparseMatrix::SingletonVector::m_value	src/SparseCore/SparseMatrix.h	/^        Index m_value;$/;"	m	class:Eigen::SparseMatrix::SingletonVector	access:private
Eigen::SparseMatrix::SingletonVector::operator []	src/SparseCore/SparseMatrix.h	/^        Index operator[](Index i) const { return i==m_index ? m_value : 0; }$/;"	f	class:Eigen::SparseMatrix::SingletonVector	access:public	signature:(Index i) const
Eigen::SparseMatrix::SingletonVector::value_type	src/SparseCore/SparseMatrix.h	/^        typedef Index value_type;$/;"	t	class:Eigen::SparseMatrix::SingletonVector	access:public
Eigen::SparseMatrix::SparseMatrix	src/SparseCore/SparseMatrix.h	/^    SparseMatrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::SparseMatrix::SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
Eigen::SparseMatrix::SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrix& other)
Eigen::SparseMatrix::SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrix::SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseSelfAdjointView<OtherDerived, UpLo>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseSelfAdjointView<OtherDerived, UpLo>& other)
Eigen::SparseMatrix::Storage	src/SparseCore/SparseMatrix.h	/^    typedef internal::CompressedStorage<Scalar,Index> Storage;$/;"	t	class:Eigen::SparseMatrix	access:public
Eigen::SparseMatrix::TransposedSparseMatrix	src/SparseCore/SparseMatrix.h	/^    typedef SparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;$/;"	t	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::check_template_parameters	src/SparseCore/SparseMatrix.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SparseMatrix	access:private	signature:()
Eigen::SparseMatrix::coeff	src/SparseCore/SparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col) const
Eigen::SparseMatrix::coeffRef	src/SparseCore/SparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
Eigen::SparseMatrix::cols	src/SparseCore/SparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::conservativeResize	src/SparseCore/SparseMatrix.h	/^    void conservativeResize(Index rows, Index cols) $/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
Eigen::SparseMatrix::data	src/SparseCore/SparseMatrix.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::data	src/SparseCore/SparseMatrix.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::default_prunning_func	src/SparseCore/SparseMatrix.h	/^  struct default_prunning_func {$/;"	s	class:Eigen::SparseMatrix	access:private
Eigen::SparseMatrix::default_prunning_func::default_prunning_func	src/SparseCore/SparseMatrix.h	/^    default_prunning_func(const Scalar& ref, const RealScalar& eps) : reference(ref), epsilon(eps) {}$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func	access:public	signature:(const Scalar& ref, const RealScalar& eps)
Eigen::SparseMatrix::default_prunning_func::epsilon	src/SparseCore/SparseMatrix.h	/^    RealScalar epsilon;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func	access:public
Eigen::SparseMatrix::default_prunning_func::operator ()	src/SparseCore/SparseMatrix.h	/^    inline bool operator() (const Index&, const Index&, const Scalar& value) const$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func	access:public	signature:(const Index&, const Index&, const Scalar& value) const
Eigen::SparseMatrix::default_prunning_func::reference	src/SparseCore/SparseMatrix.h	/^    Scalar reference;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func	access:public
Eigen::SparseMatrix::diagonal	src/SparseCore/SparseMatrix.h	/^    const Diagonal<const SparseMatrix> diagonal() const { return *this; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::finalize	src/SparseCore/SparseMatrix.h	/^    inline void finalize()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::initAssignment	src/SparseCore/SparseMatrix.h	/^    void initAssignment(const Other& other)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(const Other& other)
Eigen::SparseMatrix::innerIndexPtr	src/SparseCore/SparseMatrix.h	/^    inline Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::innerIndexPtr	src/SparseCore/SparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::innerNonZeroPtr	src/SparseCore/SparseMatrix.h	/^    inline Index* innerNonZeroPtr() { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::innerNonZeroPtr	src/SparseCore/SparseMatrix.h	/^    inline const Index* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::innerNonZeros	src/SparseCore/SparseMatrix.h	/^    Eigen::Map<Matrix<Index,Dynamic,1> > innerNonZeros() { return Eigen::Map<Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:()
Eigen::SparseMatrix::innerNonZeros	src/SparseCore/SparseMatrix.h	/^    const  Eigen::Map<const Matrix<Index,Dynamic,1> > innerNonZeros() const { return Eigen::Map<const Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:() const
Eigen::SparseMatrix::innerSize	src/SparseCore/SparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::insert	src/SparseCore/SparseMatrix.h	/^    Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
Eigen::SparseMatrix::insertBack	src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
Eigen::SparseMatrix::insertBackByOuterInner	src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer, Index inner)
Eigen::SparseMatrix::insertBackByOuterInnerUnordered	src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer, Index inner)
Eigen::SparseMatrix::insertBackUncompressed	src/SparseCore/SparseMatrix.h	/^    EIGEN_STRONG_INLINE Scalar& insertBackUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
Eigen::SparseMatrix::insertByOuterInner	src/SparseCore/SparseMatrix.h	/^    Scalar& insertByOuterInner(Index j, Index i)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index j, Index i)
Eigen::SparseMatrix::insertCompressed	src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertCompressed(Index row, Index col);$/;"	p	class:Eigen::SparseMatrix	access:protected	signature:(Index row, Index col)
Eigen::SparseMatrix::insertCompressed	src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_Index>::Scalar& SparseMatrix<_Scalar,_Options,_Index>::insertCompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	signature:(Index row, Index col)
Eigen::SparseMatrix::insertUncompressed	src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertUncompressed(Index row, Index col);$/;"	p	class:Eigen::SparseMatrix	access:protected	signature:(Index row, Index col)
Eigen::SparseMatrix::insertUncompressed	src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_Index>::Scalar& SparseMatrix<_Scalar,_Options,_Index>::insertUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	signature:(Index row, Index col)
Eigen::SparseMatrix::isCompressed	src/SparseCore/SparseMatrix.h	/^    inline bool isCompressed() const { return m_innerNonZeros==0; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::m_data	src/SparseCore/SparseMatrix.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::m_innerNonZeros	src/SparseCore/SparseMatrix.h	/^    Index* m_innerNonZeros;     \/\/ optional, if null then the data is compressed$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::m_innerSize	src/SparseCore/SparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::m_outerIndex	src/SparseCore/SparseMatrix.h	/^    Index* m_outerIndex;$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::m_outerSize	src/SparseCore/SparseMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::makeCompressed	src/SparseCore/SparseMatrix.h	/^    void makeCompressed()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::nonZeros	src/SparseCore/SparseMatrix.h	/^    inline Index nonZeros() const$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::operator <<	src/SparseCore/SparseMatrix.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrix& m)$/;"	f	class:Eigen::SparseMatrix	access:friend	signature:(std::ostream & s, const SparseMatrix& m)
Eigen::SparseMatrix::operator =	src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE SparseMatrix& operator=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrix::operator =	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::SparseMatrix::operator =	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::SparseMatrix::operator =	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrix& other)
Eigen::SparseMatrix::operator =	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
Eigen::SparseMatrix::operator =	src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE SparseMatrix<Scalar,_Options,_Index>& SparseMatrix<Scalar,_Options,_Index>::operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrix::outerIndexPtr	src/SparseCore/SparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::outerIndexPtr	src/SparseCore/SparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::outerSize	src/SparseCore/SparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::prune	src/SparseCore/SparseMatrix.h	/^    void prune(const KeepFunc& keep = KeepFunc())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const KeepFunc& keep = KeepFunc())
Eigen::SparseMatrix::prune	src/SparseCore/SparseMatrix.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())
Eigen::SparseMatrix::reserve	src/SparseCore/SparseMatrix.h	/^    inline void reserve(Index reserveSize)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index reserveSize)
Eigen::SparseMatrix::reserve	src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes)
Eigen::SparseMatrix::reserve	src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif =$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif = typename SizesType::Scalar())
Eigen::SparseMatrix::reserve	src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())
Eigen::SparseMatrix::reserveInnerVectors	src/SparseCore/SparseMatrix.h	/^    inline void reserveInnerVectors(const SizesType& reserveSizes)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(const SizesType& reserveSizes)
Eigen::SparseMatrix::resize	src/SparseCore/SparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
Eigen::SparseMatrix::resizeNonZeros	src/SparseCore/SparseMatrix.h	/^    void resizeNonZeros(Index size)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index size)
Eigen::SparseMatrix::rows	src/SparseCore/SparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::setFromTriplets	src/SparseCore/SparseMatrix.h	/^    void setFromTriplets(const InputIterators& begin, const InputIterators& end);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const InputIterators& begin, const InputIterators& end)
Eigen::SparseMatrix::setFromTriplets	src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::setFromTriplets(const InputIterators& begin, const InputIterators& end)$/;"	f	class:Eigen::SparseMatrix	signature:(const InputIterators& begin, const InputIterators& end)
Eigen::SparseMatrix::setIdentity	src/SparseCore/SparseMatrix.h	/^    inline void setIdentity()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::setZero	src/SparseCore/SparseMatrix.h	/^    inline void setZero()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::startVec	src/SparseCore/SparseMatrix.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer)
Eigen::SparseMatrix::sum	src/SparseCore/SparseMatrix.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::sum	src/SparseCore/SparseRedux.h	/^SparseMatrix<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseMatrix	signature:() const
Eigen::SparseMatrix::sumupDuplicates	src/SparseCore/SparseMatrix.h	/^    void sumupDuplicates();$/;"	p	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::sumupDuplicates	src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::sumupDuplicates()$/;"	f	class:Eigen::SparseMatrix	signature:()
Eigen::SparseMatrix::swap	src/SparseCore/SparseMatrix.h	/^    inline void swap(SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(SparseMatrix& other)
Eigen::SparseMatrix::uncompress	src/SparseCore/SparseMatrix.h	/^    void uncompress()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::valuePtr	src/SparseCore/SparseMatrix.h	/^    inline Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::valuePtr	src/SparseCore/SparseMatrix.h	/^    inline const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::~SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline ~SparseMatrix()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrixBase	src/SparseCore/SparseMatrixBase.h	/^template<typename Derived> class SparseMatrixBase$/;"	c	namespace:Eigen	inherits:internal::special_scalar_op_base
Eigen::SparseMatrixBase::AdjointReturnType	src/SparseCore/SparseMatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::Base	src/SparseCore/SparseMatrixBase.h	/^    typedef internal::special_scalar_op_base<Derived, Scalar, RealScalar, EigenBase<Derived> > Base;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::CoeffReadCost	src/SparseCore/SparseMatrixBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::CoeffReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::conditional<_HasDirectAccess, const Scalar&, Scalar>::type CoeffReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::ColsAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::ConstInnerVectorReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true> ConstInnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::ConstInnerVectorsReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,Dynamic,Dynamic,true> ConstInnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::ConstantReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Matrix<Scalar,Dynamic,Dynamic> > ConstantReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::CwiseProductDenseReturnType	src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> struct CwiseProductDenseReturnType {$/;"	s	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::CwiseProductDenseReturnType::Type	src/SparseCore/SparseMatrixBase.h	/^                          > Type;$/;"	t	struct:Eigen::SparseMatrixBase::CwiseProductDenseReturnType	access:public
Eigen::SparseMatrixBase::Flags	src/SparseCore/SparseMatrixBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::Index	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::InnerSizeAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::InnerVectorReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true>       InnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::InnerVectorsReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,Dynamic,Dynamic,true> InnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::IsRowMajor	src/SparseCore/SparseMatrixBase.h	/^      IsRowMajor = Flags&RowMajorBit ? 1 : 0,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::IsVectorAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::MaxColsAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::MaxRowsAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::MaxSizeAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::PacketReturnType	src/SparseCore/SparseMatrixBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::PacketScalar	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::PlainObject	src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrix<Scalar, Flags&RowMajorBit ? RowMajor : ColMajor, Index> PlainObject;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::RealScalar	src/SparseCore/SparseMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::RowsAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::Scalar	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::SizeAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::SparseMatrixBase	src/SparseCore/SparseMatrixBase.h	/^    SparseMatrixBase() : m_isRValue(false) { \/* TODO check flags *\/ }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::SquareMatrixType	src/SparseCore/SparseMatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::StorageBaseType	src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrixBase StorageBaseType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::StorageKind	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::_HasDirectAccess	src/SparseCore/SparseMatrixBase.h	/^      _HasDirectAccess = (int(Flags)&DirectAccessBit) ? 1 : 0 \/\/ workaround sunCC$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Eigen::SparseMatrixBase::adjoint	src/SparseCore/SparseMatrixBase.h	/^    const AdjointReturnType adjoint() const { return transpose(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::assign	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& assign(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:protected	signature:(const OtherDerived& other)
Eigen::SparseMatrixBase::assignGeneric	src/SparseCore/SparseMatrixBase.h	/^    inline void assignGeneric(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:protected	signature:(const OtherDerived& other)
Eigen::SparseMatrixBase::blueNorm	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::blueNorm	src/SparseCore/SparseMatrixBase.h	/^    RealScalar blueNorm() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::cols	src/SparseCore/SparseMatrixBase.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::const_cast_derived	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& const_cast_derived() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::cwiseProduct	src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::cwiseProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::cwiseProduct	src/SparseCore/SparseMatrixBase.h	/^    cwiseProduct(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::derived	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::derived	src/SparseCore/SparseMatrixBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::dot	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::dot	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::dot	src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> Scalar dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::dot	src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> Scalar dot(const SparseMatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::eval	src/SparseCore/SparseMatrixBase.h	/^    inline const typename internal::eval<Derived>::type eval() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::evalTo	src/SparseCore/SparseMatrixBase.h	/^    void evalTo(MatrixBase<DenseDerived>& dst) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(MatrixBase<DenseDerived>& dst) const
Eigen::SparseMatrixBase::innerSize	src/SparseCore/SparseMatrixBase.h	/^    Index innerSize() const { return (int(Flags)&RowMajorBit) ? this->cols() : this->rows(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::innerVector	src/SparseCore/SparseBlock.h	/^const typename SparseMatrixBase<Derived>::ConstInnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outer) const
Eigen::SparseMatrixBase::innerVector	src/SparseCore/SparseBlock.h	/^typename SparseMatrixBase<Derived>::InnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outer)
Eigen::SparseMatrixBase::innerVector	src/SparseCore/SparseMatrixBase.h	/^    InnerVectorReturnType innerVector(Index outer);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outer)
Eigen::SparseMatrixBase::innerVector	src/SparseCore/SparseMatrixBase.h	/^    const ConstInnerVectorReturnType innerVector(Index outer) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outer) const
Eigen::SparseMatrixBase::innerVectors	src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outerStart, Index outerSize) const
Eigen::SparseMatrixBase::innerVectors	src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outerStart, Index outerSize)
Eigen::SparseMatrixBase::innerVectors	src/SparseCore/SparseMatrixBase.h	/^    InnerVectorsReturnType innerVectors(Index outerStart, Index outerSize);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outerStart, Index outerSize)
Eigen::SparseMatrixBase::innerVectors	src/SparseCore/SparseMatrixBase.h	/^    const ConstInnerVectorsReturnType innerVectors(Index outerStart, Index outerSize) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outerStart, Index outerSize) const
Eigen::SparseMatrixBase::isApprox	src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::SparseMatrixBase::isApprox	src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const SparseMatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::SparseMatrixBase::isRValue	src/SparseCore/SparseMatrixBase.h	/^    bool isRValue() const { return m_isRValue; }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::isVector	src/SparseCore/SparseMatrixBase.h	/^    inline bool isVector() const { return rows()==1 || cols()==1; }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::m_isRValue	src/SparseCore/SparseMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SparseMatrixBase	access:protected
Eigen::SparseMatrixBase::markAsRValue	src/SparseCore/SparseMatrixBase.h	/^    Derived& markAsRValue() { m_isRValue = true; return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::nonZeros	src/SparseCore/SparseMatrixBase.h	/^    inline Index nonZeros() const { return derived().nonZeros(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::norm	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::norm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::norm	src/SparseCore/SparseMatrixBase.h	/^    RealScalar norm()  const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::operator *	src/SparseCore/SparseDiagonalProduct.h	/^SparseMatrixBase<Derived>::operator*(const DiagonalBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const DiagonalBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)
Eigen::SparseMatrixBase::operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const DiagonalBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)
Eigen::SparseMatrixBase::operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const SparseMatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator *	src/SparseCore/SparseProduct.h	/^SparseMatrixBase<Derived>::operator*(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator *=	src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const Scalar& other)
Eigen::SparseMatrixBase::operator *=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator*=(const Scalar& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const Scalar& other)
Eigen::SparseMatrixBase::operator *=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator*=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator +=	src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator+=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator +=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator+=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator -=	src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator-=(const SparseMatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived> &other)
Eigen::SparseMatrixBase::operator -=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator-=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator /=	src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const Scalar& other)
Eigen::SparseMatrixBase::operator /=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator\/=(const Scalar& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const Scalar& other)
Eigen::SparseMatrixBase::operator <<	src/SparseCore/SparseMatrixBase.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrixBase& m)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(std::ostream & s, const SparseMatrixBase& m)
Eigen::SparseMatrixBase::operator =	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::SparseMatrixBase::operator =	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::SparseMatrixBase::operator =	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const Derived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const Derived& other)
Eigen::SparseMatrixBase::operator =	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator =	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseSparseProduct<Lhs,Rhs>& product);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
Eigen::SparseMatrixBase::operator =	src/SparseCore/SparseProduct.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
Eigen::SparseMatrixBase::outerSize	src/SparseCore/SparseMatrixBase.h	/^    Index outerSize() const { return (int(Flags)&RowMajorBit) ? this->rows() : this->cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::rows	src/SparseCore/SparseMatrixBase.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::selfadjointView	src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> inline SparseSelfAdjointView<Derived, UpLo> selfadjointView();$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::selfadjointView	src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> inline const SparseSelfAdjointView<Derived, UpLo> selfadjointView() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::selfadjointView	src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::SparseMatrixBase	signature:()
Eigen::SparseMatrixBase::selfadjointView	src/SparseCore/SparseSelfAdjointView.h	/^const SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::size	src/SparseCore/SparseMatrixBase.h	/^    inline Index size() const { return rows() * cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::solveTriangular	src/SparseCore/SparseMatrixBase.h	/^    solveTriangular(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::solveTriangular	src/SparseCore/TriangularSolver.h	/^SparseMatrixBase<Derived>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::solveTriangularInPlace	src/SparseCore/SparseMatrixBase.h	/^    void solveTriangularInPlace(MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::solveTriangularInPlace	src/SparseCore/TriangularSolver.h	/^void SparseMatrixBase<Derived>::solveTriangularInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::squaredNorm	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::squaredNorm	src/SparseCore/SparseMatrixBase.h	/^    RealScalar squaredNorm() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::sum	src/SparseCore/SparseMatrixBase.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::sum	src/SparseCore/SparseRedux.h	/^SparseMatrixBase<Derived>::sum() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::toDense	src/SparseCore/SparseMatrixBase.h	/^    Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> toDense() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::transpose	src/SparseCore/SparseMatrixBase.h	/^    Transpose<Derived> transpose() { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::transpose	src/SparseCore/SparseMatrixBase.h	/^    const Transpose<const Derived> transpose() const { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::triangularView	src/SparseCore/SparseMatrixBase.h	/^    inline const SparseTriangularView<Derived, Mode> triangularView() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::triangularView	src/SparseCore/SparseTriangularView.h	/^SparseMatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::twistedBy	src/SparseCore/SparseMatrixBase.h	/^    SparseSymmetricPermutationProduct<Derived,Upper|Lower> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const
Eigen::SparseQR	src/SparseQR/SparseQR.h	/^class SparseQR$/;"	c	namespace:Eigen
Eigen::SparseQR::Index	src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseQR	access:public
Eigen::SparseQR::IndexVector	src/SparseQR/SparseQR.h	/^    typedef Matrix<Index, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::SparseQR	access:public
Eigen::SparseQR::MatrixType	src/SparseQR/SparseQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SparseQR	access:public
Eigen::SparseQR::OrderingType	src/SparseQR/SparseQR.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseQR	access:public
Eigen::SparseQR::PermutationType	src/SparseQR/SparseQR.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::SparseQR	access:public
Eigen::SparseQR::QRMatrixType	src/SparseQR/SparseQR.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> QRMatrixType;$/;"	t	class:Eigen::SparseQR	access:public
Eigen::SparseQR::RealScalar	src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SparseQR	access:public
Eigen::SparseQR::Scalar	src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseQR	access:public
Eigen::SparseQR::ScalarVector	src/SparseQR/SparseQR.h	/^    typedef Matrix<Scalar, Dynamic, 1> ScalarVector;$/;"	t	class:Eigen::SparseQR	access:public
Eigen::SparseQR::SparseQR	src/SparseQR/SparseQR.h	/^    SparseQR () : m_isInitialized(false), m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR	access:public	signature:()
Eigen::SparseQR::SparseQR	src/SparseQR/SparseQR.h	/^    SparseQR(const MatrixType& mat) : m_isInitialized(false), m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR	access:public	signature:(const MatrixType& mat)
Eigen::SparseQR::_solve	src/SparseQR/SparseQR.h	/^    bool _solve(const MatrixBase<Rhs> &B, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SparseQR	access:public	signature:(const MatrixBase<Rhs> &B, MatrixBase<Dest> &dest) const
Eigen::SparseQR::analyzePattern	src/SparseQR/SparseQR.h	/^    void analyzePattern(const MatrixType& mat);$/;"	p	class:Eigen::SparseQR	access:public	signature:(const MatrixType& mat)
Eigen::SparseQR::analyzePattern	src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR	signature:(const MatrixType& mat)
Eigen::SparseQR::cols	src/SparseQR/SparseQR.h	/^    inline Index cols() const { return m_pmat.cols();}$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
Eigen::SparseQR::colsPermutation	src/SparseQR/SparseQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
Eigen::SparseQR::compute	src/SparseQR/SparseQR.h	/^    void compute(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR	access:public	signature:(const MatrixType& mat)
Eigen::SparseQR::factorize	src/SparseQR/SparseQR.h	/^    void factorize(const MatrixType& mat);$/;"	p	class:Eigen::SparseQR	access:public	signature:(const MatrixType& mat)
Eigen::SparseQR::factorize	src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::factorize(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR	signature:(const MatrixType& mat)
Eigen::SparseQR::info	src/SparseQR/SparseQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
Eigen::SparseQR::lastErrorMessage	src/SparseQR/SparseQR.h	/^    std::string lastErrorMessage() const { return m_lastError; }$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
Eigen::SparseQR::m_Q	src/SparseQR/SparseQR.h	/^    QRMatrixType m_Q;               \/\/ The orthogonal reflectors$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_R	src/SparseQR/SparseQR.h	/^    QRMatrixType m_R;               \/\/ The triangular factor matrix$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_analysisIsok	src/SparseQR/SparseQR.h	/^    bool m_analysisIsok;$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_etree	src/SparseQR/SparseQR.h	/^    IndexVector m_etree;            \/\/ Column elimination tree$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_factorizationIsok	src/SparseQR/SparseQR.h	/^    bool m_factorizationIsok;$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_firstRowElt	src/SparseQR/SparseQR.h	/^    IndexVector m_firstRowElt;      \/\/ First element in each row$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_hcoeffs	src/SparseQR/SparseQR.h	/^    ScalarVector m_hcoeffs;         \/\/ The Householder coefficients$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_info	src/SparseQR/SparseQR.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_isEtreeOk	src/SparseQR/SparseQR.h	/^    bool m_isEtreeOk;               \/\/ whether the elimination tree match the initial input matrix$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_isInitialized	src/SparseQR/SparseQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_isQSorted	src/SparseQR/SparseQR.h	/^    bool m_isQSorted;               \/\/ whether Q is sorted or not$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_lastError	src/SparseQR/SparseQR.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_nonzeropivots	src/SparseQR/SparseQR.h	/^    Index m_nonzeropivots;          \/\/ Number of non zero pivots found $/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_outputPerm_c	src/SparseQR/SparseQR.h	/^    PermutationType m_outputPerm_c; \/\/ The final column permutation$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_perm_c	src/SparseQR/SparseQR.h	/^    PermutationType m_perm_c;       \/\/ Fill-reducing  Column  permutation$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_pivotperm	src/SparseQR/SparseQR.h	/^    PermutationType m_pivotperm;    \/\/ The permutation for rank revealing$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_pmat	src/SparseQR/SparseQR.h	/^    QRMatrixType m_pmat;            \/\/ Temporary matrix$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_threshold	src/SparseQR/SparseQR.h	/^    RealScalar m_threshold;         \/\/ Threshold to determine null Householder reflections$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::m_useDefaultThreshold	src/SparseQR/SparseQR.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SparseQR	access:protected
Eigen::SparseQR::matrixQ	src/SparseQR/SparseQR.h	/^    SparseQRMatrixQReturnType<SparseQR> matrixQ() const $/;"	f	class:Eigen::SparseQR	access:public	signature:() const
Eigen::SparseQR::matrixR	src/SparseQR/SparseQR.h	/^    const QRMatrixType& matrixR() const { return m_R; }$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
Eigen::SparseQR::rank	src/SparseQR/SparseQR.h	/^    Index rank() const $/;"	f	class:Eigen::SparseQR	access:public	signature:() const
Eigen::SparseQR::rows	src/SparseQR/SparseQR.h	/^    inline Index rows() const { return m_pmat.rows(); }$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
Eigen::SparseQR::setPivotThreshold	src/SparseQR/SparseQR.h	/^    void setPivotThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::SparseQR	access:public	signature:(const RealScalar& threshold)
Eigen::SparseQR::solve	src/SparseQR/SparseQR.h	/^    inline const internal::solve_retval<SparseQR, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseQR	access:public	signature:(const MatrixBase<Rhs>& B) const
Eigen::SparseQR::solve	src/SparseQR/SparseQR.h	/^    inline const internal::sparse_solve_retval<SparseQR, Rhs> solve(const SparseMatrixBase<Rhs>& B) const$/;"	f	class:Eigen::SparseQR	access:public	signature:(const SparseMatrixBase<Rhs>& B) const
Eigen::SparseQR::sort_matrix_Q	src/SparseQR/SparseQR.h	/^    inline void sort_matrix_Q()$/;"	f	class:Eigen::SparseQR	access:protected	signature:()
Eigen::SparseQRMatrixQReturnType	src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQReturnType : public EigenBase<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen	inherits:EigenBase
Eigen::SparseQRMatrixQReturnType::DenseMatrix	src/SparseQR/SparseQR.h	/^  typedef Matrix<Scalar,Dynamic,Dynamic> DenseMatrix;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType	access:public
Eigen::SparseQRMatrixQReturnType::Index	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Index Index;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType	access:public
Eigen::SparseQRMatrixQReturnType::Scalar	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType	access:public
Eigen::SparseQRMatrixQReturnType::SparseQRMatrixQReturnType	src/SparseQR/SparseQR.h	/^  SparseQRMatrixQReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:(const SparseQRType& qr)
Eigen::SparseQRMatrixQReturnType::adjoint	src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> adjoint() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:() const
Eigen::SparseQRMatrixQReturnType::cols	src/SparseQR/SparseQR.h	/^  inline Index cols() const { return (std::min)(m_qr.rows(),m_qr.cols()); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:() const
Eigen::SparseQRMatrixQReturnType::evalTo	src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(MatrixBase<Dest>& dest) const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:(MatrixBase<Dest>& dest) const
Eigen::SparseQRMatrixQReturnType::evalTo	src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(SparseMatrixBase<Dest>& dest) const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:(SparseMatrixBase<Dest>& dest) const
Eigen::SparseQRMatrixQReturnType::m_qr	src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQReturnType	access:public
Eigen::SparseQRMatrixQReturnType::operator *	src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:(const MatrixBase<Derived>& other)
Eigen::SparseQRMatrixQReturnType::rows	src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:() const
Eigen::SparseQRMatrixQReturnType::transpose	src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> transpose() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:() const
Eigen::SparseQRMatrixQTransposeReturnType	src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQTransposeReturnType$/;"	s	namespace:Eigen
Eigen::SparseQRMatrixQTransposeReturnType::SparseQRMatrixQTransposeReturnType	src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType	access:public	signature:(const SparseQRType& qr)
Eigen::SparseQRMatrixQTransposeReturnType::m_qr	src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQTransposeReturnType	access:public
Eigen::SparseQRMatrixQTransposeReturnType::operator *	src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType	access:public	signature:(const MatrixBase<Derived>& other)
Eigen::SparseQR_QProduct	src/SparseQR/SparseQR.h	/^struct SparseQR_QProduct : ReturnByValue<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen	inherits:ReturnByValue
Eigen::SparseQR_QProduct::Index	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Index Index;$/;"	t	struct:Eigen::SparseQR_QProduct	access:public
Eigen::SparseQR_QProduct::MatrixType	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::QRMatrixType MatrixType;$/;"	t	struct:Eigen::SparseQR_QProduct	access:public
Eigen::SparseQR_QProduct::Scalar	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQR_QProduct	access:public
Eigen::SparseQR_QProduct::SparseQR_QProduct	src/SparseQR/SparseQR.h	/^  SparseQR_QProduct(const SparseQRType& qr, const Derived& other, bool transpose) : $/;"	f	struct:Eigen::SparseQR_QProduct	access:public	signature:(const SparseQRType& qr, const Derived& other, bool transpose)
Eigen::SparseQR_QProduct::cols	src/SparseQR/SparseQR.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SparseQR_QProduct	access:public	signature:() const
Eigen::SparseQR_QProduct::evalTo	src/SparseQR/SparseQR.h	/^  void evalTo(DesType& res) const$/;"	f	struct:Eigen::SparseQR_QProduct	access:public	signature:(DesType& res) const
Eigen::SparseQR_QProduct::m_other	src/SparseQR/SparseQR.h	/^  const Derived& m_other;$/;"	m	struct:Eigen::SparseQR_QProduct	access:public
Eigen::SparseQR_QProduct::m_qr	src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQR_QProduct	access:public
Eigen::SparseQR_QProduct::m_transpose	src/SparseQR/SparseQR.h	/^  bool m_transpose;$/;"	m	struct:Eigen::SparseQR_QProduct	access:public
Eigen::SparseQR_QProduct::rows	src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_transpose ? m_qr.rows() : m_qr.cols(); }$/;"	f	struct:Eigen::SparseQR_QProduct	access:public	signature:() const
Eigen::SparseSelfAdjointTimeDenseProduct	src/SparseCore/SparseSelfAdjointView.h	/^class SparseSelfAdjointTimeDenseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::SparseSelfAdjointTimeDenseProduct::SparseSelfAdjointTimeDenseProduct	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SparseSelfAdjointTimeDenseProduct::operator =	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct& operator=(const SparseSelfAdjointTimeDenseProduct&);$/;"	p	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:private	signature:(const SparseSelfAdjointTimeDenseProduct&)
Eigen::SparseSelfAdjointTimeDenseProduct::scaleAndAddTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:public	signature:(Dest& dest, const Scalar& alpha) const
Eigen::SparseSelfAdjointView	src/SparseCore/SparseSelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SparseSelfAdjointView$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::SparseSelfAdjointView::Index	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Eigen::SparseSelfAdjointView::MatrixTypeNested	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Eigen::SparseSelfAdjointView::Scalar	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Eigen::SparseSelfAdjointView::SparseSelfAdjointView	src/SparseCore/SparseSelfAdjointView.h	/^    inline SparseSelfAdjointView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const MatrixType& matrix)
Eigen::SparseSelfAdjointView::VectorI	src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Eigen::SparseSelfAdjointView::_MatrixTypeNested	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Eigen::SparseSelfAdjointView::cols	src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
Eigen::SparseSelfAdjointView::evalTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar,int StorageOrder> void evalTo(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const
Eigen::SparseSelfAdjointView::evalTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar> void evalTo(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const
Eigen::SparseSelfAdjointView::m_countPerCol	src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerCol;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
Eigen::SparseSelfAdjointView::m_countPerRow	src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerRow;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
Eigen::SparseSelfAdjointView::m_matrix	src/SparseCore/SparseSelfAdjointView.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
Eigen::SparseSelfAdjointView::matrix	src/SparseCore/SparseSelfAdjointView.h	/^    _MatrixTypeNested& matrix() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:()
Eigen::SparseSelfAdjointView::matrix	src/SparseCore/SparseSelfAdjointView.h	/^    const _MatrixTypeNested& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
Eigen::SparseSelfAdjointView::operator *	src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)
Eigen::SparseSelfAdjointView::operator *	src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
Eigen::SparseSelfAdjointView::operator *	src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView	access:friend	signature:(const SparseMatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)
Eigen::SparseSelfAdjointView::operator *	src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseMatrixBase<OtherDerived>& rhs) const
Eigen::SparseSelfAdjointView::operator =	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView& src)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSelfAdjointView& src)
Eigen::SparseSelfAdjointView::operator =	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)
Eigen::SparseSelfAdjointView::operator =	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)
Eigen::SparseSelfAdjointView::rankUpdate	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& rankUpdate(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha = Scalar(1));$/;"	p	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha = Scalar(1))
Eigen::SparseSelfAdjointView::rankUpdate	src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<MatrixType,UpLo>::rankUpdate(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SparseSelfAdjointView	signature:(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha)
Eigen::SparseSelfAdjointView::rows	src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
Eigen::SparseSelfAdjointView::twistedBy	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct<_MatrixTypeNested,UpLo> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const
Eigen::SparseSparseProduct	src/SparseCore/SparseProduct.h	/^class SparseSparseProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,SparseMatrixBase
Eigen::SparseSparseProduct::Base	src/SparseCore/SparseProduct.h	/^    typedef SparseMatrixBase<SparseSparseProduct> Base;$/;"	t	class:Eigen::SparseSparseProduct	access:public
Eigen::SparseSparseProduct::SparseSparseProduct	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SparseSparseProduct::SparseSparseProduct	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs, const RealScalar& tolerance)$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs, const RealScalar& tolerance)
Eigen::SparseSparseProduct::_LhsNested	src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseSparseProduct	access:private
Eigen::SparseSparseProduct::_RhsNested	src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseSparseProduct	access:private
Eigen::SparseSparseProduct::cols	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
Eigen::SparseSparseProduct::evalTo	src/SparseCore/SparseProduct.h	/^    void evalTo(Dest& result) const$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(Dest& result) const
Eigen::SparseSparseProduct::init	src/SparseCore/SparseProduct.h	/^    void init()$/;"	f	class:Eigen::SparseSparseProduct	access:protected	signature:()
Eigen::SparseSparseProduct::lhs	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
Eigen::SparseSparseProduct::m_conservative	src/SparseCore/SparseProduct.h	/^    bool m_conservative;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
Eigen::SparseSparseProduct::m_lhs	src/SparseCore/SparseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
Eigen::SparseSparseProduct::m_rhs	src/SparseCore/SparseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
Eigen::SparseSparseProduct::m_tolerance	src/SparseCore/SparseProduct.h	/^    RealScalar m_tolerance;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
Eigen::SparseSparseProduct::pruned	src/SparseCore/SparseProduct.h	/^    SparseSparseProduct pruned(const Scalar& reference = 0, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision()) const$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Scalar& reference = 0, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision()) const
Eigen::SparseSparseProduct::rhs	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
Eigen::SparseSparseProduct::rows	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
Eigen::SparseSparseProductReturnType	src/SparseCore/SparseProduct.h	/^struct SparseSparseProductReturnType$/;"	s	namespace:Eigen
Eigen::SparseSparseProductReturnType::Index	src/SparseCore/SparseProduct.h	/^  typedef typename internal::traits<Lhs>::Index Index;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Eigen::SparseSparseProductReturnType::LhsNested	src/SparseCore/SparseProduct.h	/^    typename internal::nested<Lhs,Rhs::RowsAtCompileTime>::type>::type LhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Eigen::SparseSparseProductReturnType::LhsRowMajor	src/SparseCore/SparseProduct.h	/^    LhsRowMajor = internal::traits<Lhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon451
Eigen::SparseSparseProductReturnType::RhsNested	src/SparseCore/SparseProduct.h	/^    typename internal::nested<Rhs,Lhs::RowsAtCompileTime>::type>::type RhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Eigen::SparseSparseProductReturnType::RhsRowMajor	src/SparseCore/SparseProduct.h	/^    RhsRowMajor = internal::traits<Rhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon451
Eigen::SparseSparseProductReturnType::Scalar	src/SparseCore/SparseProduct.h	/^  typedef typename internal::traits<Lhs>::Scalar Scalar;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Eigen::SparseSparseProductReturnType::TransposeLhs	src/SparseCore/SparseProduct.h	/^    TransposeLhs = LhsRowMajor && (!RhsRowMajor)$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon451
Eigen::SparseSparseProductReturnType::TransposeRhs	src/SparseCore/SparseProduct.h	/^    TransposeRhs = (!LhsRowMajor) && RhsRowMajor,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon451
Eigen::SparseSparseProductReturnType::Type	src/SparseCore/SparseProduct.h	/^  typedef SparseSparseProduct<LhsNested, RhsNested> Type;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Eigen::SparseSymmetricPermutationProduct	src/SparseCore/SparseSelfAdjointView.h	/^class SparseSymmetricPermutationProduct$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::SparseSymmetricPermutationProduct::Index	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseSymmetricPermutationProduct::MatrixTypeNested	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseSymmetricPermutationProduct::Perm	src/SparseCore/SparseSelfAdjointView.h	/^    typedef PermutationMatrix<Dynamic,Dynamic,Index> Perm;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:protected
Eigen::SparseSymmetricPermutationProduct::Scalar	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseSymmetricPermutationProduct::SparseSymmetricPermutationProduct	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct(const MatrixType& mat, const Perm& perm)$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(const MatrixType& mat, const Perm& perm)
Eigen::SparseSymmetricPermutationProduct::VectorI	src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseSymmetricPermutationProduct::_MatrixTypeNested	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseSymmetricPermutationProduct::cols	src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:() const
Eigen::SparseSymmetricPermutationProduct::evalTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestType,unsigned int DestUpLo> void evalTo(SparseSelfAdjointView<DestType,DestUpLo>& dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(SparseSelfAdjointView<DestType,DestUpLo>& dest) const
Eigen::SparseSymmetricPermutationProduct::evalTo	src/SparseCore/SparseSelfAdjointView.h	/^    void evalTo(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const
Eigen::SparseSymmetricPermutationProduct::m_matrix	src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct	access:protected
Eigen::SparseSymmetricPermutationProduct::m_perm	src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& m_perm;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct	access:protected
Eigen::SparseSymmetricPermutationProduct::rows	src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:() const
Eigen::SparseTimeDenseProduct	src/SparseCore/SparseDenseProduct.h	/^class SparseTimeDenseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::SparseTimeDenseProduct::SparseTimeDenseProduct	src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseTimeDenseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SparseTimeDenseProduct::operator =	src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct& operator=(const SparseTimeDenseProduct&);$/;"	p	class:Eigen::SparseTimeDenseProduct	access:private	signature:(const SparseTimeDenseProduct&)
Eigen::SparseTimeDenseProduct::scaleAndAddTo	src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::SparseTimeDenseProduct	access:public	signature:(Dest& dest, const Scalar& alpha) const
Eigen::SparseTriangularView	src/SparseCore/SparseTriangularView.h	/^template<typename MatrixType, int Mode> class SparseTriangularView$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseTriangularView::HasUnitDiag	src/SparseCore/SparseTriangularView.h	/^           HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::SparseTriangularView::__anon453
Eigen::SparseTriangularView::InnerIterator	src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::InnerIterator : public MatrixTypeNestedCleaned::InnerIterator$/;"	c	class:Eigen::SparseTriangularView	inherits:MatrixTypeNestedCleaned::InnerIterator
Eigen::SparseTriangularView::InnerIterator::Base	src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::InnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::InnerIterator	access:private
Eigen::SparseTriangularView::InnerIterator::Index	src/SparseCore/SparseTriangularView.h	/^    typedef typename SparseTriangularView::Index Index;$/;"	t	class:Eigen::SparseTriangularView::InnerIterator	access:private
Eigen::SparseTriangularView::InnerIterator::InnerIterator	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:(const SparseTriangularView& view, Index outer)
Eigen::SparseTriangularView::InnerIterator::col	src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return (MatrixType::Flags&RowMajorBit ? this->index() : Base::outer()); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::InnerIterator::index	src/SparseCore/SparseTriangularView.h	/^    inline Index index() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::InnerIterator::m_returnOne	src/SparseCore/SparseTriangularView.h	/^    bool m_returnOne;$/;"	m	class:Eigen::SparseTriangularView::InnerIterator	access:protected
Eigen::SparseTriangularView::InnerIterator::operator ++	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:()
Eigen::SparseTriangularView::InnerIterator::operator bool	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::InnerIterator::row	src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return (MatrixType::Flags&RowMajorBit ? Base::outer() : this->index()); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::InnerIterator::value	src/SparseCore/SparseTriangularView.h	/^    inline Scalar value() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::MatrixTypeNested	src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseTriangularView	access:public
Eigen::SparseTriangularView::MatrixTypeNestedCleaned	src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SparseTriangularView	access:public
Eigen::SparseTriangularView::MatrixTypeNestedNonRef	src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	class:Eigen::SparseTriangularView	access:public
Eigen::SparseTriangularView::ReverseInnerIterator	src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::ReverseInnerIterator : public MatrixTypeNestedCleaned::ReverseInnerIterator$/;"	c	class:Eigen::SparseTriangularView	inherits:MatrixTypeNestedCleaned::ReverseInnerIterator
Eigen::SparseTriangularView::ReverseInnerIterator::Base	src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::ReverseInnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:private
Eigen::SparseTriangularView::ReverseInnerIterator::Index	src/SparseCore/SparseTriangularView.h	/^    typedef typename SparseTriangularView::Index Index;$/;"	t	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:private
Eigen::SparseTriangularView::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:(const SparseTriangularView& view, Index outer)
Eigen::SparseTriangularView::ReverseInnerIterator::col	src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return Base::col(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::ReverseInnerIterator::operator --	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:()
Eigen::SparseTriangularView::ReverseInnerIterator::operator bool	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::ReverseInnerIterator::row	src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return Base::row(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::SkipDiag	src/SparseCore/SparseTriangularView.h	/^           SkipDiag = (Mode&ZeroDiag) ? 1 : 0,$/;"	e	enum:Eigen::SparseTriangularView::__anon453
Eigen::SparseTriangularView::SkipFirst	src/SparseCore/SparseTriangularView.h	/^    enum { SkipFirst = ((Mode&Lower) && !(MatrixType::Flags&RowMajorBit))$/;"	e	enum:Eigen::SparseTriangularView::__anon453
Eigen::SparseTriangularView::SkipLast	src/SparseCore/SparseTriangularView.h	/^           SkipLast = !SkipFirst,$/;"	e	enum:Eigen::SparseTriangularView::__anon453
Eigen::SparseTriangularView::SparseTriangularView	src/SparseCore/SparseTriangularView.h	/^    inline SparseTriangularView(const MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:(const MatrixType& matrix)
Eigen::SparseTriangularView::cols	src/SparseCore/SparseTriangularView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
Eigen::SparseTriangularView::m_matrix	src/SparseCore/SparseTriangularView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseTriangularView	access:protected
Eigen::SparseTriangularView::nestedExpression	src/SparseCore/SparseTriangularView.h	/^    inline const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
Eigen::SparseTriangularView::rows	src/SparseCore/SparseTriangularView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
Eigen::SparseTriangularView::solve	src/SparseCore/SparseTriangularView.h	/^    solve(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solve	src/SparseCore/TriangularSolver.h	/^SparseTriangularView<ExpressionType,Mode>::solve(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solveInPlace	src/SparseCore/SparseTriangularView.h	/^    template<typename OtherDerived> void solveInPlace(MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(MatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solveInPlace	src/SparseCore/SparseTriangularView.h	/^    template<typename OtherDerived> void solveInPlace(SparseMatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(SparseMatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solveInPlace	src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(MatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solveInPlace	src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(SparseMatrixBase<OtherDerived>& other) const
Eigen::SparseVector	src/SparseCore/SparseVector.h	/^class SparseVector$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseVector::InnerIterator	src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseVector
Eigen::SparseVector::InnerIterator::InnerIterator	src/SparseCore/SparseVector.h	/^    InnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:(const SparseVector& vec, Index outer=0)
Eigen::SparseVector::InnerIterator::InnerIterator	src/SparseCore/SparseVector.h	/^    InnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:(const internal::CompressedStorage<Scalar,Index>& data)
Eigen::SparseVector::InnerIterator::col	src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator::index	src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator::m_data	src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
Eigen::SparseVector::InnerIterator::m_end	src/SparseCore/SparseVector.h	/^    const Index m_end;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
Eigen::SparseVector::InnerIterator::m_id	src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
Eigen::SparseVector::InnerIterator::operator ++	src/SparseCore/SparseVector.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:()
Eigen::SparseVector::InnerIterator::operator bool	src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator::row	src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator::value	src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator::valueRef	src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id)); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:()
Eigen::SparseVector::IsColVector	src/SparseCore/SparseVector.h	/^    enum { IsColVector = internal::traits<SparseVector>::IsColVector };$/;"	e	enum:Eigen::SparseVector::__anon458
Eigen::SparseVector::Options	src/SparseCore/SparseVector.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseVector::__anon459
Eigen::SparseVector::ReverseInnerIterator	src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseVector
Eigen::SparseVector::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:(const SparseVector& vec, Index outer=0)
Eigen::SparseVector::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:(const internal::CompressedStorage<Scalar,Index>& data)
Eigen::SparseVector::ReverseInnerIterator::col	src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator::index	src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator::m_data	src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
Eigen::SparseVector::ReverseInnerIterator::m_id	src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
Eigen::SparseVector::ReverseInnerIterator::m_start	src/SparseCore/SparseVector.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
Eigen::SparseVector::ReverseInnerIterator::operator --	src/SparseCore/SparseVector.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:()
Eigen::SparseVector::ReverseInnerIterator::operator bool	src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator::row	src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator::value	src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator::valueRef	src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id-1)); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:()
Eigen::SparseVector::SparseBase	src/SparseCore/SparseVector.h	/^    typedef SparseMatrixBase<SparseVector> SparseBase;$/;"	t	class:Eigen::SparseVector	access:private
Eigen::SparseVector::SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector() : m_size(0) { check_template_parameters(); resize(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector(Index rows, Index cols) : m_size(0) { check_template_parameters(); resize(rows,cols); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index rows, Index cols)
Eigen::SparseVector::SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector(Index size) : m_size(0) { check_template_parameters(); resize(size); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index size)
Eigen::SparseVector::SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseVector::SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseVector& other)
Eigen::SparseVector::Storage	src/SparseCore/SparseVector.h	/^    typedef internal::CompressedStorage<Scalar,Index> Storage;$/;"	t	class:Eigen::SparseVector	access:public
Eigen::SparseVector::_data	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Storage& _data() { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::_data	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED const Storage& _data() const { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::check_template_parameters	src/SparseCore/SparseVector.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SparseVector	access:protected	signature:()
Eigen::SparseVector::coeff	src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index i) const$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i) const
Eigen::SparseVector::coeff	src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col) const
Eigen::SparseVector::coeffRef	src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::coeffRef	src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col)
Eigen::SparseVector::cols	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsColVector ? 1 : m_size; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::data	src/SparseCore/SparseVector.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::data	src/SparseCore/SparseVector.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::endFill	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::fill	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::fill	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index r, Index c)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index r, Index c)
Eigen::SparseVector::fillrand	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::fillrand	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index r, Index c)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index r, Index c)
Eigen::SparseVector::finalize	src/SparseCore/SparseVector.h	/^    inline void finalize() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::innerIndexPtr	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::innerIndexPtr	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::innerSize	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index innerSize() const { return m_size; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::insert	src/SparseCore/SparseVector.h	/^    Scalar& insert(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::insert	src/SparseCore/SparseVector.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col)
Eigen::SparseVector::insertBack	src/SparseCore/SparseVector.h	/^    inline Scalar& insertBack(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::insertBackByOuterInner	src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index outer, Index inner)
Eigen::SparseVector::m_data	src/SparseCore/SparseVector.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseVector	access:protected
Eigen::SparseVector::m_size	src/SparseCore/SparseVector.h	/^    Index m_size;$/;"	m	class:Eigen::SparseVector	access:protected
Eigen::SparseVector::nonZeros	src/SparseCore/SparseVector.h	/^    inline Index nonZeros() const  { return static_cast<Index>(m_data.size()); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::operator <<	src/SparseCore/SparseVector.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseVector& m)$/;"	f	class:Eigen::SparseVector	access:friend	signature:(std::ostream & s, const SparseVector& m)
Eigen::SparseVector::operator =	src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseVector::operator =	src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
Eigen::SparseVector::operator =	src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseVector& other)
Eigen::SparseVector::outerSize	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index outerSize() const { return 1; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::prune	src/SparseCore/SparseVector.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseVector	access:public	signature:(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())
Eigen::SparseVector::reserve	src/SparseCore/SparseVector.h	/^    inline void reserve(Index reserveSize) { m_data.reserve(reserveSize); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index reserveSize)
Eigen::SparseVector::resize	src/SparseCore/SparseVector.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index newSize)
Eigen::SparseVector::resize	src/SparseCore/SparseVector.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index rows, Index cols)
Eigen::SparseVector::resizeNonZeros	src/SparseCore/SparseVector.h	/^    void resizeNonZeros(Index size) { m_data.resize(size); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index size)
Eigen::SparseVector::rows	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsColVector ? m_size : 1; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::setZero	src/SparseCore/SparseVector.h	/^    inline void setZero() { m_data.clear(); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::startFill	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void startFill(Index reserve)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index reserve)
Eigen::SparseVector::startVec	src/SparseCore/SparseVector.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index outer)
Eigen::SparseVector::sum	src/SparseCore/SparseRedux.h	/^SparseVector<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseVector	signature:() const
Eigen::SparseVector::sum	src/SparseCore/SparseVector.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::swap	src/SparseCore/SparseVector.h	/^    inline void swap(SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(SparseVector& other)
Eigen::SparseVector::valuePtr	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::valuePtr	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::~SparseVector	src/SparseCore/SparseVector.h	/^    inline ~SparseVector() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseView	src/SparseCore/SparseView.h	/^class SparseView : public SparseMatrixBase<SparseView<MatrixType> >$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseView::InnerIterator	src/SparseCore/SparseView.h	/^class SparseView<MatrixType>::InnerIterator : public _MatrixTypeNested::InnerIterator$/;"	c	class:Eigen::SparseView	inherits:_MatrixTypeNested::InnerIterator
Eigen::SparseView::InnerIterator::Index	src/SparseCore/SparseView.h	/^  typedef typename SparseView::Index Index;$/;"	t	class:Eigen::SparseView::InnerIterator	access:private
Eigen::SparseView::InnerIterator::InnerIterator	src/SparseCore/SparseView.h	/^  InnerIterator(const SparseView& view, Index outer) :$/;"	f	class:Eigen::SparseView::InnerIterator	access:public	signature:(const SparseView& view, Index outer)
Eigen::SparseView::InnerIterator::IterBase	src/SparseCore/SparseView.h	/^  typedef typename _MatrixTypeNested::InnerIterator IterBase;$/;"	t	class:Eigen::SparseView::InnerIterator	access:public
Eigen::SparseView::InnerIterator::incrementToNonZero	src/SparseCore/SparseView.h	/^  void incrementToNonZero()$/;"	f	class:Eigen::SparseView::InnerIterator	access:private	signature:()
Eigen::SparseView::InnerIterator::m_view	src/SparseCore/SparseView.h	/^  const SparseView& m_view;$/;"	m	class:Eigen::SparseView::InnerIterator	access:protected
Eigen::SparseView::InnerIterator::operator ++	src/SparseCore/SparseView.h	/^  EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseView::InnerIterator	access:public	signature:()
Eigen::SparseView::MatrixTypeNested	src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseView	access:private
Eigen::SparseView::SparseView	src/SparseCore/SparseView.h	/^  SparseView(const MatrixType& mat, const Scalar& m_reference = Scalar(0),$/;"	f	class:Eigen::SparseView	access:public	signature:(const MatrixType& mat, const Scalar& m_reference = Scalar(0), typename NumTraits<Scalar>::Real m_epsilon = NumTraits<Scalar>::dummy_precision())
Eigen::SparseView::_MatrixTypeNested	src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseView	access:private
Eigen::SparseView::cols	src/SparseCore/SparseView.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
Eigen::SparseView::innerSize	src/SparseCore/SparseView.h	/^  inline Index innerSize() const { return m_matrix.innerSize(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
Eigen::SparseView::m_epsilon	src/SparseCore/SparseView.h	/^  typename NumTraits<Scalar>::Real m_epsilon;$/;"	m	class:Eigen::SparseView	access:protected
Eigen::SparseView::m_matrix	src/SparseCore/SparseView.h	/^  MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseView	access:protected
Eigen::SparseView::m_reference	src/SparseCore/SparseView.h	/^  Scalar m_reference;$/;"	m	class:Eigen::SparseView	access:protected
Eigen::SparseView::outerSize	src/SparseCore/SparseView.h	/^  inline Index outerSize() const { return m_matrix.outerSize(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
Eigen::SparseView::rows	src/SparseCore/SparseView.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
Eigen::Specialized	src/Core/util/Constants.h	/^  Specialized,$/;"	e	enum:Eigen::__anon65
Eigen::StreamPrecision	src/Core/IO.h	/^enum { StreamPrecision = -1,$/;"	e	enum:Eigen::__anon273
Eigen::StrictlyLower	src/Core/util/Constants.h	/^  StrictlyLower=ZeroDiag|Lower, $/;"	e	enum:Eigen::__anon61
Eigen::StrictlyUpper	src/Core/util/Constants.h	/^  StrictlyUpper=ZeroDiag|Upper,$/;"	e	enum:Eigen::__anon61
Eigen::Stride	src/Core/Stride.h	/^class Stride$/;"	c	namespace:Eigen
Eigen::Stride::Index	src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::Stride	access:public
Eigen::Stride::InnerStrideAtCompileTime	src/Core/Stride.h	/^      InnerStrideAtCompileTime = _InnerStrideAtCompileTime,$/;"	e	enum:Eigen::Stride::__anon322
Eigen::Stride::OuterStrideAtCompileTime	src/Core/Stride.h	/^      OuterStrideAtCompileTime = _OuterStrideAtCompileTime$/;"	e	enum:Eigen::Stride::__anon322
Eigen::Stride::Stride	src/Core/Stride.h	/^    Stride()$/;"	f	class:Eigen::Stride	access:public	signature:()
Eigen::Stride::Stride	src/Core/Stride.h	/^    Stride(Index outerStride, Index innerStride)$/;"	f	class:Eigen::Stride	access:public	signature:(Index outerStride, Index innerStride)
Eigen::Stride::Stride	src/Core/Stride.h	/^    Stride(const Stride& other)$/;"	f	class:Eigen::Stride	access:public	signature:(const Stride& other)
Eigen::Stride::inner	src/Core/Stride.h	/^    inline Index inner() const { return m_inner.value(); }$/;"	f	class:Eigen::Stride	access:public	signature:() const
Eigen::Stride::m_inner	src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;$/;"	m	class:Eigen::Stride	access:protected
Eigen::Stride::m_outer	src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;$/;"	m	class:Eigen::Stride	access:protected
Eigen::Stride::outer	src/Core/Stride.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::Stride	access:public	signature:() const
Eigen::Success	src/Core/util/Constants.h	/^  Success = 0,        $/;"	e	enum:Eigen::ComputationInfo
Eigen::SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^class SuperILU : public SuperLUBase<_MatrixType,SuperILU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:SuperLUBase
Eigen::SuperILU::Base	src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperILU> Base;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::Index	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::RealScalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::Scalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU() : Base() { init(); }$/;"	f	class:Eigen::SuperILU	access:public	signature:()
Eigen::SuperILU::SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(SuperILU& ) { }$/;"	f	class:Eigen::SuperILU	access:private	signature:(SuperILU& )
Eigen::SuperILU::SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperILU::_solve	src/SuperLUSupport/SuperLUSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const;$/;"	p	class:Eigen::SuperILU	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::SuperILU::_solve	src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperILU	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
Eigen::SuperILU::analyzePattern	src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperILU::factorize	src/SuperLUSupport/SuperLUSupport.h	/^    void factorize(const MatrixType& matrix);$/;"	p	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperILU::factorize	src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperILU	signature:(const MatrixType& a)
Eigen::SuperILU::init	src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperILU	access:protected	signature:()
Eigen::SuperILU::~SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperILU()$/;"	f	class:Eigen::SuperILU	access:public	signature:()
Eigen::SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^class SuperLU : public SuperLUBase<_MatrixType,SuperLU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:SuperLUBase
Eigen::SuperLU::Base	src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperLU> Base;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::Index	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::IntColVectorType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntColVectorType IntColVectorType;    $/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::IntRowVectorType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntRowVectorType IntRowVectorType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::LMatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType, Lower|UnitDiag>  LMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::LUMatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::LUMatrixType LUMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::RealScalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::Scalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU() : Base() { init(); }$/;"	f	class:Eigen::SuperLU	access:public	signature:()
Eigen::SuperLU::SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(SuperLU& ) { }$/;"	f	class:Eigen::SuperLU	access:private	signature:(SuperLU& )
Eigen::SuperLU::SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperLU::UMatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType,  Upper>           UMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::_solve	src/SuperLUSupport/SuperLUSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const;$/;"	p	class:Eigen::SuperLU	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::SuperLU::_solve	src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperLU	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
Eigen::SuperLU::analyzePattern	src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperLU::determinant	src/SuperLUSupport/SuperLUSupport.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::determinant	src/SuperLUSupport/SuperLUSupport.h	/^typename SuperLU<MatrixType>::Scalar SuperLU<MatrixType>::determinant() const$/;"	f	class:Eigen::SuperLU	signature:() const
Eigen::SuperLU::factorize	src/SuperLUSupport/SuperLUSupport.h	/^    void factorize(const MatrixType& matrix);$/;"	p	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperLU::factorize	src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperLU	signature:(const MatrixType& a)
Eigen::SuperLU::init	src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLU	access:protected	signature:()
Eigen::SuperLU::matrixL	src/SuperLUSupport/SuperLUSupport.h	/^    inline const LMatrixType& matrixL() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::matrixU	src/SuperLUSupport/SuperLUSupport.h	/^    inline const UMatrixType& matrixU() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::permutationP	src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::permutationQ	src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::~SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLU()$/;"	f	class:Eigen::SuperLU	access:public	signature:()
Eigen::SuperLUBase	src/SuperLUSupport/SuperLUSupport.h	/^class SuperLUBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::SuperLUBase::Index	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::IntColVectorType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;    $/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::IntRowVectorType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::LUMatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::RealScalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::Scalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::SuperLUBase	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase() {}$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
Eigen::SuperLUBase::SuperLUBase	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase(SuperLUBase& ) { }$/;"	f	class:Eigen::SuperLUBase	access:private	signature:(SuperLUBase& )
Eigen::SuperLUBase::Vector	src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::analyzePattern	src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& \/*matrix*\/)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixType& )
Eigen::SuperLUBase::clearFactors	src/SuperLUSupport/SuperLUSupport.h	/^    void clearFactors()$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:()
Eigen::SuperLUBase::cols	src/SuperLUSupport/SuperLUSupport.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
Eigen::SuperLUBase::compute	src/SuperLUSupport/SuperLUSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixType& matrix)
Eigen::SuperLUBase::derived	src/SuperLUSupport/SuperLUSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
Eigen::SuperLUBase::derived	src/SuperLUSupport/SuperLUSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
Eigen::SuperLUBase::dumpMemory	src/SuperLUSupport/SuperLUSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(Stream& )
Eigen::SuperLUBase::extractData	src/SuperLUSupport/SuperLUSupport.h	/^    void extractData() const;$/;"	p	class:Eigen::SuperLUBase	access:protected	signature:() const
Eigen::SuperLUBase::extractData	src/SuperLUSupport/SuperLUSupport.h	/^void SuperLUBase<MatrixType,Derived>::extractData() const$/;"	f	class:Eigen::SuperLUBase	signature:() const
Eigen::SuperLUBase::info	src/SuperLUSupport/SuperLUSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
Eigen::SuperLUBase::init	src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:()
Eigen::SuperLUBase::initFactorization	src/SuperLUSupport/SuperLUSupport.h	/^    void initFactorization(const MatrixType& a)$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:(const MatrixType& a)
Eigen::SuperLUBase::m_analysisIsOk	src/SuperLUSupport/SuperLUSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_extractedDataAreDirty	src/SuperLUSupport/SuperLUSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_factorizationIsOk	src/SuperLUSupport/SuperLUSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_info	src/SuperLUSupport/SuperLUSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_isInitialized	src/SuperLUSupport/SuperLUSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_l	src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_matrix	src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_matrix;  \/\/ copy of the factorized matrix$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_p	src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_q	src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluA	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluA;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluB	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluBerr	src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluCscale	src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluEqued	src/SuperLUSupport/SuperLUSupport.h	/^    mutable char m_sluEqued;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluEtree	src/SuperLUSupport/SuperLUSupport.h	/^    mutable std::vector<int> m_sluEtree;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluFerr	src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluL	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluOptions	src/SuperLUSupport/SuperLUSupport.h	/^    mutable superlu_options_t m_sluOptions;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluRscale	src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluStat	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperLUStat_t m_sluStat;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluU	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluX	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_u	src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::options	src/SuperLUSupport/SuperLUSupport.h	/^    inline superlu_options_t& options() { return m_sluOptions; }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
Eigen::SuperLUBase::rows	src/SuperLUSupport/SuperLUSupport.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
Eigen::SuperLUBase::solve	src/SuperLUSupport/SuperLUSupport.h	/^    inline const internal::solve_retval<SuperLUBase, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::SuperLUBase::solve	src/SuperLUSupport/SuperLUSupport.h	/^    inline const internal::sparse_solve_retval<SuperLUBase, Rhs> solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::SuperLUBase::~SuperLUBase	src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLUBase()$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
Eigen::SwapWrapper	src/Core/Swap.h	/^template<typename ExpressionType> class SwapWrapper$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::SwapWrapper::Base	src/Core/Swap.h	/^    typedef typename internal::dense_xpr_base<SwapWrapper>::type Base;$/;"	t	class:Eigen::SwapWrapper	access:public
Eigen::SwapWrapper::Packet	src/Core/Swap.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SwapWrapper	access:public
Eigen::SwapWrapper::ScalarWithConstIfNotLvalue	src/Core/Swap.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::SwapWrapper	access:public
Eigen::SwapWrapper::SwapWrapper	src/Core/Swap.h	/^    inline SwapWrapper(ExpressionType& xpr) : m_expression(xpr) {}$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(ExpressionType& xpr)
Eigen::SwapWrapper::coeffRef	src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index) const
Eigen::SwapWrapper::coeffRef	src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index)
Eigen::SwapWrapper::coeffRef	src/Core/Swap.h	/^    inline Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index rowId, Index colId) const
Eigen::SwapWrapper::coeffRef	src/Core/Swap.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index rowId, Index colId)
Eigen::SwapWrapper::cols	src/Core/Swap.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::copyCoeff	src/Core/Swap.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::SwapWrapper::copyCoeff	src/Core/Swap.h	/^    void copyCoeff(Index rowId, Index colId, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index rowId, Index colId, const DenseBase<OtherDerived>& other)
Eigen::SwapWrapper::copyPacket	src/Core/Swap.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::SwapWrapper::copyPacket	src/Core/Swap.h	/^    void copyPacket(Index rowId, Index colId, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index rowId, Index colId, const DenseBase<OtherDerived>& other)
Eigen::SwapWrapper::data	src/Core/Swap.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:()
Eigen::SwapWrapper::data	src/Core/Swap.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::expression	src/Core/Swap.h	/^    ExpressionType& expression() const { return m_expression; }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::innerStride	src/Core/Swap.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::m_expression	src/Core/Swap.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::SwapWrapper	access:protected
Eigen::SwapWrapper::outerStride	src/Core/Swap.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::rows	src/Core/Swap.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::Symmetric	src/Core/util/Constants.h	/^  Symmetric=0x20$/;"	e	enum:Eigen::__anon61
Eigen::TopLeft	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
Eigen::TopRight	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
Eigen::Transform	src/Eigen2Support/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Eigen::Transform	src/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Eigen::Transform2d	src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,2> Transform2d;$/;"	t	namespace:Eigen
Eigen::Transform2f	src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,2> Transform2f;$/;"	t	namespace:Eigen
Eigen::Transform3d	src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,3> Transform3d;$/;"	t	namespace:Eigen
Eigen::Transform3f	src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,3> Transform3f;$/;"	t	namespace:Eigen
Eigen::Transform::AffinePart	src/Geometry/Transform.h	/^                              Block<MatrixType,Dim,HDim> >::type AffinePart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstAffinePart	src/Geometry/Transform.h	/^                              const Block<const MatrixType,Dim,HDim> >::type ConstAffinePart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstLinearPart	src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,Dim> ConstLinearPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstLinearPart	src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> ConstLinearPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstMatrixType	src/Geometry/Transform.h	/^  typedef const MatrixType ConstMatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstTranslationPart	src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,1> ConstTranslationPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstTranslationPart	src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,1,int(Mode)==(AffineCompact)> ConstTranslationPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::Dim	src/Eigen2Support/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon346
Eigen::Transform::Dim	src/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon384
Eigen::Transform::HDim	src/Eigen2Support/Geometry/Transform.h	/^    HDim = _Dim+1   \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon346
Eigen::Transform::HDim	src/Geometry/Transform.h	/^    HDim = _Dim+1,  \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon384
Eigen::Transform::Identity	src/Eigen2Support/Geometry/Transform.h	/^  static const typename MatrixType::IdentityReturnType Identity()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::Identity	src/Geometry/Transform.h	/^  static const Transform Identity()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::Index	src/Geometry/Transform.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::LinearMatrixType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::LinearMatrixType	src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim,Options> LinearMatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::LinearPart	src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim> LinearPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::LinearPart	src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> LinearPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::MatrixType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,HDim,HDim> MatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::MatrixType	src/Geometry/Transform.h	/^  typedef typename internal::make_proper_matrix_type<Scalar,Rows,HDim,Options>::type MatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::Mode	src/Geometry/Transform.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::Transform::__anon384
Eigen::Transform::Options	src/Geometry/Transform.h	/^    Options = _Options,$/;"	e	enum:Eigen::Transform::__anon384
Eigen::Transform::Rows	src/Geometry/Transform.h	/^    Rows = int(Mode)==(AffineCompact) ? Dim : HDim$/;"	e	enum:Eigen::Transform::__anon384
Eigen::Transform::Scalar	src/Eigen2Support/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::Scalar	src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ScalingType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform() { }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r) { *this = r; }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived, Dim>& r)
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const ScalingType& s) { *this = s; }$/;"	f	class:Eigen::Transform	access:public	signature:(const ScalingType& s)
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<OtherScalarType,Dim>& other)
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t) { *this = t; }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Eigen::Transform::Transform	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  Transform(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline Transform()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline Transform(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline Transform(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,Mode,OtherOptions>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,Mode,OtherOptions>& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r)$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived, Dim>& r)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim,Mode,Options>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<OtherScalarType,Dim,Mode,Options>& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t)$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Eigen::Transform::Transform	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Eigen::Transform::TransformTimeDiagonalMode	src/Geometry/Transform.h	/^  enum { TransformTimeDiagonalMode = ((Mode==int(Isometry))?Affine:int(Mode)) };$/;"	e	enum:Eigen::Transform::__anon385
Eigen::Transform::TransformTimeDiagonalReturnType	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,TransformTimeDiagonalMode> TransformTimeDiagonalReturnType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::TranslationPart	src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1> TranslationPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::TranslationPart	src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1,int(Mode)==(AffineCompact)> TranslationPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::TranslationType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::TranslationType	src/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::VectorType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::VectorType	src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::affine	src/Geometry/Transform.h	/^  inline AffinePart affine() { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::affine	src/Geometry/Transform.h	/^  inline ConstAffinePart affine() const { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::cast	src/Eigen2Support/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::cast	src/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim,Mode,Options> >::type cast() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::check_template_params	src/Geometry/Transform.h	/^    static EIGEN_STRONG_INLINE void check_template_params()$/;"	f	class:Eigen::Transform	access:protected	signature:()
Eigen::Transform::computeRotationScaling	src/Eigen2Support/Geometry/Transform.h	/^  void computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const;$/;"	p	class:Eigen::Transform	access:public	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
Eigen::Transform::computeRotationScaling	src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
Eigen::Transform::computeRotationScaling	src/Geometry/Transform.h	/^  void computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const;$/;"	p	class:Eigen::Transform	access:public	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
Eigen::Transform::computeRotationScaling	src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
Eigen::Transform::computeScalingRotation	src/Eigen2Support/Geometry/Transform.h	/^  void computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const;$/;"	p	class:Eigen::Transform	access:public	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
Eigen::Transform::computeScalingRotation	src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
Eigen::Transform::computeScalingRotation	src/Geometry/Transform.h	/^  void computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const;$/;"	p	class:Eigen::Transform	access:public	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
Eigen::Transform::computeScalingRotation	src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
Eigen::Transform::construct_from_matrix	src/Eigen2Support/Geometry/Transform.h	/^  struct construct_from_matrix$/;"	s	class:Eigen::Transform	access:public
Eigen::Transform::construct_from_matrix	src/Eigen2Support/Geometry/Transform.h	/^  template<typename OtherDerived> struct construct_from_matrix<OtherDerived, true>$/;"	s	class:Eigen::Transform	access:public
Eigen::Transform::construct_from_matrix::run	src/Eigen2Support/Geometry/Transform.h	/^    static inline void run(Transform *transform, const MatrixBase<OtherDerived>& other)$/;"	f	struct:Eigen::Transform::construct_from_matrix	access:public	signature:(Transform *transform, const MatrixBase<OtherDerived>& other)
Eigen::Transform::data	src/Eigen2Support/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::data	src/Eigen2Support/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::data	src/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::data	src/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::fromPositionOrientationScale	src/Eigen2Support/Geometry/Transform.h	/^  Transform& fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
Eigen::Transform::fromPositionOrientationScale	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
Eigen::Transform::fromPositionOrientationScale	src/Geometry/Transform.h	/^  Transform& fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
Eigen::Transform::fromPositionOrientationScale	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
Eigen::Transform::icc_11_workaround	src/Geometry/Transform.h	/^  template<int OtherMode,int OtherOptions> struct icc_11_workaround$/;"	s	class:Eigen::Transform	access:private
Eigen::Transform::icc_11_workaround::ProductType	src/Geometry/Transform.h	/^    typedef internal::transform_transform_product_impl<Transform,Transform<Scalar,Dim,OtherMode,OtherOptions> > ProductType;$/;"	t	struct:Eigen::Transform::icc_11_workaround	access:public
Eigen::Transform::icc_11_workaround::ResultType	src/Geometry/Transform.h	/^    typedef typename ProductType::ResultType ResultType;$/;"	t	struct:Eigen::Transform::icc_11_workaround	access:public
Eigen::Transform::inverse	src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType inverse(TransformTraits traits = Affine) const;$/;"	p	class:Eigen::Transform	access:public	signature:(TransformTraits traits = Affine) const
Eigen::Transform::inverse	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::inverse(TransformTraits traits) const$/;"	f	class:Eigen::Transform	signature:(TransformTraits traits) const
Eigen::Transform::inverse	src/Geometry/Transform.h	/^  inline Transform inverse(TransformTraits traits = (TransformTraits)Mode) const;$/;"	p	class:Eigen::Transform	access:public	signature:(TransformTraits traits = (TransformTraits)Mode) const
Eigen::Transform::inverse	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::inverse(TransformTraits hint) const$/;"	f	class:Eigen::Transform	signature:(TransformTraits hint) const
Eigen::Transform::isApprox	src/Eigen2Support/Geometry/Transform.h	/^  bool isApprox(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Transform::isApprox	src/Geometry/Transform.h	/^  bool isApprox(const Transform& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::Transform::linear	src/Eigen2Support/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::linear	src/Eigen2Support/Geometry/Transform.h	/^  inline LinearPart linear() { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::linear	src/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return ConstLinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::linear	src/Geometry/Transform.h	/^  inline LinearPart linear() { return LinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::linearExt	src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::linearExt	src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::m_matrix	src/Eigen2Support/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform	access:protected
Eigen::Transform::m_matrix	src/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform	access:protected
Eigen::Transform::makeAffine	src/Geometry/Transform.h	/^  void makeAffine()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::matrix	src/Eigen2Support/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::matrix	src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::matrix	src/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::matrix	src/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::operator ()	src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar operator() (int row, int col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(int row, int col) const
Eigen::Transform::operator ()	src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar& operator() (int row, int col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(int row, int col)
Eigen::Transform::operator ()	src/Geometry/Transform.h	/^  inline Scalar operator() (Index row, Index col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(Index row, Index col) const
Eigen::Transform::operator ()	src/Geometry/Transform.h	/^  inline Scalar& operator() (Index row, Index col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(Index row, Index col)
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^  friend inline Transform operator*(const LinearMatrixType& mat, const Transform& t)$/;"	f	class:Eigen::Transform	access:friend	signature:(const LinearMatrixType& mat, const Transform& t)
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const RotationBase<Derived,Dim>& r) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const ScalingType& s) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const ScalingType& s) const
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const TranslationType& t) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t) const
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const MatrixBase<OtherDerived> &a, const Transform &b)
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^  operator * (const Transform& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other) const
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const ScalingType& s) const$/;"	f	class:Eigen::Transform	signature:(const ScalingType& s) const
Eigen::Transform::operator *	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t) const
Eigen::Transform::operator *	src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const DiagonalBase<DiagonalDerived> &a, const Transform &b)
Eigen::Transform::operator *	src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &b) const$/;"	f	class:Eigen::Transform	access:public	signature:(const DiagonalBase<DiagonalDerived> &b) const
Eigen::Transform::operator *	src/Geometry/Transform.h	/^    operator * (const EigenBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const EigenBase<OtherDerived> &a, const Transform &b)
Eigen::Transform::operator *	src/Geometry/Transform.h	/^    operator * (const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const
Eigen::Transform::operator *	src/Geometry/Transform.h	/^  inline Transform operator*(const RotationBase<Derived,Dim>& r) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Transform::operator *	src/Geometry/Transform.h	/^  inline Transform operator*(const TranslationType& t) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t) const
Eigen::Transform::operator *	src/Geometry/Transform.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?int(Affine):int(Mode))> operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s) const
Eigen::Transform::operator *	src/Geometry/Transform.h	/^  inline const Transform operator * (const Transform& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other) const
Eigen::Transform::operator *	src/Geometry/Transform.h	/^  operator * (const EigenBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived> &other) const
Eigen::Transform::operator *	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Transform::operator *	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t) const
Eigen::Transform::operator *=	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator *=	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const ScalingType& s) { return scale(s.coeffs()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const ScalingType& s)
Eigen::Transform::operator *=	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const DiagonalMatrix<Scalar,Dim>& s) { linear() *= s; return *this; }$/;"	f	class:Eigen::Transform	access:public	signature:(const DiagonalMatrix<Scalar,Dim>& s)
Eigen::Transform::operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const EigenBase<OtherDerived>& other) { return *this = *this * other; }$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::Transform::operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const UniformScaling<Scalar>& s) { return scale(s.factor()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const RotationBase<Derived,Dim>& r);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const ScalingType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const ScalingType& t)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const TranslationType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const ScalingType& s)$/;"	f	class:Eigen::Transform	signature:(const ScalingType& s)
Eigen::Transform::operator =	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^  Transform& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const RotationBase<Derived,Dim>& r);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const TranslationType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const UniformScaling<Scalar>& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& t)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t)
Eigen::Transform::operator =	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform	signature:(const UniformScaling<Scalar>& s)
Eigen::Transform::prerotate	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prerotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
Eigen::Transform::prerotate	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
Eigen::Transform::prerotate	src/Geometry/Transform.h	/^  inline Transform& prerotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
Eigen::Transform::prerotate	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
Eigen::Transform::prescale	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prescale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
Eigen::Transform::prescale	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prescale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::prescale	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::prescale	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::prescale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
Eigen::Transform::prescale	src/Geometry/Transform.h	/^  inline Transform& prescale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::prescale	src/Geometry/Transform.h	/^  inline Transform& prescale(const Scalar& s);$/;"	p	class:Eigen::Transform	access:public	signature:(const Scalar& s)
Eigen::Transform::prescale	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::prescale	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::prescale(const Scalar& s)$/;"	f	class:Eigen::Transform	signature:(const Scalar& s)
Eigen::Transform::preshear	src/Eigen2Support/Geometry/Transform.h	/^  Transform& preshear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
Eigen::Transform::preshear	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::preshear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
Eigen::Transform::preshear	src/Geometry/Transform.h	/^  Transform& preshear(const Scalar& sx, const Scalar& sy);$/;"	p	class:Eigen::Transform	access:public	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Transform::preshear	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::preshear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Transform::pretranslate	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& pretranslate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::pretranslate	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::pretranslate	src/Geometry/Transform.h	/^  inline Transform& pretranslate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::pretranslate	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::rotate	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& rotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
Eigen::Transform::rotate	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
Eigen::Transform::rotate	src/Geometry/Transform.h	/^  inline Transform& rotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
Eigen::Transform::rotate	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
Eigen::Transform::rotation	src/Eigen2Support/Geometry/Transform.h	/^  LinearMatrixType rotation() const;$/;"	p	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::rotation	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotation() const$/;"	f	class:Eigen::Transform	signature:() const
Eigen::Transform::rotation	src/Geometry/Transform.h	/^  const LinearMatrixType rotation() const;$/;"	p	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::rotation	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotation() const$/;"	f	class:Eigen::Transform	signature:() const
Eigen::Transform::scale	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& scale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
Eigen::Transform::scale	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& scale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::scale	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::scale	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::scale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
Eigen::Transform::scale	src/Geometry/Transform.h	/^  inline Transform& scale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::scale	src/Geometry/Transform.h	/^  inline Transform& scale(const Scalar& s);$/;"	p	class:Eigen::Transform	access:public	signature:(const Scalar& s)
Eigen::Transform::scale	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::scale	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::scale(const Scalar& s)$/;"	f	class:Eigen::Transform	signature:(const Scalar& s)
Eigen::Transform::setIdentity	src/Eigen2Support/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::setIdentity	src/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::shear	src/Eigen2Support/Geometry/Transform.h	/^  Transform& shear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
Eigen::Transform::shear	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::shear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
Eigen::Transform::shear	src/Geometry/Transform.h	/^  Transform& shear(const Scalar& sx, const Scalar& sy);$/;"	p	class:Eigen::Transform	access:public	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Transform::shear	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::shear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Transform::take_affine_part	src/Geometry/Transform.h	/^  typedef internal::transform_take_affine_part<Transform> take_affine_part;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::toQMatrix	src/Eigen2Support/Geometry/Transform.h	/^  inline QMatrix toQMatrix(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
Eigen::Transform::toQMatrix	src/Eigen2Support/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim>::toQMatrix(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
Eigen::Transform::toQMatrix	src/Geometry/Transform.h	/^  inline QMatrix toQMatrix(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
Eigen::Transform::toQMatrix	src/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim,Mode,Options>::toQMatrix(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
Eigen::Transform::toQTransform	src/Eigen2Support/Geometry/Transform.h	/^  inline QTransform toQTransform(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
Eigen::Transform::toQTransform	src/Eigen2Support/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim>::toQTransform(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
Eigen::Transform::toQTransform	src/Geometry/Transform.h	/^  inline QTransform toQTransform(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
Eigen::Transform::toQTransform	src/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim,Mode,Options>::toQTransform(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
Eigen::Transform::translate	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& translate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::translate	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::translate	src/Geometry/Transform.h	/^  inline Transform& translate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::translate	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::translation	src/Eigen2Support/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::translation	src/Eigen2Support/Geometry/Transform.h	/^  inline TranslationPart translation() { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::translation	src/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return ConstTranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::translation	src/Geometry/Transform.h	/^  inline TranslationPart translation() { return TranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::translationExt	src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::translationExt	src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::TransformTraits	src/Core/util/Constants.h	/^enum TransformTraits {$/;"	g	namespace:Eigen
Eigen::Translation	src/Eigen2Support/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Eigen::Translation	src/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Eigen::Translation2d	src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Eigen::Translation2d	src/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Eigen::Translation2f	src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Eigen::Translation2f	src/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Eigen::Translation3d	src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Eigen::Translation3d	src/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Eigen::Translation3f	src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
Eigen::Translation3f	src/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
Eigen::Translation::AffineTransformType	src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Affine> AffineTransformType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::Dim	src/Eigen2Support/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon347
Eigen::Translation::Dim	src/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon390
Eigen::Translation::Identity	src/Geometry/Translation.h	/^  static const Translation Identity() { return Translation(VectorType::Zero()); }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::IsometryTransformType	src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Isometry> IsometryTransformType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::LinearMatrixType	src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::LinearMatrixType	src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::Scalar	src/Eigen2Support/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::Scalar	src/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::ScalingType	src/Eigen2Support/Geometry/Translation.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::TransformType	src/Eigen2Support/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::Translation	src/Eigen2Support/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::Translation	src/Eigen2Support/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& vector)
Eigen::Translation::Translation	src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Translation::Translation	src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Eigen::Translation::Translation	src/Eigen2Support/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation<OtherScalarType,Dim>& other)
Eigen::Translation::Translation	src/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::Translation	src/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& vector)
Eigen::Translation::Translation	src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Translation::Translation	src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Eigen::Translation::Translation	src/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation<OtherScalarType,Dim>& other)
Eigen::Translation::VectorType	src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::VectorType	src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::cast	src/Eigen2Support/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::cast	src/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::inverse	src/Eigen2Support/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::inverse	src/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::isApprox	src/Eigen2Support/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Translation::isApprox	src/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::Translation::m_coeffs	src/Eigen2Support/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation	access:protected
Eigen::Translation::m_coeffs	src/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation	access:protected
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^  friend inline TransformType operator* (const LinearMatrixType& linear, const Translation& t)$/;"	f	class:Eigen::Translation	access:friend	signature:(const LinearMatrixType& linear, const Translation& t)
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const LinearMatrixType& linear) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const LinearMatrixType& linear) const
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const ScalingType& other) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const ScalingType& other) const
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const TransformType& t) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const TransformType& t) const
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other) const
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& other) const
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const LinearMatrixType& linear) const$/;"	f	class:Eigen::Translation	signature:(const LinearMatrixType& linear) const
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const ScalingType& other) const$/;"	f	class:Eigen::Translation	signature:(const ScalingType& other) const
Eigen::Translation::operator *	src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Translation	signature:(const TransformType& t) const
Eigen::Translation::operator *	src/Geometry/Translation.h	/^  inline AffineTransformType operator* (const EigenBase<OtherDerived>& linear) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const EigenBase<OtherDerived>& linear) const
Eigen::Translation::operator *	src/Geometry/Translation.h	/^  inline AffineTransformType operator* (const UniformScaling<Scalar>& other) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const UniformScaling<Scalar>& other) const
Eigen::Translation::operator *	src/Geometry/Translation.h	/^  inline AffineTransformType operator*(const EigenBase<OtherDerived>& linear, const Translation& t)$/;"	f	class:Eigen::Translation	access:friend	signature:(const EigenBase<OtherDerived>& linear, const Translation& t)
Eigen::Translation::operator *	src/Geometry/Translation.h	/^  inline IsometryTransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Translation::operator *	src/Geometry/Translation.h	/^  inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Transform<Scalar,Dim,Mode,Options>& t) const
Eigen::Translation::operator *	src/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other) const
Eigen::Translation::operator *	src/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& other) const
Eigen::Translation::operator *	src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const EigenBase<OtherDerived>& linear) const$/;"	f	class:Eigen::Translation	signature:(const EigenBase<OtherDerived>& linear) const
Eigen::Translation::operator *	src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const UniformScaling<Scalar>& other) const$/;"	f	class:Eigen::Translation	signature:(const UniformScaling<Scalar>& other) const
Eigen::Translation::operator =	src/Eigen2Support/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other)
Eigen::Translation::operator =	src/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other)
Eigen::Translation::translation	src/Geometry/Translation.h	/^  VectorType& translation() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::translation	src/Geometry/Translation.h	/^  const VectorType& translation() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::vector	src/Eigen2Support/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::vector	src/Eigen2Support/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::vector	src/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::vector	src/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::x	src/Geometry/Translation.h	/^  inline Scalar x() const { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::x	src/Geometry/Translation.h	/^  inline Scalar& x() { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::y	src/Geometry/Translation.h	/^  inline Scalar y() const { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::y	src/Geometry/Translation.h	/^  inline Scalar& y() { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::z	src/Geometry/Translation.h	/^  inline Scalar z() const { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::z	src/Geometry/Translation.h	/^  inline Scalar& z() { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Transpose	src/Core/PermutationMatrix.h	/^class Transpose<PermutationBase<Derived> >$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::Transpose	src/Core/Transpose.h	/^template<typename MatrixType> class Transpose$/;"	c	namespace:Eigen	inherits:TransposeImpl
Eigen::Transpose	src/Core/Transpositions.h	/^class Transpose<TranspositionsBase<TranspositionsDerived> >$/;"	c	namespace:Eigen
Eigen::Transpose::Base	src/Core/Transpose.h	/^    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::Transpose	access:public
Eigen::Transpose::CoeffReadCost	src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::Transpose::__anon289
Eigen::Transpose::ColsAtCompileTime	src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon289
Eigen::Transpose::DenseMatrixType	src/Core/PermutationMatrix.h	/^    typedef typename Derived::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::Transpose	access:public
Eigen::Transpose::Flags	src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::Transpose::__anon289
Eigen::Transpose::IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::Transpose::IndicesType	src/Core/Transpositions.h	/^    typedef typename TranspositionType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::Transpose::MaxColsAtCompileTime	src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::Transpose::__anon289
Eigen::Transpose::MaxRowsAtCompileTime	src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon289
Eigen::Transpose::PermutationType	src/Core/PermutationMatrix.h	/^    typedef Derived PermutationType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::Transpose::PlainPermutationType	src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::PlainPermutationType PlainPermutationType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::Transpose::RowsAtCompileTime	src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon289
Eigen::Transpose::Scalar	src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::Transpose	access:public
Eigen::Transpose::Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationType> Traits;$/;"	t	class:Eigen::Transpose	access:public
Eigen::Transpose::Transpose	src/Core/PermutationMatrix.h	/^    Transpose(const PermutationType& p) : m_permutation(p) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(const PermutationType& p)
Eigen::Transpose::Transpose	src/Core/Transpose.h	/^    inline Transpose(MatrixType& a_matrix) : m_matrix(a_matrix) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(MatrixType& a_matrix)
Eigen::Transpose::Transpose	src/Core/Transpositions.h	/^    Transpose(const TranspositionType& t) : m_transpositions(t) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(const TranspositionType& t)
Eigen::Transpose::TranspositionType	src/Core/Transpositions.h	/^    typedef TranspositionsDerived TranspositionType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::Transpose::cols	src/Core/PermutationMatrix.h	/^    inline int cols() const { return m_permutation.cols(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::cols	src/Core/Transpose.h	/^    inline Index cols() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::eval	src/Core/PermutationMatrix.h	/^    PlainPermutationType eval() const { return *this; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::evalTo	src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::Transpose	access:public	signature:(MatrixBase<DenseDerived>& other) const
Eigen::Transpose::m_matrix	src/Core/Transpose.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Transpose	access:protected
Eigen::Transpose::m_permutation	src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	class:Eigen::Transpose	access:protected
Eigen::Transpose::m_transpositions	src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	class:Eigen::Transpose	access:protected
Eigen::Transpose::nestedExpression	src/Core/Transpose.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::nestedExpression	src/Core/Transpose.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::Transpose	access:public	signature:()
Eigen::Transpose::nestedPermutation	src/Core/PermutationMatrix.h	/^    const PermutationType& nestedPermutation() const { return m_permutation; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::operator *	src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::Transpose	access:public	signature:(const MatrixBase<OtherDerived>& matrix) const
Eigen::Transpose::operator *	src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)$/;"	f	class:Eigen::Transpose	access:friend	signature:(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)
Eigen::Transpose::operator *	src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix) const$/;"	f	class:Eigen::Transpose	access:public	signature:(const MatrixBase<Derived>& matrix) const
Eigen::Transpose::operator *	src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix, const Transpose& trt)$/;"	f	class:Eigen::Transpose	access:friend	signature:(const MatrixBase<Derived>& matrix, const Transpose& trt)
Eigen::Transpose::rows	src/Core/PermutationMatrix.h	/^    inline int rows() const { return m_permutation.rows(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::rows	src/Core/Transpose.h	/^    inline Index rows() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::size	src/Core/Transpositions.h	/^    inline int size() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::toDenseMatrix	src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return *this; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::TransposeImpl	src/Core/Transpose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Dense>$/;"	c	namespace:Eigen	inherits:internal::TransposeImpl_base::type
Eigen::TransposeImpl	src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::TransposeImpl::Base	src/Core/Transpose.h	/^    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;$/;"	t	class:Eigen::TransposeImpl	access:public
Eigen::TransposeImpl::InnerIterator	src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::TransposeImpl	inherits:_MatrixTypeNested::InnerIterator
Eigen::TransposeImpl::InnerIterator::Base	src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::InnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::InnerIterator	access:private
Eigen::TransposeImpl::InnerIterator::Index	src/SparseCore/SparseTranspose.h	/^    typedef typename TransposeImpl::Index Index;$/;"	t	class:Eigen::TransposeImpl::InnerIterator	access:private
Eigen::TransposeImpl::InnerIterator::InnerIterator	src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE InnerIterator(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)
Eigen::TransposeImpl::InnerIterator::col	src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:() const
Eigen::TransposeImpl::InnerIterator::row	src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:() const
Eigen::TransposeImpl::ReverseInnerIterator	src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::TransposeImpl	inherits:_MatrixTypeNested::ReverseInnerIterator
Eigen::TransposeImpl::ReverseInnerIterator::Base	src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::ReverseInnerIterator	access:private
Eigen::TransposeImpl::ReverseInnerIterator::Index	src/SparseCore/SparseTranspose.h	/^    typedef typename TransposeImpl::Index Index;$/;"	t	class:Eigen::TransposeImpl::ReverseInnerIterator	access:private
Eigen::TransposeImpl::ReverseInnerIterator::ReverseInnerIterator	src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)
Eigen::TransposeImpl::ReverseInnerIterator::col	src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::TransposeImpl::ReverseInnerIterator::row	src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::TransposeImpl::ScalarWithConstIfNotLvalue	src/Core/Transpose.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::TransposeImpl	access:public
Eigen::TransposeImpl::_MatrixTypeNested	src/SparseCore/SparseTranspose.h	/^    typedef typename internal::remove_all<typename MatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::TransposeImpl	access:private
Eigen::TransposeImpl::coeff	src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
Eigen::TransposeImpl::coeff	src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId) const
Eigen::TransposeImpl::coeffRef	src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index)
Eigen::TransposeImpl::coeffRef	src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId)
Eigen::TransposeImpl::coeffRef	src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
Eigen::TransposeImpl::coeffRef	src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId) const
Eigen::TransposeImpl::data	src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:()
Eigen::TransposeImpl::data	src/Core/Transpose.h	/^    inline const Scalar* data() const { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
Eigen::TransposeImpl::innerStride	src/Core/Transpose.h	/^    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
Eigen::TransposeImpl::nonZeros	src/SparseCore/SparseTranspose.h	/^    inline Index nonZeros() const { return derived().nestedExpression().nonZeros(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
Eigen::TransposeImpl::outerStride	src/Core/Transpose.h	/^    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
Eigen::TransposeImpl::packet	src/Core/Transpose.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
Eigen::TransposeImpl::packet	src/Core/Transpose.h	/^    inline const PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId) const
Eigen::TransposeImpl::writePacket	src/Core/Transpose.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index, const PacketScalar& x)
Eigen::TransposeImpl::writePacket	src/Core/Transpose.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId, const PacketScalar& x)
Eigen::Transpositions	src/Core/Transpositions.h	/^class Transpositions : public TranspositionsBase<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Eigen::Transpositions::Base	src/Core/Transpositions.h	/^    typedef TranspositionsBase<Transpositions> Base;$/;"	t	class:Eigen::Transpositions	access:public
Eigen::Transpositions::Index	src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Transpositions	access:public
Eigen::Transpositions::IndicesType	src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Transpositions	access:public
Eigen::Transpositions::Traits	src/Core/Transpositions.h	/^    typedef internal::traits<Transpositions> Traits;$/;"	t	class:Eigen::Transpositions	access:private
Eigen::Transpositions::Transpositions	src/Core/Transpositions.h	/^    explicit inline Transpositions(const MatrixBase<Other>& a_indices) : m_indices(a_indices)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const MatrixBase<Other>& a_indices)
Eigen::Transpositions::Transpositions	src/Core/Transpositions.h	/^    inline Transpositions() {}$/;"	f	class:Eigen::Transpositions	access:public	signature:()
Eigen::Transpositions::Transpositions	src/Core/Transpositions.h	/^    inline Transpositions(Index size) : m_indices(size)$/;"	f	class:Eigen::Transpositions	access:public	signature:(Index size)
Eigen::Transpositions::Transpositions	src/Core/Transpositions.h	/^    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::Transpositions	access:public	signature:(const Transpositions& other)
Eigen::Transpositions::Transpositions	src/Core/Transpositions.h	/^    inline Transpositions(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::Transpositions::indices	src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Transpositions	access:public	signature:()
Eigen::Transpositions::indices	src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Transpositions	access:public	signature:() const
Eigen::Transpositions::m_indices	src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Transpositions	access:protected
Eigen::Transpositions::operator =	src/Core/Transpositions.h	/^    Transpositions& operator=(const Transpositions& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const Transpositions& other)
Eigen::Transpositions::operator =	src/Core/Transpositions.h	/^    Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::TranspositionsBase	src/Core/Transpositions.h	/^class TranspositionsBase$/;"	c	namespace:Eigen
Eigen::TranspositionsBase::Index	src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsBase	access:public
Eigen::TranspositionsBase::IndicesType	src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsBase	access:public
Eigen::TranspositionsBase::Traits	src/Core/Transpositions.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::TranspositionsBase	access:private
Eigen::TranspositionsBase::coeff	src/Core/Transpositions.h	/^    inline const Index& coeff(Index i) const { return indices().coeff(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
Eigen::TranspositionsBase::coeffRef	src/Core/Transpositions.h	/^    inline Index& coeffRef(Index i) { return indices().coeffRef(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
Eigen::TranspositionsBase::derived	src/Core/Transpositions.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
Eigen::TranspositionsBase::derived	src/Core/Transpositions.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Eigen::TranspositionsBase::indices	src/Core/Transpositions.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
Eigen::TranspositionsBase::indices	src/Core/Transpositions.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Eigen::TranspositionsBase::inverse	src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> inverse() const$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Eigen::TranspositionsBase::operator ()	src/Core/Transpositions.h	/^    inline Index& operator()(Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
Eigen::TranspositionsBase::operator ()	src/Core/Transpositions.h	/^    inline const Index& operator()(Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
Eigen::TranspositionsBase::operator =	src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase& other)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(const TranspositionsBase& other)
Eigen::TranspositionsBase::operator =	src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::TranspositionsBase::operator []	src/Core/Transpositions.h	/^    inline Index& operator[](Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
Eigen::TranspositionsBase::operator []	src/Core/Transpositions.h	/^    inline const Index& operator[](Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
Eigen::TranspositionsBase::resize	src/Core/Transpositions.h	/^    inline void resize(int newSize)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(int newSize)
Eigen::TranspositionsBase::setIdentity	src/Core/Transpositions.h	/^    void setIdentity()$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
Eigen::TranspositionsBase::size	src/Core/Transpositions.h	/^    inline Index size() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Eigen::TranspositionsBase::transpose	src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> transpose() const$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Eigen::TranspositionsWrapper	src/Core/Transpositions.h	/^class TranspositionsWrapper$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Eigen::TranspositionsWrapper::Base	src/Core/Transpositions.h	/^    typedef TranspositionsBase<TranspositionsWrapper> Base;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Eigen::TranspositionsWrapper::Index	src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Eigen::TranspositionsWrapper::IndicesType	src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Eigen::TranspositionsWrapper::Traits	src/Core/Transpositions.h	/^    typedef internal::traits<TranspositionsWrapper> Traits;$/;"	t	class:Eigen::TranspositionsWrapper	access:private
Eigen::TranspositionsWrapper::TranspositionsWrapper	src/Core/Transpositions.h	/^    inline TranspositionsWrapper(IndicesType& a_indices)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(IndicesType& a_indices)
Eigen::TranspositionsWrapper::indices	src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:()
Eigen::TranspositionsWrapper::indices	src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:() const
Eigen::TranspositionsWrapper::m_indices	src/Core/Transpositions.h	/^    const typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::TranspositionsWrapper	access:protected
Eigen::TranspositionsWrapper::operator =	src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::TranspositionsWrapper::operator =	src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(const TranspositionsWrapper& other)
Eigen::TriangularBase	src/Core/TriangularMatrix.h	/^template<typename Derived> class TriangularBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::TriangularBase::CoeffReadCost	src/Core/TriangularMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::TriangularBase::__anon326
Eigen::TriangularBase::ColsAtCompileTime	src/Core/TriangularMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon326
Eigen::TriangularBase::DenseMatrixType	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::DenseType	src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::Index	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::MaxColsAtCompileTime	src/Core/TriangularMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime$/;"	e	enum:Eigen::TriangularBase::__anon326
Eigen::TriangularBase::MaxRowsAtCompileTime	src/Core/TriangularMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon326
Eigen::TriangularBase::Mode	src/Core/TriangularMatrix.h	/^      Mode = internal::traits<Derived>::Mode,$/;"	e	enum:Eigen::TriangularBase::__anon326
Eigen::TriangularBase::RowsAtCompileTime	src/Core/TriangularMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon326
Eigen::TriangularBase::Scalar	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::StorageKind	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::TriangularBase	src/Core/TriangularMatrix.h	/^    inline TriangularBase() { eigen_assert(!((Mode&UnitDiag) && (Mode&ZeroDiag))); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:()
Eigen::TriangularBase::check_coordinates	src/Core/TriangularMatrix.h	/^    void check_coordinates(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index row, Index col) const
Eigen::TriangularBase::check_coordinates_internal	src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index , Index ) const {}$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index , Index ) const
Eigen::TriangularBase::check_coordinates_internal	src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index row, Index col) const
Eigen::TriangularBase::coeff	src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const  { return derived().coeff(row,col); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col) const
Eigen::TriangularBase::coeffRef	src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col)
Eigen::TriangularBase::cols	src/Core/TriangularMatrix.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::copyCoeff	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, Other& other)$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col, Other& other)
Eigen::TriangularBase::derived	src/Core/TriangularMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:()
Eigen::TriangularBase::derived	src/Core/TriangularMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::evalTo	src/Core/TriangularMatrix.h	/^    void evalTo(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::TriangularBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::TriangularBase::evalTo	src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase	signature:(MatrixBase<DenseDerived> &other) const
Eigen::TriangularBase::evalToLazy	src/Core/TriangularMatrix.h	/^    void evalToLazy(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::TriangularBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::TriangularBase::evalToLazy	src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase	signature:(MatrixBase<DenseDerived> &other) const
Eigen::TriangularBase::innerStride	src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().innerStride(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::operator ()	src/Core/TriangularMatrix.h	/^    inline Scalar operator()(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col) const
Eigen::TriangularBase::operator ()	src/Core/TriangularMatrix.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col)
Eigen::TriangularBase::outerStride	src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().outerStride(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::rows	src/Core/TriangularMatrix.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::toDenseMatrix	src/Core/TriangularMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularProduct	src/Core/products/TriangularMatrixMatrix.h	/^struct TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::TriangularProduct	src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,false,Lhs,true,Rhs,false>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::TriangularProduct	src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,true,Lhs,false,Rhs,true>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::TriangularProduct::TriangularProduct	src/Core/products/TriangularMatrixMatrix.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::TriangularProduct::TriangularProduct	src/Core/products/TriangularMatrixVector.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::TriangularProduct::scaleAndAddTo	src/Core/products/TriangularMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(Dest& dst, const Scalar& alpha) const
Eigen::TriangularProduct::scaleAndAddTo	src/Core/products/TriangularMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(Dest& dst, const Scalar& alpha) const
Eigen::TriangularView	src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularView$/;"	c	namespace:Eigen	inherits:TriangularBase
Eigen::TriangularView::Base	src/Core/TriangularMatrix.h	/^    typedef TriangularBase<TriangularView> Base;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::DenseMatrixType	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::Index	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Index Index;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::MatrixConjugateReturnType	src/Core/TriangularMatrix.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::MatrixType	src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::MatrixTypeNested	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::MatrixTypeNestedCleaned	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::MatrixTypeNestedNonRef	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::Mode	src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularView::__anon328
Eigen::TriangularView::PlainObject	src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType PlainObject;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::Scalar	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Scalar Scalar;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::StorageKind	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::TransposeMode	src/Core/TriangularMatrix.h	/^      TransposeMode = (Mode & Upper ? Lower : 0)$/;"	e	enum:Eigen::TriangularView::__anon328
Eigen::TriangularView::TriangularView	src/Core/TriangularMatrix.h	/^    inline TriangularView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixType& matrix)
Eigen::TriangularView::adjoint	src/Core/TriangularMatrix.h	/^    inline const TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> adjoint() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::assignProduct	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& assignProduct(const ProductBase<ProductDerived, Lhs,Rhs>& prod, const Scalar& alpha);$/;"	p	class:Eigen::TriangularView	access:protected	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& prod, const Scalar& alpha)
Eigen::TriangularView::assignProduct	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& assignProduct(const TriangularProduct<Mode, LhsIsTriangular, Lhs, LhsIsVector, Rhs, RhsIsVector>& prod, const Scalar& alpha)$/;"	f	class:Eigen::TriangularView	access:protected	signature:(const TriangularProduct<Mode, LhsIsTriangular, Lhs, LhsIsVector, Rhs, RhsIsVector>& prod, const Scalar& alpha)
Eigen::TriangularView::assignProduct	src/Core/products/GeneralMatrixMatrixTriangular.h	/^TriangularView<MatrixType,UpLo>& TriangularView<MatrixType,UpLo>::assignProduct(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)$/;"	f	class:Eigen::TriangularView	signature:(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)
Eigen::TriangularView::coeff	src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(Index row, Index col) const
Eigen::TriangularView::coeffRef	src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TriangularView	access:public	signature:(Index row, Index col)
Eigen::TriangularView::cols	src/Core/TriangularMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::conjugate	src/Core/TriangularMatrix.h	/^    inline TriangularView<MatrixConjugateReturnType,Mode> conjugate()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::conjugate	src/Core/TriangularMatrix.h	/^    inline const TriangularView<MatrixConjugateReturnType,Mode> conjugate() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::determinant	src/Core/TriangularMatrix.h	/^    Scalar determinant() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::eigen2_product_return_type	src/Core/TriangularMatrix.h	/^    struct eigen2_product_return_type$/;"	s	class:Eigen::TriangularView	access:public
Eigen::TriangularView::eigen2_product_return_type::DenseMatrixType	src/Core/TriangularMatrix.h	/^      typedef typename TriangularView<MatrixType,Mode>::DenseMatrixType DenseMatrixType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
Eigen::TriangularView::eigen2_product_return_type::OtherPlainObject	src/Core/TriangularMatrix.h	/^      typedef typename OtherDerived::PlainObject::DenseType OtherPlainObject;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
Eigen::TriangularView::eigen2_product_return_type::ProdRetType	src/Core/TriangularMatrix.h	/^      typedef typename ProductReturnType<DenseMatrixType, OtherPlainObject>::Type ProdRetType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
Eigen::TriangularView::eigen2_product_return_type::type	src/Core/TriangularMatrix.h	/^      typedef typename ProdRetType::PlainObject type;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
Eigen::TriangularView::fill	src/Core/TriangularMatrix.h	/^    void fill(const Scalar& value) { setConstant(value); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const Scalar& value)
Eigen::TriangularView::innerStride	src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::isApprox	src/Core/TriangularMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
Eigen::TriangularView::isApprox	src/Core/TriangularMatrix.h	/^    bool isApprox(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
Eigen::TriangularView::lazyAssign	src/Core/TriangularMatrix.h	/^    void lazyAssign(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::TriangularView::lazyAssign	src/Core/TriangularMatrix.h	/^    void lazyAssign(const TriangularBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const TriangularBase<OtherDerived>& other)
Eigen::TriangularView::lazyAssign	src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& other)
Eigen::TriangularView::lazyAssign	src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const TriangularBase<OtherDerived>& other)
Eigen::TriangularView::m_matrix	src/Core/TriangularMatrix.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::nestedExpression	src/Core/TriangularMatrix.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::nestedExpression	src/Core/TriangularMatrix.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::operator *	src/Core/TriangularMatrix.h	/^    operator*(const EigenBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const EigenBase<OtherDerived>& rhs) const
Eigen::TriangularView::operator *	src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)$/;"	f	class:Eigen::TriangularView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)
Eigen::TriangularView::operator *	src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
Eigen::TriangularView::operator *=	src/Core/TriangularMatrix.h	/^    TriangularView&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix * other; }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const typename internal::traits<MatrixType>::Scalar& other)
Eigen::TriangularView::operator +=	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::TriangularView::operator +=	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
Eigen::TriangularView::operator +=	src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator+=(const DenseBase<Other>& other) { return *this = m_matrix + other.derived(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const DenseBase<Other>& other)
Eigen::TriangularView::operator -=	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::TriangularView::operator -=	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
Eigen::TriangularView::operator -=	src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator-=(const DenseBase<Other>& other) { return *this = m_matrix - other.derived(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const DenseBase<Other>& other)
Eigen::TriangularView::operator /=	src/Core/TriangularMatrix.h	/^    TriangularView&  operator\/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix \/ other; }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const typename internal::traits<MatrixType>::Scalar& other)
Eigen::TriangularView::operator =	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::TriangularView::operator =	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
Eigen::TriangularView::operator =	src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::TriangularView::operator =	src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const TriangularBase<OtherDerived>& other)
Eigen::TriangularView::operator =	src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularView& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const TriangularView& other)
Eigen::TriangularView::operator =	src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& other)
Eigen::TriangularView::operator =	src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const TriangularBase<OtherDerived>& other)
Eigen::TriangularView::outerStride	src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::rows	src/Core/TriangularMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::selfadjointView	src/Core/TriangularMatrix.h	/^    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::selfadjointView	src/Core/TriangularMatrix.h	/^    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::setConstant	src/Core/TriangularMatrix.h	/^    TriangularView& setConstant(const Scalar& value)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const Scalar& value)
Eigen::TriangularView::setOnes	src/Core/TriangularMatrix.h	/^    TriangularView& setOnes() { return setConstant(Scalar(1)); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::setZero	src/Core/TriangularMatrix.h	/^    TriangularView& setZero() { return setConstant(Scalar(0)); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::solve	src/Core/SolveTriangular.h	/^TriangularView<Derived,Mode>::solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<Other>& other) const
Eigen::TriangularView::solve	src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<Other>& other) const
Eigen::TriangularView::solve	src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const;$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<Other>& other) const
Eigen::TriangularView::solveInPlace	src/Core/SolveTriangular.h	/^void TriangularView<MatrixType,Mode>::solveInPlace(const MatrixBase<OtherDerived>& _other) const$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& _other) const
Eigen::TriangularView::solveInPlace	src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::TriangularView::solveInPlace	src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::TriangularView::swap	src/Core/TriangularMatrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(MatrixBase<OtherDerived> const & other)
Eigen::TriangularView::swap	src/Core/TriangularMatrix.h	/^    void swap(TriangularBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(TriangularBase<OtherDerived> const & other)
Eigen::TriangularView::transpose	src/Core/TriangularMatrix.h	/^    inline TriangularView<Transpose<MatrixType>,TransposeMode> transpose()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::transpose	src/Core/TriangularMatrix.h	/^    inline const TriangularView<Transpose<MatrixType>,TransposeMode> transpose() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::Tridiagonalization	src/Eigenvalues/Tridiagonalization.h	/^template<typename _MatrixType> class Tridiagonalization$/;"	c	namespace:Eigen
Eigen::Tridiagonalization::CoeffVectorType	src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::DiagonalReturnType	src/Eigenvalues/Tridiagonalization.h	/^            >::type DiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::DiagonalType	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type DiagonalType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::HouseholderSequenceType	src/Eigenvalues/Tridiagonalization.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::Index	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::MatrixTReturnType	src/Eigenvalues/Tridiagonalization.h	/^    typedef internal::TridiagonalizationMatrixTReturnType<MatrixTypeRealView> MatrixTReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::MatrixType	src/Eigenvalues/Tridiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::MatrixTypeRealView	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::remove_all<typename MatrixType::RealReturnType>::type MatrixTypeRealView;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::MaxSize	src/Eigenvalues/Tridiagonalization.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon368
Eigen::Tridiagonalization::MaxSizeMinusOne	src/Eigenvalues/Tridiagonalization.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : (MaxSize > 1 ? MaxSize - 1 : 1)$/;"	e	enum:Eigen::Tridiagonalization::__anon368
Eigen::Tridiagonalization::Options	src/Eigenvalues/Tridiagonalization.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::Tridiagonalization::__anon368
Eigen::Tridiagonalization::RealScalar	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::Scalar	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::Size	src/Eigenvalues/Tridiagonalization.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon368
Eigen::Tridiagonalization::SizeMinusOne	src/Eigenvalues/Tridiagonalization.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : (Size > 1 ? Size - 1 : 1),$/;"	e	enum:Eigen::Tridiagonalization::__anon368
Eigen::Tridiagonalization::SubDiagonalReturnType	src/Eigenvalues/Tridiagonalization.h	/^            >::type SubDiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::SubDiagonalType	src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<RealScalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> SubDiagonalType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::Tridiagonalization	src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(Index size = Size==Dynamic ? 2 : Size)
Eigen::Tridiagonalization::Tridiagonalization	src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(const MatrixType& matrix)
Eigen::Tridiagonalization::compute	src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization& compute(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(const MatrixType& matrix)
Eigen::Tridiagonalization::diagonal	src/Eigenvalues/Tridiagonalization.h	/^    DiagonalReturnType diagonal() const;$/;"	p	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::diagonal	src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::diagonal() const$/;"	f	class:Eigen::Tridiagonalization	signature:() const
Eigen::Tridiagonalization::householderCoefficients	src/Eigenvalues/Tridiagonalization.h	/^    inline CoeffVectorType householderCoefficients() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::m_hCoeffs	src/Eigenvalues/Tridiagonalization.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::Tridiagonalization	access:protected
Eigen::Tridiagonalization::m_isInitialized	src/Eigenvalues/Tridiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::Tridiagonalization	access:protected
Eigen::Tridiagonalization::m_matrix	src/Eigenvalues/Tridiagonalization.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::Tridiagonalization	access:protected
Eigen::Tridiagonalization::matrixQ	src/Eigenvalues/Tridiagonalization.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::matrixT	src/Eigenvalues/Tridiagonalization.h	/^    MatrixTReturnType matrixT() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::packedMatrix	src/Eigenvalues/Tridiagonalization.h	/^    inline const MatrixType& packedMatrix() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::subDiagonal	src/Eigenvalues/Tridiagonalization.h	/^    SubDiagonalReturnType subDiagonal() const;$/;"	p	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::subDiagonal	src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::subDiagonal() const$/;"	f	class:Eigen::Tridiagonalization	signature:() const
Eigen::Triplet	src/SparseCore/SparseUtil.h	/^class Triplet$/;"	c	namespace:Eigen
Eigen::Triplet::Triplet	src/SparseCore/SparseUtil.h	/^  Triplet() : m_row(0), m_col(0), m_value(0) {}$/;"	f	class:Eigen::Triplet	access:public	signature:()
Eigen::Triplet::Triplet	src/SparseCore/SparseUtil.h	/^  Triplet(const Index& i, const Index& j, const Scalar& v = Scalar(0))$/;"	f	class:Eigen::Triplet	access:public	signature:(const Index& i, const Index& j, const Scalar& v = Scalar(0))
Eigen::Triplet::col	src/SparseCore/SparseUtil.h	/^  const Index& col() const { return m_col; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
Eigen::Triplet::m_col	src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet	access:protected
Eigen::Triplet::m_row	src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet	access:protected
Eigen::Triplet::m_value	src/SparseCore/SparseUtil.h	/^  Scalar m_value;$/;"	m	class:Eigen::Triplet	access:protected
Eigen::Triplet::row	src/SparseCore/SparseUtil.h	/^  const Index& row() const { return m_row; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
Eigen::Triplet::value	src/SparseCore/SparseUtil.h	/^  const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
Eigen::UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^class UmfPackLU : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::UmfPackLU::Index	src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::IntColVectorType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::IntRowVectorType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::LUMatrixType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::MatrixType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::RealScalar	src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::Scalar	src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU() { init(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:()
Eigen::UmfPackLU::UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(UmfPackLU& ) { }$/;"	f	class:Eigen::UmfPackLU	access:private	signature:(UmfPackLU& )
Eigen::UmfPackLU::UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
Eigen::UmfPackLU::UmfpackMatrixType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar,ColMajor,int> UmfpackMatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::Vector	src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::_solve	src/UmfPackSupport/UmfPackSupport.h	/^    bool _solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const
Eigen::UmfPackLU::_solve	src/UmfPackSupport/UmfPackSupport.h	/^bool UmfPackLU<MatrixType>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const$/;"	f	class:Eigen::UmfPackLU	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const
Eigen::UmfPackLU::analyzePattern	src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const InputMatrixType& matrix)
Eigen::UmfPackLU::analyzePattern_impl	src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern_impl()$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:()
Eigen::UmfPackLU::cols	src/UmfPackSupport/UmfPackSupport.h	/^    inline Index cols() const { return m_copyMatrix.cols(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::compute	src/UmfPackSupport/UmfPackSupport.h	/^    void compute(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const InputMatrixType& matrix)
Eigen::UmfPackLU::determinant	src/UmfPackSupport/UmfPackSupport.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::determinant	src/UmfPackSupport/UmfPackSupport.h	/^typename UmfPackLU<MatrixType>::Scalar UmfPackLU<MatrixType>::determinant() const$/;"	f	class:Eigen::UmfPackLU	signature:() const
Eigen::UmfPackLU::extractData	src/UmfPackSupport/UmfPackSupport.h	/^    void extractData() const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::extractData	src/UmfPackSupport/UmfPackSupport.h	/^void UmfPackLU<MatrixType>::extractData() const$/;"	f	class:Eigen::UmfPackLU	signature:() const
Eigen::UmfPackLU::factorize	src/UmfPackSupport/UmfPackSupport.h	/^    void factorize(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const InputMatrixType& matrix)
Eigen::UmfPackLU::factorize_impl	src/UmfPackSupport/UmfPackSupport.h	/^    void factorize_impl()$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:()
Eigen::UmfPackLU::grapInput	src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput(const InputMatrixType& mat)$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:(const InputMatrixType& mat)
Eigen::UmfPackLU::grapInput_impl	src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput_impl(const InputMatrixType& mat, internal::false_type)$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:(const InputMatrixType& mat, internal::false_type)
Eigen::UmfPackLU::grapInput_impl	src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput_impl(const InputMatrixType& mat, internal::true_type)$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:(const InputMatrixType& mat, internal::true_type)
Eigen::UmfPackLU::info	src/UmfPackSupport/UmfPackSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::init	src/UmfPackSupport/UmfPackSupport.h	/^    void init()$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:()
Eigen::UmfPackLU::m_analysisIsOk	src/UmfPackSupport/UmfPackSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_copyMatrix	src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixType m_copyMatrix;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_extractedDataAreDirty	src/UmfPackSupport/UmfPackSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_factorizationIsOk	src/UmfPackSupport/UmfPackSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_info	src/UmfPackSupport/UmfPackSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_innerIndexPtr	src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_innerIndexPtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_isInitialized	src/UmfPackSupport/UmfPackSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_l	src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_numeric	src/UmfPackSupport/UmfPackSupport.h	/^    void* m_numeric;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_outerIndexPtr	src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_outerIndexPtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_p	src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_q	src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^    void* m_symbolic;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_u	src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_valuePtr	src/UmfPackSupport/UmfPackSupport.h	/^    const Scalar* m_valuePtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::matrixL	src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixL() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::matrixU	src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixU() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::permutationP	src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::permutationQ	src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::rows	src/UmfPackSupport/UmfPackSupport.h	/^    inline Index rows() const { return m_copyMatrix.rows(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::solve	src/UmfPackSupport/UmfPackSupport.h	/^    inline const internal::solve_retval<UmfPackLU, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::UmfPackLU::solve	src/UmfPackSupport/UmfPackSupport.h	/^    inline const internal::sparse_solve_retval<UmfPackLU, Rhs> solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::UmfPackLU::~UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^    ~UmfPackLU()$/;"	f	class:Eigen::UmfPackLU	access:public	signature:()
Eigen::Unaligned	src/Core/util/Constants.h	/^  Unaligned=0, $/;"	e	enum:Eigen::__anon62
Eigen::UniformScaling	src/Geometry/Scaling.h	/^class UniformScaling$/;"	c	namespace:Eigen
Eigen::UniformScaling::Scalar	src/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::UniformScaling	access:public
Eigen::UniformScaling::UniformScaling	src/Geometry/Scaling.h	/^  UniformScaling() {}$/;"	f	class:Eigen::UniformScaling	access:public	signature:()
Eigen::UniformScaling::UniformScaling	src/Geometry/Scaling.h	/^  explicit inline UniformScaling(const Scalar& s) : m_factor(s) {}$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const Scalar& s)
Eigen::UniformScaling::UniformScaling	src/Geometry/Scaling.h	/^  inline explicit UniformScaling(const UniformScaling<OtherScalarType>& other)$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling<OtherScalarType>& other)
Eigen::UniformScaling::cast	src/Geometry/Scaling.h	/^  inline UniformScaling<NewScalarType> cast() const$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
Eigen::UniformScaling::factor	src/Geometry/Scaling.h	/^  inline Scalar& factor() { return m_factor; }$/;"	f	class:Eigen::UniformScaling	access:public	signature:()
Eigen::UniformScaling::factor	src/Geometry/Scaling.h	/^  inline const Scalar& factor() const { return m_factor; }$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
Eigen::UniformScaling::inverse	src/Geometry/Scaling.h	/^  inline UniformScaling inverse() const$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
Eigen::UniformScaling::isApprox	src/Geometry/Scaling.h	/^  bool isApprox(const UniformScaling& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::UniformScaling::m_factor	src/Geometry/Scaling.h	/^  Scalar m_factor;$/;"	m	class:Eigen::UniformScaling	access:protected
Eigen::UniformScaling::operator *	src/Geometry/Scaling.h	/^  inline Matrix<Scalar,Dim,Dim> operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::UniformScaling::operator *	src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?Affine:Mode)> operator* (const Transform<Scalar,Dim, Mode, Options>& t) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const Transform<Scalar,Dim, Mode, Options>& t) const
Eigen::UniformScaling::operator *	src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,Affine> operator* (const Translation<Scalar,Dim>& t) const;$/;"	p	class:Eigen::UniformScaling	access:public	signature:(const Translation<Scalar,Dim>& t) const
Eigen::UniformScaling::operator *	src/Geometry/Scaling.h	/^  inline UniformScaling operator* (const UniformScaling& other) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling& other) const
Eigen::UniformScaling::operator *	src/Geometry/Scaling.h	/^  inline typename internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const MatrixBase<Derived>& other) const
Eigen::UniformScaling::operator *	src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::UniformScaling	signature:(const Translation<Scalar,Dim>& t) const
Eigen::UnitDiag	src/Core/util/Constants.h	/^  UnitDiag=0x4, $/;"	e	enum:Eigen::__anon61
Eigen::UnitDiagBit	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitDiagBit = UnitDiag;$/;"	m	namespace:Eigen
Eigen::UnitLower	src/Core/util/Constants.h	/^  UnitLower=UnitDiag|Lower, $/;"	e	enum:Eigen::__anon61
Eigen::UnitLowerTriangular	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitLowerTriangular = UnitLower;$/;"	m	namespace:Eigen
Eigen::UnitUpper	src/Core/util/Constants.h	/^  UnitUpper=UnitDiag|Upper,$/;"	e	enum:Eigen::__anon61
Eigen::UnitUpperTriangular	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitUpperTriangular = UnitUpper;$/;"	m	namespace:Eigen
Eigen::Upper	src/Core/util/Constants.h	/^  Upper=0x2,                      $/;"	e	enum:Eigen::__anon61
Eigen::UpperTriangular	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangular = Upper;$/;"	m	namespace:Eigen
Eigen::UpperTriangularBit	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangularBit = Upper;$/;"	m	namespace:Eigen
Eigen::VectorBlock	src/Core/VectorBlock.h	/^template<typename VectorType, int Size> class VectorBlock$/;"	c	namespace:Eigen	inherits:Block
Eigen::VectorBlock::Base	src/Core/VectorBlock.h	/^                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1> Base;$/;"	t	class:Eigen::VectorBlock	access:private
Eigen::VectorBlock::IsColVector	src/Core/VectorBlock.h	/^      IsColVector = !(internal::traits<VectorType>::Flags & RowMajorBit)$/;"	e	enum:Eigen::VectorBlock::__anon330
Eigen::VectorBlock::VectorBlock	src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start)$/;"	f	class:Eigen::VectorBlock	access:public	signature:(VectorType& vector, Index start)
Eigen::VectorBlock::VectorBlock	src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start, Index size)$/;"	f	class:Eigen::VectorBlock	access:public	signature:(VectorType& vector, Index start, Index size)
Eigen::VectorwiseOp	src/Core/VectorwiseOp.h	/^template<typename ExpressionType, int Direction> class VectorwiseOp$/;"	c	namespace:Eigen
Eigen::VectorwiseOp::CrossReturnType	src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::PlainObject CrossReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ExpressionTypeNested	src/Core/VectorwiseOp.h	/^        ExpressionType, ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ExpressionTypeNestedCleaned	src/Core/VectorwiseOp.h	/^    typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ExtendedType	src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct ExtendedType {$/;"	s	class:Eigen::VectorwiseOp	access:protected
Eigen::VectorwiseOp::ExtendedType::Type	src/Core/VectorwiseOp.h	/^                        Direction==Horizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::ExtendedType	access:public
Eigen::VectorwiseOp::HNormalizedReturnType	src/Core/VectorwiseOp.h	/^            HNormalizedReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::HNormalized_Block	src/Core/VectorwiseOp.h	/^            HNormalized_Block;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::HNormalized_Factors	src/Core/VectorwiseOp.h	/^            HNormalized_Factors;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::HNormalized_Size	src/Core/VectorwiseOp.h	/^      HNormalized_Size = Direction==Vertical ? internal::traits<ExpressionType>::RowsAtCompileTime$/;"	e	enum:Eigen::VectorwiseOp::__anon335
Eigen::VectorwiseOp::HNormalized_SizeMinusOne	src/Core/VectorwiseOp.h	/^      HNormalized_SizeMinusOne = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1$/;"	e	enum:Eigen::VectorwiseOp::__anon335
Eigen::VectorwiseOp::Index	src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Index Index;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::IsHorizontal	src/Core/VectorwiseOp.h	/^      IsHorizontal = (Direction==Horizontal) ? 1 : 0$/;"	e	enum:Eigen::VectorwiseOp::__anon334
Eigen::VectorwiseOp::IsVertical	src/Core/VectorwiseOp.h	/^      IsVertical   = (Direction==Vertical) ? 1 : 0,$/;"	e	enum:Eigen::VectorwiseOp::__anon334
Eigen::VectorwiseOp::OppositeExtendedType	src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct OppositeExtendedType {$/;"	s	class:Eigen::VectorwiseOp	access:protected
Eigen::VectorwiseOp::OppositeExtendedType::Type	src/Core/VectorwiseOp.h	/^                        Direction==Vertical   ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::OppositeExtendedType	access:public
Eigen::VectorwiseOp::RealScalar	src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::RealScalar RealScalar;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ReduxReturnType	src/Core/VectorwiseOp.h	/^    template<typename BinaryOp> struct ReduxReturnType$/;"	s	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ReduxReturnType::Type	src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReduxReturnType	access:public
Eigen::VectorwiseOp::ReplicateReturnType	src/Core/VectorwiseOp.h	/^    typedef Replicate<ExpressionType,Direction==Vertical?Dynamic:1,Direction==Horizontal?Dynamic:1> ReplicateReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ReturnType	src/Core/VectorwiseOp.h	/^                      typename Scalar=typename internal::traits<ExpressionType>::Scalar> struct ReturnType$/;"	s	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ReturnType::Type	src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReturnType	access:public
Eigen::VectorwiseOp::Scalar	src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::SubVector	src/Core/VectorwiseOp.h	/^                               typename ExpressionType::RowXpr>::type SubVector;$/;"	t	class:Eigen::VectorwiseOp	access:protected
Eigen::VectorwiseOp::VectorwiseOp	src/Core/VectorwiseOp.h	/^    inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(ExpressionType& matrix)
Eigen::VectorwiseOp::_expression	src/Core/VectorwiseOp.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::all	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_all>::Type all() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::any	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_any>::Type any() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::blueNorm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_blueNorm,RealScalar>::Type blueNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::count	src/Core/VectorwiseOp.h	/^    const PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> count() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::cross	src/Core/VectorwiseOp.h	/^    const CrossReturnType cross(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::VectorwiseOp::cross	src/Geometry/OrthoMethods.h	/^VectorwiseOp<ExpressionType,Direction>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::VectorwiseOp::extendedTo	src/Core/VectorwiseOp.h	/^    extendedTo(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::extendedToOpposite	src/Core/VectorwiseOp.h	/^    extendedToOpposite(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::hnormalized	src/Core/VectorwiseOp.h	/^    const HNormalizedReturnType hnormalized() const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::hnormalized	src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::hnormalized() const$/;"	f	class:Eigen::VectorwiseOp	signature:() const
Eigen::VectorwiseOp::homogeneous	src/Core/VectorwiseOp.h	/^    Homogeneous<ExpressionType,Direction> homogeneous() const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::homogeneous	src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::homogeneous() const$/;"	f	class:Eigen::VectorwiseOp	signature:() const
Eigen::VectorwiseOp::hypotNorm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_hypotNorm,RealScalar>::Type hypotNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::m_matrix	src/Core/VectorwiseOp.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::VectorwiseOp	access:protected
Eigen::VectorwiseOp::maxCoeff	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_maxCoeff>::Type maxCoeff() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::mean	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_mean>::Type mean() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::minCoeff	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_minCoeff>::Type minCoeff() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::norm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_norm,RealScalar>::Type norm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::normalize	src/Core/VectorwiseOp.h	/^    void normalize() {$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:()
Eigen::VectorwiseOp::normalized	src/Core/VectorwiseOp.h	/^    normalized() const { return m_matrix.cwiseQuotient(extendedToOpposite(this->norm())); }$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::operator *	src/Core/VectorwiseOp.h	/^    operator*(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::operator *=	src/Core/VectorwiseOp.h	/^    ExpressionType& operator*=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::operator +	src/Core/VectorwiseOp.h	/^    operator+(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::operator +=	src/Core/VectorwiseOp.h	/^    ExpressionType& operator+=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::operator -	src/Core/VectorwiseOp.h	/^    operator-(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::operator -=	src/Core/VectorwiseOp.h	/^    ExpressionType& operator-=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::operator /	src/Core/VectorwiseOp.h	/^    operator\/(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::operator /=	src/Core/VectorwiseOp.h	/^    ExpressionType& operator\/=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::operator =	src/Core/VectorwiseOp.h	/^    ExpressionType& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::prod	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_prod>::Type prod() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::redux	src/Core/VectorwiseOp.h	/^    redux(const BinaryOp& func = BinaryOp()) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const BinaryOp& func = BinaryOp()) const
Eigen::VectorwiseOp::replicate	src/Core/Replicate.h	/^VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const$/;"	f	class:Eigen::VectorwiseOp	signature:(Index factor) const
Eigen::VectorwiseOp::replicate	src/Core/VectorwiseOp.h	/^    const ReplicateReturnType replicate(Index factor) const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:(Index factor) const
Eigen::VectorwiseOp::replicate	src/Core/VectorwiseOp.h	/^    replicate(Index factor = Factor) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(Index factor = Factor) const
Eigen::VectorwiseOp::reverse	src/Core/VectorwiseOp.h	/^    const Reverse<ExpressionType, Direction> reverse() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::squaredNorm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_squaredNorm,RealScalar>::Type squaredNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::stableNorm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_stableNorm,RealScalar>::Type stableNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::subVector	src/Core/VectorwiseOp.h	/^    SubVector subVector(Index i)$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(Index i)
Eigen::VectorwiseOp::subVectors	src/Core/VectorwiseOp.h	/^    Index subVectors() const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:() const
Eigen::VectorwiseOp::sum	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_sum>::Type sum() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::Vertical	src/Core/util/Constants.h	/^  Vertical, $/;"	e	enum:Eigen::DirectionType
Eigen::WithFormat	src/Core/IO.h	/^class WithFormat$/;"	c	namespace:Eigen
Eigen::WithFormat::WithFormat	src/Core/IO.h	/^    WithFormat(const ExpressionType& matrix, const IOFormat& format)$/;"	f	class:Eigen::WithFormat	access:public	signature:(const ExpressionType& matrix, const IOFormat& format)
Eigen::WithFormat::m_format	src/Core/IO.h	/^    IOFormat m_format;$/;"	m	class:Eigen::WithFormat	access:protected
Eigen::WithFormat::m_matrix	src/Core/IO.h	/^    const typename ExpressionType::Nested m_matrix;$/;"	m	class:Eigen::WithFormat	access:protected
Eigen::WithFormat::operator <<	src/Core/IO.h	/^    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)$/;"	f	class:Eigen::WithFormat	access:friend	signature:(std::ostream & s, const WithFormat& wf)
Eigen::WriteAccessors	src/Core/util/Constants.h	/^  WriteAccessors, $/;"	e	enum:Eigen::AccessorLevels
Eigen::ZeroDiag	src/Core/util/Constants.h	/^  ZeroDiag=0x8,$/;"	e	enum:Eigen::__anon61
Eigen::aligned_allocator	src/Core/util/Memory.h	/^class aligned_allocator$/;"	c	namespace:Eigen
Eigen::aligned_allocator::address	src/Core/util/Memory.h	/^    const_pointer address( const_reference value ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const_reference value ) const
Eigen::aligned_allocator::address	src/Core/util/Memory.h	/^    pointer address( reference value ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( reference value ) const
Eigen::aligned_allocator::aligned_allocator	src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator& )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const aligned_allocator& )
Eigen::aligned_allocator::aligned_allocator	src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator<U>& )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const aligned_allocator<U>& )
Eigen::aligned_allocator::aligned_allocator	src/Core/util/Memory.h	/^    aligned_allocator()$/;"	f	class:Eigen::aligned_allocator	access:public	signature:()
Eigen::aligned_allocator::allocate	src/Core/util/Memory.h	/^    pointer allocate( size_type num, const void* hint = 0 )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( size_type num, const void* hint = 0 )
Eigen::aligned_allocator::const_pointer	src/Core/util/Memory.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::const_reference	src/Core/util/Memory.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::construct	src/Core/util/Memory.h	/^    void construct( pointer p, const T& value )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p, const T& value )
Eigen::aligned_allocator::deallocate	src/Core/util/Memory.h	/^    void deallocate( pointer p, size_type \/*num*\/ )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p, size_type )
Eigen::aligned_allocator::destroy	src/Core/util/Memory.h	/^    void destroy( pointer p )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p )
Eigen::aligned_allocator::difference_type	src/Core/util/Memory.h	/^    typedef std::ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::max_size	src/Core/util/Memory.h	/^    size_type max_size() const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:() const
Eigen::aligned_allocator::operator !=	src/Core/util/Memory.h	/^    bool operator!=(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(const aligned_allocator<T>& ) const
Eigen::aligned_allocator::operator ==	src/Core/util/Memory.h	/^    bool operator==(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(const aligned_allocator<T>& ) const
Eigen::aligned_allocator::pointer	src/Core/util/Memory.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::rebind	src/Core/util/Memory.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::rebind::other	src/Core/util/Memory.h	/^        typedef aligned_allocator<U> other;$/;"	t	struct:Eigen::aligned_allocator::rebind	access:public
Eigen::aligned_allocator::reference	src/Core/util/Memory.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::size_type	src/Core/util/Memory.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::value_type	src/Core/util/Memory.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::~aligned_allocator	src/Core/util/Memory.h	/^    ~aligned_allocator()$/;"	f	class:Eigen::aligned_allocator	access:public	signature:()
Eigen::aligned_allocator_indirection	src/StlSupport/details.h	/^  class aligned_allocator_indirection : public EIGEN_ALIGNED_ALLOCATOR<T>$/;"	c	namespace:Eigen	inherits:EIGEN_ALIGNED_ALLOCATOR
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:()
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<T>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const EIGEN_ALIGNED_ALLOCATOR<T>& )
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const EIGEN_ALIGNED_ALLOCATOR<U>& )
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection& ) : EIGEN_ALIGNED_ALLOCATOR<T>() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const aligned_allocator_indirection& )
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const aligned_allocator_indirection<U>& )
Eigen::aligned_allocator_indirection::const_pointer	src/StlSupport/details.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::const_reference	src/StlSupport/details.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::difference_type	src/StlSupport/details.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::pointer	src/StlSupport/details.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::rebind	src/StlSupport/details.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::rebind::other	src/StlSupport/details.h	/^      typedef aligned_allocator_indirection<U> other;$/;"	t	struct:Eigen::aligned_allocator_indirection::rebind	access:public
Eigen::aligned_allocator_indirection::reference	src/StlSupport/details.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::size_type	src/StlSupport/details.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::value_type	src/StlSupport/details.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::~aligned_allocator_indirection	src/StlSupport/details.h	/^    ~aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:()
Eigen::cdiv	src/Eigenvalues/EigenSolver.h	/^std::complex<Scalar> cdiv(const Scalar& xr, const Scalar& xi, const Scalar& yr, const Scalar& yi)$/;"	f	namespace:Eigen	signature:(const Scalar& xr, const Scalar& xi, const Scalar& yr, const Scalar& yi)
Eigen::coeffRef	src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index i) const$/;"	f	namespace:Eigen	signature:(Index i) const
Eigen::coeffRef	src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index row, Index col) const$/;"	f	namespace:Eigen	signature:(Index row, Index col) const
Eigen::dcomplex	src/Core/util/MKL_support.h	/^typedef std::complex<double> dcomplex;$/;"	t	namespace:Eigen
Eigen::ei_abs	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs (const T& x) { using std::abs; return abs(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_abs2	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs2(const T& x) { return numext::abs2(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_aligned_delete	src/Eigen2Support/Memory.h	/^template<typename T> inline void ei_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen	signature:(T *ptr, size_t size)
Eigen::ei_aligned_free	src/Eigen2Support/Memory.h	/^inline void  ei_aligned_free(void *ptr) { internal::aligned_free(ptr); }$/;"	f	namespace:Eigen	signature:(void *ptr)
Eigen::ei_aligned_malloc	src/Eigen2Support/Memory.h	/^inline void* ei_aligned_malloc(size_t size) { return internal::aligned_malloc(size); }$/;"	f	namespace:Eigen	signature:(size_t size)
Eigen::ei_aligned_new	src/Eigen2Support/Memory.h	/^template<typename T> inline T* ei_aligned_new(size_t size)$/;"	f	namespace:Eigen	signature:(size_t size)
Eigen::ei_aligned_realloc	src/Eigen2Support/Memory.h	/^inline void* ei_aligned_realloc(void *ptr, size_t new_size, size_t old_size) { return internal::aligned_realloc(ptr, new_size, old_size); }$/;"	f	namespace:Eigen	signature:(void *ptr, size_t new_size, size_t old_size)
Eigen::ei_atan2	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_atan2(const T& x,const T& y) { using std::atan2; return atan2(x,y); }$/;"	f	namespace:Eigen	signature:(const T& x,const T& y)
Eigen::ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_conditional_aligned_free	src/Eigen2Support/Memory.h	/^template<bool Align> inline void ei_conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen	signature:(void *ptr)
Eigen::ei_conditional_aligned_malloc	src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen	signature:(size_t size)
Eigen::ei_conditional_aligned_realloc	src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen	signature:(void* ptr, size_t new_size, size_t old_size)
Eigen::ei_conj	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_conj(const T& x) { return numext::conj(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_cos	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_cos (const T& x) { using std::cos;  return cos(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_exp	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_exp (const T& x) { using std::exp;  return exp(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_handmade_aligned_free	src/Eigen2Support/Memory.h	/^inline void  ei_handmade_aligned_free(void *ptr) { internal::handmade_aligned_free(ptr); }$/;"	f	namespace:Eigen	signature:(void *ptr)
Eigen::ei_handmade_aligned_malloc	src/Eigen2Support/Memory.h	/^inline void* ei_handmade_aligned_malloc(size_t size) { return internal::handmade_aligned_malloc(size); }$/;"	f	namespace:Eigen	signature:(size_t size)
Eigen::ei_imag	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_imag(const T& x) { return numext::imag(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_isApprox	src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::ei_isApproxOrLessThan	src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::ei_isMuchSmallerThan	src/Eigen2Support/MathFunctions.h	/^inline bool ei_isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const OtherScalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::ei_is_same_type	src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	s	namespace:Eigen
Eigen::ei_is_same_type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	s	namespace:Eigen
Eigen::ei_is_same_type::ret	src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon354
Eigen::ei_is_same_type::ret	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon355
Eigen::ei_log	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_log (const T& x) { using std::log;  return log(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_meta_false	src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	s	namespace:Eigen
Eigen::ei_meta_false::ret	src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_meta_false::__anon353
Eigen::ei_meta_if	src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	s	namespace:Eigen
Eigen::ei_meta_if	src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	s	namespace:Eigen
Eigen::ei_meta_if::ret	src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	t	struct:Eigen::ei_meta_if	access:public
Eigen::ei_meta_if::ret	src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	t	struct:Eigen::ei_meta_if	access:public
Eigen::ei_meta_true	src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	s	namespace:Eigen
Eigen::ei_meta_true::ret	src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_meta_true::__anon352
Eigen::ei_pow	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_pow (const T& x,const T& y) { return numext::pow(x,y); }$/;"	f	namespace:Eigen	signature:(const T& x,const T& y)
Eigen::ei_quaternion_assign_impl	src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,3,3>$/;"	s	namespace:Eigen
Eigen::ei_quaternion_assign_impl	src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,4,1>$/;"	s	namespace:Eigen
Eigen::ei_quaternion_assign_impl::Scalar	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_quaternion_assign_impl	access:public
Eigen::ei_quaternion_assign_impl::run	src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& mat)$/;"	f	struct:Eigen::ei_quaternion_assign_impl	access:public	signature:(Quaternion<Scalar>& q, const Other& mat)
Eigen::ei_quaternion_assign_impl::run	src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& vec)$/;"	f	struct:Eigen::ei_quaternion_assign_impl	access:public	signature:(Quaternion<Scalar>& q, const Other& vec)
Eigen::ei_quaternion_product	src/Eigen2Support/Geometry/Quaternion.h	/^ei_quaternion_product(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)$/;"	f	namespace:Eigen	signature:(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)
Eigen::ei_random	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random () { return internal::random<T>(); }$/;"	f	namespace:Eigen	signature:()
Eigen::ei_random	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random (const T& x, const T& y) { return internal::random(x, y); }$/;"	f	namespace:Eigen	signature:(const T& x, const T& y)
Eigen::ei_real	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_real(const T& x) { return numext::real(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_sin	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sin (const T& x) { using std::sin;  return sin(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_sqrt	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sqrt(const T& x) { using std::sqrt; return sqrt(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_toRotationMatrix	src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> ei_toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen	signature:(const Scalar& s)
Eigen::ei_toRotationMatrix	src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> ei_toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen	signature:(const RotationBase<OtherDerived,Dim>& r)
Eigen::ei_toRotationMatrix	src/Eigen2Support/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& ei_toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen	signature:(const MatrixBase<OtherDerived>& mat)
Eigen::ei_traits	src/Eigen2Support/Geometry/AngleAxis.h	/^template<typename _Scalar> struct ei_traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen
Eigen::ei_traits	src/Eigen2Support/Geometry/Quaternion.h	/^template<typename _Scalar> struct ei_traits<Quaternion<_Scalar> >$/;"	s	namespace:Eigen
Eigen::ei_traits	src/Eigen2Support/Geometry/Rotation2D.h	/^template<typename _Scalar> struct ei_traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen
Eigen::ei_traits	src/Eigen2Support/Meta.h	/^struct ei_traits : internal::traits<T>$/;"	s	namespace:Eigen	inherits:internal::traits
Eigen::ei_traits::Scalar	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Eigen::ei_traits::Scalar	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Eigen::ei_traits::Scalar	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Eigen::ei_transform_product_impl	src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,1>$/;"	s	namespace:Eigen
Eigen::ei_transform_product_impl	src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen
Eigen::ei_transform_product_impl	src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,1>$/;"	s	namespace:Eigen
Eigen::ei_transform_product_impl	src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen
Eigen::ei_transform_product_impl::MatrixType	src/Eigen2Support/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::ResultType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::ResultType	src/Eigen2Support/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::ResultType	src/Eigen2Support/Geometry/Transform.h	/^  typedef typename ProductReturnType<MatrixType,Other>::Type ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::Scalar	src/Eigen2Support/Geometry/Transform.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::TransformType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::TransformType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::run	src/Eigen2Support/Geometry/Transform.h	/^  static ResultType run(const TransformType& tr, const Other& other)$/;"	f	struct:Eigen::ei_transform_product_impl	access:public	signature:(const TransformType& tr, const Other& other)
Eigen::ei_unconst	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unconst	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	s	namespace:Eigen
Eigen::ei_unconst	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	s	namespace:Eigen
Eigen::ei_unconst	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unconst::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	t	struct:Eigen::ei_unconst	access:public
Eigen::ei_unconst::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	t	struct:Eigen::ei_unconst	access:public
Eigen::ei_unconst::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	t	struct:Eigen::ei_unconst	access:public
Eigen::ei_unconst::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	t	struct:Eigen::ei_unconst	access:public
Eigen::ei_unpointer	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unpointer	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unpointer	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unpointer::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
Eigen::ei_unpointer::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
Eigen::ei_unpointer::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
Eigen::ei_unref	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unref	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unref::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	t	struct:Eigen::ei_unref	access:public
Eigen::ei_unref::type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	t	struct:Eigen::ei_unref	access:public
Eigen::fitHyperplane	src/Eigen2Support/LeastSquares.h	/^void fitHyperplane(int numPoints,$/;"	f	namespace:Eigen	signature:(int numPoints, VectorType **points, HyperplaneType *result, typename NumTraits<typename VectorType::Scalar>::Real* soundness = 0)
Eigen::general_product_to_triangular_selector	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,false>$/;"	s	namespace:Eigen
Eigen::general_product_to_triangular_selector	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,true>$/;"	s	namespace:Eigen
Eigen::general_product_to_triangular_selector::run	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static void run(MatrixType& mat, const ProductType& prod, const typename MatrixType::Scalar& alpha)$/;"	f	struct:Eigen::general_product_to_triangular_selector	access:public	signature:(MatrixType& mat, const ProductType& prod, const typename MatrixType::Scalar& alpha)
Eigen::householderSequence	src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen	signature:(const VectorsType& v, const CoeffsType& h)
Eigen::initParallel	src/Core/products/Parallelizer.h	/^inline void initParallel()$/;"	f	namespace:Eigen	signature:()
Eigen::internal	src/Cholesky/LDLT.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Cholesky/LLT.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Cholesky/LLT.h	/^namespace internal{$/;"	n	namespace:Eigen
Eigen::internal	src/Cholesky/LLT_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/CholmodSupport/CholmodSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Array.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/ArrayWrapper.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Assign.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Assign_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/BandMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Block.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/BooleanRedux.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/CwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/CwiseNullaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/CwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/CwiseUnaryView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/DenseBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/DenseCoeffsBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/DenseStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Diagonal.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/DiagonalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/DiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Dot.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Flagged.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/ForceAlignedAccess.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Functors.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Fuzzy.h	/^namespace internal$/;"	n	namespace:Eigen
Eigen::internal	src/Core/GeneralProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/GenericPacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/GlobalFunctions.h	/^  namespace internal$/;"	n	namespace:Eigen
Eigen::internal	src/Core/IO.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Map.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Matrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/NestByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/PermutationMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/PlainObjectBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/ProductBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Random.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Redux.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Ref.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Replicate.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/ReturnByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Reverse.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Select.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/SelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/SelfCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/SolveTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/StableNorm.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Swap.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Transpose.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Transpositions.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/TriangularMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/VectorBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/VectorwiseOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/Visitor.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/arch/AltiVec/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/arch/AltiVec/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/arch/NEON/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/arch/NEON/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/arch/SSE/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/arch/SSE/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/arch/SSE/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/CoeffBasedProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/GeneralBlockPanelKernel.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/GeneralMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/GeneralMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/GeneralMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/Parallelizer.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/SelfadjointMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/SelfadjointMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/SelfadjointRank2Update.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/TriangularMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/TriangularMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/TriangularMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/TriangularSolverMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/products/TriangularSolverVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/BlasUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/Constants.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/ForwardDeclarations.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/MKL_support.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/Macros.h	/^    namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/Macros.h	/^  namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/StaticAssert.h	/^    namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Core/util/XprHelper.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Eigen2Support/Minor.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Eigenvalues/ComplexSchur.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Eigenvalues/HessenbergDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Eigenvalues/Tridiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Geometry/AngleAxis.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Geometry/Homogeneous.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Geometry/OrthoMethods.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Geometry/Quaternion.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Geometry/Rotation2D.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Geometry/RotationBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Geometry/Transform.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Geometry/Umeyama.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Geometry/arch/Geometry_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Householder/BlockHouseholder.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Householder/Householder.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Householder/HouseholderSequence.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/Jacobi/Jacobi.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/LU/Determinant.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/LU/FullPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/LU/Inverse.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/LU/PartialPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/LU/PartialPivLU_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/LU/arch/Inverse_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/OrderingMethods/Amd.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/OrderingMethods/Ordering.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/PaStiXSupport/PaStiXSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/PaStiXSupport/PaStiXSupport.h	/^namespace internal$/;"	n	namespace:Eigen
Eigen::internal	src/PardisoSupport/PardisoSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/PardisoSupport/PardisoSupport.h	/^namespace internal$/;"	n	namespace:Eigen
Eigen::internal	src/QR/ColPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/QR/FullPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/QR/HouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/QR/HouseholderQR_MKL.h	/^  namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SPQRSupport/SuiteSparseQRSupport.h	/^  namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SPQRSupport/SuiteSparseQRSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SVD/JacobiSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SVD/UpperBidiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCholesky/SimplicialCholesky.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/AmbiVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/CompressedStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/MappedSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseColEtree.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseDenseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseDiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparsePermutation.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseSelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseSparseProductWithPruning.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseTriangularView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/SparseView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseCore/TriangularSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLUImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_Structs.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_SupernodalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_Utils.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_column_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_column_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_copy_to_ucol.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_gemm_kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_heap_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_kernel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_panel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_panel_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_pivotL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_pruneL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseLU/SparseLU_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SparseQR/SparseQR.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/StlSupport/details.h	/^  namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/SuperLUSupport/SuperLUSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/UmfPackSupport/UmfPackSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/misc/Image.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/misc/Kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/misc/Solve.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	src/misc/SparseSolve.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal::AmbiVector	src/SparseCore/AmbiVector.h	/^class AmbiVector$/;"	c	namespace:Eigen::internal
Eigen::internal::AmbiVector::AmbiVector	src/SparseCore/AmbiVector.h	/^    AmbiVector(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index size)
Eigen::internal::AmbiVector::Index	src/SparseCore/AmbiVector.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::AmbiVector	access:public
Eigen::internal::AmbiVector::Iterator	src/SparseCore/AmbiVector.h	/^class AmbiVector<_Scalar,_Index>::Iterator$/;"	c	class:Eigen::internal::AmbiVector
Eigen::internal::AmbiVector::Iterator::Iterator	src/SparseCore/AmbiVector.h	/^    Iterator(const AmbiVector& vec, const RealScalar& epsilon = 0)$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:(const AmbiVector& vec, const RealScalar& epsilon = 0)
Eigen::internal::AmbiVector::Iterator::RealScalar	src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator	access:public
Eigen::internal::AmbiVector::Iterator::Scalar	src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator	access:public
Eigen::internal::AmbiVector::Iterator::index	src/SparseCore/AmbiVector.h	/^    Index index() const { return m_cachedIndex; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
Eigen::internal::AmbiVector::Iterator::m_cachedIndex	src/SparseCore/AmbiVector.h	/^    Index m_cachedIndex;          \/\/ current coordinate$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_cachedValue	src/SparseCore/AmbiVector.h	/^    Scalar m_cachedValue;       \/\/ current value$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_currentEl	src/SparseCore/AmbiVector.h	/^    Index m_currentEl;            \/\/ the current element in sparse\/linked-list mode$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_epsilon	src/SparseCore/AmbiVector.h	/^    RealScalar m_epsilon;       \/\/ epsilon used to prune zero coefficients$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_isDense	src/SparseCore/AmbiVector.h	/^    bool m_isDense;             \/\/ mode of the vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_vector	src/SparseCore/AmbiVector.h	/^    const AmbiVector& m_vector; \/\/ the target vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::operator ++	src/SparseCore/AmbiVector.h	/^    Iterator& operator++()$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:()
Eigen::internal::AmbiVector::Iterator::operator bool	src/SparseCore/AmbiVector.h	/^    operator bool() const { return m_cachedIndex>=0; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
Eigen::internal::AmbiVector::Iterator::value	src/SparseCore/AmbiVector.h	/^    Scalar value() const { return m_cachedValue; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
Eigen::internal::AmbiVector::ListEl	src/SparseCore/AmbiVector.h	/^    struct ListEl$/;"	s	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::ListEl::index	src/SparseCore/AmbiVector.h	/^      Index index;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
Eigen::internal::AmbiVector::ListEl::next	src/SparseCore/AmbiVector.h	/^      Index next;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
Eigen::internal::AmbiVector::ListEl::value	src/SparseCore/AmbiVector.h	/^      Scalar value;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
Eigen::internal::AmbiVector::RealScalar	src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector	access:public
Eigen::internal::AmbiVector::Scalar	src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector	access:public
Eigen::internal::AmbiVector::coeff	src/SparseCore/AmbiVector.h	/^    Scalar& coeff(Index i);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(Index i)
Eigen::internal::AmbiVector::coeff	src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeff(_Index i)$/;"	f	class:Eigen::internal::AmbiVector	signature:(_Index i)
Eigen::internal::AmbiVector::coeffRef	src/SparseCore/AmbiVector.h	/^    Scalar& coeffRef(Index i);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(Index i)
Eigen::internal::AmbiVector::coeffRef	src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeffRef(_Index i)$/;"	f	class:Eigen::internal::AmbiVector	signature:(_Index i)
Eigen::internal::AmbiVector::init	src/SparseCore/AmbiVector.h	/^    void init(double estimatedDensity);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(double estimatedDensity)
Eigen::internal::AmbiVector::init	src/SparseCore/AmbiVector.h	/^    void init(int mode);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(int mode)
Eigen::internal::AmbiVector::init	src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(double estimatedDensity)$/;"	f	class:Eigen::internal::AmbiVector	signature:(double estimatedDensity)
Eigen::internal::AmbiVector::init	src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(int mode)$/;"	f	class:Eigen::internal::AmbiVector	signature:(int mode)
Eigen::internal::AmbiVector::m_allocatedElements	src/SparseCore/AmbiVector.h	/^    Index m_allocatedElements;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_allocatedSize	src/SparseCore/AmbiVector.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_buffer	src/SparseCore/AmbiVector.h	/^    Scalar* m_buffer;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_end	src/SparseCore/AmbiVector.h	/^    Index m_end;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_llCurrent	src/SparseCore/AmbiVector.h	/^    Index m_llCurrent;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_llSize	src/SparseCore/AmbiVector.h	/^    Index m_llSize;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_llStart	src/SparseCore/AmbiVector.h	/^    Index m_llStart;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_mode	src/SparseCore/AmbiVector.h	/^    Index m_mode;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_size	src/SparseCore/AmbiVector.h	/^    Index m_size;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_start	src/SparseCore/AmbiVector.h	/^    Index m_start;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_zero	src/SparseCore/AmbiVector.h	/^    Scalar m_zero;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::nonZeros	src/SparseCore/AmbiVector.h	/^    Index nonZeros() const;$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:() const
Eigen::internal::AmbiVector::nonZeros	src/SparseCore/AmbiVector.h	/^_Index AmbiVector<_Scalar,_Index>::nonZeros() const$/;"	f	class:Eigen::internal::AmbiVector	signature:() const
Eigen::internal::AmbiVector::reallocate	src/SparseCore/AmbiVector.h	/^    void reallocate(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:protected	signature:(Index size)
Eigen::internal::AmbiVector::reallocateSparse	src/SparseCore/AmbiVector.h	/^    void reallocateSparse()$/;"	f	class:Eigen::internal::AmbiVector	access:protected	signature:()
Eigen::internal::AmbiVector::resize	src/SparseCore/AmbiVector.h	/^    void resize(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index size)
Eigen::internal::AmbiVector::restart	src/SparseCore/AmbiVector.h	/^    void restart();$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:()
Eigen::internal::AmbiVector::restart	src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::restart()$/;"	f	class:Eigen::internal::AmbiVector	signature:()
Eigen::internal::AmbiVector::setBounds	src/SparseCore/AmbiVector.h	/^    void setBounds(Index start, Index end) { m_start = start; m_end = end; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index start, Index end)
Eigen::internal::AmbiVector::setZero	src/SparseCore/AmbiVector.h	/^    void setZero();$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:()
Eigen::internal::AmbiVector::setZero	src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::setZero()$/;"	f	class:Eigen::internal::AmbiVector	signature:()
Eigen::internal::AmbiVector::size	src/SparseCore/AmbiVector.h	/^    Index size() const { return m_size; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:() const
Eigen::internal::AmbiVector::~AmbiVector	src/SparseCore/AmbiVector.h	/^    ~AmbiVector() { delete[] m_buffer; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:()
Eigen::internal::BandMatrix	src/Core/BandMatrix.h	/^class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >$/;"	c	namespace:Eigen::internal	inherits:BandMatrixBase
Eigen::internal::BandMatrix::BandMatrix	src/Core/BandMatrix.h	/^    inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)
Eigen::internal::BandMatrix::CoefficientsType	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Eigen::internal::BandMatrix::Index	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Index Index;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Eigen::internal::BandMatrix::Scalar	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Eigen::internal::BandMatrix::coeffs	src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:()
Eigen::internal::BandMatrix::coeffs	src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrix::cols	src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrix::m_coeffs	src/Core/BandMatrix.h	/^    CoefficientsType m_coeffs;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
Eigen::internal::BandMatrix::m_rows	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
Eigen::internal::BandMatrix::m_subs	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
Eigen::internal::BandMatrix::m_supers	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
Eigen::internal::BandMatrix::rows	src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrix::subs	src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrix::supers	src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrixBase	src/Core/BandMatrix.h	/^class BandMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen::internal	inherits:EigenBase
Eigen::internal::BandMatrixBase::Base	src/Core/BandMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::CoeffReadCost	src/Core/BandMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Eigen::internal::BandMatrixBase::CoefficientsType	src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::ColsAtCompileTime	src/Core/BandMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Eigen::internal::BandMatrixBase::DataRowsAtCompileTime	src/Core/BandMatrix.h	/^      DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon142
Eigen::internal::BandMatrixBase::DenseMatrixType	src/Core/BandMatrix.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::DiagonalIntReturnType	src/Core/BandMatrix.h	/^    template<int Index> struct DiagonalIntReturnType {$/;"	s	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::ActualIndex	src/Core/BandMatrix.h	/^        ActualIndex = ReturnOpposite ? -Index : Index,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon143
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::BuildType	src/Core/BandMatrix.h	/^      typedef Block<CoefficientsType,1, DiagonalSize> BuildType;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType	access:public
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::Conjugate	src/Core/BandMatrix.h	/^        Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon143
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::DiagonalSize	src/Core/BandMatrix.h	/^        DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon143
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::ReturnOpposite	src/Core/BandMatrix.h	/^        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon143
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::Type	src/Core/BandMatrix.h	/^                 BuildType>::type Type;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType	access:public
Eigen::internal::BandMatrixBase::Flags	src/Core/BandMatrix.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Eigen::internal::BandMatrixBase::Index	src/Core/BandMatrix.h	/^    typedef typename DenseMatrixType::Index Index;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::MaxColsAtCompileTime	src/Core/BandMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Eigen::internal::BandMatrixBase::MaxRowsAtCompileTime	src/Core/BandMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Eigen::internal::BandMatrixBase::Options	src/Core/BandMatrix.h	/^      Options = internal::traits<Derived>::Options$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Eigen::internal::BandMatrixBase::RowsAtCompileTime	src/Core/BandMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Eigen::internal::BandMatrixBase::Scalar	src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::SizeAtCompileTime	src/Core/BandMatrix.h	/^      SizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime)$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon142
Eigen::internal::BandMatrixBase::Subs	src/Core/BandMatrix.h	/^      Subs   = internal::traits<Derived>::Subs,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Eigen::internal::BandMatrixBase::Supers	src/Core/BandMatrix.h	/^      Supers = internal::traits<Derived>::Supers,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Eigen::internal::BandMatrixBase::coeffs	src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
Eigen::internal::BandMatrixBase::coeffs	src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::col	src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,Dynamic,1> col(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i)
Eigen::internal::BandMatrixBase::diagonal	src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,Dynamic> diagonal(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i)
Eigen::internal::BandMatrixBase::diagonal	src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,SizeAtCompileTime> diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
Eigen::internal::BandMatrixBase::diagonal	src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i) const
Eigen::internal::BandMatrixBase::diagonal	src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::diagonal	src/Core/BandMatrix.h	/^    template<int N> inline const typename DiagonalIntReturnType<N>::Type diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::diagonal	src/Core/BandMatrix.h	/^    template<int N> inline typename DiagonalIntReturnType<N>::Type diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
Eigen::internal::BandMatrixBase::diagonalLength	src/Core/BandMatrix.h	/^    inline Index diagonalLength(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:protected	signature:(Index i) const
Eigen::internal::BandMatrixBase::evalTo	src/Core/BandMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Dest& dst) const
Eigen::internal::BandMatrixBase::subs	src/Core/BandMatrix.h	/^    inline Index subs() const { return derived().subs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::supers	src/Core/BandMatrix.h	/^    inline Index supers() const { return derived().supers(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::toDenseMatrix	src/Core/BandMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixWrapper	src/Core/BandMatrix.h	/^class BandMatrixWrapper : public BandMatrixBase<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	c	namespace:Eigen::internal	inherits:BandMatrixBase
Eigen::internal::BandMatrixWrapper::BandMatrixWrapper	src/Core/BandMatrix.h	/^    inline BandMatrixWrapper(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)
Eigen::internal::BandMatrixWrapper::CoefficientsType	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Eigen::internal::BandMatrixWrapper::Index	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Index Index;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Eigen::internal::BandMatrixWrapper::Scalar	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Eigen::internal::BandMatrixWrapper::coeffs	src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::BandMatrixWrapper::cols	src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::BandMatrixWrapper::m_coeffs	src/Core/BandMatrix.h	/^    const CoefficientsType& m_coeffs;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
Eigen::internal::BandMatrixWrapper::m_rows	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
Eigen::internal::BandMatrixWrapper::m_subs	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
Eigen::internal::BandMatrixWrapper::m_supers	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
Eigen::internal::BandMatrixWrapper::rows	src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::BandMatrixWrapper::subs	src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::BandMatrixWrapper::supers	src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::BlockImpl_dense	src/Core/Block.h	/^class BlockImpl_dense<XprType,BlockRows,BlockCols, InnerPanel,true>$/;"	c	namespace:Eigen::internal	inherits:MapBase
Eigen::internal::BlockImpl_dense	src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class BlockImpl_dense$/;"	c	namespace:Eigen::internal	inherits:internal::dense_xpr_base::type
Eigen::internal::BlockImpl_dense::Base	src/Core/Block.h	/^    typedef MapBase<BlockType> Base;$/;"	t	class:Eigen::internal::BlockImpl_dense	access:public
Eigen::internal::BlockImpl_dense::Base	src/Core/Block.h	/^    typedef typename internal::dense_xpr_base<BlockType>::type Base;$/;"	t	class:Eigen::internal::BlockImpl_dense	access:public
Eigen::internal::BlockImpl_dense::BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index a_startRow, Index a_startCol)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol)
Eigen::internal::BlockImpl_dense::BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index i)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index i)
Eigen::internal::BlockImpl_dense::BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index startRow, Index startCol)
Eigen::internal::BlockImpl_dense::BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:protected	signature:(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
Eigen::internal::BlockImpl_dense::BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr,$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)
Eigen::internal::BlockImpl_dense::BlockImpl_dense	src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr,$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)
Eigen::internal::BlockImpl_dense::BlockType	src/Core/Block.h	/^    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::internal::BlockImpl_dense	access:private
Eigen::internal::BlockImpl_dense::coeff	src/Core/Block.h	/^    EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId) const
Eigen::internal::BlockImpl_dense::coeff	src/Core/Block.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index) const
Eigen::internal::BlockImpl_dense::coeffRef	src/Core/Block.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index)
Eigen::internal::BlockImpl_dense::coeffRef	src/Core/Block.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId)
Eigen::internal::BlockImpl_dense::coeffRef	src/Core/Block.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index) const
Eigen::internal::BlockImpl_dense::coeffRef	src/Core/Block.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId) const
Eigen::internal::BlockImpl_dense::cols	src/Core/Block.h	/^    inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::data	src/Core/Block.h	/^    inline const Scalar* data() const;$/;"	p	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::init	src/Core/Block.h	/^    void init()$/;"	f	class:Eigen::internal::BlockImpl_dense	access:protected	signature:()
Eigen::internal::BlockImpl_dense::innerStride	src/Core/Block.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::innerStride	src/Core/Block.h	/^    inline Index innerStride() const;$/;"	p	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::m_blockCols	src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
Eigen::internal::BlockImpl_dense::m_blockRows	src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
Eigen::internal::BlockImpl_dense::m_outerStride	src/Core/Block.h	/^    Index m_outerStride;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
Eigen::internal::BlockImpl_dense::m_startCol	src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
Eigen::internal::BlockImpl_dense::m_startRow	src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
Eigen::internal::BlockImpl_dense::m_xpr	src/Core/Block.h	/^    const typename XprType::Nested m_xpr;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
Eigen::internal::BlockImpl_dense::m_xpr	src/Core/Block.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
Eigen::internal::BlockImpl_dense::nestedExpression	src/Core/Block.h	/^    const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const $/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::outerStride	src/Core/Block.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::outerStride	src/Core/Block.h	/^    inline Index outerStride() const;$/;"	p	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::packet	src/Core/Block.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index) const
Eigen::internal::BlockImpl_dense::packet	src/Core/Block.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId) const
Eigen::internal::BlockImpl_dense::rows	src/Core/Block.h	/^    inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::startCol	src/Core/Block.h	/^    Index startCol() const $/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::startRow	src/Core/Block.h	/^    Index startRow() const $/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
Eigen::internal::BlockImpl_dense::writePacket	src/Core/Block.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index, const PacketScalar& val)
Eigen::internal::BlockImpl_dense::writePacket	src/Core/Block.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId, const PacketScalar& val)
Eigen::internal::ComparisonName	src/Core/util/Constants.h	/^  enum ComparisonName {$/;"	g	namespace:Eigen::internal
Eigen::internal::CompressedStorage	src/SparseCore/CompressedStorage.h	/^class CompressedStorage$/;"	c	namespace:Eigen::internal
Eigen::internal::CompressedStorage::CompressedStorage	src/SparseCore/CompressedStorage.h	/^    CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
Eigen::internal::CompressedStorage::CompressedStorage	src/SparseCore/CompressedStorage.h	/^    CompressedStorage(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const CompressedStorage& other)
Eigen::internal::CompressedStorage::CompressedStorage	src/SparseCore/CompressedStorage.h	/^    CompressedStorage(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size)
Eigen::internal::CompressedStorage::Index	src/SparseCore/CompressedStorage.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::CompressedStorage	access:public
Eigen::internal::CompressedStorage::Map	src/SparseCore/CompressedStorage.h	/^    static CompressedStorage Map(Index* indices, Scalar* values, size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index* indices, Scalar* values, size_t size)
Eigen::internal::CompressedStorage::RealScalar	src/SparseCore/CompressedStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::Scalar	src/SparseCore/CompressedStorage.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::CompressedStorage	access:public
Eigen::internal::CompressedStorage::allocatedSize	src/SparseCore/CompressedStorage.h	/^    inline size_t allocatedSize() const { return m_allocatedSize; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:() const
Eigen::internal::CompressedStorage::append	src/SparseCore/CompressedStorage.h	/^    void append(const Scalar& v, Index i)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const Scalar& v, Index i)
Eigen::internal::CompressedStorage::at	src/SparseCore/CompressedStorage.h	/^    inline Scalar at(Index key, const Scalar& defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key, const Scalar& defaultValue = Scalar(0)) const
Eigen::internal::CompressedStorage::atInRange	src/SparseCore/CompressedStorage.h	/^    inline Scalar atInRange(size_t start, size_t end, Index key, const Scalar& defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t start, size_t end, Index key, const Scalar& defaultValue = Scalar(0)) const
Eigen::internal::CompressedStorage::atWithInsertion	src/SparseCore/CompressedStorage.h	/^    inline Scalar& atWithInsertion(Index key, const Scalar& defaultValue = Scalar(0))$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key, const Scalar& defaultValue = Scalar(0))
Eigen::internal::CompressedStorage::clear	src/SparseCore/CompressedStorage.h	/^    inline void clear() { m_size = 0; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
Eigen::internal::CompressedStorage::index	src/SparseCore/CompressedStorage.h	/^    inline Index& index(size_t i) { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i)
Eigen::internal::CompressedStorage::index	src/SparseCore/CompressedStorage.h	/^    inline const Index& index(size_t i) const { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i) const
Eigen::internal::CompressedStorage::m_allocatedSize	src/SparseCore/CompressedStorage.h	/^    size_t m_allocatedSize;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::m_indices	src/SparseCore/CompressedStorage.h	/^    Index* m_indices;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::m_size	src/SparseCore/CompressedStorage.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::m_values	src/SparseCore/CompressedStorage.h	/^    Scalar* m_values;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::operator =	src/SparseCore/CompressedStorage.h	/^    CompressedStorage& operator=(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const CompressedStorage& other)
Eigen::internal::CompressedStorage::prune	src/SparseCore/CompressedStorage.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())
Eigen::internal::CompressedStorage::reallocate	src/SparseCore/CompressedStorage.h	/^    inline void reallocate(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:protected	signature:(size_t size)
Eigen::internal::CompressedStorage::reserve	src/SparseCore/CompressedStorage.h	/^    void reserve(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size)
Eigen::internal::CompressedStorage::resize	src/SparseCore/CompressedStorage.h	/^    void resize(size_t size, double reserveSizeFactor = 0)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size, double reserveSizeFactor = 0)
Eigen::internal::CompressedStorage::searchLowerIndex	src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index key) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key) const
Eigen::internal::CompressedStorage::searchLowerIndex	src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(size_t start, size_t end, Index key) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t start, size_t end, Index key) const
Eigen::internal::CompressedStorage::size	src/SparseCore/CompressedStorage.h	/^    inline size_t size() const { return m_size; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:() const
Eigen::internal::CompressedStorage::squeeze	src/SparseCore/CompressedStorage.h	/^    void squeeze()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
Eigen::internal::CompressedStorage::swap	src/SparseCore/CompressedStorage.h	/^    void swap(CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(CompressedStorage& other)
Eigen::internal::CompressedStorage::value	src/SparseCore/CompressedStorage.h	/^    inline Scalar& value(size_t i) { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i)
Eigen::internal::CompressedStorage::value	src/SparseCore/CompressedStorage.h	/^    inline const Scalar& value(size_t i) const { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i) const
Eigen::internal::CompressedStorage::~CompressedStorage	src/SparseCore/CompressedStorage.h	/^    ~CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(all, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(all, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(any, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(any, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(blueNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(blueNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(count, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(count, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(hypotNorm, (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost );$/;"	p	namespace:Eigen::internal	signature:(hypotNorm, (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost )
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(mean, (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost);$/;"	p	namespace:Eigen::internal	signature:(mean, (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(norm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(norm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(prod, (Size-1)*NumTraits<Scalar>::MulCost);$/;"	p	namespace:Eigen::internal	signature:(prod, (Size-1)*NumTraits<Scalar>::MulCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(squaredNorm, Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(squaredNorm, Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(stableNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(stableNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(sum, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(sum, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::FullPivHouseholderQRMatrixQReturnType	src/QR/FullPivHouseholderQR.h	/^template<typename MatrixType> struct FullPivHouseholderQRMatrixQReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::FullPivHouseholderQRMatrixQReturnType	src/QR/FullPivHouseholderQR.h	/^  FullPivHouseholderQRMatrixQReturnType(const MatrixType&       qr,$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(const MatrixType& qr, const HCoeffsType& hCoeffs, const IntDiagSizeVectorType& rowsTranspositions)
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::HCoeffsType	src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::Index	src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::IntDiagSizeVectorType	src/QR/FullPivHouseholderQR.h	/^  typedef typename FullPivHouseholderQR<MatrixType>::IntDiagSizeVectorType IntDiagSizeVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::WorkVectorType	src/QR/FullPivHouseholderQR.h	/^                 MatrixType::MaxRowsAtCompileTime> WorkVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::cols	src/QR/FullPivHouseholderQR.h	/^    Index cols() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:() const
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::evalTo	src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(ResultType& result) const
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::evalTo	src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result, WorkVectorType& workspace) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(ResultType& result, WorkVectorType& workspace) const
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::m_hCoeffs	src/QR/FullPivHouseholderQR.h	/^  typename HCoeffsType::Nested m_hCoeffs;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::m_qr	src/QR/FullPivHouseholderQR.h	/^  typename MatrixType::Nested m_qr;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::m_rowsTranspositions	src/QR/FullPivHouseholderQR.h	/^  typename IntDiagSizeVectorType::Nested m_rowsTranspositions;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::rows	src/QR/FullPivHouseholderQR.h	/^    Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:() const
Eigen::internal::GemmParallelInfo	src/Core/products/Parallelizer.h	/^template<typename Index> struct GemmParallelInfo$/;"	s	namespace:Eigen::internal
Eigen::internal::GemmParallelInfo::GemmParallelInfo	src/Core/products/Parallelizer.h	/^  GemmParallelInfo() : sync(-1), users(0), rhs_start(0), rhs_length(0) {}$/;"	f	struct:Eigen::internal::GemmParallelInfo	access:public	signature:()
Eigen::internal::GemmParallelInfo::rhs_length	src/Core/products/Parallelizer.h	/^  Index rhs_length;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
Eigen::internal::GemmParallelInfo::rhs_start	src/Core/products/Parallelizer.h	/^  Index rhs_start;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
Eigen::internal::GemmParallelInfo::sync	src/Core/products/Parallelizer.h	/^  int volatile sync;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
Eigen::internal::GemmParallelInfo::users	src/Core/products/Parallelizer.h	/^  int volatile users;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
Eigen::internal::HessenbergDecompositionMatrixHReturnType	src/Eigenvalues/HessenbergDecomposition.h	/^template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::HessenbergDecompositionMatrixHReturnType::HessenbergDecompositionMatrixHReturnType	src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecompositionMatrixHReturnType(const HessenbergDecomposition<MatrixType>& hess) : m_hess(hess) { }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:(const HessenbergDecomposition<MatrixType>& hess)
Eigen::internal::HessenbergDecompositionMatrixHReturnType::Index	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public
Eigen::internal::HessenbergDecompositionMatrixHReturnType::cols	src/Eigenvalues/HessenbergDecomposition.h	/^    Index cols() const { return m_hess.packedMatrix().cols(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:() const
Eigen::internal::HessenbergDecompositionMatrixHReturnType::evalTo	src/Eigenvalues/HessenbergDecomposition.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:(ResultType& result) const
Eigen::internal::HessenbergDecompositionMatrixHReturnType::m_hess	src/Eigenvalues/HessenbergDecomposition.h	/^    const HessenbergDecomposition<MatrixType>& m_hess;$/;"	m	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:protected
Eigen::internal::HessenbergDecompositionMatrixHReturnType::rows	src/Eigenvalues/HessenbergDecomposition.h	/^    Index rows() const { return m_hess.packedMatrix().rows(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:() const
Eigen::internal::Indefinite	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Eigen::internal::LDLT_Traits	src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::LDLT_Traits	src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::LDLT_Traits::MatrixL	src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
Eigen::internal::LDLT_Traits::MatrixL	src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
Eigen::internal::LDLT_Traits::MatrixU	src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
Eigen::internal::LDLT_Traits::MatrixU	src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
Eigen::internal::LDLT_Traits::getL	src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LDLT_Traits::getL	src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LDLT_Traits::getU	src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LDLT_Traits::getU	src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LLT_Traits	src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::LLT_Traits	src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::LLT_Traits::MatrixL	src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
Eigen::internal::LLT_Traits::MatrixL	src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
Eigen::internal::LLT_Traits::MatrixU	src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
Eigen::internal::LLT_Traits::MatrixU	src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
Eigen::internal::LLT_Traits::getL	src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LLT_Traits::getL	src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LLT_Traits::getU	src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LLT_Traits::getU	src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LLT_Traits::inplace_decomposition	src/Cholesky/LLT.h	/^  static bool inplace_decomposition(MatrixType& m)$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(MatrixType& m)
Eigen::internal::LLVL	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
Eigen::internal::LSUB	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
Eigen::internal::LUNoMarker	src/SparseLU/SparseLU_Memory.h	/^enum { LUNoMarker = 3 };$/;"	e	enum:Eigen::internal::__anon461
Eigen::internal::LUSUP	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
Eigen::internal::LUTempSpace	src/SparseLU/SparseLU_Memory.h	/^inline Index LUTempSpace(Index&m, Index& w)$/;"	f	namespace:Eigen::internal	signature:(Index&m, Index& w)
Eigen::internal::LU_GlobalLU_t	src/SparseLU/SparseLU_Structs.h	/^struct LU_GlobalLU_t {$/;"	s	namespace:Eigen::internal
Eigen::internal::LU_GlobalLU_t::Index	src/SparseLU/SparseLU_Structs.h	/^  typedef typename IndexVector::Scalar Index; $/;"	t	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::lsub	src/SparseLU/SparseLU_Structs.h	/^  IndexVector lsub; \/\/ Compressed row indices of L rectangular supernodes. $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::lusup	src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  lusup; \/\/ nonzero values of L ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::n	src/SparseLU/SparseLU_Structs.h	/^  Index   n; \/\/ Number of columns in the matrix  $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::num_expansions	src/SparseLU/SparseLU_Structs.h	/^  Index   num_expansions; $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::nzlmax	src/SparseLU/SparseLU_Structs.h	/^  Index   nzlmax; \/\/ Current max size of lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::nzlumax	src/SparseLU/SparseLU_Structs.h	/^  Index   nzlumax; \/\/ Current max size of lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::nzumax	src/SparseLU/SparseLU_Structs.h	/^  Index   nzumax; \/\/ Current max size of ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::supno	src/SparseLU/SparseLU_Structs.h	/^  IndexVector supno; \/\/ Supernode number corresponding to this column (column to supernode mapping)$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::ucol	src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  ucol; \/\/ nonzero values of U ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::usub	src/SparseLU/SparseLU_Structs.h	/^  IndexVector usub; \/\/ row indices of U columns in ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::xlsub	src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlsub; \/\/ pointers to the beginning of each column in lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::xlusup	src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlusup; \/\/ pointers to the beginning of each column in lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::xsup	src/SparseLU/SparseLU_Structs.h	/^  IndexVector xsup; \/\/First supernode column ... xsup(s) points to the beginning of the s-th supernode$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_GlobalLU_t::xusub	src/SparseLU/SparseLU_Structs.h	/^  IndexVector xusub; \/\/ Pointers to the beginning of each column of U in ucol $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
Eigen::internal::LU_kernel_bmod	src/SparseLU/SparseLU_kernel_bmod.h	/^template <> struct LU_kernel_bmod<1>$/;"	s	namespace:Eigen::internal
Eigen::internal::LU_kernel_bmod	src/SparseLU/SparseLU_kernel_bmod.h	/^template <int SegSizeAtCompileTime> struct LU_kernel_bmod$/;"	s	namespace:Eigen::internal
Eigen::internal::LU_kernel_bmod::run	src/SparseLU/SparseLU_kernel_bmod.h	/^  static EIGEN_DONT_INLINE void run(const int \/*segsize*\/, BlockScalarVector& dense, ScalarVector& \/*tempv*\/, ScalarVector& lusup, Index& luptr,$/;"	p	struct:Eigen::internal::LU_kernel_bmod	access:public	signature:(const int , BlockScalarVector& dense, ScalarVector& , ScalarVector& lusup, Index& luptr, const Index lda, const Index nrow, IndexVector& lsub, const Index lptr, const Index no_zeros)
Eigen::internal::LU_kernel_bmod::run	src/SparseLU/SparseLU_kernel_bmod.h	/^  static EIGEN_DONT_INLINE void run(const int segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda,$/;"	p	struct:Eigen::internal::LU_kernel_bmod	access:public	signature:(const int segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda, const Index nrow, IndexVector& lsub, const Index lptr, const Index no_zeros)
Eigen::internal::LU_kernel_bmod::run	src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<1>::run(const int \/*segsize*\/, BlockScalarVector& dense, ScalarVector& \/*tempv*\/, ScalarVector& lusup, Index& luptr,$/;"	f	class:Eigen::internal::LU_kernel_bmod	signature:(const int , BlockScalarVector& dense, ScalarVector& , ScalarVector& lusup, Index& luptr, const Index lda, const Index nrow, IndexVector& lsub, const Index lptr, const Index no_zeros)
Eigen::internal::LU_kernel_bmod::run	src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<SegSizeAtCompileTime>::run(const int segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda,$/;"	f	class:Eigen::internal::LU_kernel_bmod	signature:(const int segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda, const Index nrow, IndexVector& lsub, const Index lptr, const Index no_zeros)
Eigen::internal::LUnumTempV	src/SparseLU/SparseLU_Memory.h	/^inline Index LUnumTempV(Index& m, Index& w, Index& t, Index& b)$/;"	f	namespace:Eigen::internal	signature:(Index& m, Index& w, Index& t, Index& b)
Eigen::internal::MappedSuperNodalMatrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix$/;"	c	namespace:Eigen::internal
Eigen::internal::MappedSuperNodalMatrix::Index	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix	access:public
Eigen::internal::MappedSuperNodalMatrix::IndexVector	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<Index,Dynamic,1> IndexVector; $/;"	t	class:Eigen::internal::MappedSuperNodalMatrix	access:public
Eigen::internal::MappedSuperNodalMatrix::InnerIterator	src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix<Scalar,Index>::InnerIterator$/;"	c	class:Eigen::internal::MappedSuperNodalMatrix
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::InnerIterator	src/SparseLU/SparseLU_SupernodalMatrix.h	/^     InnerIterator(const MappedSuperNodalMatrix& mat, Index outer)$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:(const MappedSuperNodalMatrix& mat, Index outer)
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::col	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index col() const { return m_outer; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::index	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index index() const { return m_matrix.rowIndex()[m_idrow]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::m_endidrow	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_endidrow;                       \/\/ End index of row indices of the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::m_endidval	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_endidval;                 \/\/ End of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::m_idrow	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idrow;                          \/\/ Index to browse the row indices $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::m_idval	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idval;                          \/\/ Index to browse the values in the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::m_matrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const MappedSuperNodalMatrix& m_matrix; \/\/ Supernodal lower triangular matrix $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::m_outer	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_outer;                    \/\/ Current column $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::m_startidval	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_startidval;               \/\/ Start of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::m_supno	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_supno;                    \/\/ Current SuperNode number$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::operator ++	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline InnerIterator& operator++()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::operator bool	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline operator bool() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::row	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index row() const { return index(); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::supIndex	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index supIndex() const { return m_supno; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::value	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_idval]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::InnerIterator::valueRef	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_idval]); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::MappedSuperNodalMatrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::MappedSuperNodalMatrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix(Index m, Index n,  ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:(Index m, Index n, ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, IndexVector& rowind_colptr, IndexVector& col_to_sup, IndexVector& sup_to_col )
Eigen::internal::MappedSuperNodalMatrix::Scalar	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _Scalar Scalar; $/;"	t	class:Eigen::internal::MappedSuperNodalMatrix	access:public
Eigen::internal::MappedSuperNodalMatrix::ScalarVector	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix	access:public
Eigen::internal::MappedSuperNodalMatrix::colIndexPtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* colIndexPtr()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::colIndexPtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* colIndexPtr() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::colToSup	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* colToSup()  { return m_col_to_sup; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::colToSup	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* colToSup() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::cols	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index cols() { return m_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::m_col	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_col; \/\/ Number of columns $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
Eigen::internal::MappedSuperNodalMatrix::m_col_to_sup	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_col_to_sup; \/\/ col_to_sup[j] is the supernode number to which column j belongs$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
Eigen::internal::MappedSuperNodalMatrix::m_nsuper	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_nsuper; \/\/ Number of supernodes $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
Eigen::internal::MappedSuperNodalMatrix::m_nzval	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* m_nzval; \/\/array of nonzero values packed by column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
Eigen::internal::MappedSuperNodalMatrix::m_nzval_colptr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_nzval_colptr; \/\/nzval_colptr[j] Stores the location in nzval[] which starts column j $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
Eigen::internal::MappedSuperNodalMatrix::m_row	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_row; \/\/ Number of rows$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
Eigen::internal::MappedSuperNodalMatrix::m_rowind	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_rowind; \/\/ Array of compressed row indices of rectangular supernodes$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
Eigen::internal::MappedSuperNodalMatrix::m_rowind_colptr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_rowind_colptr; \/\/rowind_colptr[j] stores the location in rowind[] which starts column j$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
Eigen::internal::MappedSuperNodalMatrix::m_sup_to_col	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_sup_to_col; \/\/sup_to_col[s] points to the starting column of the s-th supernode$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
Eigen::internal::MappedSuperNodalMatrix::nsuper	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index nsuper() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::rowIndex	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* rowIndex()  { return m_rowind; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::rowIndex	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* rowIndex() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::rowIndexPtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* rowIndexPtr() { return m_rowind_colptr; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::rowIndexPtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* rowIndexPtr() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::rows	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index rows() { return m_row; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::setInfos	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    void setInfos(Index m, Index n, ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:(Index m, Index n, ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, IndexVector& rowind_colptr, IndexVector& col_to_sup, IndexVector& sup_to_col )
Eigen::internal::MappedSuperNodalMatrix::solveInPlace	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    void solveInPlace( MatrixBase<Dest>&X) const;$/;"	p	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:( MatrixBase<Dest>&X) const
Eigen::internal::MappedSuperNodalMatrix::solveInPlace	src/SparseLU/SparseLU_SupernodalMatrix.h	/^void MappedSuperNodalMatrix<Scalar,Index>::solveInPlace( MatrixBase<Dest>&X) const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	signature:( MatrixBase<Dest>&X) const
Eigen::internal::MappedSuperNodalMatrix::supToCol	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* supToCol() { return m_sup_to_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::supToCol	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* supToCol() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::valuePtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* valuePtr() {  return m_nzval; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MappedSuperNodalMatrix::valuePtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Scalar* valuePtr() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
Eigen::internal::MappedSuperNodalMatrix::~MappedSuperNodalMatrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    ~MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
Eigen::internal::MemType	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	t	namespace:Eigen::internal	typeref:enum:Eigen::internal::__anon463
Eigen::internal::NegativeSemiDef	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Eigen::internal::NewInf	src/Core/util/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen::internal
Eigen::internal::NewSup	src/Core/util/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen::internal
Eigen::internal::Packet16uc	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned char  Packet16uc;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet1cd	src/Core/arch/SSE/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Eigen::internal::Packet1cd::Packet1cd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd	access:public	signature:()
Eigen::internal::Packet1cd::Packet1cd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const __m128d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd	access:public	signature:(const __m128d& a)
Eigen::internal::Packet1cd::v	src/Core/arch/SSE/Complex.h	/^  __m128d  v;$/;"	m	struct:Eigen::internal::Packet1cd	access:public
Eigen::internal::Packet2cf	src/Core/arch/AltiVec/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Eigen::internal::Packet2cf	src/Core/arch/NEON/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Eigen::internal::Packet2cf	src/Core/arch/SSE/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Eigen::internal::Packet2cf::Packet2cf	src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Eigen::internal::Packet2cf::Packet2cf	src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const Packet4f& a)
Eigen::internal::Packet2cf::Packet2cf	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Eigen::internal::Packet2cf::Packet2cf	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const Packet4f& a)
Eigen::internal::Packet2cf::Packet2cf	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Eigen::internal::Packet2cf::Packet2cf	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const __m128& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const __m128& a)
Eigen::internal::Packet2cf::v	src/Core/arch/AltiVec/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
Eigen::internal::Packet2cf::v	src/Core/arch/NEON/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
Eigen::internal::Packet2cf::v	src/Core/arch/SSE/Complex.h	/^  __m128  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
Eigen::internal::Packet2d	src/Core/arch/SSE/PacketMath.h	/^typedef __m128d Packet2d;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4bi	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool int     Packet4bi;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4f	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector float          Packet4f;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4f	src/Core/arch/NEON/PacketMath.h	/^typedef float32x4_t Packet4f;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4f	src/Core/arch/SSE/PacketMath.h	/^typedef __m128  Packet4f;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector int            Packet4i;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4i	src/Core/arch/NEON/PacketMath.h	/^typedef int32x4_t   Packet4i;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4i	src/Core/arch/SSE/PacketMath.h	/^typedef __m128i Packet4i;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4ui	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned int   Packet4ui;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4ui	src/Core/arch/NEON/PacketMath.h	/^typedef uint32x4_t  Packet4ui;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet8i	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector short int      Packet8i;$/;"	t	namespace:Eigen::internal
Eigen::internal::PermPermProduct	src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	e	enum:Eigen::internal::PermPermProduct_t
Eigen::internal::PermPermProduct_t	src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	g	namespace:Eigen::internal
Eigen::internal::PositiveSemiDef	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Eigen::internal::PreconditionIfMoreColsThanRows	src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon416
Eigen::internal::PreconditionIfMoreRowsThanCols	src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon416
Eigen::internal::QuickSplit	src/IterativeLinearSolvers/IncompleteLUT.h	/^Index QuickSplit(VectorV &row, VectorI &ind, Index ncut)$/;"	f	namespace:Eigen::internal	signature:(VectorV &row, VectorI &ind, Index ncut)
Eigen::internal::SDP_IsDiagonal	src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon443
Eigen::internal::SDP_IsSparseColMajor	src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon443
Eigen::internal::SDP_IsSparseRowMajor	src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon443
Eigen::internal::SVA_Inner	src/SparseCore/SparseVector.h	/^  SVA_Inner,$/;"	e	enum:Eigen::internal::__anon457
Eigen::internal::SVA_Outer	src/SparseCore/SparseVector.h	/^  SVA_Outer$/;"	e	enum:Eigen::internal::__anon457
Eigen::internal::SVA_RuntimeSwitch	src/SparseCore/SparseVector.h	/^  SVA_RuntimeSwitch,$/;"	e	enum:Eigen::internal::__anon457
Eigen::internal::SignMatrix	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	g	namespace:Eigen::internal
Eigen::internal::SparseLUImpl	src/SparseLU/SparseLUImpl.h	/^class SparseLUImpl$/;"	c	namespace:Eigen::internal
Eigen::internal::SparseLUImpl::BlockIndexVector	src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<Index,Dynamic,1> > BlockIndexVector;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
Eigen::internal::SparseLUImpl::BlockScalarVector	src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<Scalar,Dynamic,1> > BlockScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
Eigen::internal::SparseLUImpl::GlobalLU_t	src/SparseLU/SparseLUImpl.h	/^    typedef LU_GlobalLU_t<IndexVector, ScalarVector> GlobalLU_t; $/;"	t	class:Eigen::internal::SparseLUImpl	access:public
Eigen::internal::SparseLUImpl::IndexVector	src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Index,Dynamic,1> IndexVector; $/;"	t	class:Eigen::internal::SparseLUImpl	access:public
Eigen::internal::SparseLUImpl::MappedMatrixBlock	src/SparseLU/SparseLUImpl.h	/^    typedef Map<ScalarMatrix, 0,  OuterStride<> > MappedMatrixBlock;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
Eigen::internal::SparseLUImpl::MatrixType	src/SparseLU/SparseLUImpl.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> MatrixType; $/;"	t	class:Eigen::internal::SparseLUImpl	access:public
Eigen::internal::SparseLUImpl::RealScalar	src/SparseLU/SparseLUImpl.h	/^    typedef typename ScalarVector::RealScalar RealScalar; $/;"	t	class:Eigen::internal::SparseLUImpl	access:public
Eigen::internal::SparseLUImpl::ScalarMatrix	src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic,ColMajor> ScalarMatrix;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
Eigen::internal::SparseLUImpl::ScalarVector	src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
Eigen::internal::SparseLUImpl::column_bmod	src/SparseLU/SparseLUImpl.h	/^     Index column_bmod(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::column_bmod	src/SparseLU/SparseLU_column_bmod.h	/^Index SparseLUImpl<Scalar,Index>::column_bmod(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::column_dfs	src/SparseLU/SparseLUImpl.h	/^     Index column_dfs(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg,  BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg, BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::column_dfs	src/SparseLU/SparseLU_column_dfs.h	/^Index SparseLUImpl<Scalar,Index>::column_dfs(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg,  BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg, BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::copy_to_ucol	src/SparseLU/SparseLUImpl.h	/^     Index copy_to_ucol(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::copy_to_ucol	src/SparseLU/SparseLU_copy_to_ucol.h	/^Index SparseLUImpl<Scalar,Index>::copy_to_ucol(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::countnz	src/SparseLU/SparseLUImpl.h	/^     void countnz(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::countnz	src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,Index>::countnz(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::dfs_kernel	src/SparseLU/SparseLUImpl.h	/^     void dfs_kernel(const Index jj, IndexVector& perm_r,$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jj, IndexVector& perm_r, Index& nseg, IndexVector& panel_lsub, IndexVector& segrep, Ref<IndexVector> repfnz_col, IndexVector& xprune, Ref<IndexVector> marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu, Index& nextl_col, Index krow, Traits& traits)
Eigen::internal::SparseLUImpl::dfs_kernel	src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,Index>::dfs_kernel(const Index jj, IndexVector& perm_r,$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jj, IndexVector& perm_r, Index& nseg, IndexVector& panel_lsub, IndexVector& segrep, Ref<IndexVector> repfnz_col, IndexVector& xprune, Ref<IndexVector> marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu, Index& nextl_col, Index krow, Traits& traits )
Eigen::internal::SparseLUImpl::expand	src/SparseLU/SparseLUImpl.h	/^     Index expand(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions)
Eigen::internal::SparseLUImpl::expand	src/SparseLU/SparseLU_Memory.h	/^Index  SparseLUImpl<Scalar,Index>::expand(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions) $/;"	f	class:Eigen::internal::SparseLUImpl	signature:(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions)
Eigen::internal::SparseLUImpl::fixupL	src/SparseLU/SparseLUImpl.h	/^     void fixupL(const Index n, const IndexVector& perm_r, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::fixupL	src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,Index>::fixupL(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::heap_relax_snode	src/SparseLU/SparseLUImpl.h	/^     void heap_relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)
Eigen::internal::SparseLUImpl::heap_relax_snode	src/SparseLU/SparseLU_heap_relax_snode.h	/^void SparseLUImpl<Scalar,Index>::heap_relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)
Eigen::internal::SparseLUImpl::memInit	src/SparseLU/SparseLUImpl.h	/^     Index memInit(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size,  GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::memInit	src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,Index>::memInit(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size,  GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::memXpand	src/SparseLU/SparseLUImpl.h	/^     Index memXpand(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions)
Eigen::internal::SparseLUImpl::memXpand	src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,Index>::memXpand(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions)
Eigen::internal::SparseLUImpl::panel_bmod	src/SparseLU/SparseLUImpl.h	/^     void panel_bmod(const Index m, const Index w, const Index jcol, const Index nseg, ScalarVector& dense, ScalarVector& tempv, IndexVector& segrep, IndexVector& repfnz, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index m, const Index w, const Index jcol, const Index nseg, ScalarVector& dense, ScalarVector& tempv, IndexVector& segrep, IndexVector& repfnz, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::panel_bmod	src/SparseLU/SparseLU_panel_bmod.h	/^void SparseLUImpl<Scalar,Index>::panel_bmod(const Index m, const Index w, const Index jcol, $/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index m, const Index w, const Index jcol, const Index nseg, ScalarVector& dense, ScalarVector& tempv, IndexVector& segrep, IndexVector& repfnz, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::panel_dfs	src/SparseLU/SparseLUImpl.h	/^     void panel_dfs(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::panel_dfs	src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,Index>::panel_dfs(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::pivotL	src/SparseLU/SparseLUImpl.h	/^     Index pivotL(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::pivotL	src/SparseLU/SparseLU_pivotL.h	/^Index SparseLUImpl<Scalar,Index>::pivotL(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::pruneL	src/SparseLU/SparseLUImpl.h	/^     void pruneL(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg, const IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg, const IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::pruneL	src/SparseLU/SparseLU_pruneL.h	/^void SparseLUImpl<Scalar,Index>::pruneL(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg, const IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg, const IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::relax_snode	src/SparseLU/SparseLUImpl.h	/^     void relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)
Eigen::internal::SparseLUImpl::relax_snode	src/SparseLU/SparseLU_relax_snode.h	/^void SparseLUImpl<Scalar,Index>::relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)
Eigen::internal::SparseLUImpl::snode_bmod	src/SparseLU/SparseLUImpl.h	/^     Index snode_bmod (const Index jcol, const Index fsupc, ScalarVector& dense, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const Index fsupc, ScalarVector& dense, GlobalLU_t& glu)
Eigen::internal::SparseLUImpl::snode_dfs	src/SparseLU/SparseLUImpl.h	/^     Index snode_dfs(const Index jcol, const Index kcol,const MatrixType& mat,  IndexVector& xprune, IndexVector& marker, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const Index kcol,const MatrixType& mat, IndexVector& xprune, IndexVector& marker, GlobalLU_t& glu)
Eigen::internal::TransposeImpl_base	src/Core/Transpose.h	/^struct TransposeImpl_base$/;"	s	namespace:Eigen::internal
Eigen::internal::TransposeImpl_base	src/Core/Transpose.h	/^struct TransposeImpl_base<MatrixType, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::TransposeImpl_base::type	src/Core/Transpose.h	/^  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;$/;"	t	struct:Eigen::internal::TransposeImpl_base	access:public
Eigen::internal::TridiagonalMatrix	src/Core/BandMatrix.h	/^class TridiagonalMatrix : public BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor>$/;"	c	namespace:Eigen::internal	inherits:BandMatrix
Eigen::internal::TridiagonalMatrix::Base	src/Core/BandMatrix.h	/^    typedef BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor> Base;$/;"	t	class:Eigen::internal::TridiagonalMatrix	access:private
Eigen::internal::TridiagonalMatrix::Index	src/Core/BandMatrix.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::internal::TridiagonalMatrix	access:private
Eigen::internal::TridiagonalMatrix::TridiagonalMatrix	src/Core/BandMatrix.h	/^    TridiagonalMatrix(Index size = Size) : Base(size,size,Options&SelfAdjoint?0:1,1) {}$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:(Index size = Size)
Eigen::internal::TridiagonalMatrix::sub	src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<-1>::Type sub() const$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:() const
Eigen::internal::TridiagonalMatrix::sub	src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<-1>::Type sub()$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:()
Eigen::internal::TridiagonalMatrix::super	src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<1>::Type super() const$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:() const
Eigen::internal::TridiagonalMatrix::super	src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<1>::Type super()$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:()
Eigen::internal::TridiagonalizationMatrixTReturnType	src/Eigenvalues/Tridiagonalization.h	/^template<typename MatrixType> struct TridiagonalizationMatrixTReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::TridiagonalizationMatrixTReturnType::Index	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public
Eigen::internal::TridiagonalizationMatrixTReturnType::TridiagonalizationMatrixTReturnType	src/Eigenvalues/Tridiagonalization.h	/^    TridiagonalizationMatrixTReturnType(const MatrixType& mat) : m_matrix(mat) { }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:(const MatrixType& mat)
Eigen::internal::TridiagonalizationMatrixTReturnType::cols	src/Eigenvalues/Tridiagonalization.h	/^    Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:() const
Eigen::internal::TridiagonalizationMatrixTReturnType::evalTo	src/Eigenvalues/Tridiagonalization.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:(ResultType& result) const
Eigen::internal::TridiagonalizationMatrixTReturnType::m_matrix	src/Eigenvalues/Tridiagonalization.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:protected
Eigen::internal::TridiagonalizationMatrixTReturnType::rows	src/Eigenvalues/Tridiagonalization.h	/^    Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:() const
Eigen::internal::UCOL	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
Eigen::internal::ULVL	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
Eigen::internal::USUB	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
Eigen::internal::UpperBidiagonalization	src/SVD/UpperBidiagonalization.h	/^template<typename _MatrixType> class UpperBidiagonalization$/;"	c	namespace:Eigen::internal
Eigen::internal::UpperBidiagonalization::BidiagonalType	src/SVD/UpperBidiagonalization.h	/^    typedef BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0> BidiagonalType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::ColVectorType	src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::ColsAtCompileTime	src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon423
Eigen::internal::UpperBidiagonalization::ColsAtCompileTimeMinusOne	src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTimeMinusOne = internal::decrement_size<ColsAtCompileTime>::ret$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon423
Eigen::internal::UpperBidiagonalization::DiagVectorType	src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1> DiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::HouseholderUSequenceType	src/SVD/UpperBidiagonalization.h	/^            > HouseholderUSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::HouseholderVSequenceType	src/SVD/UpperBidiagonalization.h	/^            > HouseholderVSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::Index	src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::MatrixType	src/SVD/UpperBidiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::RealScalar	src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::RowVectorType	src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, 1, ColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::RowsAtCompileTime	src/SVD/UpperBidiagonalization.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon423
Eigen::internal::UpperBidiagonalization::Scalar	src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::SuperDiagVectorType	src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTimeMinusOne, 1> SuperDiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::UpperBidiagonalization	src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization() : m_householder(), m_bidiagonal(), m_isInitialized(false) {}$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:()
Eigen::internal::UpperBidiagonalization::UpperBidiagonalization	src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:(const MatrixType& matrix)
Eigen::internal::UpperBidiagonalization::bidiagonal	src/SVD/UpperBidiagonalization.h	/^    const BidiagonalType& bidiagonal() const { return m_bidiagonal; }$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
Eigen::internal::UpperBidiagonalization::compute	src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization& compute(const MatrixType& matrix);$/;"	p	class:Eigen::internal::UpperBidiagonalization	access:public	signature:(const MatrixType& matrix)
Eigen::internal::UpperBidiagonalization::compute	src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::compute(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization	signature:(const _MatrixType& matrix)
Eigen::internal::UpperBidiagonalization::householder	src/SVD/UpperBidiagonalization.h	/^    const MatrixType& householder() const { return m_householder; }$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
Eigen::internal::UpperBidiagonalization::householderU	src/SVD/UpperBidiagonalization.h	/^    const HouseholderUSequenceType householderU() const$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
Eigen::internal::UpperBidiagonalization::householderV	src/SVD/UpperBidiagonalization.h	/^    const HouseholderVSequenceType householderV() \/\/ const here gives nasty errors and i'm lazy$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:()
Eigen::internal::UpperBidiagonalization::m_bidiagonal	src/SVD/UpperBidiagonalization.h	/^    BidiagonalType m_bidiagonal;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
Eigen::internal::UpperBidiagonalization::m_householder	src/SVD/UpperBidiagonalization.h	/^    MatrixType m_householder;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
Eigen::internal::UpperBidiagonalization::m_isInitialized	src/SVD/UpperBidiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
Eigen::internal::ZeroSign	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4f	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4f(ZERO, 0);$/;"	p	namespace:Eigen::internal	signature:(ZERO, 0)
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS1,-1);$/;"	p	namespace:Eigen::internal	signature:(MINUS1,-1)
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS16,-16);$/;"	p	namespace:Eigen::internal	signature:(MINUS16,-16)
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(ONE,1);$/;"	p	namespace:Eigen::internal	signature:(ONE,1)
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(ZERO, 0);$/;"	p	namespace:Eigen::internal	signature:(ZERO, 0)
Eigen::internal::abs2_impl	src/Core/MathFunctions.h	/^struct abs2_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::abs2_impl	src/Core/MathFunctions.h	/^struct abs2_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::abs2_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl	access:public
Eigen::internal::abs2_impl::run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl	access:public	signature:(const Scalar& x)
Eigen::internal::abs2_impl::run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::abs2_impl	access:public	signature:(const std::complex<RealScalar>& x)
Eigen::internal::abs2_retval	src/Core/MathFunctions.h	/^struct abs2_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::abs2_retval::type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs2_retval	access:public
Eigen::internal::accessors_level	src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct accessors_level$/;"	s	namespace:Eigen::internal
Eigen::internal::accessors_level::has_direct_access	src/Core/util/ForwardDeclarations.h	/^  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon71
Eigen::internal::accessors_level::has_write_access	src/Core/util/ForwardDeclarations.h	/^         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon71
Eigen::internal::accessors_level::value	src/Core/util/ForwardDeclarations.h	/^         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)$/;"	e	enum:Eigen::internal::accessors_level::__anon71
Eigen::internal::add_const	src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const	src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const::type	src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	t	struct:Eigen::internal::add_const	access:public
Eigen::internal::add_const::type	src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	t	struct:Eigen::internal::add_const	access:public
Eigen::internal::add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type::type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const_on_value_type::type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const_on_value_type::type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const_on_value_type::type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const_on_value_type::type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const_on_value_type_if_arithmetic	src/Core/DenseCoeffsBase.h	/^template<typename T> struct add_const_on_value_type_if_arithmetic$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type_if_arithmetic::type	src/Core/DenseCoeffsBase.h	/^  typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;$/;"	t	struct:Eigen::internal::add_const_on_value_type_if_arithmetic	access:public
Eigen::internal::aligned_delete	src/Core/util/Memory.h	/^template<typename T> inline void aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::aligned_free	src/Core/util/Memory.h	/^inline void aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::aligned_free	src/Core/util/Memory.h	/^void  aligned_free(void *ptr);$/;"	p	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::aligned_malloc	src/Core/util/Memory.h	/^inline void* aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::aligned_malloc	src/Core/util/Memory.h	/^void* aligned_malloc(std::size_t size);$/;"	p	namespace:Eigen::internal	signature:(std::size_t size)
Eigen::internal::aligned_new	src/Core/util/Memory.h	/^template<typename T> inline T* aligned_new(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::aligned_realloc	src/Core/util/Memory.h	/^inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void *ptr, size_t new_size, size_t old_size)
Eigen::internal::aligned_stack_memory_handler	src/Core/util/Memory.h	/^template<typename T> class aligned_stack_memory_handler$/;"	c	namespace:Eigen::internal
Eigen::internal::aligned_stack_memory_handler::aligned_stack_memory_handler	src/Core/util/Memory.h	/^    aligned_stack_memory_handler(T* ptr, size_t size, bool dealloc)$/;"	f	class:Eigen::internal::aligned_stack_memory_handler	access:public	signature:(T* ptr, size_t size, bool dealloc)
Eigen::internal::aligned_stack_memory_handler::m_deallocate	src/Core/util/Memory.h	/^    bool m_deallocate;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
Eigen::internal::aligned_stack_memory_handler::m_ptr	src/Core/util/Memory.h	/^    T* m_ptr;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
Eigen::internal::aligned_stack_memory_handler::m_size	src/Core/util/Memory.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
Eigen::internal::aligned_stack_memory_handler::~aligned_stack_memory_handler	src/Core/util/Memory.h	/^    ~aligned_stack_memory_handler()$/;"	f	class:Eigen::internal::aligned_stack_memory_handler	access:public	signature:()
Eigen::internal::all_unroller	src/Core/BooleanRedux.h	/^struct all_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::all_unroller	src/Core/BooleanRedux.h	/^struct all_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
Eigen::internal::all_unroller	src/Core/BooleanRedux.h	/^struct all_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
Eigen::internal::all_unroller::col	src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::all_unroller::__anon147
Eigen::internal::all_unroller::row	src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::all_unroller::__anon147
Eigen::internal::all_unroller::run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &)
Eigen::internal::all_unroller::run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &\/*mat*\/) { return true; }$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived & )
Eigen::internal::all_unroller::run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &mat)
Eigen::internal::always_void	src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::always_void::type	src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	t	struct:Eigen::internal::always_void	access:public
Eigen::internal::amd_flip	src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_flip(const T& i) { return -i-2; }$/;"	f	namespace:Eigen::internal	signature:(const T& i)
Eigen::internal::amd_mark	src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline void amd_mark(const T0* w, const T1& j) { return w[j] = amd_flip(w[j]); }$/;"	f	namespace:Eigen::internal	signature:(const T0* w, const T1& j)
Eigen::internal::amd_marked	src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline bool amd_marked(const T0* w, const T1& j) { return w[j]<0; }$/;"	f	namespace:Eigen::internal	signature:(const T0* w, const T1& j)
Eigen::internal::amd_unflip	src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_unflip(const T& i) { return i<0 ? amd_flip(i) : i; }$/;"	f	namespace:Eigen::internal	signature:(const T& i)
Eigen::internal::any_unroller	src/Core/BooleanRedux.h	/^struct any_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::any_unroller	src/Core/BooleanRedux.h	/^struct any_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
Eigen::internal::any_unroller	src/Core/BooleanRedux.h	/^struct any_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
Eigen::internal::any_unroller::col	src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::any_unroller::__anon148
Eigen::internal::any_unroller::row	src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::any_unroller::__anon148
Eigen::internal::any_unroller::run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived & \/*mat*\/) { return false; }$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived & )
Eigen::internal::any_unroller::run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &)
Eigen::internal::any_unroller::run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &mat)
Eigen::internal::apply_block_householder_on_the_left	src/Householder/BlockHouseholder.h	/^void apply_block_householder_on_the_left(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)
Eigen::internal::apply_rotation_in_the_plane	src/Jacobi/Jacobi.h	/^void \/*EIGEN_DONT_INLINE*\/ apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)$/;"	f	namespace:Eigen::internal	signature:(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)
Eigen::internal::apply_rotation_in_the_plane	src/Jacobi/Jacobi.h	/^void apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j);$/;"	p	namespace:Eigen::internal	signature:(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)
Eigen::internal::asSluMatrix	src/SuperLUSupport/SuperLUSupport.h	/^SluMatrix asSluMatrix(MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::inner	src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon136
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::outer	src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon136
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_DefaultTraversal_InnerUnrolling	src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_DefaultTraversal_InnerUnrolling	src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_DefaultTraversal_InnerUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, typename Derived1::Index) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling	access:public	signature:(Derived1 &, const Derived2 &, typename Derived1::Index)
Eigen::internal::assign_DefaultTraversal_InnerUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)
Eigen::internal::assign_LinearTraversal_CompleteUnrolling	src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_LinearTraversal_CompleteUnrolling	src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_LinearTraversal_CompleteUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::assign_LinearTraversal_CompleteUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_conj_scalar_eig2mkl	src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex16& mklScalar, const dcomplex& eigenScalar)
Eigen::internal::assign_conj_scalar_eig2mkl	src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex8& mklScalar, const scomplex& eigenScalar)
Eigen::internal::assign_conj_scalar_eig2mkl	src/Core/util/MKL_support.h	/^static inline void assign_conj_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKLType& mklScalar, const EigenType& eigenScalar)
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InvalidTraversal, Unrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, SliceVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl::Index	src/Core/Assign.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::assign_impl	access:public
Eigen::internal::assign_impl::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_impl::run	src/Core/Assign.h	/^  static inline void run(Derived1 &, const Derived2 &) { }$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::assign_impl::run	src/Core/Assign.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_innervec_CompleteUnrolling	src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_innervec_CompleteUnrolling	src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_innervec_CompleteUnrolling::JointAlignment	src/Core/Assign.h	/^    JointAlignment = assign_traits<Derived1,Derived2>::JointAlignment$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon137
Eigen::internal::assign_innervec_CompleteUnrolling::inner	src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon137
Eigen::internal::assign_innervec_CompleteUnrolling::outer	src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon137
Eigen::internal::assign_innervec_CompleteUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::assign_innervec_CompleteUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_innervec_InnerUnrolling	src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_innervec_InnerUnrolling	src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_innervec_InnerUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, typename Derived1::Index) {}$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling	access:public	signature:(Derived1 &, const Derived2 &, typename Derived1::Index)
Eigen::internal::assign_innervec_InnerUnrolling::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)
Eigen::internal::assign_scalar_eig2mkl	src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex16& mklScalar, const dcomplex& eigenScalar)
Eigen::internal::assign_scalar_eig2mkl	src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex8& mklScalar, const scomplex& eigenScalar)
Eigen::internal::assign_scalar_eig2mkl	src/Core/util/MKL_support.h	/^static inline void assign_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKLType& mklScalar, const EigenType& eigenScalar)
Eigen::internal::assign_selector	src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_selector	src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_selector	src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_selector	src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_selector::evalTo	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& evalTo(ActualDerived& dst, const ActualOtherDerived& other) { Transpose<ActualDerived> dstTrans(dst); other.evalTo(dstTrans); return dst; }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(ActualDerived& dst, const ActualOtherDerived& other)
Eigen::internal::assign_selector::evalTo	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& evalTo(ActualDerived& dst, const ActualOtherDerived& other) { other.evalTo(dst); return dst; }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(ActualDerived& dst, const ActualOtherDerived& other)
Eigen::internal::assign_selector::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
Eigen::internal::assign_selector::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.eval()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
Eigen::internal::assign_selector::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
Eigen::internal::assign_selector::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose().eval()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
Eigen::internal::assign_traits	src/Core/Assign.h	/^struct assign_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_traits::DstHasDirectAccess	src/Core/Assign.h	/^    DstHasDirectAccess = Derived::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon130
Eigen::internal::assign_traits::DstIsAligned	src/Core/Assign.h	/^    DstIsAligned = Derived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon130
Eigen::internal::assign_traits::InnerMaxSize	src/Core/Assign.h	/^    InnerMaxSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon131
Eigen::internal::assign_traits::InnerSize	src/Core/Assign.h	/^    InnerSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon131
Eigen::internal::assign_traits::JointAlignment	src/Core/Assign.h	/^    JointAlignment = bool(DstIsAligned) && bool(SrcIsAligned) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::assign_traits::__anon130
Eigen::internal::assign_traits::MaxSizeAtCompileTime	src/Core/Assign.h	/^    MaxSizeAtCompileTime = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_traits::__anon131
Eigen::internal::assign_traits::MayInnerVectorize	src/Core/Assign.h	/^    MayInnerVectorize  = MightVectorize && int(InnerSize)!=Dynamic && int(InnerSize)%int(PacketSize)==0$/;"	e	enum:Eigen::internal::assign_traits::__anon132
Eigen::internal::assign_traits::MayLinearVectorize	src/Core/Assign.h	/^    MayLinearVectorize = MightVectorize && MayLinearize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon132
Eigen::internal::assign_traits::MayLinearize	src/Core/Assign.h	/^    MayLinearize = StorageOrdersAgree && (int(Derived::Flags) & int(OtherDerived::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::assign_traits::__anon132
Eigen::internal::assign_traits::MaySliceVectorize	src/Core/Assign.h	/^    MaySliceVectorize  = MightVectorize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon132
Eigen::internal::assign_traits::MayUnrollCompletely	src/Core/Assign.h	/^    MayUnrollCompletely = int(Derived::SizeAtCompileTime) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon134
Eigen::internal::assign_traits::MayUnrollInner	src/Core/Assign.h	/^    MayUnrollInner      = int(InnerSize) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon134
Eigen::internal::assign_traits::MightVectorize	src/Core/Assign.h	/^    MightVectorize = StorageOrdersAgree$/;"	e	enum:Eigen::internal::assign_traits::__anon132
Eigen::internal::assign_traits::PacketSize	src/Core/Assign.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size$/;"	e	enum:Eigen::internal::assign_traits::__anon131
Eigen::internal::assign_traits::SrcIsAligned	src/Core/Assign.h	/^    SrcIsAligned = OtherDerived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon130
Eigen::internal::assign_traits::StorageOrdersAgree	src/Core/Assign.h	/^    StorageOrdersAgree = (int(Derived::IsRowMajor) == int(OtherDerived::IsRowMajor)),$/;"	e	enum:Eigen::internal::assign_traits::__anon132
Eigen::internal::assign_traits::Traversal	src/Core/Assign.h	/^    Traversal = int(MayInnerVectorize)  ? int(InnerVectorizedTraversal)$/;"	e	enum:Eigen::internal::assign_traits::__anon133
Eigen::internal::assign_traits::Unrolling	src/Core/Assign.h	/^    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))$/;"	e	enum:Eigen::internal::assign_traits::__anon135
Eigen::internal::assign_traits::UnrollingLimit	src/Core/Assign.h	/^    UnrollingLimit      = EIGEN_UNROLLING_LIMIT * (Vectorized ? int(PacketSize) : 1),$/;"	e	enum:Eigen::internal::assign_traits::__anon134
Eigen::internal::assign_traits::Vectorized	src/Core/Assign.h	/^    Vectorized = int(Traversal) == InnerVectorizedTraversal$/;"	e	enum:Eigen::internal::assign_traits::__anon133
Eigen::internal::assign_traits::debug	src/Core/Assign.h	/^  static void debug()$/;"	f	struct:Eigen::internal::assign_traits	access:public	signature:()
Eigen::internal::atanh2_default_impl	src/Core/MathFunctions.h	/^struct atanh2_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::atanh2_default_impl	src/Core/MathFunctions.h	/^struct atanh2_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::atanh2_default_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::atanh2_default_impl	access:public
Eigen::internal::atanh2_default_impl::retval	src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::atanh2_default_impl	access:public
Eigen::internal::atanh2_default_impl::run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::atanh2_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::atanh2_default_impl::run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar&, const Scalar&)$/;"	f	struct:Eigen::internal::atanh2_default_impl	access:public	signature:(const Scalar&, const Scalar&)
Eigen::internal::atanh2_impl	src/Core/MathFunctions.h	/^struct atanh2_impl : atanh2_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:atanh2_default_impl
Eigen::internal::atanh2_retval	src/Core/MathFunctions.h	/^struct atanh2_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::atanh2_retval::type	src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::atanh2_retval	access:public
Eigen::internal::bicgstab	src/IterativeLinearSolvers/BiCGSTAB.h	/^bool bicgstab(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, const Rhs& rhs, Dest& x, const Preconditioner& precond, int& iters, typename Dest::RealScalar& tol_error)
Eigen::internal::binary_result_of_select	src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	s	namespace:Eigen::internal
Eigen::internal::binary_result_of_select	src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
Eigen::internal::binary_result_of_select	src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
Eigen::internal::binary_result_of_select::type	src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
Eigen::internal::binary_result_of_select::type	src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
Eigen::internal::binary_result_of_select::type	src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
Eigen::internal::blas_data_mapper	src/Core/util/BlasUtil.h	/^class blas_data_mapper$/;"	c	namespace:Eigen::internal
Eigen::internal::blas_data_mapper::blas_data_mapper	src/Core/util/BlasUtil.h	/^    blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::blas_data_mapper	access:public	signature:(Scalar* data, Index stride)
Eigen::internal::blas_data_mapper::m_data	src/Core/util/BlasUtil.h	/^    Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::blas_data_mapper	access:protected
Eigen::internal::blas_data_mapper::m_stride	src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::blas_data_mapper	access:protected
Eigen::internal::blas_data_mapper::operator ()	src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i, Index j)$/;"	f	class:Eigen::internal::blas_data_mapper	access:public	signature:(Index i, Index j)
Eigen::internal::blas_traits	src/Core/Transpose.h	/^struct blas_traits<SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<Transpose<NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<const T>$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	src/Core/util/BlasUtil.h	/^template<typename XprType> struct blas_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::blas_traits::Base	src/Core/util/BlasUtil.h	/^  typedef blas_traits<NestedXpr> Base;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::DirectLinearAccessType	src/Core/util/BlasUtil.h	/^    >::type DirectLinearAccessType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::ExtractType	src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType>  ExtractType; \/\/ const to get rid of a compile error; anyway blas traits are only used on the RHS$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::ExtractType	src/Core/util/BlasUtil.h	/^  typedef const XprType& ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::ExtractType	src/Core/util/BlasUtil.h	/^  typedef typename Base::ExtractType ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::HasUsableDirectAccess	src/Core/util/BlasUtil.h	/^    HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)$/;"	e	enum:Eigen::internal::blas_traits::__anon58
Eigen::internal::blas_traits::IsComplex	src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon58
Eigen::internal::blas_traits::IsComplex	src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon59
Eigen::internal::blas_traits::IsTransposed	src/Core/util/BlasUtil.h	/^    IsTransposed = Base::IsTransposed ? 0 : 1$/;"	e	enum:Eigen::internal::blas_traits::__anon60
Eigen::internal::blas_traits::IsTransposed	src/Core/util/BlasUtil.h	/^    IsTransposed = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon58
Eigen::internal::blas_traits::NeedToConjugate	src/Core/util/BlasUtil.h	/^    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex$/;"	e	enum:Eigen::internal::blas_traits::__anon59
Eigen::internal::blas_traits::NeedToConjugate	src/Core/util/BlasUtil.h	/^    NeedToConjugate = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon58
Eigen::internal::blas_traits::Scalar	src/Core/util/BlasUtil.h	/^  typedef typename NestedXpr::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::Scalar	src/Core/util/BlasUtil.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	src/Core/Transpose.h	/^  typedef SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	src/Core/util/BlasUtil.h	/^  typedef Transpose<NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::_ExtractType	src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType> _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::_ExtractType	src/Core/util/BlasUtil.h	/^  typedef XprType _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::extract	src/Core/Transpose.h	/^  static inline const XprType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extract	src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extract	src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extractScalarFactor	src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extractScalarFactor	src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extractScalarFactor	src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x)$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extractScalarFactor	src/Core/util/BlasUtil.h	/^  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType&)
Eigen::internal::blueNorm_impl	src/Core/StableNorm.h	/^blueNorm_impl(const EigenBase<Derived>& _vec)$/;"	f	namespace:Eigen::internal	signature:(const EigenBase<Derived>& _vec)
Eigen::internal::bruteforce_det3_helper	src/LU/Determinant.h	/^inline const typename Derived::Scalar bruteforce_det3_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int a, int b, int c)
Eigen::internal::bruteforce_det4_helper	src/LU/Determinant.h	/^const typename Derived::Scalar bruteforce_det4_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int j, int k, int m, int n)
Eigen::internal::c_to_fortran_numbering	src/PaStiXSupport/PaStiXSupport.h	/^  void c_to_fortran_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
Eigen::internal::cast	src/Core/MathFunctions.h	/^inline NewType cast(const OldType& x)$/;"	f	namespace:Eigen::internal	signature:(const OldType& x)
Eigen::internal::cast_impl	src/Core/MathFunctions.h	/^struct cast_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::cast_impl::run	src/Core/MathFunctions.h	/^  static inline NewType run(const OldType& x)$/;"	f	struct:Eigen::internal::cast_impl	access:public	signature:(const OldType& x)
Eigen::internal::checkTransposeAliasing_impl	src/Core/Transpose.h	/^struct checkTransposeAliasing_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::checkTransposeAliasing_impl	src/Core/Transpose.h	/^struct checkTransposeAliasing_impl<Derived, OtherDerived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::checkTransposeAliasing_impl::run	src/Core/Transpose.h	/^    static void run(const Derived& dst, const OtherDerived& other)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl	access:public	signature:(const Derived& dst, const OtherDerived& other)
Eigen::internal::checkTransposeAliasing_impl::run	src/Core/Transpose.h	/^    static void run(const Derived&, const OtherDerived&)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl	access:public	signature:(const Derived&, const OtherDerived&)
Eigen::internal::check_DenseIndex_is_signed	src/Core/DenseBase.h	/^static inline void check_DenseIndex_is_signed() {$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::check_rows_cols_for_overflow	src/Core/PlainObjectBase.h	/^template<> struct check_rows_cols_for_overflow<Dynamic> {$/;"	s	namespace:Eigen::internal
Eigen::internal::check_rows_cols_for_overflow	src/Core/PlainObjectBase.h	/^template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow {$/;"	s	namespace:Eigen::internal
Eigen::internal::check_rows_cols_for_overflow::run	src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index rows, Index cols)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow	access:public	signature:(Index rows, Index cols)
Eigen::internal::check_rows_cols_for_overflow::run	src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index, Index)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow	access:public	signature:(Index, Index)
Eigen::internal::check_size_for_overflow	src/Core/util/Memory.h	/^EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::check_static_allocation_size	src/Core/DenseStorage.h	/^template<typename T, int Size> void check_static_allocation_size()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::check_that_malloc_is_allowed	src/Core/util/Memory.h	/^inline void check_that_malloc_is_allowed()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::check_transpose_aliasing_compile_time_selector	src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::check_transpose_aliasing_compile_time_selector	src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
Eigen::internal::check_transpose_aliasing_compile_time_selector::ret	src/Core/Transpose.h	/^  enum { ret =    bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon325
Eigen::internal::check_transpose_aliasing_compile_time_selector::ret	src/Core/Transpose.h	/^  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon324
Eigen::internal::check_transpose_aliasing_run_time_selector	src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::check_transpose_aliasing_run_time_selector	src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
Eigen::internal::check_transpose_aliasing_run_time_selector::run	src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector	access:public	signature:(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)
Eigen::internal::check_transpose_aliasing_run_time_selector::run	src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const OtherDerived& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector	access:public	signature:(const Scalar* dest, const OtherDerived& src)
Eigen::internal::cholmod_configure_matrix	src/CholmodSupport/CholmodSupport.h	/^void cholmod_configure_matrix(CholmodType& mat)$/;"	f	namespace:Eigen::internal	signature:(CholmodType& mat)
Eigen::internal::cmp_EQ	src/Core/util/Constants.h	/^    cmp_EQ = 0,$/;"	e	enum:Eigen::internal::ComparisonName
Eigen::internal::cmp_LE	src/Core/util/Constants.h	/^    cmp_LE = 2,$/;"	e	enum:Eigen::internal::ComparisonName
Eigen::internal::cmp_LT	src/Core/util/Constants.h	/^    cmp_LT = 1,$/;"	e	enum:Eigen::internal::ComparisonName
Eigen::internal::cmp_NEQ	src/Core/util/Constants.h	/^    cmp_NEQ = 4$/;"	e	enum:Eigen::internal::ComparisonName
Eigen::internal::cmp_UNORD	src/Core/util/Constants.h	/^    cmp_UNORD = 3,$/;"	e	enum:Eigen::internal::ComparisonName
Eigen::internal::coeff_visitor	src/Core/Visitor.h	/^struct coeff_visitor$/;"	s	namespace:Eigen::internal
Eigen::internal::coeff_visitor::Index	src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::coeff_visitor::Scalar	src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::coeff_visitor::col	src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::coeff_visitor::init	src/Core/Visitor.h	/^  inline void init(const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
Eigen::internal::coeff_visitor::res	src/Core/Visitor.h	/^  Scalar res;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::coeff_visitor::row	src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::cofactor_3x3	src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_3x3(const MatrixType& m)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& m)
Eigen::internal::cofactor_4x4	src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_4x4(const MatrixType& matrix)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& matrix)
Eigen::internal::coletree	src/SparseCore/SparseColEtree.h	/^int coletree(const MatrixType& mat, IndexVector& parent, IndexVector& firstRowElt, typename MatrixType::Index *perm=0)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, IndexVector& parent, IndexVector& firstRowElt, typename MatrixType::Index *perm=0)
Eigen::internal::column_dfs_traits	src/SparseLU/SparseLU_column_dfs.h	/^struct column_dfs_traits : no_assignment_operator$/;"	s	namespace:Eigen::internal	inherits:no_assignment_operator
Eigen::internal::column_dfs_traits::ExpandMem	src/SparseLU/SparseLU_column_dfs.h	/^  enum { ExpandMem = true };$/;"	e	enum:Eigen::internal::column_dfs_traits::__anon464
Eigen::internal::column_dfs_traits::Index	src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename IndexVector::Scalar Index;$/;"	t	struct:Eigen::internal::column_dfs_traits	access:public
Eigen::internal::column_dfs_traits::Scalar	src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename ScalarVector::Scalar Scalar;$/;"	t	struct:Eigen::internal::column_dfs_traits	access:public
Eigen::internal::column_dfs_traits::column_dfs_traits	src/SparseLU/SparseLU_column_dfs.h	/^  column_dfs_traits(Index jcol, Index& jsuper, typename SparseLUImpl<Scalar, Index>::GlobalLU_t& glu, SparseLUImpl<Scalar, Index>& luImpl)$/;"	f	struct:Eigen::internal::column_dfs_traits	access:public	signature:(Index jcol, Index& jsuper, typename SparseLUImpl<Scalar, Index>::GlobalLU_t& glu, SparseLUImpl<Scalar, Index>& luImpl)
Eigen::internal::column_dfs_traits::m_glu	src/SparseLU/SparseLU_column_dfs.h	/^  typename SparseLUImpl<Scalar, Index>::GlobalLU_t& m_glu;$/;"	m	struct:Eigen::internal::column_dfs_traits	access:public
Eigen::internal::column_dfs_traits::m_jcol	src/SparseLU/SparseLU_column_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::column_dfs_traits	access:public
Eigen::internal::column_dfs_traits::m_jsuper_ref	src/SparseLU/SparseLU_column_dfs.h	/^  Index& m_jsuper_ref;$/;"	m	struct:Eigen::internal::column_dfs_traits	access:public
Eigen::internal::column_dfs_traits::m_luImpl	src/SparseLU/SparseLU_column_dfs.h	/^  SparseLUImpl<Scalar, Index>& m_luImpl;$/;"	m	struct:Eigen::internal::column_dfs_traits	access:public
Eigen::internal::column_dfs_traits::mem_expand	src/SparseLU/SparseLU_column_dfs.h	/^  void mem_expand(IndexVector& lsub, Index& nextl, Index chmark)$/;"	f	struct:Eigen::internal::column_dfs_traits	access:public	signature:(IndexVector& lsub, Index& nextl, Index chmark)
Eigen::internal::column_dfs_traits::update_segrep	src/SparseLU/SparseLU_column_dfs.h	/^  bool update_segrep(Index \/*krep*\/, Index \/*jj*\/)$/;"	f	struct:Eigen::internal::column_dfs_traits	access:public	signature:(Index , Index )
Eigen::internal::complex_schur_reduce_to_hessenberg	src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg$/;"	s	namespace:Eigen::internal
Eigen::internal::complex_schur_reduce_to_hessenberg	src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg<MatrixType, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::complex_schur_reduce_to_hessenberg::run	src/Eigenvalues/ComplexSchur.h	/^  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)$/;"	f	struct:Eigen::internal::complex_schur_reduce_to_hessenberg	access:public	signature:(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)
Eigen::internal::computeProductBlockingSizes	src/Core/products/GeneralBlockPanelKernel.h	/^inline void computeProductBlockingSizes(SizeType& k, SizeType& m, SizeType& n)$/;"	f	namespace:Eigen::internal	signature:(SizeType& k, SizeType& m, SizeType& n)
Eigen::internal::computeProductBlockingSizes	src/Core/products/GeneralBlockPanelKernel.h	/^void computeProductBlockingSizes(SizeType& k, SizeType& m, SizeType& n)$/;"	f	namespace:Eigen::internal	signature:(SizeType& k, SizeType& m, SizeType& n)
Eigen::internal::compute_inverse	src/LU/Inverse.h	/^struct compute_inverse$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse	src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse	src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse	src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse	src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal	inherits:compute_inverse_size4
Eigen::internal::compute_inverse::run	src/LU/Inverse.h	/^  static inline void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse	access:public	signature:(const MatrixType& matrix, ResultType& result)
Eigen::internal::compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check { \/* nothing! general case not supported. *\/ };$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check::run	src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check	access:public	signature:( const MatrixType& matrix, const typename MatrixType::RealScalar& absDeterminantThreshold, ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible )
Eigen::internal::compute_inverse_and_det_with_check::run	src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check	access:public	signature:( const MatrixType& matrix, const typename MatrixType::RealScalar& absDeterminantThreshold, ResultType& result, typename ResultType::Scalar& determinant, bool& invertible )
Eigen::internal::compute_inverse_size2_helper	src/LU/Inverse.h	/^inline void compute_inverse_size2_helper($/;"	f	namespace:Eigen::internal	signature:( const MatrixType& matrix, const typename ResultType::Scalar& invdet, ResultType& result)
Eigen::internal::compute_inverse_size3_helper	src/LU/Inverse.h	/^inline void compute_inverse_size3_helper($/;"	f	namespace:Eigen::internal	signature:( const MatrixType& matrix, const typename ResultType::Scalar& invdet, const Matrix<typename ResultType::Scalar,3,1>& cofactors_col0, ResultType& result)
Eigen::internal::compute_inverse_size4	src/LU/Inverse.h	/^struct compute_inverse_size4$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_size4	src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, double, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_size4	src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, float, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_size4::MatrixAlignment	src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon396
Eigen::internal::compute_inverse_size4::MatrixAlignment	src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon397
Eigen::internal::compute_inverse_size4::ResultAlignment	src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon396
Eigen::internal::compute_inverse_size4::ResultAlignment	src/LU/arch/Inverse_SSE.h	/^    ResultAlignment = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon397
Eigen::internal::compute_inverse_size4::StorageOrdersMatch	src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon396
Eigen::internal::compute_inverse_size4::StorageOrdersMatch	src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon397
Eigen::internal::compute_inverse_size4::run	src/LU/Inverse.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4	access:public	signature:(const MatrixType& matrix, ResultType& result)
Eigen::internal::compute_inverse_size4::run	src/LU/arch/Inverse_SSE.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4	access:public	signature:(const MatrixType& matrix, ResultType& result)
Eigen::internal::conditional	src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::conditional	src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::conditional::type	src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	t	struct:Eigen::internal::conditional	access:public
Eigen::internal::conditional::type	src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	t	struct:Eigen::internal::conditional	access:public
Eigen::internal::conditional_aligned_delete	src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::conditional_aligned_delete_auto	src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete_auto(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::conditional_aligned_free	src/Core/util/Memory.h	/^template<> inline void conditional_aligned_free<false>(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::conditional_aligned_free	src/Core/util/Memory.h	/^template<bool Align> inline void conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::conditional_aligned_malloc	src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_malloc<false>(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::conditional_aligned_malloc	src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::conditional_aligned_new	src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::conditional_aligned_new_auto	src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new_auto(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::conditional_aligned_realloc	src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t new_size, size_t)
Eigen::internal::conditional_aligned_realloc	src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t new_size, size_t old_size)
Eigen::internal::conditional_aligned_realloc_new	src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(T* pts, size_t new_size, size_t old_size)
Eigen::internal::conditional_aligned_realloc_new_auto	src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(T* pts, size_t new_size, size_t old_size)
Eigen::internal::conj_expr_if	src/Core/products/SelfadjointRank2Update.h	/^template<bool Cond, typename T> struct conj_expr_if$/;"	s	namespace:Eigen::internal	inherits:conditional
Eigen::internal::conj_helper	src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet2d, false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet4f, false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2d, Packet1cd, false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet4f, Packet2cf, false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	src/Core/util/BlasUtil.h	/^template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper::Scalar	src/Core/util/BlasUtil.h	/^  typedef std::complex<RealScalar> Scalar;$/;"	t	struct:Eigen::internal::conj_helper	access:public
Eigen::internal::conj_helper::pmadd	src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
Eigen::internal::conj_helper::pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const
Eigen::internal::conj_helper::pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const
Eigen::internal::conj_helper::pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const RealScalar& x, const Scalar& y, const Scalar& c) const
Eigen::internal::conj_helper::pmadd	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const RealScalar& y, const Scalar& c) const
Eigen::internal::conj_helper::pmadd	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& c) const
Eigen::internal::conj_helper::pmadd	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& c) const
Eigen::internal::conj_helper::pmul	src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
Eigen::internal::conj_helper::pmul	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
Eigen::internal::conj_helper::pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& a, const Packet1cd& b) const
Eigen::internal::conj_helper::pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& x, const Packet2d& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet2d& y) const
Eigen::internal::conj_helper::pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet2d& x, const Packet1cd& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2d& x, const Packet1cd& y) const
Eigen::internal::conj_helper::pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
Eigen::internal::conj_helper::pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& x, const Packet4f& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet4f& y) const
Eigen::internal::conj_helper::pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet4f& x, const Packet2cf& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet4f& x, const Packet2cf& y) const
Eigen::internal::conj_helper::pmul	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const RealScalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const RealScalar& x, const Scalar& y) const
Eigen::internal::conj_helper::pmul	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const RealScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const RealScalar& y) const
Eigen::internal::conj_helper::pmul	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y) const
Eigen::internal::conj_helper::pmul	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y) const
Eigen::internal::conj_if	src/Core/util/BlasUtil.h	/^template<> struct conj_if<false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_if	src/Core/util/BlasUtil.h	/^template<> struct conj_if<true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_if::operator ()	src/Core/util/BlasUtil.h	/^  inline T operator()(const T& x) { return numext::conj(x); }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
Eigen::internal::conj_if::operator ()	src/Core/util/BlasUtil.h	/^  inline const T& operator()(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
Eigen::internal::conj_if::pconj	src/Core/util/BlasUtil.h	/^  inline T pconj(const T& x) { return internal::pconj(x); }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
Eigen::internal::conj_if::pconj	src/Core/util/BlasUtil.h	/^  inline const T& pconj(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
Eigen::internal::conj_impl	src/Core/MathFunctions.h	/^struct conj_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_impl	src/Core/MathFunctions.h	/^struct conj_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_impl::run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::conj_impl	access:public	signature:(const Scalar& x)
Eigen::internal::conj_retval	src/Core/MathFunctions.h	/^struct conj_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_retval::type	src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::conj_retval	access:public
Eigen::internal::conjugate_gradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^void conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, const Rhs& rhs, Dest& x, const Preconditioner& precond, int& iters, typename Dest::RealScalar& tol_error)
Eigen::internal::conservative_resize_like_impl	src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_resize_like_impl	src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl<Derived,OtherDerived,true>$/;"	s	namespace:Eigen::internal	inherits:conservative_resize_like_impl
Eigen::internal::conservative_resize_like_impl::Index	src/Core/PlainObjectBase.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::conservative_resize_like_impl	access:public
Eigen::internal::conservative_resize_like_impl::run	src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index rows, Index cols)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, Index rows, Index cols)
Eigen::internal::conservative_resize_like_impl::run	src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index size)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, Index size)
Eigen::internal::conservative_resize_like_impl::run	src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)
Eigen::internal::conservative_sparse_sparse_product_impl	src/SparseCore/ConservativeSparseSparseProduct.h	/^static void conservative_sparse_sparse_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	namespace:Eigen::internal	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res)
Eigen::internal::conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector::LhsCleaned	src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Eigen::internal::conservative_sparse_sparse_product_selector::Scalar	src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename LhsCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Eigen::internal::conservative_sparse_sparse_product_selector::Scalar	src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Eigen::internal::conservative_sparse_sparse_product_selector::run	src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res)
Eigen::internal::const_blas_data_mapper	src/Core/util/BlasUtil.h	/^class const_blas_data_mapper$/;"	c	namespace:Eigen::internal
Eigen::internal::const_blas_data_mapper::const_blas_data_mapper	src/Core/util/BlasUtil.h	/^    const_blas_data_mapper(const Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::const_blas_data_mapper	access:public	signature:(const Scalar* data, Index stride)
Eigen::internal::const_blas_data_mapper::m_data	src/Core/util/BlasUtil.h	/^    const Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::const_blas_data_mapper	access:protected
Eigen::internal::const_blas_data_mapper::m_stride	src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::const_blas_data_mapper	access:protected
Eigen::internal::const_blas_data_mapper::operator ()	src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i, Index j) const$/;"	f	class:Eigen::internal::const_blas_data_mapper	access:public	signature:(Index i, Index j) const
Eigen::internal::construct_elements_of_array	src/Core/util/Memory.h	/^template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::constructor_without_unaligned_array_assert	src/Core/DenseStorage.h	/^struct constructor_without_unaligned_array_assert {};$/;"	s	namespace:Eigen::internal
Eigen::internal::copy_bool	src/Core/util/Macros.h	/^    inline bool copy_bool(bool b) { return b; }$/;"	f	namespace:Eigen::internal	signature:(bool b)
Eigen::internal::cpuid_is_vendor	src/Core/util/Memory.h	/^inline bool cpuid_is_vendor(int abcd[4], const int vendor[3])$/;"	f	namespace:Eigen::internal	signature:(int abcd[4], const int vendor[3])
Eigen::internal::cross3_impl	src/Geometry/OrthoMethods.h	/^struct cross3_impl {$/;"	s	namespace:Eigen::internal
Eigen::internal::cross3_impl	src/Geometry/arch/Geometry_SSE.h	/^struct cross3_impl<Architecture::SSE,VectorLhs,VectorRhs,float,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::cross3_impl::run	src/Geometry/OrthoMethods.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl	access:public	signature:(const VectorLhs& lhs, const VectorRhs& rhs)
Eigen::internal::cross3_impl::run	src/Geometry/arch/Geometry_SSE.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl	access:public	signature:(const VectorLhs& lhs, const VectorRhs& rhs)
Eigen::internal::cs_tdfs	src/OrderingMethods/Amd.h	/^Index cs_tdfs(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)$/;"	f	namespace:Eigen::internal	signature:(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)
Eigen::internal::cs_wclear	src/OrderingMethods/Amd.h	/^static int cs_wclear (Index mark, Index lemax, Index *w, Index n)$/;"	f	namespace:Eigen::internal	signature:(Index mark, Index lemax, Index *w, Index n)
Eigen::internal::decrement_size	src/Householder/Householder.h	/^template<int n> struct decrement_size$/;"	s	namespace:Eigen::internal
Eigen::internal::decrement_size::ret	src/Householder/Householder.h	/^    ret = n==Dynamic ? n : n-1$/;"	e	enum:Eigen::internal::decrement_size::__anon392
Eigen::internal::default_packet_traits	src/Core/GenericPacketMath.h	/^struct default_packet_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::default_packet_traits::HasACos	src/Core/GenericPacketMath.h	/^    HasACos   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasASin	src/Core/GenericPacketMath.h	/^    HasASin   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasATan	src/Core/GenericPacketMath.h	/^    HasATan   = 0$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasAbs	src/Core/GenericPacketMath.h	/^    HasAbs    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasAbs2	src/Core/GenericPacketMath.h	/^    HasAbs2   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasAdd	src/Core/GenericPacketMath.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasConj	src/Core/GenericPacketMath.h	/^    HasConj   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasCos	src/Core/GenericPacketMath.h	/^    HasCos    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasDiv	src/Core/GenericPacketMath.h	/^    HasDiv    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasExp	src/Core/GenericPacketMath.h	/^    HasExp    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasLog	src/Core/GenericPacketMath.h	/^    HasLog    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasMax	src/Core/GenericPacketMath.h	/^    HasMax    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasMin	src/Core/GenericPacketMath.h	/^    HasMin    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasMul	src/Core/GenericPacketMath.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasNegate	src/Core/GenericPacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasPow	src/Core/GenericPacketMath.h	/^    HasPow    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasSetLinear	src/Core/GenericPacketMath.h	/^    HasSetLinear = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasSin	src/Core/GenericPacketMath.h	/^    HasSin    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasSqrt	src/Core/GenericPacketMath.h	/^    HasSqrt   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasSub	src/Core/GenericPacketMath.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::default_packet_traits::HasTan	src/Core/GenericPacketMath.h	/^    HasTan    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
Eigen::internal::dense_xpr_base_dispatcher_for_doxygen	src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:ArrayBase
Eigen::internal::dense_xpr_base_dispatcher_for_doxygen	src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:MatrixBase
Eigen::internal::destruct_elements_of_array	src/Core/util/Memory.h	/^template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::determinant_impl	src/LU/Determinant.h	/^> struct determinant_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl	src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl	src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 2>$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl	src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 3>$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl	src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 4>$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl::run	src/LU/Determinant.h	/^  static inline typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl	access:public	signature:(const Derived& m)
Eigen::internal::determinant_impl::run	src/LU/Determinant.h	/^  static typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl	access:public	signature:(const Derived& m)
Eigen::internal::direct_selfadjoint_eigenvalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues$/;"	s	namespace:Eigen::internal
Eigen::internal::direct_selfadjoint_eigenvalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,2,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::direct_selfadjoint_eigenvalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,3,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::direct_selfadjoint_eigenvalues::EigenvectorsType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::EigenvectorsType EigenvectorsType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Eigen::internal::direct_selfadjoint_eigenvalues::Index	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Eigen::internal::direct_selfadjoint_eigenvalues::MatrixType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Eigen::internal::direct_selfadjoint_eigenvalues::Scalar	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::Scalar Scalar;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Eigen::internal::direct_selfadjoint_eigenvalues::VectorType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::RealVectorType VectorType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Eigen::internal::direct_selfadjoint_eigenvalues::computeRoots	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void computeRoots(const MatrixType& m, VectorType& roots)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(const MatrixType& m, VectorType& roots)
Eigen::internal::direct_selfadjoint_eigenvalues::extract_kernel	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline bool extract_kernel(MatrixType& mat, Ref<VectorType> res, Ref<VectorType> representative)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(MatrixType& mat, Ref<VectorType> res, Ref<VectorType> representative)
Eigen::internal::direct_selfadjoint_eigenvalues::run	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& eig, const typename SolverType::MatrixType& A, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(SolverType& eig, const typename SolverType::MatrixType& A, int options)
Eigen::internal::direct_selfadjoint_eigenvalues::run	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& solver, const MatrixType& mat, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(SolverType& solver, const MatrixType& mat, int options)
Eigen::internal::dot_nocheck	src/Core/Dot.h	/^struct dot_nocheck$/;"	s	namespace:Eigen::internal
Eigen::internal::dot_nocheck	src/Core/Dot.h	/^struct dot_nocheck<T, U, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::dot_nocheck::ResScalar	src/Core/Dot.h	/^  typedef typename scalar_product_traits<typename traits<T>::Scalar,typename traits<U>::Scalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::dot_nocheck	access:public
Eigen::internal::dot_nocheck::run	src/Core/Dot.h	/^  static inline ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)$/;"	f	struct:Eigen::internal::dot_nocheck	access:public	signature:(const MatrixBase<T>& a, const MatrixBase<U>& b)
Eigen::internal::eigen2_part_return_type	src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type$/;"	s	namespace:Eigen::internal
Eigen::internal::eigen2_part_return_type	src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type<MatrixType, SelfAdjoint>$/;"	s	namespace:Eigen::internal
Eigen::internal::eigen2_part_return_type::type	src/Core/TriangularMatrix.h	/^  typedef SelfAdjointView<MatrixType, Upper> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type	access:public
Eigen::internal::eigen2_part_return_type::type	src/Core/TriangularMatrix.h	/^  typedef TriangularView<MatrixType, Mode> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type	access:public
Eigen::internal::eigen_pastix	src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)
Eigen::internal::eigen_pastix	src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)
Eigen::internal::eigen_pastix	src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)
Eigen::internal::eigen_pastix	src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)
Eigen::internal::eigen_unaligned_array_assert_workaround_gcc47	src/Core/DenseStorage.h	/^  EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }$/;"	f	namespace:Eigen::internal	signature:(PtrType array)
Eigen::internal::eigenvalues_selector	src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::eigenvalues_selector	src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector<Derived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::eigenvalues_selector::MatrixBase::run	src/Eigenvalues/MatrixBaseEigenvalues.h	/^  run(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::internal::eigenvalues_selector::MatrixBase	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::internal::emptyIdxLU	src/SparseLU/SparseLU_Memory.h	/^enum {emptyIdxLU = -1};$/;"	e	enum:Eigen::internal::__anon462
Eigen::internal::enable_if	src/Core/util/Meta.h	/^template<typename T> struct enable_if<true,T>$/;"	s	namespace:Eigen::internal
Eigen::internal::enable_if::type	src/Core/util/Meta.h	/^{ typedef T type; };$/;"	t	struct:Eigen::internal::enable_if	access:public
Eigen::internal::etree_find	src/SparseCore/SparseColEtree.h	/^Index etree_find (Index i, IndexVector& pp)$/;"	f	namespace:Eigen::internal	signature:(Index i, IndexVector& pp)
Eigen::internal::eval	src/SparseCore/SparseUtil.h	/^template<typename T> struct eval<T,Sparse>$/;"	s	namespace:Eigen::internal	inherits:sparse_eval
Eigen::internal::extract_data	src/Core/util/BlasUtil.h	/^template<typename T> const typename T::Scalar* extract_data(const T& m)$/;"	f	namespace:Eigen::internal	signature:(const T& m)
Eigen::internal::extract_data_selector	src/Core/util/BlasUtil.h	/^struct extract_data_selector {$/;"	s	namespace:Eigen::internal
Eigen::internal::extract_data_selector	src/Core/util/BlasUtil.h	/^struct extract_data_selector<T,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::extract_data_selector::run	src/Core/util/BlasUtil.h	/^  static const typename T::Scalar* run(const T& m)$/;"	f	struct:Eigen::internal::extract_data_selector	access:public	signature:(const T& m)
Eigen::internal::extract_data_selector::run	src/Core/util/BlasUtil.h	/^  static typename T::Scalar* run(const T&) { return 0; }$/;"	f	struct:Eigen::internal::extract_data_selector	access:public	signature:(const T&)
Eigen::internal::false_type	src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::false_type::value	src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::false_type::__anon95
Eigen::internal::first_aligned	src/Core/DenseCoeffsBase.h	/^static inline typename Derived::Index first_aligned(const Derived& m)$/;"	f	namespace:Eigen::internal	signature:(const Derived& m)
Eigen::internal::first_aligned	src/Core/util/Memory.h	/^static inline Index first_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal	signature:(const Scalar* array, Index size)
Eigen::internal::first_aligned_impl	src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::first_aligned_impl	src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl<Derived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::first_aligned_impl::run	src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived& m)$/;"	f	struct:Eigen::internal::first_aligned_impl	access:public	signature:(const Derived& m)
Eigen::internal::first_aligned_impl::run	src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived&)$/;"	f	struct:Eigen::internal::first_aligned_impl	access:public	signature:(const Derived&)
Eigen::internal::first_multiple	src/Core/util/Memory.h	/^inline static Index first_multiple(Index size, Index base)$/;"	f	namespace:Eigen::internal	signature:(Index size, Index base)
Eigen::internal::floor_log2	src/Core/MathFunctions.h	/^struct floor_log2 {};$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2	src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_bogus>$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2	src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_down>$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2	src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_up>$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2	src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_terminate>$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2::value	src/Core/MathFunctions.h	/^  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };$/;"	e	enum:Eigen::internal::floor_log2::__anon281
Eigen::internal::floor_log2::value	src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, floor_log2_selector<n, lower, upper>::middle, upper>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon280
Eigen::internal::floor_log2::value	src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, lower, floor_log2_selector<n, lower, upper>::middle>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon279
Eigen::internal::floor_log2_bogus	src/Core/MathFunctions.h	/^  floor_log2_bogus$/;"	e	enum:Eigen::internal::__anon277
Eigen::internal::floor_log2_move_down	src/Core/MathFunctions.h	/^  floor_log2_move_down,$/;"	e	enum:Eigen::internal::__anon277
Eigen::internal::floor_log2_move_up	src/Core/MathFunctions.h	/^  floor_log2_move_up,$/;"	e	enum:Eigen::internal::__anon277
Eigen::internal::floor_log2_selector	src/Core/MathFunctions.h	/^template<unsigned int n, int lower, int upper> struct floor_log2_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2_selector::middle	src/Core/MathFunctions.h	/^  enum { middle = (lower + upper) \/ 2,$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon278
Eigen::internal::floor_log2_selector::value	src/Core/MathFunctions.h	/^         value = (upper <= lower + 1) ? int(floor_log2_terminate)$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon278
Eigen::internal::floor_log2_terminate	src/Core/MathFunctions.h	/^  floor_log2_terminate,$/;"	e	enum:Eigen::internal::__anon277
Eigen::internal::fortran_to_c_numbering	src/PaStiXSupport/PaStiXSupport.h	/^  void fortran_to_c_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
Eigen::internal::functor_has_linear_access	src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_has_linear_access	src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_has_linear_access::ret	src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon200
Eigen::internal::functor_has_linear_access::ret	src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon201
Eigen::internal::functor_is_product_like	src/Core/Functors.h	/^template<typename Functor> struct functor_is_product_like { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_is_product_like	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_is_product_like	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_is_product_like	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_quotient_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_is_product_like::ret	src/Core/Functors.h	/^template<typename Functor> struct functor_is_product_like { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon202
Eigen::internal::functor_is_product_like::ret	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon204
Eigen::internal::functor_is_product_like::ret	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon203
Eigen::internal::functor_is_product_like::ret	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_quotient_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon205
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_abs2_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_abs_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_acos_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_add_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_asin_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_binary_pow_op<Scalar,OtherScalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_cast_op<Scalar,NewType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_cmp_op<Scalar, cmp> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_conjugate_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_constant_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_cos_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_cube_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_difference_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_exp_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_hypot_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_identity_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_imag_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_imag_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_inverse_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_log_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_max_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_min_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_multiple2_op<Scalar1,Scalar2> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_multiple_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_opposite_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_pow_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_quotient_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_real_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_real_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_sin_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_sqrt_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_square_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_sum_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_tan_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::binary_compose<T0,T1,T2> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::binary_negate<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::binder1st<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::binder2nd<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::divides<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::equal_to<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::greater<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::greater_equal<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::less<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::less_equal<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::logical_and<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::logical_not<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::logical_or<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::minus<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::multiplies<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::negate<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::not_equal_to<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::plus<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::project1st<T0,T1> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::project2nd<T0,T1> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::select1st<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::select2nd<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::unary_compose<T0,T1> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^struct functor_traits<std::unary_negate<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct functor_traits< linspaced_op<Scalar,RandomAccess> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_and_op> {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_or_op> {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Random.h	/^struct functor_traits<scalar_random_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Visitor.h	/^struct functor_traits<max_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	src/Core/Visitor.h	/^struct functor_traits<min_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost), \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon179
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon170
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon207
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon208
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon209
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon210
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon211
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon212
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<LhsScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon172
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon168
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon173
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon174
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon177
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon182
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon183
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon184
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,$/;"	e	enum:Eigen::internal::functor_traits::__anon186
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon180
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon181
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon176
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon175
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon188
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon189
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon190
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon191
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon235
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon236
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon237
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon238
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon233
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon234
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon222
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon223
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon224
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon225
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon226
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon227
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon228
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon229
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon230
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon199
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon197
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon196
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon216
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon213
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon192
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon193
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon195
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon198
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon206
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon185
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon214
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon194
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon215
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon219
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon220
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon221
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon217
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon218
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon240
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon239
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon231
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon232
Eigen::internal::functor_traits::Cost	src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon187
Eigen::internal::functor_traits::Cost	src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon295
Eigen::internal::functor_traits::Cost	src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon337
Eigen::internal::functor_traits::Cost	src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon338
Eigen::internal::functor_traits::IsRepeatable	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon199
Eigen::internal::functor_traits::IsRepeatable	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon197
Eigen::internal::functor_traits::IsRepeatable	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon198
Eigen::internal::functor_traits::IsRepeatable	src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon295
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon180
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon181
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon182
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon172
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasACos$/;"	e	enum:Eigen::internal::functor_traits::__anon211
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasASin$/;"	e	enum:Eigen::internal::functor_traits::__anon212
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAbs$/;"	e	enum:Eigen::internal::functor_traits::__anon184
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon168
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasConj$/;"	e	enum:Eigen::internal::functor_traits::__anon186
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasCos$/;"	e	enum:Eigen::internal::functor_traits::__anon208
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMax$/;"	e	enum:Eigen::internal::functor_traits::__anon174
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMin$/;"	e	enum:Eigen::internal::functor_traits::__anon173
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasNegate };$/;"	e	enum:Eigen::internal::functor_traits::__anon183
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSin$/;"	e	enum:Eigen::internal::functor_traits::__anon209
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon207
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon177
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasTan$/;"	e	enum:Eigen::internal::functor_traits::__anon210
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = scalar_product_op<LhsScalar,RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon170
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^    PacketAccess = scalar_quotient_op<LhsScalar,RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon179
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon176
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon175
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon188
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon189
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon190
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon191
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon235
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon236
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon237
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon238
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon233
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon234
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon222
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon223
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon224
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon225
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon226
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon227
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon228
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon229
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon230
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon199
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon197
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon196
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon216
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon213
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon192
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon193
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon195
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon198
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon206
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon185
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon214
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon194
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon215
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon219
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon220
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon221
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon217
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon218
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon240
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon239
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon231
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon232
Eigen::internal::functor_traits::PacketAccess	src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon187
Eigen::internal::functor_traits::PacketAccess	src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon295
Eigen::internal::gebp_kernel	src/Core/products/GeneralBlockPanelKernel.h	/^struct gebp_kernel$/;"	s	namespace:Eigen::internal
Eigen::internal::gebp_kernel::AccPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::AccPacket AccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::LhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::LhsPacket LhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress   = Traits::LhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon38
Eigen::internal::gebp_kernel::ResPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResPacket ResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Traits::ResPacketSize$/;"	e	enum:Eigen::internal::gebp_kernel::__anon38
Eigen::internal::gebp_kernel::ResScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::RhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::RhsPacket RhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress   = Traits::RhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon38
Eigen::internal::gebp_kernel::Traits	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable  = Traits::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon38
Eigen::internal::gebp_kernel::operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha,$/;"	f	class:Eigen::internal::gebp_kernel	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha, Index strideA, Index strideB, Index offsetA, Index offsetB, RhsScalar* unpackedB)
Eigen::internal::gebp_kernel::operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha,$/;"	p	struct:Eigen::internal::gebp_kernel	access:public	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0, RhsScalar* unpackedB=0)
Eigen::internal::gebp_madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void gebp_madd(const CJ& cj, A& a, B& b, C& c, T& t)$/;"	f	namespace:Eigen::internal	signature:(const CJ& cj, A& a, B& b, C& c, T& t)
Eigen::internal::gebp_madd_selector	src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename A, typename B, typename C, typename T> struct gebp_madd_selector {$/;"	s	namespace:Eigen::internal
Eigen::internal::gebp_madd_selector	src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename T> struct gebp_madd_selector<CJ,T,T,T,T> {$/;"	s	namespace:Eigen::internal
Eigen::internal::gebp_madd_selector::run	src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, A& a, B& b, C& c, T& \/*t*\/)$/;"	f	struct:Eigen::internal::gebp_madd_selector	access:public	signature:(const CJ& cj, A& a, B& b, C& c, T& )
Eigen::internal::gebp_madd_selector::run	src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, T& a, T& b, T& c, T& t)$/;"	f	struct:Eigen::internal::gebp_madd_selector	access:public	signature:(const CJ& cj, T& a, T& b, T& c, T& t)
Eigen::internal::gebp_traits	src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits$/;"	c	namespace:Eigen::internal
Eigen::internal::gebp_traits	src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<RealScalar, std::complex<RealScalar>, false, _ConjRhs >$/;"	c	namespace:Eigen::internal
Eigen::internal::gebp_traits	src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, RealScalar, _ConjLhs, false>$/;"	c	namespace:Eigen::internal
Eigen::internal::gebp_traits	src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, std::complex<RealScalar>, _ConjLhs, _ConjRhs >$/;"	c	namespace:Eigen::internal
Eigen::internal::gebp_traits::AccPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef ResPacket AccPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::AccPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type AccPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ConjLhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::ConjLhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::ConjLhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::ConjLhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::ConjRhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::ConjRhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::ConjRhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::ConjRhs	src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::DoublePacket	src/Core/products/GeneralBlockPanelKernel.h	/^  struct DoublePacket$/;"	s	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::DoublePacket::first	src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket first;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket	access:public
Eigen::internal::gebp_traits::DoublePacket::second	src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket second;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket	access:public
Eigen::internal::gebp_traits::LhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,RealPacket,  Scalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::LhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::LhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::LhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar> LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::NumberOfRegisters	src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::NumberOfRegisters	src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::NumberOfRegisters	src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::RealPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RealScalar>::type RealPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RealPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacketSize  = Vectorizable ? packet_traits<RealScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::ResPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ResPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize   = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::ResScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ResScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ResScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::RhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::RhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = ResPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = Vectorizable ? 2*ResPacketSize : 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::RhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::Scalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  Scalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ScalarPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type     ScalarPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::WorkSpaceFactor	src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = Vectorizable ? 2*nr*RealPacketSize : nr,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::WorkSpaceFactor	src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr * RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::WorkSpaceFactor	src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::WorkSpaceFactor	src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::_LhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::_ResPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::_RhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::acc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const
Eigen::internal::gebp_traits::acc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const
Eigen::internal::gebp_traits::acc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const Scalar& c, const Scalar& alpha, Scalar& r) const { r += alpha * c; }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const Scalar& c, const Scalar& alpha, Scalar& r) const
Eigen::internal::gebp_traits::cj	src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
Eigen::internal::gebp_traits::cj	src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,ConjLhs,false> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
Eigen::internal::gebp_traits::cj	src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,false,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
Eigen::internal::gebp_traits::initAcc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(AccPacket& p)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(AccPacket& p)
Eigen::internal::gebp_traits::initAcc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(DoublePacket& p)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DoublePacket& p)
Eigen::internal::gebp_traits::initAcc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(Scalar& p) { p = Scalar(0); }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(Scalar& p)
Eigen::internal::gebp_traits::loadLhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsScalar* a, LhsPacket& dest) const
Eigen::internal::gebp_traits::loadRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, DoublePacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, DoublePacket& dest) const
Eigen::internal::gebp_traits::loadRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, ResPacket& dest) const { dest = *b; }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, ResPacket& dest) const
Eigen::internal::gebp_traits::loadRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, RhsPacket& dest) const
Eigen::internal::gebp_traits::madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const
Eigen::internal::gebp_traits::madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const
Eigen::internal::gebp_traits::madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& ) const
Eigen::internal::gebp_traits::madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& ) const
Eigen::internal::gebp_traits::madd_impl	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const
Eigen::internal::gebp_traits::madd_impl	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& \/*tmp*\/, const false_type&) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& , const false_type&) const
Eigen::internal::gebp_traits::mr	src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::mr	src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::mr	src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::mr	src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2*ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::nr	src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 2,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Eigen::internal::gebp_traits::nr	src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Eigen::internal::gebp_traits::nr	src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Eigen::internal::gebp_traits::nr	src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Eigen::internal::gebp_traits::unpackRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)
Eigen::internal::gebp_traits::unpackRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const Scalar* rhs, Scalar* b)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DenseIndex n, const Scalar* rhs, Scalar* b)
Eigen::internal::gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, false>$/;"	c	namespace:Eigen::internal	inherits:level3_blocking
Eigen::internal::gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, true>$/;"	c	namespace:Eigen::internal	inherits:level3_blocking
Eigen::internal::gemm_blocking_space::ActualCols	src/Core/products/GeneralMatrixMatrix.h	/^      ActualCols = Transpose ? MaxRows : MaxCols$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon41
Eigen::internal::gemm_blocking_space::ActualRows	src/Core/products/GeneralMatrixMatrix.h	/^      ActualRows = Transpose ? MaxCols : MaxRows,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon41
Eigen::internal::gemm_blocking_space::LhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::RhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::SizeA	src/Core/products/GeneralMatrixMatrix.h	/^      SizeA = ActualRows * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon42
Eigen::internal::gemm_blocking_space::SizeB	src/Core/products/GeneralMatrixMatrix.h	/^      SizeB = ActualCols * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon42
Eigen::internal::gemm_blocking_space::SizeW	src/Core/products/GeneralMatrixMatrix.h	/^      SizeW = MaxDepth * Traits::WorkSpaceFactor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon42
Eigen::internal::gemm_blocking_space::Traits	src/Core/products/GeneralMatrixMatrix.h	/^    typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::Transpose	src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon43
Eigen::internal::gemm_blocking_space::Transpose	src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon41
Eigen::internal::gemm_blocking_space::allocateA	src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateA() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateA	src/Core/products/GeneralMatrixMatrix.h	/^    void allocateA()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateAll	src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateAll() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateAll	src/Core/products/GeneralMatrixMatrix.h	/^    void allocateAll()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateB	src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateB() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateB	src/Core/products/GeneralMatrixMatrix.h	/^    void allocateB()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateW	src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateW() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateW	src/Core/products/GeneralMatrixMatrix.h	/^    void allocateW()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex \/*rows*\/, DenseIndex \/*cols*\/, DenseIndex \/*depth*\/)$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:(DenseIndex , DenseIndex , DenseIndex )
Eigen::internal::gemm_blocking_space::gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex rows, DenseIndex cols, DenseIndex depth)$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:(DenseIndex rows, DenseIndex cols, DenseIndex depth)
Eigen::internal::gemm_blocking_space::m_sizeA	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeA;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_sizeB	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeB;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_sizeW	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeW;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_staticA	src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 LhsScalar m_staticA[SizeA];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_staticB	src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticB[SizeB];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_staticW	src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticW[SizeW];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::~gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^    ~gemm_blocking_space()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_functor	src/Core/products/GeneralMatrixMatrix.h	/^struct gemm_functor$/;"	s	namespace:Eigen::internal
Eigen::internal::gemm_functor::gemm_functor	src/Core/products/GeneralMatrixMatrix.h	/^  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, const Scalar& actualAlpha,$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:(const Lhs& lhs, const Rhs& rhs, Dest& dest, const Scalar& actualAlpha, BlockingType& blocking)
Eigen::internal::gemm_functor::initParallelSession	src/Core/products/GeneralMatrixMatrix.h	/^  void initParallelSession() const$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:() const
Eigen::internal::gemm_functor::m_actualAlpha	src/Core/products/GeneralMatrixMatrix.h	/^    Scalar m_actualAlpha;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::m_blocking	src/Core/products/GeneralMatrixMatrix.h	/^    BlockingType& m_blocking;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::m_dest	src/Core/products/GeneralMatrixMatrix.h	/^    Dest& m_dest;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::m_lhs	src/Core/products/GeneralMatrixMatrix.h	/^    const Lhs& m_lhs;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::m_rhs	src/Core/products/GeneralMatrixMatrix.h	/^    const Rhs& m_rhs;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::operator ()	src/Core/products/GeneralMatrixMatrix.h	/^  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:(Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const
Eigen::internal::gemm_pack_lhs	src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs$/;"	s	namespace:Eigen::internal
Eigen::internal::gemm_pack_lhs::operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_lhs	signature:(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride, Index offset)
Eigen::internal::gemm_pack_lhs::operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride=0, Index offset=0);$/;"	p	struct:Eigen::internal::gemm_pack_lhs	access:public	signature:(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride=0, Index offset=0)
Eigen::internal::gemm_pack_rhs	src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemm_pack_rhs	src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemm_pack_rhs::Packet	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::gemm_pack_rhs	access:public
Eigen::internal::gemm_pack_rhs::PacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon39
Eigen::internal::gemm_pack_rhs::PacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon40
Eigen::internal::gemm_pack_rhs::operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_rhs	signature:(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride, Index offset)
Eigen::internal::gemm_pack_rhs::operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride=0, Index offset=0);$/;"	p	struct:Eigen::internal::gemm_pack_rhs	access:public	signature:(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride=0, Index offset=0)
Eigen::internal::gemv_selector	src/Core/GeneralProduct.h	/^struct gemv_selector<OnTheLeft,StorageOrder,BlasCompatible>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector	src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector	src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector	src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector	src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector::run	src/Core/GeneralProduct.h	/^  static inline void run(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_selector	access:public	signature:(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)
Eigen::internal::gemv_selector::run	src/Core/GeneralProduct.h	/^  static void run(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_selector	access:public	signature:(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)
Eigen::internal::gemv_static_vector_if	src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,Dynamic,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_static_vector_if	src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_static_vector_if	src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_static_vector_if::data	src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE  Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
Eigen::internal::gemv_static_vector_if::data	src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
Eigen::internal::gemv_static_vector_if::data	src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return m_data.array; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
Eigen::internal::gemv_static_vector_if::m_data	src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize),0> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if	access:public
Eigen::internal::general_det3_helper	src/LU/Inverse.h	/^inline const typename Derived::Scalar general_det3_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int i1, int i2, int i3, int j1, int j2, int j3)
Eigen::internal::general_matrix_matrix_product	src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_matrix_product	src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_matrix_product::ResScalar	src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product	access:public
Eigen::internal::general_matrix_matrix_product::ResScalar	src/Core/products/GeneralMatrixMatrix.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product	access:public
Eigen::internal::general_matrix_matrix_product::run	src/Core/products/GeneralMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::general_matrix_matrix_product	access:public	signature:( Index rows, Index cols, Index depth, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha, level3_blocking<RhsScalar,LhsScalar>& blocking, GemmParallelInfo<Index>* info = 0)
Eigen::internal::general_matrix_matrix_product::run	src/Core/products/GeneralMatrixMatrix.h	/^static void run(Index rows, Index cols, Index depth,$/;"	f	struct:Eigen::internal::general_matrix_matrix_product	access:public	signature:(Index rows, Index cols, Index depth, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha, level3_blocking<LhsScalar,RhsScalar>& blocking, GemmParallelInfo<Index>* info = 0)
Eigen::internal::general_matrix_matrix_rankupdate	src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^struct general_matrix_matrix_rankupdate :$/;"	s	namespace:Eigen::internal	inherits:general_matrix_matrix_triangular_product
Eigen::internal::general_matrix_matrix_triangular_product	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_matrix_triangular_product	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_matrix_triangular_product::ResScalar	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public
Eigen::internal::general_matrix_matrix_triangular_product::run	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public	signature:(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsStride, ResScalar* res, Index resStride, const ResScalar& alpha)
Eigen::internal::general_matrix_matrix_triangular_product::run	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public	signature:(Index size, Index depth,const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride, const ResScalar& alpha)
Eigen::internal::general_matrix_vector_product	src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_vector_product	src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_vector_product::LhsPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::LhsPacketSize	src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon46
Eigen::internal::general_matrix_vector_product::LhsPacketSize	src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon47
Eigen::internal::general_matrix_vector_product::ResPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::ResPacketSize	src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon46
Eigen::internal::general_matrix_vector_product::ResPacketSize	src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon47
Eigen::internal::general_matrix_vector_product::ResScalar	src/Core/products/GeneralMatrixVector.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::RhsPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::RhsPacketSize	src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon46
Eigen::internal::general_matrix_vector_product::RhsPacketSize	src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon47
Eigen::internal::general_matrix_vector_product::Vectorizable	src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon46
Eigen::internal::general_matrix_vector_product::Vectorizable	src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon47
Eigen::internal::general_matrix_vector_product::_LhsPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::_ResPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::_RhsPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::run	src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE static void run($/;"	p	struct:Eigen::internal::general_matrix_vector_product	access:public	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, ResScalar alpha)
Eigen::internal::general_matrix_vector_product::run	src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE static void run($/;"	p	struct:Eigen::internal::general_matrix_vector_product	access:public	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, RhsScalar alpha)
Eigen::internal::general_matrix_vector_product::run	src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, RhsScalar alpha)
Eigen::internal::general_matrix_vector_product::run	src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, ResScalar alpha)
Eigen::internal::general_matrix_vector_product_gemv	src/Core/products/GeneralMatrixVector_MKL.h	/^struct general_matrix_vector_product_gemv :$/;"	s	namespace:Eigen::internal	inherits:general_matrix_vector_product
Eigen::internal::generic_aligned_realloc	src/Core/util/Memory.h	/^inline void* generic_aligned_realloc(void* ptr, size_t size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t size, size_t old_size)
Eigen::internal::get_factor	src/Core/util/BlasUtil.h	/^template<typename From,typename To> struct get_factor {$/;"	s	namespace:Eigen::internal
Eigen::internal::get_factor	src/Core/util/BlasUtil.h	/^template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {$/;"	s	namespace:Eigen::internal
Eigen::internal::get_factor::run	src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE To run(const From& x) { return x; }$/;"	f	struct:Eigen::internal::get_factor	access:public	signature:(const From& x)
Eigen::internal::get_factor::run	src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return numext::real(x); }$/;"	f	struct:Eigen::internal::get_factor	access:public	signature:(const Scalar& x)
Eigen::internal::global_math_functions_filtering_base	src/Core/MathFunctions.h	/^struct global_math_functions_filtering_base$/;"	s	namespace:Eigen::internal
Eigen::internal::global_math_functions_filtering_base::type	src/Core/MathFunctions.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base	access:public
Eigen::internal::global_math_functions_filtering_base::type	src/Core/MathFunctions.h	/^  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base	access:public
Eigen::internal::handmade_aligned_free	src/Core/util/Memory.h	/^inline void handmade_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::handmade_aligned_malloc	src/Core/util/Memory.h	/^inline void* handmade_aligned_malloc(std::size_t size)$/;"	f	namespace:Eigen::internal	signature:(std::size_t size)
Eigen::internal::handmade_aligned_realloc	src/Core/util/Memory.h	/^inline void* handmade_aligned_realloc(void* ptr, std::size_t size, std::size_t = 0)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, std::size_t size, std::size_t = 0)
Eigen::internal::has_direct_access	src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct has_direct_access$/;"	s	namespace:Eigen::internal
Eigen::internal::has_direct_access::ret	src/Core/util/ForwardDeclarations.h	/^  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };$/;"	e	enum:Eigen::internal::has_direct_access::__anon70
Eigen::internal::has_none	src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	s	namespace:Eigen::internal
Eigen::internal::has_none::a	src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	m	struct:Eigen::internal::has_none	access:public
Eigen::internal::has_std_result_type	src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	s	namespace:Eigen::internal
Eigen::internal::has_std_result_type::a	src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	m	struct:Eigen::internal::has_std_result_type	access:public
Eigen::internal::has_tr1_result	src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	s	namespace:Eigen::internal
Eigen::internal::has_tr1_result::a	src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	m	struct:Eigen::internal::has_tr1_result	access:public
Eigen::internal::homogeneous_left_product_impl	src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs>$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::homogeneous_left_product_impl::Index	src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::LhsMatrixType	src/Geometry/Homogeneous.h	/^  typedef typename traits<homogeneous_left_product_impl>::LhsMatrixType LhsMatrixType;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::LhsMatrixTypeCleaned	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::LhsMatrixTypeNested	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename LhsMatrixTypeCleaned::Nested>::type LhsMatrixTypeNested;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::cols	src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:() const
Eigen::internal::homogeneous_left_product_impl::evalTo	src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:(Dest& dst) const
Eigen::internal::homogeneous_left_product_impl::homogeneous_left_product_impl	src/Geometry/Homogeneous.h	/^  homogeneous_left_product_impl(const Lhs& lhs, const MatrixType& rhs)$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:(const Lhs& lhs, const MatrixType& rhs)
Eigen::internal::homogeneous_left_product_impl::m_lhs	src/Geometry/Homogeneous.h	/^  typename LhsMatrixTypeCleaned::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::m_rhs	src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::rows	src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:() const
Eigen::internal::homogeneous_right_product_impl	src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs>$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::homogeneous_right_product_impl::Index	src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Eigen::internal::homogeneous_right_product_impl::RhsNested	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNested;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Eigen::internal::homogeneous_right_product_impl::cols	src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:() const
Eigen::internal::homogeneous_right_product_impl::evalTo	src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:(Dest& dst) const
Eigen::internal::homogeneous_right_product_impl::homogeneous_right_product_impl	src/Geometry/Homogeneous.h	/^  homogeneous_right_product_impl(const MatrixType& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:(const MatrixType& lhs, const Rhs& rhs)
Eigen::internal::homogeneous_right_product_impl::m_lhs	src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Eigen::internal::homogeneous_right_product_impl::m_rhs	src/Geometry/Homogeneous.h	/^  typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Eigen::internal::homogeneous_right_product_impl::rows	src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:() const
Eigen::internal::householder_qr_inplace_blocked	src/QR/HouseholderQR.h	/^struct householder_qr_inplace_blocked$/;"	s	namespace:Eigen::internal
Eigen::internal::householder_qr_inplace_blocked::run	src/QR/HouseholderQR.h	/^  static void run(MatrixQR& mat, HCoeffs& hCoeffs,$/;"	f	struct:Eigen::internal::householder_qr_inplace_blocked	access:public	signature:(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Index maxBlockSize=32, typename MatrixQR::Scalar* tempData = 0)
Eigen::internal::householder_qr_inplace_unblocked	src/QR/HouseholderQR.h	/^void householder_qr_inplace_unblocked(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)$/;"	f	namespace:Eigen::internal	signature:(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)
Eigen::internal::hseq_side_dependent_impl	src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::hseq_side_dependent_impl	src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl<VectorsType, CoeffsType, OnTheRight>$/;"	s	namespace:Eigen::internal
Eigen::internal::hseq_side_dependent_impl::EssentialVectorType	src/Householder/HouseholderSequence.h	/^  typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hseq_side_dependent_impl::EssentialVectorType	src/Householder/HouseholderSequence.h	/^  typedef Transpose<Block<const VectorsType, 1, Dynamic> > EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hseq_side_dependent_impl::HouseholderSequenceType	src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hseq_side_dependent_impl::HouseholderSequenceType	src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheRight> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hseq_side_dependent_impl::Index	src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hseq_side_dependent_impl::essentialVector	src/Householder/HouseholderSequence.h	/^  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)$/;"	f	struct:Eigen::internal::hseq_side_dependent_impl	access:public	signature:(const HouseholderSequenceType& h, Index k)
Eigen::internal::hypot_impl	src/Core/MathFunctions.h	/^struct hypot_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::hypot_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::hypot_impl	access:public
Eigen::internal::hypot_impl::run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::hypot_impl	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::hypot_retval	src/Core/MathFunctions.h	/^struct hypot_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::hypot_retval::type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::hypot_retval	access:public
Eigen::internal::ignore_unused_variable	src/Core/util/Macros.h	/^    template<typename T> void ignore_unused_variable(const T&) {}$/;"	f	namespace:Eigen::internal	signature:(const T&)
Eigen::internal::imag_default_impl	src/Core/MathFunctions.h	/^struct imag_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_default_impl	src/Core/MathFunctions.h	/^struct imag_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_default_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_default_impl	access:public
Eigen::internal::imag_default_impl::run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_default_impl	access:public	signature:(const Scalar& x)
Eigen::internal::imag_default_impl::run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_default_impl	access:public	signature:(const Scalar&)
Eigen::internal::imag_impl	src/Core/MathFunctions.h	/^template<typename Scalar> struct imag_impl : imag_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal	inherits:imag_default_impl
Eigen::internal::imag_ref_default_impl	src/Core/MathFunctions.h	/^struct imag_ref_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_ref_default_impl	src/Core/MathFunctions.h	/^struct imag_ref_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_ref_default_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_ref_default_impl	access:public
Eigen::internal::imag_ref_default_impl::run	src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(Scalar& x)
Eigen::internal::imag_ref_default_impl::run	src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(Scalar&)
Eigen::internal::imag_ref_default_impl::run	src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(const Scalar& x)
Eigen::internal::imag_ref_default_impl::run	src/Core/MathFunctions.h	/^  static inline const Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(const Scalar&)
Eigen::internal::imag_ref_impl	src/Core/MathFunctions.h	/^struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal	inherits:imag_ref_default_impl
Eigen::internal::imag_ref_retval	src/Core/MathFunctions.h	/^struct imag_ref_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_ref_retval::type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::imag_ref_retval	access:public
Eigen::internal::imag_retval	src/Core/MathFunctions.h	/^struct imag_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_retval::type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::imag_retval	access:public
Eigen::internal::image_retval	src/LU/FullPivLU.h	/^struct image_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:image_retval_base
Eigen::internal::image_retval::MaxSmallDimAtCompileTime	src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::image_retval::__anon400
Eigen::internal::image_retval::evalTo	src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval	access:public	signature:(Dest& dst) const
Eigen::internal::image_retval_base	src/misc/Image.h	/^template<typename _DecompositionType> struct image_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::image_retval_base::Base	src/misc/Image.h	/^  typedef ReturnByValue<image_retval_base> Base;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Eigen::internal::image_retval_base::DecompositionType	src/misc/Image.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Eigen::internal::image_retval_base::Index	src/misc/Image.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Eigen::internal::image_retval_base::MatrixType	src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Eigen::internal::image_retval_base::cols	src/misc/Image.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::image_retval_base::dec	src/misc/Image.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::image_retval_base::evalTo	src/misc/Image.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:(Dest& dst) const
Eigen::internal::image_retval_base::image_retval_base	src/misc/Image.h	/^  image_retval_base(const DecompositionType& dec, const MatrixType& originalMatrix)$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:(const DecompositionType& dec, const MatrixType& originalMatrix)
Eigen::internal::image_retval_base::m_cols	src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
Eigen::internal::image_retval_base::m_dec	src/misc/Image.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
Eigen::internal::image_retval_base::m_originalMatrix	src/misc/Image.h	/^    const MatrixType& m_originalMatrix;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
Eigen::internal::image_retval_base::m_rank	src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
Eigen::internal::image_retval_base::originalMatrix	src/misc/Image.h	/^  inline const MatrixType& originalMatrix() const { return m_originalMatrix; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::image_retval_base::rank	src/misc/Image.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::image_retval_base::rows	src/misc/Image.h	/^  inline Index rows() const { return m_dec.rows(); }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::inner_stride_at_compile_time	src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time$/;"	s	namespace:Eigen::internal
Eigen::internal::inner_stride_at_compile_time	src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::inner_stride_at_compile_time::ret	src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon158
Eigen::internal::inner_stride_at_compile_time::ret	src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::InnerStrideAtCompileTime };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon157
Eigen::internal::inplace_transpose_selector	src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,false> { \/\/ non square matrix$/;"	s	namespace:Eigen::internal
Eigen::internal::inplace_transpose_selector	src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true> { \/\/ square matrix$/;"	s	namespace:Eigen::internal
Eigen::internal::inplace_transpose_selector::run	src/Core/Transpose.h	/^  static void run(MatrixType& m) {$/;"	f	struct:Eigen::internal::inplace_transpose_selector	access:public	signature:(MatrixType& m)
Eigen::internal::inverse_impl	src/LU/Inverse.h	/^struct inverse_impl : public ReturnByValue<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::inverse_impl::Index	src/LU/Inverse.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
Eigen::internal::inverse_impl::MatrixTypeNested	src/LU/Inverse.h	/^  typedef typename internal::eval<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
Eigen::internal::inverse_impl::MatrixTypeNestedCleaned	src/LU/Inverse.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
Eigen::internal::inverse_impl::cols	src/LU/Inverse.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:() const
Eigen::internal::inverse_impl::evalTo	src/LU/Inverse.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:(Dest& dst) const
Eigen::internal::inverse_impl::inverse_impl	src/LU/Inverse.h	/^  inverse_impl(const MatrixType& matrix)$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:(const MatrixType& matrix)
Eigen::internal::inverse_impl::m_matrix	src/LU/Inverse.h	/^  MatrixTypeNested m_matrix;$/;"	m	struct:Eigen::internal::inverse_impl	access:public
Eigen::internal::inverse_impl::rows	src/LU/Inverse.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:() const
Eigen::internal::isApprox	src/Core/MathFunctions.h	/^inline bool isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::internal::isApproxOrLessThan	src/Core/MathFunctions.h	/^inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::internal::isApprox_selector	src/Core/Fuzzy.h	/^struct isApprox_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::isApprox_selector	src/Core/Fuzzy.h	/^struct isApprox_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::isApprox_selector::run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isApprox_selector	access:public	signature:(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)
Eigen::internal::isApprox_selector::run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isApprox_selector	access:public	signature:(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar&)
Eigen::internal::isMuchSmallerThan	src/Core/MathFunctions.h	/^inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const OtherScalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::internal::isMuchSmallerThan_object_selector	src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::isMuchSmallerThan_object_selector	src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::isMuchSmallerThan_object_selector::run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector	access:public	signature:(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)
Eigen::internal::isMuchSmallerThan_object_selector::run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector	access:public	signature:(const Derived& x, const OtherDerived&, const typename Derived::RealScalar&)
Eigen::internal::isMuchSmallerThan_scalar_selector	src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::isMuchSmallerThan_scalar_selector	src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector<Derived, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::isMuchSmallerThan_scalar_selector::run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector	access:public	signature:(const Derived& x, const typename Derived::RealScalar& y, const typename Derived::RealScalar& prec)
Eigen::internal::isMuchSmallerThan_scalar_selector::run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector	access:public	signature:(const Derived& x, const typename Derived::RealScalar&, const typename Derived::RealScalar&)
Eigen::internal::is_arithmetic	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic::value	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon21
Eigen::internal::is_arithmetic::value	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon23
Eigen::internal::is_arithmetic::value	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon22
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon102
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon103
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon100
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon99
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon101
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon104
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon108
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon110
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon106
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon105
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon109
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon111
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon107
Eigen::internal::is_arithmetic::value	src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon98
Eigen::internal::is_const	src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_const	src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_const::value	src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_const::__anon112
Eigen::internal::is_const::value	src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_const::__anon113
Eigen::internal::is_malloc_allowed	src/Core/util/Memory.h	/^inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::is_malloc_allowed_impl	src/Core/util/Memory.h	/^inline bool is_malloc_allowed_impl(bool update, bool new_value = false)$/;"	f	namespace:Eigen::internal	signature:(bool update, bool new_value = false)
Eigen::internal::is_same	src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_same	src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_same::value	src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_same::__anon96
Eigen::internal::is_same::value	src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_same::__anon97
Eigen::internal::kernel_retval	src/LU/FullPivLU.h	/^struct kernel_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:kernel_retval_base
Eigen::internal::kernel_retval::MaxSmallDimAtCompileTime	src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::kernel_retval::__anon399
Eigen::internal::kernel_retval::evalTo	src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval	access:public	signature:(Dest& dst) const
Eigen::internal::kernel_retval_base	src/misc/Kernel.h	/^template<typename _DecompositionType> struct kernel_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::kernel_retval_base::Base	src/misc/Kernel.h	/^  typedef ReturnByValue<kernel_retval_base> Base;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Eigen::internal::kernel_retval_base::DecompositionType	src/misc/Kernel.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Eigen::internal::kernel_retval_base::Index	src/misc/Kernel.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Eigen::internal::kernel_retval_base::cols	src/misc/Kernel.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
Eigen::internal::kernel_retval_base::dec	src/misc/Kernel.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
Eigen::internal::kernel_retval_base::evalTo	src/misc/Kernel.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:(Dest& dst) const
Eigen::internal::kernel_retval_base::kernel_retval_base	src/misc/Kernel.h	/^  kernel_retval_base(const DecompositionType& dec)$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:(const DecompositionType& dec)
Eigen::internal::kernel_retval_base::m_cols	src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
Eigen::internal::kernel_retval_base::m_dec	src/misc/Kernel.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
Eigen::internal::kernel_retval_base::m_rank	src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
Eigen::internal::kernel_retval_base::rank	src/misc/Kernel.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
Eigen::internal::kernel_retval_base::rows	src/misc/Kernel.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
Eigen::internal::ldlt_inplace	src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::ldlt_inplace	src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::ldlt_inplace::unblocked	src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)
Eigen::internal::ldlt_inplace::unblocked	src/Cholesky/LDLT.h	/^  static bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)
Eigen::internal::ldlt_inplace::update	src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool update(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, const typename MatrixType::RealScalar& sigma=1)
Eigen::internal::ldlt_inplace::update	src/Cholesky/LDLT.h	/^  static bool update(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, const typename MatrixType::RealScalar& sigma=1)
Eigen::internal::ldlt_inplace::updateInPlace	src/Cholesky/LDLT.h	/^  static bool updateInPlace(MatrixType& mat, MatrixBase<WDerived>& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, MatrixBase<WDerived>& w, const typename MatrixType::RealScalar& sigma=1)
Eigen::internal::level3_blocking	src/Core/products/GeneralMatrixMatrix.h	/^class level3_blocking$/;"	c	namespace:Eigen::internal
Eigen::internal::level3_blocking::LhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::level3_blocking	access:private
Eigen::internal::level3_blocking::RhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::level3_blocking	access:private
Eigen::internal::level3_blocking::blockA	src/Core/products/GeneralMatrixMatrix.h	/^    inline LhsScalar* blockA() { return m_blockA; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
Eigen::internal::level3_blocking::blockB	src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockB() { return m_blockB; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
Eigen::internal::level3_blocking::blockW	src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockW() { return m_blockW; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
Eigen::internal::level3_blocking::kc	src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex kc() const { return m_kc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
Eigen::internal::level3_blocking::level3_blocking	src/Core/products/GeneralMatrixMatrix.h	/^    level3_blocking()$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
Eigen::internal::level3_blocking::m_blockA	src/Core/products/GeneralMatrixMatrix.h	/^    LhsScalar* m_blockA;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::m_blockB	src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockB;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::m_blockW	src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockW;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::m_kc	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_kc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::m_mc	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_mc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::m_nc	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_nc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::mc	src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex mc() const { return m_mc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
Eigen::internal::level3_blocking::nc	src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex nc() const { return m_nc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
Eigen::internal::linspaced_op	src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct linspaced_op$/;"	s	namespace:Eigen::internal
Eigen::internal::linspaced_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op	access:public
Eigen::internal::linspaced_op::impl	src/Core/Functors.h	/^  const linspaced_op_impl<Scalar,RandomAccess> impl;$/;"	m	struct:Eigen::internal::linspaced_op	access:public
Eigen::internal::linspaced_op::linspaced_op	src/Core/Functors.h	/^  linspaced_op(const Scalar& low, const Scalar& high, DenseIndex num_steps) : impl((num_steps==1 ? high : low), (num_steps==1 ? Scalar() : (high-low)\/Scalar(num_steps-1))) {}$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(const Scalar& low, const Scalar& high, DenseIndex num_steps)
Eigen::internal::linspaced_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return impl(i); }$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index i) const
Eigen::internal::linspaced_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const $/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index row, Index col) const
Eigen::internal::linspaced_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const { return impl.packetOp(i); }$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index i) const
Eigen::internal::linspaced_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index row, Index col) const$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index row, Index col) const
Eigen::internal::linspaced_op_impl	src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::linspaced_op_impl	src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::linspaced_op_impl::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::linspaced_op_impl	src/Core/Functors.h	/^  linspaced_op_impl(const Scalar& low, const Scalar& step) :$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(const Scalar& low, const Scalar& step)
Eigen::internal::linspaced_op_impl::m_base	src/Core/Functors.h	/^  mutable Packet m_base;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_interPacket	src/Core/Functors.h	/^  const Packet m_interPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_low	src/Core/Functors.h	/^  const Scalar m_low;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_lowPacket	src/Core/Functors.h	/^  const Packet m_lowPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_packetStep	src/Core/Functors.h	/^  const Packet m_packetStep;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_step	src/Core/Functors.h	/^  const Scalar m_step;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_stepPacket	src/Core/Functors.h	/^  const Packet m_stepPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const $/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
Eigen::internal::linspaced_op_impl::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return m_low+i*m_step; }$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
Eigen::internal::linspaced_op_impl::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
Eigen::internal::linspaced_op_impl::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index) const { return m_base = padd(m_base,m_packetStep); }$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index) const
Eigen::internal::llt_inplace	src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::llt_inplace	src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::llt_inplace::RealScalar	src/Cholesky/LLT.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::llt_inplace	access:public
Eigen::internal::llt_inplace::blocked	src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index blocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
Eigen::internal::llt_inplace::blocked	src/Cholesky/LLT.h	/^  static typename MatrixType::Index blocked(MatrixType& m)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& m)
Eigen::internal::llt_inplace::rankUpdate	src/Cholesky/LLT.h	/^  static typename MatrixType::Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)
Eigen::internal::llt_inplace::unblocked	src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
Eigen::internal::llt_inplace::unblocked	src/Cholesky/LLT.h	/^  static typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
Eigen::internal::llt_rank_update_lower	src/Cholesky/LLT.h	/^static typename MatrixType::Index llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)
Eigen::internal::lpNorm_selector	src/Core/Dot.h	/^struct lpNorm_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::lpNorm_selector	src/Core/Dot.h	/^struct lpNorm_selector<Derived, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::lpNorm_selector	src/Core/Dot.h	/^struct lpNorm_selector<Derived, 2>$/;"	s	namespace:Eigen::internal
Eigen::internal::lpNorm_selector	src/Core/Dot.h	/^struct lpNorm_selector<Derived, Infinity>$/;"	s	namespace:Eigen::internal
Eigen::internal::lpNorm_selector::RealScalar	src/Core/Dot.h	/^  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::lpNorm_selector	access:public
Eigen::internal::lpNorm_selector::run	src/Core/Dot.h	/^  static inline RealScalar run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::internal::lpNorm_selector::run	src/Core/Dot.h	/^  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::internal::make_block_householder_triangular_factor	src/Householder/BlockHouseholder.h	/^void make_block_householder_triangular_factor(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)
Eigen::internal::manage_caching_sizes	src/Core/products/GeneralBlockPanelKernel.h	/^inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)$/;"	f	namespace:Eigen::internal	signature:(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)
Eigen::internal::manage_caching_sizes_helper	src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)$/;"	f	namespace:Eigen::internal	signature:(std::ptrdiff_t a, std::ptrdiff_t b)
Eigen::internal::manage_multi_threading	src/Core/products/Parallelizer.h	/^inline void manage_multi_threading(Action action, int* v)$/;"	f	namespace:Eigen::internal	signature:(Action action, int* v)
Eigen::internal::map_superlu	src/SuperLUSupport/SuperLUSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> map_superlu(SluMatrix& sluMat)$/;"	f	namespace:Eigen::internal	signature:(SluMatrix& sluMat)
Eigen::internal::matrix_swap_impl	src/Core/PlainObjectBase.h	/^struct matrix_swap_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::matrix_swap_impl	src/Core/PlainObjectBase.h	/^struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::matrix_swap_impl::run	src/Core/PlainObjectBase.h	/^  static inline void run(MatrixTypeA& a, MatrixTypeB& b)$/;"	f	struct:Eigen::internal::matrix_swap_impl	access:public	signature:(MatrixTypeA& a, MatrixTypeB& b)
Eigen::internal::matrix_type_times_scalar_type	src/Householder/HouseholderSequence.h	/^template<typename OtherScalarType, typename MatrixType> struct matrix_type_times_scalar_type$/;"	s	namespace:Eigen::internal
Eigen::internal::matrix_type_times_scalar_type::ResultScalar	src/Householder/HouseholderSequence.h	/^    ResultScalar;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type	access:public
Eigen::internal::matrix_type_times_scalar_type::Type	src/Householder/HouseholderSequence.h	/^                 0, MatrixType::MaxRowsAtCompileTime, MatrixType::MaxColsAtCompileTime> Type;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type	access:public
Eigen::internal::max_coeff_visitor	src/Core/Visitor.h	/^struct max_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal	inherits:coeff_visitor
Eigen::internal::max_coeff_visitor::Index	src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::max_coeff_visitor	access:public
Eigen::internal::max_coeff_visitor::Scalar	src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::max_coeff_visitor	access:public
Eigen::internal::max_coeff_visitor::operator ()	src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::max_coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
Eigen::internal::member_redux	src/Core/VectorwiseOp.h	/^struct member_redux {$/;"	s	namespace:Eigen::internal
Eigen::internal::member_redux::Cost	src/Core/VectorwiseOp.h	/^  template<typename _Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_redux	access:public
Eigen::internal::member_redux::Cost::value	src/Core/VectorwiseOp.h	/^  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };$/;"	e	enum:Eigen::internal::member_redux::Cost::__anon333
Eigen::internal::member_redux::m_functor	src/Core/VectorwiseOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::member_redux	access:public
Eigen::internal::member_redux::member_redux	src/Core/VectorwiseOp.h	/^  member_redux(const BinaryOp func) : m_functor(func) {}$/;"	f	struct:Eigen::internal::member_redux	access:public	signature:(const BinaryOp func)
Eigen::internal::member_redux::operator ()	src/Core/VectorwiseOp.h	/^  inline result_type operator()(const DenseBase<Derived>& mat) const$/;"	f	struct:Eigen::internal::member_redux	access:public	signature:(const DenseBase<Derived>& mat) const
Eigen::internal::member_redux::result_type	src/Core/VectorwiseOp.h	/^                   >::type  result_type;$/;"	t	struct:Eigen::internal::member_redux	access:public
Eigen::internal::min_coeff_visitor	src/Core/Visitor.h	/^struct min_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal	inherits:coeff_visitor
Eigen::internal::min_coeff_visitor::Index	src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::min_coeff_visitor	access:public
Eigen::internal::min_coeff_visitor::Scalar	src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::min_coeff_visitor	access:public
Eigen::internal::min_coeff_visitor::operator ()	src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::min_coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
Eigen::internal::minimum_degree_ordering	src/OrderingMethods/Amd.h	/^void minimum_degree_ordering(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)$/;"	f	namespace:Eigen::internal	signature:(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)
Eigen::internal::nested	src/Core/ReturnByValue.h	/^struct nested<ReturnByValue<Derived>, n, PlainObject>$/;"	s	namespace:Eigen::internal
Eigen::internal::nested	src/Core/products/CoeffBasedProduct.h	/^struct nested<CoeffBasedProduct<Lhs,Rhs,EvalBeforeNestingBit|EvalBeforeAssigningBit>, N, PlainObject>$/;"	s	namespace:Eigen::internal
Eigen::internal::nested::type	src/Core/ReturnByValue.h	/^  typedef typename traits<Derived>::ReturnType type;$/;"	t	struct:Eigen::internal::nested	access:public
Eigen::internal::nested::type	src/Core/products/CoeffBasedProduct.h	/^  typedef PlainObject const& type;$/;"	t	struct:Eigen::internal::nested	access:public
Eigen::internal::no_assignment_operator	src/Core/util/XprHelper.h	/^class no_assignment_operator$/;"	c	namespace:Eigen::internal
Eigen::internal::no_assignment_operator::operator =	src/Core/util/XprHelper.h	/^    no_assignment_operator& operator=(const no_assignment_operator&);$/;"	p	class:Eigen::internal::no_assignment_operator	access:private	signature:(const no_assignment_operator&)
Eigen::internal::noncopyable	src/Core/util/Meta.h	/^class noncopyable$/;"	c	namespace:Eigen::internal
Eigen::internal::noncopyable::noncopyable	src/Core/util/Meta.h	/^  noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable	access:protected	signature:()
Eigen::internal::noncopyable::noncopyable	src/Core/util/Meta.h	/^  noncopyable(const noncopyable&);$/;"	p	class:Eigen::internal::noncopyable	access:private	signature:(const noncopyable&)
Eigen::internal::noncopyable::operator =	src/Core/util/Meta.h	/^  const noncopyable& operator=(const noncopyable&);$/;"	p	class:Eigen::internal::noncopyable	access:private	signature:(const noncopyable&)
Eigen::internal::noncopyable::~noncopyable	src/Core/util/Meta.h	/^  ~noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable	access:protected	signature:()
Eigen::internal::norm1_default_impl	src/Core/MathFunctions.h	/^struct norm1_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::norm1_default_impl	src/Core/MathFunctions.h	/^struct norm1_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::norm1_default_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::norm1_default_impl	access:public
Eigen::internal::norm1_default_impl::run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl	access:public	signature:(const Scalar& x)
Eigen::internal::norm1_default_impl::run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl	access:public	signature:(const Scalar& x)
Eigen::internal::norm1_impl	src/Core/MathFunctions.h	/^struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal	inherits:norm1_default_impl
Eigen::internal::norm1_retval	src/Core/MathFunctions.h	/^struct norm1_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::norm1_retval::type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::norm1_retval	access:public
Eigen::internal::nr_etdfs	src/SparseCore/SparseColEtree.h	/^void nr_etdfs (Index n, IndexVector& parent, IndexVector& first_kid, IndexVector& next_kid, IndexVector& post, Index postnum)$/;"	f	namespace:Eigen::internal	signature:(Index n, IndexVector& parent, IndexVector& first_kid, IndexVector& next_kid, IndexVector& post, Index postnum)
Eigen::internal::ordering_helper_at_plus_a	src/OrderingMethods/Ordering.h	/^void ordering_helper_at_plus_a(const MatrixType& mat, MatrixType& symmat)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, MatrixType& symmat)
Eigen::internal::outer_product_selector_run	src/Core/GeneralProduct.h	/^EIGEN_DONT_INLINE void outer_product_selector_run(const ProductType& prod, Dest& dest, const Func& func, const false_type&)$/;"	f	namespace:Eigen::internal	signature:(const ProductType& prod, Dest& dest, const Func& func, const false_type&)
Eigen::internal::outer_product_selector_run	src/Core/GeneralProduct.h	/^EIGEN_DONT_INLINE void outer_product_selector_run(const ProductType& prod, Dest& dest, const Func& func, const true_type&) {$/;"	f	namespace:Eigen::internal	signature:(const ProductType& prod, Dest& dest, const Func& func, const true_type&)
Eigen::internal::outer_stride_at_compile_time	src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time$/;"	s	namespace:Eigen::internal
Eigen::internal::outer_stride_at_compile_time	src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::outer_stride_at_compile_time::ret	src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon160
Eigen::internal::outer_stride_at_compile_time::ret	src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::OuterStrideAtCompileTime };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon159
Eigen::internal::p16uc_COMPLEX_IM	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_IM   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 1), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_COMPLEX_RE	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_RE   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_COMPLEX_REV	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV  = vec_sld(p16uc_REVERSE, p16uc_REVERSE, 8);\/\/{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_COMPLEX_REV2	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV2 = vec_sld(p16uc_FORWARD, p16uc_FORWARD, 8);\/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_DUPLICATE	src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE = {0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7};$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_FORWARD	src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = vec_lvsl(0, (float*)0);$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_PSET_HI	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_HI = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 1));\/\/{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_PSET_LO	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_LO = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 2), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 3));\/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_REVERSE	src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE = {12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3};$/;"	m	namespace:Eigen::internal
Eigen::internal::p2ui_CONJ_XOR	src/Core/arch/NEON/Complex.h	/^static uint32x2_t p2ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET2(0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
Eigen::internal::p4f_COUNTDOWN	src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 3.0, 2.0, 1.0, 0.0 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p4f_ONE	src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ONE = vec_ctf(p4i_ONE, 0);$/;"	m	namespace:Eigen::internal
Eigen::internal::p4f_ZERO_	src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ZERO_ = (Packet4f) vec_sl((Packet4ui)p4i_MINUS1, (Packet4ui)p4i_MINUS1);$/;"	m	namespace:Eigen::internal
Eigen::internal::p4i_COUNTDOWN	src/Core/arch/AltiVec/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 3, 2, 1, 0 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p4ui_CONJ_XOR	src/Core/arch/AltiVec/Complex.h	/^static Packet4ui  p4ui_CONJ_XOR = vec_mergeh((Packet4ui)p4i_ZERO, (Packet4ui)p4f_ZERO_);\/\/{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p4ui_CONJ_XOR	src/Core/arch/NEON/Complex.h	/^static uint32x4_t p4ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET4(0x00000000, 0x80000000, 0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
Eigen::internal::pabs	src/Core/GenericPacketMath.h	/^pabs(const Packet& a) { using std::abs; return abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pabs	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pabs	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pabs	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vabsq_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pabs	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vabsq_s32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pabs	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pabs	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pabs	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::packet_traits	src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/GenericPacketMath.h	/^    AlignedOnScalar = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon270
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
Eigen::internal::packet_traits::AlignedOnScalar	src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon26
Eigen::internal::packet_traits::HasAbs	src/Core/GenericPacketMath.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasAbs	src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasAbs	src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasAbs	src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasAbs	src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::HasAbs2	src/Core/GenericPacketMath.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasAbs2	src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasAbs2	src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasAbs2	src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasAbs2	src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::HasAdd	src/Core/GenericPacketMath.h	/^    HasAdd    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasAdd	src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasAdd	src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasAdd	src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasAdd	src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::HasConj	src/Core/GenericPacketMath.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasCos	src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
Eigen::internal::packet_traits::HasCos	src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Eigen::internal::packet_traits::HasCos	src/Core/arch/SSE/PacketMath.h	/^    HasCos  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Eigen::internal::packet_traits::HasDiv	src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasDiv	src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasDiv	src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Eigen::internal::packet_traits::HasDiv	src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasDiv	src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::HasDiv	src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Eigen::internal::packet_traits::HasDiv	src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
Eigen::internal::packet_traits::HasExp	src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
Eigen::internal::packet_traits::HasExp	src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Eigen::internal::packet_traits::HasExp	src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Eigen::internal::packet_traits::HasExp	src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
Eigen::internal::packet_traits::HasLog	src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
Eigen::internal::packet_traits::HasLog	src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Eigen::internal::packet_traits::HasLog	src/Core/arch/SSE/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Eigen::internal::packet_traits::HasMax	src/Core/GenericPacketMath.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasMax	src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasMax	src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasMax	src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasMax	src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::HasMin	src/Core/GenericPacketMath.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasMin	src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasMin	src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasMin	src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasMin	src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::HasMul	src/Core/GenericPacketMath.h	/^    HasMul    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasMul	src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasMul	src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasMul	src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasMul	src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::HasNegate	src/Core/GenericPacketMath.h	/^    HasNegate = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasNegate	src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasNegate	src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasNegate	src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasNegate	src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::HasSetLinear	src/Core/GenericPacketMath.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasSetLinear	src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasSetLinear	src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasSetLinear	src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasSetLinear	src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::HasSin	src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
Eigen::internal::packet_traits::HasSin	src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Eigen::internal::packet_traits::HasSin	src/Core/arch/SSE/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Eigen::internal::packet_traits::HasSqrt	src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon7
Eigen::internal::packet_traits::HasSqrt	src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Eigen::internal::packet_traits::HasSqrt	src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Eigen::internal::packet_traits::HasSqrt	src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon25
Eigen::internal::packet_traits::HasSub	src/Core/GenericPacketMath.h	/^    HasSub    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
Eigen::internal::packet_traits::HasSub	src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::HasSub	src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::HasSub	src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::HasSub	src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::Vectorizable	src/Core/GenericPacketMath.h	/^    Vectorizable = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon270
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
Eigen::internal::packet_traits::Vectorizable	src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon26
Eigen::internal::packet_traits::size	src/Core/GenericPacketMath.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon270
Eigen::internal::packet_traits::size	src/Core/arch/AltiVec/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Eigen::internal::packet_traits::size	src/Core/arch/AltiVec/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon8
Eigen::internal::packet_traits::size	src/Core/arch/AltiVec/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
Eigen::internal::packet_traits::size	src/Core/arch/NEON/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Eigen::internal::packet_traits::size	src/Core/arch/NEON/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Eigen::internal::packet_traits::size	src/Core/arch/NEON/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon14
Eigen::internal::packet_traits::size	src/Core/arch/SSE/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Eigen::internal::packet_traits::size	src/Core/arch/SSE/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Eigen::internal::packet_traits::size	src/Core/arch/SSE/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
Eigen::internal::packet_traits::size	src/Core/arch/SSE/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon26
Eigen::internal::packet_traits::size	src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Eigen::internal::packet_traits::type	src/Core/GenericPacketMath.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::pacos	src/Core/GenericPacketMath.h	/^Packet pacos(const Packet& a) { using std::acos; return acos(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::padd	src/Core/GenericPacketMath.h	/^padd(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::padd	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_add(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::padd	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::padd	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::padd	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::padd	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vaddq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::padd	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vaddq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::padd	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::padd	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::padd	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::padd	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::padd	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::palign	src/Core/GenericPacketMath.h	/^inline void palign(PacketType& first, const PacketType& second)$/;"	f	namespace:Eigen::internal	signature:(PacketType& first, const PacketType& second)
Eigen::internal::palign_impl	src/Core/GenericPacketMath.h	/^struct palign_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl::run	src/Core/GenericPacketMath.h	/^  static inline void run(PacketType&, const PacketType&) {}$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(PacketType&, const PacketType&)
Eigen::internal::palign_impl::run	src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
Eigen::internal::palign_impl::run	src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4f& first, const Packet4f& second)
Eigen::internal::palign_impl::run	src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4i& first, const Packet4i& second)
Eigen::internal::palign_impl::run	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE static void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
Eigen::internal::palign_impl::run	src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet1cd& , const Packet1cd& )
Eigen::internal::palign_impl::run	src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
Eigen::internal::palign_impl::run	src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2d& first, const Packet2d& second)
Eigen::internal::palign_impl::run	src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4f& first, const Packet4f& second)
Eigen::internal::palign_impl::run	src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4i& first, const Packet4i& second)
Eigen::internal::pand	src/Core/GenericPacketMath.h	/^pand(const Packet& a, const Packet& b) { return a & b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pand	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pand	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pand	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pand	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pand	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pand	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vandq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pand	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pand	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pand	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pand	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pand	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pandnot	src/Core/GenericPacketMath.h	/^pandnot(const Packet& a, const Packet& b) { return a & (!b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pandnot	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v, vec_nor(b.v,b.v))); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pandnot	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pandnot	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pandnot	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pandnot	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pandnot	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vbicq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pandnot	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pandnot	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pandnot	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pandnot	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pandnot	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::panel_dfs_traits	src/SparseLU/SparseLU_panel_dfs.h	/^struct panel_dfs_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::panel_dfs_traits::ExpandMem	src/SparseLU/SparseLU_panel_dfs.h	/^  enum { ExpandMem = false };$/;"	e	enum:Eigen::internal::panel_dfs_traits::__anon465
Eigen::internal::panel_dfs_traits::Index	src/SparseLU/SparseLU_panel_dfs.h	/^  typedef typename IndexVector::Scalar Index;$/;"	t	struct:Eigen::internal::panel_dfs_traits	access:public
Eigen::internal::panel_dfs_traits::m_jcol	src/SparseLU/SparseLU_panel_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::panel_dfs_traits	access:public
Eigen::internal::panel_dfs_traits::m_marker	src/SparseLU/SparseLU_panel_dfs.h	/^  Index* m_marker;$/;"	m	struct:Eigen::internal::panel_dfs_traits	access:public
Eigen::internal::panel_dfs_traits::mem_expand	src/SparseLU/SparseLU_panel_dfs.h	/^  void mem_expand(IndexVector& \/*glu.lsub*\/, Index \/*nextl*\/, Index \/*chmark*\/) {}$/;"	f	struct:Eigen::internal::panel_dfs_traits	access:public	signature:(IndexVector& , Index , Index )
Eigen::internal::panel_dfs_traits::panel_dfs_traits	src/SparseLU/SparseLU_panel_dfs.h	/^  panel_dfs_traits(Index jcol, Index* marker)$/;"	f	struct:Eigen::internal::panel_dfs_traits	access:public	signature:(Index jcol, Index* marker)
Eigen::internal::panel_dfs_traits::update_segrep	src/SparseLU/SparseLU_panel_dfs.h	/^  bool update_segrep(Index krep, Index jj)$/;"	f	struct:Eigen::internal::panel_dfs_traits	access:public	signature:(Index krep, Index jj)
Eigen::internal::parallelize_gemm	src/Core/products/Parallelizer.h	/^void parallelize_gemm(const Functor& func, Index rows, Index cols, bool transpose)$/;"	f	namespace:Eigen::internal	signature:(const Functor& func, Index rows, Index cols, bool transpose)
Eigen::internal::pardiso_run_selector	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_run_selector	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector<long long int>$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_run_selector::Index	src/PardisoSupport/PardisoSupport.h	/^    typedef long long int Index;$/;"	t	struct:Eigen::internal::pardiso_run_selector	access:public
Eigen::internal::pardiso_run_selector::run	src/PardisoSupport/PardisoSupport.h	/^    static Index run( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a,$/;"	f	struct:Eigen::internal::pardiso_run_selector	access:public	signature:( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a, Index *ia, Index *ja, Index *perm, Index nrhs, Index *iparm, Index msglvl, void *b, void *x)
Eigen::internal::pardiso_traits	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLDLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_traits	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_traits	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_traits::Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;    $/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::pardiso_traits::Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::pardiso_traits::MatrixType	src/PardisoSupport/PardisoSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::pardiso_traits::RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::pardiso_traits::Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::partial_lu_impl	src/LU/PartialPivLU.h	/^struct partial_lu_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::partial_lu_impl::BlockType	src/LU/PartialPivLU.h	/^  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl::Index	src/LU/PartialPivLU.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl::MapLU	src/LU/PartialPivLU.h	/^  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl::MatrixType	src/LU/PartialPivLU.h	/^  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl::RealScalar	src/LU/PartialPivLU.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl::blocked_lu	src/LU/PartialPivLU.h	/^  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)$/;"	f	struct:Eigen::internal::partial_lu_impl	access:public	signature:(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)
Eigen::internal::partial_lu_impl::unblocked_lu	src/LU/PartialPivLU.h	/^  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)$/;"	f	struct:Eigen::internal::partial_lu_impl	access:public	signature:(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)
Eigen::internal::partial_lu_inplace	src/LU/PartialPivLU.h	/^void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)
Eigen::internal::pasin	src/Core/GenericPacketMath.h	/^Packet pasin(const Packet& a) { using std::asin; return asin(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pastix_traits	src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLDLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pastix_traits	src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pastix_traits	src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pastix_traits::Index	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Eigen::internal::pastix_traits::MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Eigen::internal::pastix_traits::RealScalar	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Eigen::internal::pastix_traits::Scalar	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Eigen::internal::pconj	src/Core/GenericPacketMath.h	/^pconj(const Packet& a) { return numext::conj(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pconj	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf((Packet4f)vec_xor((Packet4ui)a.v, p4ui_CONJ_XOR)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pconj	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pconj	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pconj	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pconj	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pconj	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pconj	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::pconj	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pconj	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pconj	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pconj	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pcos	src/Core/GenericPacketMath.h	/^Packet pcos(const Packet& a) { using std::cos; return cos(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pcos	src/Core/arch/SSE/MathFunctions.h	/^Packet4f pcos<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::pcplxflip	src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet pcplxflip(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pcplxflip	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& x)
Eigen::internal::pcplxflip	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pcplxflip	src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& x)
Eigen::internal::pcplxflip	src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/*<Packet2cf>*\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& x)
Eigen::internal::pdiv	src/Core/GenericPacketMath.h	/^pdiv(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pdiv	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pdiv	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pdiv	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
Eigen::internal::pdiv	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pdiv	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pdiv	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
Eigen::internal::pdiv	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pdiv	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pdiv	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pdiv	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pdiv	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
Eigen::internal::perfvalues	src/SparseLU/SparseLU_Structs.h	/^struct perfvalues {$/;"	s	namespace:Eigen::internal
Eigen::internal::perfvalues::colblk	src/SparseLU/SparseLU_Structs.h	/^  Index colblk; \/\/ The minimum column dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues	access:public
Eigen::internal::perfvalues::fillfactor	src/SparseLU/SparseLU_Structs.h	/^  Index fillfactor; \/\/ The estimated fills factors for L and U, compared with A$/;"	m	struct:Eigen::internal::perfvalues	access:public
Eigen::internal::perfvalues::maxsuper	src/SparseLU/SparseLU_Structs.h	/^  Index maxsuper; \/\/ The maximum size for a supernode in complete LU$/;"	m	struct:Eigen::internal::perfvalues	access:public
Eigen::internal::perfvalues::panel_size	src/SparseLU/SparseLU_Structs.h	/^  Index panel_size; \/\/ a panel consists of at most <panel_size> consecutive columns$/;"	m	struct:Eigen::internal::perfvalues	access:public
Eigen::internal::perfvalues::relax	src/SparseLU/SparseLU_Structs.h	/^  Index relax; \/\/ To control degree of relaxing supernodes. If the number of nodes (columns) $/;"	m	struct:Eigen::internal::perfvalues	access:public
Eigen::internal::perfvalues::rowblk	src/SparseLU/SparseLU_Structs.h	/^  Index rowblk; \/\/ The minimum row dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues	access:public
Eigen::internal::permut_matrix_product_retval	src/Core/PermutationMatrix.h	/^struct permut_matrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::permut_matrix_product_retval::Index	src/Core/PermutationMatrix.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::permut_matrix_product_retval	access:public
Eigen::internal::permut_matrix_product_retval::MatrixTypeNestedCleaned	src/Core/PermutationMatrix.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_matrix_product_retval	access:public
Eigen::internal::permut_matrix_product_retval::cols	src/Core/PermutationMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:() const
Eigen::internal::permut_matrix_product_retval::evalTo	src/Core/PermutationMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:(Dest& dst) const
Eigen::internal::permut_matrix_product_retval::m_matrix	src/Core/PermutationMatrix.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval	access:protected
Eigen::internal::permut_matrix_product_retval::m_permutation	src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval	access:protected
Eigen::internal::permut_matrix_product_retval::permut_matrix_product_retval	src/Core/PermutationMatrix.h	/^    permut_matrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:(const PermutationType& perm, const MatrixType& matrix)
Eigen::internal::permut_matrix_product_retval::rows	src/Core/PermutationMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:() const
Eigen::internal::permut_sparsematrix_product_retval	src/SparseCore/SparsePermutation.h	/^struct permut_sparsematrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::permut_sparsematrix_product_retval::Index	src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Eigen::internal::permut_sparsematrix_product_retval::MatrixTypeNestedCleaned	src/SparseCore/SparsePermutation.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Eigen::internal::permut_sparsematrix_product_retval::MoveOuter	src/SparseCore/SparsePermutation.h	/^      MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon450
Eigen::internal::permut_sparsematrix_product_retval::Scalar	src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Eigen::internal::permut_sparsematrix_product_retval::SrcStorageOrder	src/SparseCore/SparsePermutation.h	/^      SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon450
Eigen::internal::permut_sparsematrix_product_retval::cols	src/SparseCore/SparsePermutation.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:() const
Eigen::internal::permut_sparsematrix_product_retval::evalTo	src/SparseCore/SparsePermutation.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:(Dest& dst) const
Eigen::internal::permut_sparsematrix_product_retval::m_matrix	src/SparseCore/SparsePermutation.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval	access:protected
Eigen::internal::permut_sparsematrix_product_retval::m_permutation	src/SparseCore/SparsePermutation.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval	access:protected
Eigen::internal::permut_sparsematrix_product_retval::permut_sparsematrix_product_retval	src/SparseCore/SparsePermutation.h	/^    permut_sparsematrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:(const PermutationType& perm, const MatrixType& matrix)
Eigen::internal::permut_sparsematrix_product_retval::rows	src/SparseCore/SparsePermutation.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:() const
Eigen::internal::permute_symm_to_fullsymm	src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0);$/;"	p	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0)
Eigen::internal::permute_symm_to_fullsymm	src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)
Eigen::internal::permute_symm_to_symm	src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0);$/;"	p	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0)
Eigen::internal::permute_symm_to_symm	src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)
Eigen::internal::pexp	src/Core/GenericPacketMath.h	/^Packet pexp(const Packet& a) { using std::exp; return exp(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pexp	src/Core/arch/SSE/MathFunctions.h	/^Packet2d pexp<Packet2d>(const Packet2d& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& _x)
Eigen::internal::pexp	src/Core/arch/SSE/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::pfirst	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type pfirst(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pfirst	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pfirst	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pfirst	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pfirst	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vst1q_f32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vst1q_s32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pfirst	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::pfirst	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::plain_array	src/Core/DenseStorage.h	/^struct plain_array$/;"	s	namespace:Eigen::internal
Eigen::internal::plain_array	src/Core/DenseStorage.h	/^struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>$/;"	s	namespace:Eigen::internal
Eigen::internal::plain_array	src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 16>$/;"	s	namespace:Eigen::internal
Eigen::internal::plain_array::array	src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[1];$/;"	m	struct:Eigen::internal::plain_array	access:public
Eigen::internal::plain_array::array	src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[Size];$/;"	m	struct:Eigen::internal::plain_array	access:public
Eigen::internal::plain_array::array	src/Core/DenseStorage.h	/^  T array[Size];$/;"	m	struct:Eigen::internal::plain_array	access:public
Eigen::internal::plain_array::plain_array	src/Core/DenseStorage.h	/^  plain_array() $/;"	f	struct:Eigen::internal::plain_array	access:public	signature:()
Eigen::internal::plain_array::plain_array	src/Core/DenseStorage.h	/^  plain_array() {}$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:()
Eigen::internal::plain_array::plain_array	src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) $/;"	f	struct:Eigen::internal::plain_array	access:public	signature:(constructor_without_unaligned_array_assert)
Eigen::internal::plain_array::plain_array	src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) {}$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:(constructor_without_unaligned_array_assert)
Eigen::internal::plain_matrix_type	src/SparseCore/SparseUtil.h	/^template<typename T> struct plain_matrix_type<T,Sparse>$/;"	s	namespace:Eigen::internal
Eigen::internal::plain_matrix_type::_Index	src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Index _Index;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
Eigen::internal::plain_matrix_type::_Options	src/SparseCore/SparseUtil.h	/^  enum { _Options = ((traits<T>::Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::plain_matrix_type::__anon455
Eigen::internal::plain_matrix_type::_Scalar	src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
Eigen::internal::plain_matrix_type::type	src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> type;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
Eigen::internal::pload	src/Core/GenericPacketMath.h	/^pload(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
Eigen::internal::pload	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::pload	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::pload	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::pload	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::pload	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::pload	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*   from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::pload	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
Eigen::internal::pload	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::pload	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double* from)
Eigen::internal::pload	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::pload	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploaddup	src/Core/GenericPacketMath.h	/^ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
Eigen::internal::ploaddup	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*     from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploaddup	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploaddup	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploaddup	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploaddup	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploaddup	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploaddup	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
Eigen::internal::ploaddup	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploaddup	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)$/;"	f	namespace:Eigen::internal	signature:(const double* from)
Eigen::internal::ploaddup	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploaddup	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploadt	src/Core/GenericPacketMath.h	/^inline Packet ploadt(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
Eigen::internal::ploadu	src/Core/GenericPacketMath.h	/^ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
Eigen::internal::ploadu	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploadu	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploadu	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploadu	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploadu	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploadu	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)   { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploadu	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
Eigen::internal::ploadu	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploadu	src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double* from)
Eigen::internal::ploadu	src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploadu	src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploadu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal	signature:(const double* from)
Eigen::internal::ploadu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploadu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::plog	src/Core/GenericPacketMath.h	/^Packet plog(const Packet& a) { using std::log; return log(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::plog	src/Core/arch/SSE/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::plset	src/Core/GenericPacketMath.h	/^plset(const Scalar& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Scalar& a)
Eigen::internal::plset	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return vec_add(pset1<Packet4f>(a), p4f_COUNTDOWN); }$/;"	f	namespace:Eigen::internal	signature:(const float& a)
Eigen::internal::plset	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)     { return vec_add(pset1<Packet4i>(a), p4i_COUNTDOWN); }$/;"	f	namespace:Eigen::internal	signature:(const int& a)
Eigen::internal::plset	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a)$/;"	f	namespace:Eigen::internal	signature:(const float& a)
Eigen::internal::plset	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)$/;"	f	namespace:Eigen::internal	signature:(const int& a)
Eigen::internal::plset	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<double>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const double& a)
Eigen::internal::plset	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const float& a)
Eigen::internal::plset	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const int& a)
Eigen::internal::pmadd	src/Core/GenericPacketMath.h	/^pmadd(const Packet&  a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b, const Packet& c)
Eigen::internal::pmadd	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b, const Packet4f& c)
Eigen::internal::pmadd	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
Eigen::internal::pmadd	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vmlaq_f32(c,a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b, const Packet4f& c)
Eigen::internal::pmadd	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return vmlaq_s32(c,a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
Eigen::internal::pmadd	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
Eigen::internal::pmax	src/Core/GenericPacketMath.h	/^pmax(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pmax	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmax	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmax	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmaxq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmax	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmaxq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmax	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pmax	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmax	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmin	src/Core/GenericPacketMath.h	/^pmin(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pmin	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmin	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmin	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vminq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmin	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vminq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmin	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pmin	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmin	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmul	src/Core/GenericPacketMath.h	/^pmul(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pmul	src/Core/GenericPacketMath.h	/^template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>& a, const std::complex<double>& b)
Eigen::internal::pmul	src/Core/GenericPacketMath.h	/^template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& a, const std::complex<float>& b)
Eigen::internal::pmul	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pmul	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_madd(a,b,p4f_ZERO); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmul	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pmul	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmulq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmul	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmulq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmul	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pmul	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pmul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pmul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pnegate	src/Core/GenericPacketMath.h	/^pnegate(const Packet& a) { return -a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pnegate	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pnegate	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return psub<Packet4f>(p4f_ZERO, a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pnegate	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return psub<Packet4i>(p4i_ZERO, a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pnegate	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate<Packet4f>(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pnegate	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return vnegq_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pnegate	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return vnegq_s32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pnegate	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::pnegate	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pnegate	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pnegate	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pnegate	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::por	src/Core/GenericPacketMath.h	/^por(const Packet& a, const Packet& b) { return a | b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::por	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_or(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::por	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::por	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::por	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::por	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::por	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vorrq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::por	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::por	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::por	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::por	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::por	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pow_default_impl	src/Core/MathFunctions.h	/^struct pow_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::pow_default_impl	src/Core/MathFunctions.h	/^struct pow_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::pow_default_impl::retval	src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::pow_default_impl	access:public
Eigen::internal::pow_default_impl::run	src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar x, Scalar y)$/;"	f	struct:Eigen::internal::pow_default_impl	access:public	signature:(Scalar x, Scalar y)
Eigen::internal::pow_default_impl::run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::pow_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::pow_impl	src/Core/MathFunctions.h	/^struct pow_impl : pow_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:pow_default_impl
Eigen::internal::pow_retval	src/Core/MathFunctions.h	/^struct pow_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::pow_retval::type	src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::pow_retval	access:public
Eigen::internal::predux	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::predux	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::predux	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return pfirst(_mm_hadd_pd(a, a)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_max	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_max(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::predux_max	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_max	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_max	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_max	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_max	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux_max	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_max	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_min	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_min(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::predux_min	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_min	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_min	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_min	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_min	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux_min	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_min	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_mul	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_mul(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::predux_mul	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux_mul	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_mul	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_mul	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux_mul	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_mul	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_mul	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::predux_mul	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux_mul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux_mul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_mul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::preduxp	src/Core/GenericPacketMath.h	/^preduxp(const Packet* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet* vecs)
Eigen::internal::preduxp	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
Eigen::internal::preduxp	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
Eigen::internal::preduxp	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
Eigen::internal::preduxp	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
Eigen::internal::preduxp	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
Eigen::internal::preduxp	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
Eigen::internal::preduxp	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd* vecs)
Eigen::internal::preduxp	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
Eigen::internal::preduxp	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d* vecs)
Eigen::internal::preduxp	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
Eigen::internal::preduxp	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
Eigen::internal::prefetch	src/Core/GenericPacketMath.h	/^template<typename Scalar> inline void prefetch(const Scalar* addr)$/;"	f	namespace:Eigen::internal	signature:(const Scalar* addr)
Eigen::internal::prefetch	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { vec_dstt((float *)addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
Eigen::internal::prefetch	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
Eigen::internal::prefetch	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
Eigen::internal::prefetch	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { EIGEN_ARM_PREFETCH((float *)addr); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
Eigen::internal::prefetch	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
Eigen::internal::prefetch	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
Eigen::internal::prefetch	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double> * addr)
Eigen::internal::prefetch	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
Eigen::internal::prefetch	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const double* addr)
Eigen::internal::prefetch	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
Eigen::internal::prefetch	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
Eigen::internal::preverse	src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet preverse(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::preverse	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::preverse	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) { return (Packet4f)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::preverse	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) { return (Packet4i)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::preverse	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::preverse	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) {$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::preverse	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) {$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::preverse	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::preverse	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(_mm_castps_pd(a.v)))); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::preverse	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::preverse	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::preverse	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::print_matrix	src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)$/;"	f	namespace:Eigen::internal	signature:(std::ostream & s, const Derived& _m, const IOFormat& fmt)
Eigen::internal::print_matrix	src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt);$/;"	p	namespace:Eigen::internal	signature:(std::ostream & s, const Derived& _m, const IOFormat& fmt)
Eigen::internal::product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, 0, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, 1, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, 0, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl::Index	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_impl	access:public
Eigen::internal::product_coeff_impl::Packet	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::PacketScalar Packet;$/;"	t	struct:Eigen::internal::product_coeff_impl	access:public
Eigen::internal::product_coeff_impl::PacketSize	src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_impl::__anon33
Eigen::internal::product_coeff_impl::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& \/*lhs*\/, const Rhs& \/*rhs*\/, RetScalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index , Index , const Lhs& , const Rhs& , RetScalar &res)
Eigen::internal::product_coeff_impl::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)
Eigen::internal::product_coeff_impl::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)
Eigen::internal::product_coeff_impl::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_dyn_selector	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_dyn_selector	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,1>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_dyn_selector	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,RhsCols>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_dyn_selector	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,LhsRows,1>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_dyn_selector::Index	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public
Eigen::internal::product_coeff_vectorized_dyn_selector::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index , Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_dyn_selector::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index , Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_dyn_selector::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index row, Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_dyn_selector::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_unroller	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_unroller	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller<0, Lhs, Rhs, Packet>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_unroller::Index	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_unroller	access:public
Eigen::internal::product_coeff_vectorized_unroller::PacketSize	src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_vectorized_unroller::__anon32
Eigen::internal::product_coeff_vectorized_unroller::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_unroller	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)
Eigen::internal::product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl::Index	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_packet_impl	access:public
Eigen::internal::product_packet_impl::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& \/*lhs*\/, const Rhs& \/*rhs*\/, Packet &res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index , Index , const Lhs& , const Rhs& , Packet &res)
Eigen::internal::product_packet_impl::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)
Eigen::internal::product_packet_impl::run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)
Eigen::internal::product_selfadjoint_matrix	src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_selfadjoint_matrix	src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_selfadjoint_matrix	src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_selfadjoint_matrix::run	src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	p	struct:Eigen::internal::product_selfadjoint_matrix	access:public	signature:( Index rows, Index cols, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha)
Eigen::internal::product_selfadjoint_matrix::run	src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix	access:public	signature:( Index rows, Index cols, const Scalar* lhs, Index lhsStride, const Scalar* rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha)
Eigen::internal::product_selfadjoint_matrix::run	src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix	signature:( Index rows, Index cols, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha)
Eigen::internal::product_selfadjoint_matrix::run	src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix	signature:( Index rows, Index cols, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha)
Eigen::internal::product_size_category	src/Core/GeneralProduct.h	/^template<int Size, int MaxSize> struct product_size_category$/;"	s	namespace:Eigen::internal
Eigen::internal::product_size_category::is_large	src/Core/GeneralProduct.h	/^  enum { is_large = MaxSize == Dynamic ||$/;"	e	enum:Eigen::internal::product_size_category::__anon242
Eigen::internal::product_size_category::value	src/Core/GeneralProduct.h	/^         value = is_large  ? Large$/;"	e	enum:Eigen::internal::product_size_category::__anon242
Eigen::internal::product_triangular_matrix_matrix	src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,$/;"	s	namespace:Eigen::internal
Eigen::internal::product_triangular_matrix_matrix	src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,$/;"	s	namespace:Eigen::internal
Eigen::internal::product_triangular_matrix_matrix	src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,$/;"	s	namespace:Eigen::internal
Eigen::internal::product_triangular_matrix_matrix::IsLower	src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon52
Eigen::internal::product_triangular_matrix_matrix::IsLower	src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon53
Eigen::internal::product_triangular_matrix_matrix::SetDiag	src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon52
Eigen::internal::product_triangular_matrix_matrix::SetDiag	src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon53
Eigen::internal::product_triangular_matrix_matrix::SmallPanelWidth	src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon52
Eigen::internal::product_triangular_matrix_matrix::SmallPanelWidth	src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon53
Eigen::internal::product_triangular_matrix_matrix::Traits	src/Core/products/TriangularMatrixMatrix.h	/^  typedef gebp_traits<Scalar,Scalar> Traits;$/;"	t	struct:Eigen::internal::product_triangular_matrix_matrix	access:public
Eigen::internal::product_triangular_matrix_matrix::run	src/Core/products/TriangularMatrixMatrix.h	/^                                                        RhsStorageOrder,ConjugateRhs,ColMajor,Version>::run($/;"	f	class:Eigen::internal::product_triangular_matrix_matrix	signature:( Index _rows, Index _cols, Index _depth, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
Eigen::internal::product_triangular_matrix_matrix::run	src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	p	struct:Eigen::internal::product_triangular_matrix_matrix	access:public	signature:( Index _rows, Index _cols, Index _depth, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
Eigen::internal::product_triangular_matrix_matrix::run	src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix	access:public	signature:( Index rows, Index cols, Index depth, const Scalar* lhs, Index lhsStride, const Scalar* rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
Eigen::internal::product_triangular_matrix_matrix_trmm	src/Core/products/TriangularMatrixMatrix_MKL.h	/^struct product_triangular_matrix_matrix_trmm :$/;"	s	namespace:Eigen::internal	inherits:product_triangular_matrix_matrix
Eigen::internal::product_type	src/Core/GeneralProduct.h	/^template<typename Lhs, typename Rhs> struct product_type$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type::Cols	src/Core/GeneralProduct.h	/^    Cols  = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
Eigen::internal::product_type::Depth	src/Core/GeneralProduct.h	/^    Depth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
Eigen::internal::product_type::LargeThreshold	src/Core/GeneralProduct.h	/^    LargeThreshold = EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD$/;"	e	enum:Eigen::internal::product_type::__anon243
Eigen::internal::product_type::MaxCols	src/Core/GeneralProduct.h	/^    MaxCols  = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
Eigen::internal::product_type::MaxDepth	src/Core/GeneralProduct.h	/^    MaxDepth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
Eigen::internal::product_type::MaxRows	src/Core/GeneralProduct.h	/^    MaxRows  = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
Eigen::internal::product_type::Rows	src/Core/GeneralProduct.h	/^    Rows  = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
Eigen::internal::product_type::_Lhs	src/Core/GeneralProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::product_type	access:public
Eigen::internal::product_type::_Rhs	src/Core/GeneralProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::product_type	access:public
Eigen::internal::product_type::cols_select	src/Core/GeneralProduct.h	/^    cols_select = product_size_category<Cols,MaxCols>::value,$/;"	e	enum:Eigen::internal::product_type::__anon244
Eigen::internal::product_type::debug	src/Core/GeneralProduct.h	/^  static void debug()$/;"	f	struct:Eigen::internal::product_type	access:public	signature:()
Eigen::internal::product_type::depth_select	src/Core/GeneralProduct.h	/^    depth_select = product_size_category<Depth,MaxDepth>::value$/;"	e	enum:Eigen::internal::product_type::__anon244
Eigen::internal::product_type::rows_select	src/Core/GeneralProduct.h	/^    rows_select = product_size_category<Rows,MaxRows>::value,$/;"	e	enum:Eigen::internal::product_type::__anon244
Eigen::internal::product_type::selector	src/Core/GeneralProduct.h	/^  typedef product_type_selector<rows_select, cols_select, depth_select> selector;$/;"	t	struct:Eigen::internal::product_type	access:private
Eigen::internal::product_type::value	src/Core/GeneralProduct.h	/^    value = selector::ret$/;"	e	enum:Eigen::internal::product_type::__anon245
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon248
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon256
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon255
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon257
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon250
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon254
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon259
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon258
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon264
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon267
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon262
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon265
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon253
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon252
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon260
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon249
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon263
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon266
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon261
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon251
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon247
Eigen::internal::product_type_selector::ret	src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon246
Eigen::internal::projective_transform_inverse	src/Geometry/Transform.h	/^struct projective_transform_inverse$/;"	s	namespace:Eigen::internal
Eigen::internal::projective_transform_inverse	src/Geometry/Transform.h	/^struct projective_transform_inverse<TransformType, Projective>$/;"	s	namespace:Eigen::internal
Eigen::internal::projective_transform_inverse::run	src/Geometry/Transform.h	/^  static inline void run(const TransformType& m, TransformType& res)$/;"	f	struct:Eigen::internal::projective_transform_inverse	access:public	signature:(const TransformType& m, TransformType& res)
Eigen::internal::projective_transform_inverse::run	src/Geometry/Transform.h	/^  static inline void run(const TransformType&, TransformType&)$/;"	f	struct:Eigen::internal::projective_transform_inverse	access:public	signature:(const TransformType&, TransformType&)
Eigen::internal::promote_index_type	src/Core/util/XprHelper.h	/^struct promote_index_type$/;"	s	namespace:Eigen::internal
Eigen::internal::promote_storage_type	src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Dense,Sparse>$/;"	s	namespace:Eigen::internal
Eigen::internal::promote_storage_type	src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Sparse,Dense>$/;"	s	namespace:Eigen::internal
Eigen::internal::promote_storage_type::ret	src/SparseCore/SparseCwiseBinaryOp.h	/^{ typedef Sparse ret; };$/;"	t	struct:Eigen::internal::promote_storage_type	access:public
Eigen::internal::pset1	src/Core/GenericPacketMath.h	/^pset1(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type& a)
Eigen::internal::pset1	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
Eigen::internal::pset1	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) {$/;"	f	namespace:Eigen::internal	signature:(const float& from)
Eigen::internal::pset1	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   {$/;"	f	namespace:Eigen::internal	signature:(const int& from)
Eigen::internal::pset1	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
Eigen::internal::pset1	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return vdupq_n_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
Eigen::internal::pset1	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   { return vdupq_n_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
Eigen::internal::pset1	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>& from)
Eigen::internal::pset1	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
Eigen::internal::pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double& from)
Eigen::internal::pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }$/;"	f	namespace:Eigen::internal	signature:(const double& from)
Eigen::internal::pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set1_ps(from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
Eigen::internal::pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
Eigen::internal::pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
Eigen::internal::pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
Eigen::internal::psin	src/Core/GenericPacketMath.h	/^Packet psin(const Packet& a) { using std::sin; return sin(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::psin	src/Core/arch/SSE/MathFunctions.h	/^Packet4f psin<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::psqrt	src/Core/GenericPacketMath.h	/^Packet psqrt(const Packet& a) { using std::sqrt; return sqrt(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::psqrt	src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::psqrt	src/Core/arch/SSE/MathFunctions.h	/^template<> EIGEN_STRONG_INLINE Packet2d psqrt<Packet2d>(const Packet2d& x) { return _mm_sqrt_pd(x); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& x)
Eigen::internal::psqrt	src/Core/arch/SSE/MathFunctions.h	/^template<> EIGEN_STRONG_INLINE Packet4f psqrt<Packet4f>(const Packet4f& x) { return _mm_sqrt_ps(x); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& x)
Eigen::internal::pstore	src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstore(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
Eigen::internal::pstore	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstore	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstore	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstore	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstore	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstore	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstore	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<double> * to, const Packet1cd& from)
Eigen::internal::pstore	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstore	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }$/;"	f	namespace:Eigen::internal	signature:(double* to, const Packet2d& from)
Eigen::internal::pstore	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstore	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<Packet4i*>(to), from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstore1	src/Core/GenericPacketMath.h	/^inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)$/;"	f	namespace:Eigen::internal	signature:(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)
Eigen::internal::pstore1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal	signature:(double* to, const double& a)
Eigen::internal::pstore1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal	signature:(float* to, const float& a)
Eigen::internal::pstoret	src/Core/GenericPacketMath.h	/^inline void pstoret(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
Eigen::internal::pstoreu	src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstoreu(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
Eigen::internal::pstoreu	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstoreu	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from)$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstoreu	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from)$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstoreu	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstoreu	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstoreu	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstoreu	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<double> * to, const Packet1cd& from)
Eigen::internal::pstoreu	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstoreu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) {$/;"	f	namespace:Eigen::internal	signature:(double* to, const Packet2d& from)
Eigen::internal::pstoreu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castps_pd(from)); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstoreu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castsi128_pd(from)); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::psub	src/Core/GenericPacketMath.h	/^psub(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::psub	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_sub(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::psub	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::psub	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::psub	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::psub	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vsubq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::psub	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vsubq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::psub	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::psub	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::psub	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::psub	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::psub	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::ptan	src/Core/GenericPacketMath.h	/^Packet ptan(const Packet& a) { using std::tan; return tan(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::punpackp	src/Core/arch/SSE/PacketMath.h	/^EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(Packet4f* vecs)
Eigen::internal::pxor	src/Core/GenericPacketMath.h	/^pxor(const Packet& a, const Packet& b) { return a ^ b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pxor	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_xor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pxor	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pxor	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pxor	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pxor	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pxor	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return veorq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pxor	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pxor	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pxor	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pxor	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pxor	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^> struct qr_preconditioner_impl {};$/;"	s	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, QRPreconditioner, Case, false>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl::ColsAtCompileTime	src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
Eigen::internal::qr_preconditioner_impl::ColsAtCompileTime	src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
Eigen::internal::qr_preconditioner_impl::ColsAtCompileTime	src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
Eigen::internal::qr_preconditioner_impl::Index	src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Eigen::internal::qr_preconditioner_impl::MaxColsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
Eigen::internal::qr_preconditioner_impl::MaxColsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
Eigen::internal::qr_preconditioner_impl::MaxColsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
Eigen::internal::qr_preconditioner_impl::MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
Eigen::internal::qr_preconditioner_impl::MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
Eigen::internal::qr_preconditioner_impl::MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
Eigen::internal::qr_preconditioner_impl::MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
Eigen::internal::qr_preconditioner_impl::Options	src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
Eigen::internal::qr_preconditioner_impl::Options	src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
Eigen::internal::qr_preconditioner_impl::Options	src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
Eigen::internal::qr_preconditioner_impl::QRType	src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::QRType	src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::QRType	src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::QRType	src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::QRType	src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::QRType	src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::RowsAtCompileTime	src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
Eigen::internal::qr_preconditioner_impl::RowsAtCompileTime	src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
Eigen::internal::qr_preconditioner_impl::RowsAtCompileTime	src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
Eigen::internal::qr_preconditioner_impl::RowsAtCompileTime	src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
Eigen::internal::qr_preconditioner_impl::Scalar	src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Eigen::internal::qr_preconditioner_impl::TransposeTypeWithSameStorageOrder	src/SVD/JacobiSVD.h	/^          TransposeTypeWithSameStorageOrder;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Eigen::internal::qr_preconditioner_impl::WorkspaceType	src/SVD/JacobiSVD.h	/^  typedef Matrix<Scalar, 1, RowsAtCompileTime, RowMajor, 1, MaxRowsAtCompileTime> WorkspaceType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Eigen::internal::qr_preconditioner_impl::allocate	src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)
Eigen::internal::qr_preconditioner_impl::allocate	src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)
Eigen::internal::qr_preconditioner_impl::allocate	src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)
Eigen::internal::qr_preconditioner_impl::allocate	src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, QRPreconditioner>&) {}$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, QRPreconditioner>&)
Eigen::internal::qr_preconditioner_impl::m_adjoint	src/SVD/JacobiSVD.h	/^  TransposeTypeWithSameStorageOrder m_adjoint;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_qr	src/SVD/JacobiSVD.h	/^  QRType m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_workspace	src/SVD/JacobiSVD.h	/^  WorkspaceType m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_workspace	src/SVD/JacobiSVD.h	/^  typename internal::plain_col_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_workspace	src/SVD/JacobiSVD.h	/^  typename internal::plain_row_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::run	src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
Eigen::internal::qr_preconditioner_impl::run	src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
Eigen::internal::qr_preconditioner_impl::run	src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)
Eigen::internal::qr_preconditioner_impl::run	src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)
Eigen::internal::qr_preconditioner_should_do_anything	src/SVD/JacobiSVD.h	/^struct qr_preconditioner_should_do_anything$/;"	s	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_should_do_anything::a	src/SVD/JacobiSVD.h	/^  enum { a = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon417
Eigen::internal::qr_preconditioner_should_do_anything::b	src/SVD/JacobiSVD.h	/^         b = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon417
Eigen::internal::qr_preconditioner_should_do_anything::ret	src/SVD/JacobiSVD.h	/^         ret = !( (QRPreconditioner == NoQRPreconditioner) ||$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon417
Eigen::internal::quat_product	src/Geometry/Quaternion.h	/^template<int Arch, class Derived1, class Derived2, typename Scalar, int _Options> struct quat_product$/;"	s	namespace:Eigen::internal
Eigen::internal::quat_product	src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, double, Aligned>$/;"	s	namespace:Eigen::internal
Eigen::internal::quat_product	src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, float, Aligned>$/;"	s	namespace:Eigen::internal
Eigen::internal::quat_product::run	src/Geometry/Quaternion.h	/^  static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b){$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b)
Eigen::internal::quat_product::run	src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)
Eigen::internal::quat_product::run	src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)
Eigen::internal::quaternionbase_assign_impl	src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,3,3>$/;"	s	namespace:Eigen::internal
Eigen::internal::quaternionbase_assign_impl	src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,4,1>$/;"	s	namespace:Eigen::internal
Eigen::internal::quaternionbase_assign_impl::Index	src/Geometry/Quaternion.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl	access:public
Eigen::internal::quaternionbase_assign_impl::Scalar	src/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl	access:public
Eigen::internal::quaternionbase_assign_impl::run	src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& mat)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl	access:public	signature:(QuaternionBase<Derived>& q, const Other& mat)
Eigen::internal::quaternionbase_assign_impl::run	src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& vec)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl	access:public	signature:(QuaternionBase<Derived>& q, const Other& vec)
Eigen::internal::queryCacheSizes	src/Core/util/Memory.h	/^inline void queryCacheSizes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
Eigen::internal::queryCacheSizes_amd	src/Core/util/Memory.h	/^inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
Eigen::internal::queryCacheSizes_intel	src/Core/util/Memory.h	/^inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3, int max_std_funcs)
Eigen::internal::queryCacheSizes_intel_codes	src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
Eigen::internal::queryCacheSizes_intel_direct	src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
Eigen::internal::queryL1CacheSize	src/Core/util/Memory.h	/^inline int queryL1CacheSize()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::queryTopLevelCacheSize	src/Core/util/Memory.h	/^inline int queryTopLevelCacheSize()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::random	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::random	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::random	src/Core/MathFunctions.h	/^template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random();$/;"	p	namespace:Eigen::internal	signature:()
Eigen::internal::random	src/Core/MathFunctions.h	/^template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y);$/;"	p	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::random_default_impl	src/Core/MathFunctions.h	/^struct random_default_impl {};$/;"	s	namespace:Eigen::internal
Eigen::internal::random_default_impl	src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::random_default_impl	src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::random_default_impl	src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::random_default_impl::NonInteger	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::NonInteger NonInteger;$/;"	t	struct:Eigen::internal::random_default_impl	access:public
Eigen::internal::random_default_impl::run	src/Core/MathFunctions.h	/^  static inline Scalar run()$/;"	f	struct:Eigen::internal::random_default_impl	access:public	signature:()
Eigen::internal::random_default_impl::run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::random_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::random_impl	src/Core/MathFunctions.h	/^struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:random_default_impl
Eigen::internal::random_impl	src/Core/MathFunctions.h	/^template<> struct random_impl<bool>$/;"	s	namespace:Eigen::internal
Eigen::internal::random_impl::run	src/Core/MathFunctions.h	/^  static inline bool run()$/;"	f	struct:Eigen::internal::random_impl	access:public	signature:()
Eigen::internal::random_retval	src/Core/MathFunctions.h	/^struct random_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::random_retval::type	src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::random_retval	access:public
Eigen::internal::real_2x2_jacobi_svd	src/SVD/JacobiSVD.h	/^void real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& matrix, Index p, Index q, JacobiRotation<RealScalar> *j_left, JacobiRotation<RealScalar> *j_right)
Eigen::internal::real_default_impl	src/Core/MathFunctions.h	/^struct real_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::real_default_impl	src/Core/MathFunctions.h	/^struct real_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::real_default_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_default_impl	access:public
Eigen::internal::real_default_impl::run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_default_impl	access:public	signature:(const Scalar& x)
Eigen::internal::real_impl	src/Core/MathFunctions.h	/^template<typename Scalar> struct real_impl : real_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal	inherits:real_default_impl
Eigen::internal::real_ref_impl	src/Core/MathFunctions.h	/^struct real_ref_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::real_ref_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_ref_impl	access:public
Eigen::internal::real_ref_impl::run	src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl	access:public	signature:(Scalar& x)
Eigen::internal::real_ref_impl::run	src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl	access:public	signature:(const Scalar& x)
Eigen::internal::real_ref_retval	src/Core/MathFunctions.h	/^struct real_ref_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::real_ref_retval::type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::real_ref_retval	access:public
Eigen::internal::real_retval	src/Core/MathFunctions.h	/^struct real_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::real_retval::type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::real_retval	access:public
Eigen::internal::redux_impl	src/Core/Redux.h	/^struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_impl	src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_impl	src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_impl	src/Core/Redux.h	/^struct redux_impl<Func, Derived, SliceVectorizedTraversal, Unrolling>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_impl	src/Core/Redux.h	/^struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal	inherits:redux_novec_unroller
Eigen::internal::redux_impl::Index	src/Core/Redux.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Eigen::internal::redux_impl::PacketScalar	src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Eigen::internal::redux_impl::PacketSize	src/Core/Redux.h	/^    PacketSize = packet_traits<Scalar>::size,$/;"	e	enum:Eigen::internal::redux_impl::__anon305
Eigen::internal::redux_impl::Scalar	src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Eigen::internal::redux_impl::Size	src/Core/Redux.h	/^    Size = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_impl::__anon305
Eigen::internal::redux_impl::VectorizedSize	src/Core/Redux.h	/^    VectorizedSize = (Size \/ PacketSize) * PacketSize$/;"	e	enum:Eigen::internal::redux_impl::__anon305
Eigen::internal::redux_impl::run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl	access:public	signature:(const Derived& mat, const Func& func)
Eigen::internal::redux_impl::run	src/Core/Redux.h	/^  static Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl	access:public	signature:(const Derived& mat, const Func& func)
Eigen::internal::redux_novec_unroller	src/Core/Redux.h	/^struct redux_novec_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_novec_unroller	src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 0>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_novec_unroller	src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_novec_unroller::HalfLength	src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon301
Eigen::internal::redux_novec_unroller::Scalar	src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_novec_unroller	access:public
Eigen::internal::redux_novec_unroller::inner	src/Core/Redux.h	/^    inner = Start % Derived::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon302
Eigen::internal::redux_novec_unroller::outer	src/Core/Redux.h	/^    outer = Start \/ Derived::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon302
Eigen::internal::redux_novec_unroller::run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived &mat, const Func& func)
Eigen::internal::redux_novec_unroller::run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived &mat, const Func&)
Eigen::internal::redux_novec_unroller::run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived&, const Func&) { return Scalar(); }$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived&, const Func&)
Eigen::internal::redux_traits	src/Core/Redux.h	/^struct redux_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_traits::Cost	src/Core/Redux.h	/^    Cost = (  Derived::SizeAtCompileTime == Dynamic$/;"	e	enum:Eigen::internal::redux_traits::__anon299
Eigen::internal::redux_traits::InnerMaxSize	src/Core/Redux.h	/^    InnerMaxSize = int(Derived::IsRowMajor)$/;"	e	enum:Eigen::internal::redux_traits::__anon296
Eigen::internal::redux_traits::MayLinearVectorize	src/Core/Redux.h	/^    MayLinearVectorize = MightVectorize && (int(Derived::Flags)&LinearAccessBit),$/;"	e	enum:Eigen::internal::redux_traits::__anon297
Eigen::internal::redux_traits::MaySliceVectorize	src/Core/Redux.h	/^    MaySliceVectorize  = MightVectorize && int(InnerMaxSize)>=3*PacketSize$/;"	e	enum:Eigen::internal::redux_traits::__anon297
Eigen::internal::redux_traits::MightVectorize	src/Core/Redux.h	/^    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)$/;"	e	enum:Eigen::internal::redux_traits::__anon297
Eigen::internal::redux_traits::PacketSize	src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_traits::__anon296
Eigen::internal::redux_traits::Traversal	src/Core/Redux.h	/^    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::redux_traits::__anon298
Eigen::internal::redux_traits::Unrolling	src/Core/Redux.h	/^    Unrolling = Cost != Dynamic && Cost <= UnrollingLimit$/;"	e	enum:Eigen::internal::redux_traits::__anon300
Eigen::internal::redux_traits::UnrollingLimit	src/Core/Redux.h	/^    UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))$/;"	e	enum:Eigen::internal::redux_traits::__anon299
Eigen::internal::redux_vec_unroller	src/Core/Redux.h	/^struct redux_vec_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_vec_unroller	src/Core/Redux.h	/^struct redux_vec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_vec_unroller::HalfLength	src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon303
Eigen::internal::redux_vec_unroller::PacketScalar	src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller	access:public
Eigen::internal::redux_vec_unroller::PacketSize	src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon303
Eigen::internal::redux_vec_unroller::Scalar	src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller	access:public
Eigen::internal::redux_vec_unroller::alignment	src/Core/Redux.h	/^    alignment = (Derived::Flags & AlignedBit) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon304
Eigen::internal::redux_vec_unroller::index	src/Core/Redux.h	/^    index = Start * packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon304
Eigen::internal::redux_vec_unroller::inner	src/Core/Redux.h	/^    inner = index % int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon304
Eigen::internal::redux_vec_unroller::outer	src/Core/Redux.h	/^    outer = index \/ int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon304
Eigen::internal::redux_vec_unroller::run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_vec_unroller	access:public	signature:(const Derived &mat, const Func& func)
Eigen::internal::redux_vec_unroller::run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_vec_unroller	access:public	signature:(const Derived &mat, const Func&)
Eigen::internal::remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all::type	src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_const	src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_const	src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_const	src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_const	src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_const::type	src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	t	struct:Eigen::internal::remove_const	access:public
Eigen::internal::remove_const::type	src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const	access:public
Eigen::internal::remove_const::type	src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const	access:public
Eigen::internal::remove_const::type	src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	t	struct:Eigen::internal::remove_const	access:public
Eigen::internal::remove_pointer	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_pointer	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_pointer	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_pointer::type	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
Eigen::internal::remove_pointer::type	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
Eigen::internal::remove_pointer::type	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
Eigen::internal::remove_reference	src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_reference	src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_reference::type	src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference	access:public
Eigen::internal::remove_reference::type	src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference	access:public
Eigen::internal::result_of	src/Core/Functors.h	/^struct result_of<scalar_cmp_op<Scalar, Cmp>(Scalar,Scalar)> {$/;"	s	namespace:Eigen::internal
Eigen::internal::result_of	src/Core/util/Meta.h	/^struct result_of<Func(ArgType)> {$/;"	s	namespace:Eigen::internal
Eigen::internal::result_of	src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1)> {$/;"	s	namespace:Eigen::internal
Eigen::internal::result_of	src/Core/util/Meta.h	/^template<typename T> struct result_of {};$/;"	s	namespace:Eigen::internal
Eigen::internal::result_of::FunctorType	src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon114
Eigen::internal::result_of::FunctorType	src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon115
Eigen::internal::result_of::testFunctor	src/Core/util/Meta.h	/^    static has_none            testFunctor(...);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(....)
Eigen::internal::result_of::testFunctor	src/Core/util/Meta.h	/^    static has_std_result_type testFunctor(T const *, typename T::result_type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::result_type const * = 0)
Eigen::internal::result_of::testFunctor	src/Core/util/Meta.h	/^    static has_tr1_result      testFunctor(T const *, typename T::template result<T(ArgType)>::type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::template result<T(ArgType)>::type const * = 0)
Eigen::internal::result_of::testFunctor	src/Core/util/Meta.h	/^    static has_tr1_result      testFunctor(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0)
Eigen::internal::result_of::type	src/Core/Functors.h	/^  typedef bool type;$/;"	t	struct:Eigen::internal::result_of	access:public
Eigen::internal::result_of::type	src/Core/util/Meta.h	/^    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of	access:public
Eigen::internal::result_of::type	src/Core/util/Meta.h	/^    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of	access:public
Eigen::internal::ret	src/Core/util/Meta.h	/^    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::internal::__anon116
Eigen::internal::reverse_packet_cond	src/Core/Reverse.h	/^template<typename PacketScalar, bool ReversePacket> struct reverse_packet_cond$/;"	s	namespace:Eigen::internal
Eigen::internal::reverse_packet_cond	src/Core/Reverse.h	/^template<typename PacketScalar> struct reverse_packet_cond<PacketScalar,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::reverse_packet_cond::run	src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return preverse(x); }$/;"	f	struct:Eigen::internal::reverse_packet_cond	access:public	signature:(const PacketScalar& x)
Eigen::internal::reverse_packet_cond::run	src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return x; }$/;"	f	struct:Eigen::internal::reverse_packet_cond	access:public	signature:(const PacketScalar& x)
Eigen::internal::rotation_base_generic_product_selector	src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector< RotationDerived, DiagonalMatrix<Scalar,Dim,MaxDim>, false >$/;"	s	namespace:Eigen::internal
Eigen::internal::rotation_base_generic_product_selector	src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,MatrixType,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::rotation_base_generic_product_selector	src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,OtherVectorType,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::rotation_base_generic_product_selector::Dim	src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon381
Eigen::internal::rotation_base_generic_product_selector::Dim	src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon382
Eigen::internal::rotation_base_generic_product_selector::ReturnType	src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,1> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
Eigen::internal::rotation_base_generic_product_selector::ReturnType	src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,Dim> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
Eigen::internal::rotation_base_generic_product_selector::ReturnType	src/Geometry/RotationBase.h	/^  typedef Transform<Scalar,Dim,Affine> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
Eigen::internal::rotation_base_generic_product_selector::run	src/Geometry/RotationBase.h	/^  static EIGEN_STRONG_INLINE ReturnType run(const RotationDerived& r, const OtherVectorType& v)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const OtherVectorType& v)
Eigen::internal::rotation_base_generic_product_selector::run	src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)
Eigen::internal::rotation_base_generic_product_selector::run	src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const MatrixType& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const MatrixType& m)
Eigen::internal::scalar_abs2_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs2_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_abs2_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs2(a); }$/;"	f	struct:Eigen::internal::scalar_abs2_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_abs2_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs2_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_abs2_op::result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs2_op	access:public
Eigen::internal::scalar_abs_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_abs_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { using std::abs; return abs(a); }$/;"	f	struct:Eigen::internal::scalar_abs_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_abs_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_abs_op::result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs_op	access:public
Eigen::internal::scalar_acos_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_acos_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_acos_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_acos_op	access:public
Eigen::internal::scalar_acos_op::operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::acos; return acos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_acos_op::packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_add_op	src/Core/Functors.h	/^struct scalar_add_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_add_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_add_op	access:public
Eigen::internal::scalar_add_op::m_other	src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_add_op	access:public
Eigen::internal::scalar_add_op::operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a + m_other; }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_add_op::packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_add_op::scalar_add_op	src/Core/Functors.h	/^  inline scalar_add_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_add_op::scalar_add_op	src/Core/Functors.h	/^  inline scalar_add_op(const scalar_add_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const scalar_add_op& other)
Eigen::internal::scalar_asin_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_asin_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_asin_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_asin_op	access:public
Eigen::internal::scalar_asin_op::operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::asin; return asin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_asin_op::packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_binary_pow_op	src/Core/Functors.h	/^template<typename Scalar, typename OtherScalar> struct scalar_binary_pow_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_binary_pow_op::operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a, const OtherScalar& b) const { return numext::pow(a, b); }$/;"	f	struct:Eigen::internal::scalar_binary_pow_op	access:public	signature:(const Scalar& a, const OtherScalar& b) const
Eigen::internal::scalar_boolean_and_op	src/Core/Functors.h	/^struct scalar_boolean_and_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_boolean_and_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a && b; }$/;"	f	struct:Eigen::internal::scalar_boolean_and_op	access:public	signature:(const bool& a, const bool& b) const
Eigen::internal::scalar_boolean_or_op	src/Core/Functors.h	/^struct scalar_boolean_or_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_boolean_or_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a || b; }$/;"	f	struct:Eigen::internal::scalar_boolean_or_op	access:public	signature:(const bool& a, const bool& b) const
Eigen::internal::scalar_cast_op	src/Core/Functors.h	/^struct scalar_cast_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cast_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }$/;"	f	struct:Eigen::internal::scalar_cast_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_cast_op::result_type	src/Core/Functors.h	/^  typedef NewType result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op	access:public
Eigen::internal::scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_EQ> {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_LE> {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_LT> {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_NEQ> {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_UNORD> {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cmp_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return !(a<=b || b<=a);}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_cmp_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a!=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_cmp_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a<=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_cmp_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a<b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_cmp_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a==b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_conj_product_op	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_conj_product_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_conj_product_op::Conj	src/Core/Functors.h	/^    Conj = NumTraits<LhsScalar>::IsComplex$/;"	e	enum:Eigen::internal::scalar_conj_product_op::__anon171
Eigen::internal::scalar_conj_product_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
Eigen::internal::scalar_conj_product_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_conj_product_op::result_type	src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_conj_product_op	access:public
Eigen::internal::scalar_conjugate_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_conjugate_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_conjugate_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { using numext::conj; return conj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_conjugate_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_constant_op	src/Core/Functors.h	/^struct scalar_constant_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_constant_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_constant_op	access:public
Eigen::internal::scalar_constant_op::m_other	src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_constant_op	access:public
Eigen::internal::scalar_constant_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index, Index = 0) const { return m_other; }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(Index, Index = 0) const
Eigen::internal::scalar_constant_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index, Index = 0) const { return internal::pset1<Packet>(m_other); }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(Index, Index = 0) const
Eigen::internal::scalar_constant_op::scalar_constant_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_constant_op::scalar_constant_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(const scalar_constant_op& other)
Eigen::internal::scalar_cos_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cos_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cos_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_cos_op	access:public
Eigen::internal::scalar_cos_op::operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { using std::cos; return cos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_cos_op::packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_cube_op	src/Core/Functors.h	/^struct scalar_cube_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cube_op::operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a*a; }$/;"	f	struct:Eigen::internal::scalar_cube_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_cube_op::packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_cube_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_difference_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_difference_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_difference_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a - b; }$/;"	f	struct:Eigen::internal::scalar_difference_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_difference_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_difference_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_exp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_exp_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_exp_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_exp_op	access:public
Eigen::internal::scalar_exp_op::operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::exp; return exp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_exp_op::packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_fuzzy_default_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl {};$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_default_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_default_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_default_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_default_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public
Eigen::internal::scalar_fuzzy_default_impl::isApprox	src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar& prec)
Eigen::internal::scalar_fuzzy_default_impl::isApprox	src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar&)
Eigen::internal::scalar_fuzzy_default_impl::isApproxOrLessThan	src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar& prec)
Eigen::internal::scalar_fuzzy_default_impl::isApproxOrLessThan	src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar&)
Eigen::internal::scalar_fuzzy_default_impl::isMuchSmallerThan	src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const OtherScalar& y, const RealScalar& prec)
Eigen::internal::scalar_fuzzy_default_impl::isMuchSmallerThan	src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar&, const RealScalar&)
Eigen::internal::scalar_fuzzy_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:scalar_fuzzy_default_impl
Eigen::internal::scalar_fuzzy_impl	src/Core/MathFunctions.h	/^template<> struct scalar_fuzzy_impl<bool>$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_impl::RealScalar	src/Core/MathFunctions.h	/^  typedef bool RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_impl	access:public
Eigen::internal::scalar_fuzzy_impl::isApprox	src/Core/MathFunctions.h	/^  static inline bool isApprox(bool x, bool y, bool)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(bool x, bool y, bool)
Eigen::internal::scalar_fuzzy_impl::isApproxOrLessThan	src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(const bool& x, const bool& y, const bool&)
Eigen::internal::scalar_fuzzy_impl::isMuchSmallerThan	src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(const bool& x, const bool&, const bool&)
Eigen::internal::scalar_hypot_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_hypot_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_hypot_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& _x, const Scalar& _y) const$/;"	f	struct:Eigen::internal::scalar_hypot_op	access:public	signature:(const Scalar& _x, const Scalar& _y) const
Eigen::internal::scalar_identity_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_identity_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_identity_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const { return row==col ? Scalar(1) : Scalar(0); }$/;"	f	struct:Eigen::internal::scalar_identity_op	access:public	signature:(Index row, Index col) const
Eigen::internal::scalar_imag_op	src/Core/Functors.h	/^struct scalar_imag_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_imag_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::imag(a); }$/;"	f	struct:Eigen::internal::scalar_imag_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_imag_op::result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_op	access:public
Eigen::internal::scalar_imag_ref_op	src/Core/Functors.h	/^struct scalar_imag_ref_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_imag_ref_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::imag_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_imag_ref_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_imag_ref_op::result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_ref_op	access:public
Eigen::internal::scalar_inverse_mult_op	src/Core/Functors.h	/^struct scalar_inverse_mult_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_inverse_mult_op::m_other	src/Core/Functors.h	/^  Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_inverse_mult_op	access:public
Eigen::internal::scalar_inverse_mult_op::operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return m_other \/ a; }$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_inverse_mult_op::packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_inverse_mult_op::scalar_inverse_mult_op	src/Core/Functors.h	/^  scalar_inverse_mult_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_inverse_op	src/Core/Functors.h	/^struct scalar_inverse_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_inverse_op::operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return Scalar(1)\/a; }$/;"	f	struct:Eigen::internal::scalar_inverse_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_inverse_op::packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_log_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_log_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_log_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_log_op	access:public
Eigen::internal::scalar_log_op::operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::log; return log(a); }$/;"	f	struct:Eigen::internal::scalar_log_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_log_op::packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::plog(a); }$/;"	f	struct:Eigen::internal::scalar_log_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_max_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_max_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_max_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::max; return (max)(a, b); }$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_max_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_max_op::predux	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_min_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_min_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_min_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::min; return (min)(a, b); }$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_min_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_min_op::predux	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_multiple2_op	src/Core/Functors.h	/^struct scalar_multiple2_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_multiple2_op::m_other	src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar2>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple2_op	access:public
Eigen::internal::scalar_multiple2_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar1& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const Scalar1& a) const
Eigen::internal::scalar_multiple2_op::result_type	src/Core/Functors.h	/^  typedef typename scalar_product_traits<Scalar1,Scalar2>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_multiple2_op	access:public
Eigen::internal::scalar_multiple2_op::scalar_multiple2_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const Scalar2& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const Scalar2& other)
Eigen::internal::scalar_multiple2_op::scalar_multiple2_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const scalar_multiple2_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const scalar_multiple2_op& other)
Eigen::internal::scalar_multiple_op	src/Core/Functors.h	/^struct scalar_multiple_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_multiple_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_multiple_op	access:public
Eigen::internal::scalar_multiple_op::m_other	src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple_op	access:public
Eigen::internal::scalar_multiple_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_multiple_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_multiple_op::scalar_multiple_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_multiple_op::scalar_multiple_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const scalar_multiple_op& other)
Eigen::internal::scalar_opposite_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_opposite_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_opposite_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }$/;"	f	struct:Eigen::internal::scalar_opposite_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_opposite_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_opposite_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_pow_op	src/Core/Functors.h	/^struct scalar_pow_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_pow_op::m_exponent	src/Core/Functors.h	/^  const Scalar m_exponent;$/;"	m	struct:Eigen::internal::scalar_pow_op	access:public
Eigen::internal::scalar_pow_op::operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return numext::pow(a, m_exponent); }$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_pow_op::scalar_pow_op	src/Core/Functors.h	/^  inline scalar_pow_op(const Scalar& exponent) : m_exponent(exponent) {}$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const Scalar& exponent)
Eigen::internal::scalar_pow_op::scalar_pow_op	src/Core/Functors.h	/^  inline scalar_pow_op(const scalar_pow_op& other) : m_exponent(other.m_exponent) { }$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const scalar_pow_op& other)
Eigen::internal::scalar_product_op	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_product_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_product_op::Vectorizable	src/Core/Functors.h	/^    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul$/;"	e	enum:Eigen::internal::scalar_product_op::__anon169
Eigen::internal::scalar_product_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
Eigen::internal::scalar_product_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_product_op::predux	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_product_op::result_type	src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_product_op	access:public
Eigen::internal::scalar_quotient1_op	src/Core/Functors.h	/^struct scalar_quotient1_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_quotient1_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_quotient1_op	access:public
Eigen::internal::scalar_quotient1_op::m_other	src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_quotient1_op	access:public
Eigen::internal::scalar_quotient1_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a \/ m_other; }$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_quotient1_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_quotient1_op::scalar_quotient1_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_quotient1_op::scalar_quotient1_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const scalar_quotient1_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const scalar_quotient1_op& other)
Eigen::internal::scalar_quotient_op	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_quotient_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_quotient_op::Vectorizable	src/Core/Functors.h	/^    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasDiv && packet_traits<RhsScalar>::HasDiv$/;"	e	enum:Eigen::internal::scalar_quotient_op::__anon178
Eigen::internal::scalar_quotient_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a \/ b; }$/;"	f	struct:Eigen::internal::scalar_quotient_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
Eigen::internal::scalar_quotient_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_quotient_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_quotient_op::result_type	src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_quotient_op	access:public
Eigen::internal::scalar_random_op	src/Core/Random.h	/^template<typename Scalar> struct scalar_random_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_random_op::operator ()	src/Core/Random.h	/^  inline const Scalar operator() (Index, Index = 0) const { return random<Scalar>(); }$/;"	f	struct:Eigen::internal::scalar_random_op	access:public	signature:(Index, Index = 0) const
Eigen::internal::scalar_real_op	src/Core/Functors.h	/^struct scalar_real_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_real_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::real(a); }$/;"	f	struct:Eigen::internal::scalar_real_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_real_op::result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_op	access:public
Eigen::internal::scalar_real_ref_op	src/Core/Functors.h	/^struct scalar_real_ref_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_real_ref_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::real_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_real_ref_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_real_ref_op::result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_ref_op	access:public
Eigen::internal::scalar_sin_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_sin_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_sin_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sin_op	access:public
Eigen::internal::scalar_sin_op::operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::sin; return sin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_sin_op::packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_sqrt_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_sqrt_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_sqrt_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sqrt_op	access:public
Eigen::internal::scalar_sqrt_op::operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::sqrt; return sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_sqrt_op::packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_square_op	src/Core/Functors.h	/^struct scalar_square_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_square_op::operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a; }$/;"	f	struct:Eigen::internal::scalar_square_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_square_op::packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_square_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_sum_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_sum_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_sum_op::operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_sum_op::packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_sum_op::predux	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_tan_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_tan_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_tan_op::Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_tan_op	access:public
Eigen::internal::scalar_tan_op::operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::tan; return tan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_tan_op::packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op	access:public	signature:(const Packet& a) const
Eigen::internal::selfadjoint_matrix_vector_product	src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_matrix_vector_product$/;"	s	namespace:Eigen::internal
Eigen::internal::selfadjoint_matrix_vector_product::run	src/Core/products/SelfadjointMatrixVector.h	/^EIGEN_DONT_INLINE void selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::selfadjoint_matrix_vector_product	signature:( Index size, const Scalar* lhs, Index lhsStride, const Scalar* _rhs, Index rhsIncr, Scalar* res, Scalar alpha)
Eigen::internal::selfadjoint_matrix_vector_product::run	src/Core/products/SelfadjointMatrixVector.h	/^static EIGEN_DONT_INLINE void run($/;"	p	struct:Eigen::internal::selfadjoint_matrix_vector_product	access:public	signature:( Index size, const Scalar* lhs, Index lhsStride, const Scalar* _rhs, Index rhsIncr, Scalar* res, Scalar alpha)
Eigen::internal::selfadjoint_matrix_vector_product_symv	src/Core/products/SelfadjointMatrixVector_MKL.h	/^struct selfadjoint_matrix_vector_product_symv :$/;"	s	namespace:Eigen::internal	inherits:selfadjoint_matrix_vector_product
Eigen::internal::selfadjoint_rank2_update_selector	src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::selfadjoint_rank2_update_selector	src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::selfadjoint_rank2_update_selector::run	src/Core/products/SelfadjointRank2Update.h	/^  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, const Scalar& alpha)$/;"	f	struct:Eigen::internal::selfadjoint_rank2_update_selector	access:public	signature:(Scalar* mat, Index stride, const UType& u, const VType& v, const Scalar& alpha)
Eigen::internal::setIdentity_impl	src/Core/CwiseNullaryOp.h	/^struct setIdentity_impl<Derived, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::setIdentity_impl::Index	src/Core/CwiseNullaryOp.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::setIdentity_impl	access:public
Eigen::internal::setIdentity_impl::run	src/Core/CwiseNullaryOp.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& m)$/;"	f	struct:Eigen::internal::setIdentity_impl	access:public	signature:(Derived& m)
Eigen::internal::set_from_triplets	src/SparseCore/SparseMatrix.h	/^void set_from_triplets(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)$/;"	f	namespace:Eigen::internal	signature:(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)
Eigen::internal::set_is_malloc_allowed	src/Core/util/Memory.h	/^inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }$/;"	f	namespace:Eigen::internal	signature:(bool new_value)
Eigen::internal::significant_decimals_default_impl	src/Core/IO.h	/^struct significant_decimals_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::significant_decimals_default_impl	src/Core/IO.h	/^struct significant_decimals_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::significant_decimals_default_impl::RealScalar	src/Core/IO.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::significant_decimals_default_impl	access:public
Eigen::internal::significant_decimals_default_impl::run	src/Core/IO.h	/^  static inline int run()$/;"	f	struct:Eigen::internal::significant_decimals_default_impl	access:public	signature:()
Eigen::internal::significant_decimals_impl	src/Core/IO.h	/^struct significant_decimals_impl$/;"	s	namespace:Eigen::internal	inherits:significant_decimals_default_impl
Eigen::internal::smart_copy	src/Core/util/Memory.h	/^template<typename T> void smart_copy(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal	signature:(const T* start, const T* end, T* target)
Eigen::internal::smart_copy_helper	src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::smart_copy_helper	src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::smart_copy_helper::run	src/Core/util/Memory.h	/^  static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_copy_helper	access:public	signature:(const T* start, const T* end, T* target)
Eigen::internal::solve_retval	src/Cholesky/LDLT.h	/^struct solve_retval<LDLT<_MatrixType,_UpLo>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/Cholesky/LLT.h	/^struct solve_retval<LLT<_MatrixType, UpLo>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/CholmodSupport/CholmodSupport.h	/^struct solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/IterativeLinearSolvers/BasicPreconditioners.h	/^struct solve_retval<DiagonalPreconditioner<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/IterativeLinearSolvers/BiCGSTAB.h	/^struct solve_retval<BiCGSTAB<_MatrixType, _Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/IterativeLinearSolvers/ConjugateGradient.h	/^struct solve_retval<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/IterativeLinearSolvers/IncompleteLUT.h	/^struct solve_retval<IncompleteLUT<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/LU/FullPivLU.h	/^struct solve_retval<FullPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/LU/PartialPivLU.h	/^struct solve_retval<PartialPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/PaStiXSupport/PaStiXSupport.h	/^struct solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/PardisoSupport/PardisoSupport.h	/^struct solve_retval<PardisoImpl<_Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/QR/ColPivHouseholderQR.h	/^struct solve_retval<ColPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/QR/FullPivHouseholderQR.h	/^struct solve_retval<FullPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/QR/HouseholderQR.h	/^struct solve_retval<HouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/SPQRSupport/SuiteSparseQRSupport.h	/^struct solve_retval<SPQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/SVD/JacobiSVD.h	/^struct solve_retval<JacobiSVD<_MatrixType, QRPreconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/SparseCholesky/SimplicialCholesky.h	/^struct solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/SparseLU/SparseLU.h	/^struct solve_retval<SparseLU<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/SparseQR/SparseQR.h	/^struct solve_retval<SparseQR<_MatrixType,OrderingType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/SuperLUSupport/SuperLUSupport.h	/^struct solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	src/UmfPackSupport/UmfPackSupport.h	/^struct solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval::Dec	src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/IterativeLinearSolvers/BasicPreconditioners.h	/^  typedef DiagonalPreconditioner<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef BiCGSTAB<_MatrixType, _Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/IterativeLinearSolvers/IncompleteLUT.h	/^  typedef IncompleteLUT<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<_Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef SPQR<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/SparseLU/SparseLU.h	/^  typedef SparseLU<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/SparseQR/SparseQR.h	/^  typedef SparseQR<_MatrixType,OrderingType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::JacobiSVDType	src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<_MatrixType, QRPreconditioner> JacobiSVDType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::LDLTType	src/Cholesky/LDLT.h	/^  typedef LDLT<_MatrixType,_UpLo> LDLTType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::LLTType	src/Cholesky/LLT.h	/^  typedef LLT<_MatrixType,UpLo> LLTType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::evalTo	src/Cholesky/LDLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/Cholesky/LLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/IterativeLinearSolvers/BasicPreconditioners.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/IterativeLinearSolvers/BiCGSTAB.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/IterativeLinearSolvers/ConjugateGradient.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/IterativeLinearSolvers/IncompleteLUT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/LU/PartialPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/QR/ColPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/QR/FullPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/QR/HouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/SPQRSupport/SuiteSparseQRSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/SVD/JacobiSVD.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/SparseLU/SparseLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval_base	src/misc/Solve.h	/^template<typename _DecompositionType, typename Rhs> struct solve_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::solve_retval_base::Base	src/misc/Solve.h	/^  typedef ReturnByValue<solve_retval_base> Base;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Eigen::internal::solve_retval_base::DecompositionType	src/misc/Solve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Eigen::internal::solve_retval_base::Index	src/misc/Solve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Eigen::internal::solve_retval_base::RhsNestedCleaned	src/misc/Solve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Eigen::internal::solve_retval_base::cols	src/misc/Solve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
Eigen::internal::solve_retval_base::dec	src/misc/Solve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
Eigen::internal::solve_retval_base::evalTo	src/misc/Solve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval_base::m_dec	src/misc/Solve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_base	access:protected
Eigen::internal::solve_retval_base::m_rhs	src/misc/Solve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_base	access:protected
Eigen::internal::solve_retval_base::rhs	src/misc/Solve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
Eigen::internal::solve_retval_base::rows	src/misc/Solve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
Eigen::internal::solve_retval_base::solve_retval_base	src/misc/Solve.h	/^  solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:(const DecompositionType& dec, const Rhs& rhs)
Eigen::internal::solve_retval_with_guess	src/misc/SparseSolve.h	/^template<typename DecompositionType, typename Rhs, typename Guess> struct solve_retval_with_guess$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::solve_retval_with_guess::Index	src/misc/SparseSolve.h	/^  typedef typename DecompositionType::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_with_guess	access:public
Eigen::internal::solve_retval_with_guess::cols	src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:() const
Eigen::internal::solve_retval_with_guess::evalTo	src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval_with_guess::m_dec	src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
Eigen::internal::solve_retval_with_guess::m_guess	src/misc/SparseSolve.h	/^    const typename Guess::Nested m_guess;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
Eigen::internal::solve_retval_with_guess::m_rhs	src/misc/SparseSolve.h	/^    const typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
Eigen::internal::solve_retval_with_guess::rows	src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:() const
Eigen::internal::solve_retval_with_guess::solve_retval_with_guess	src/misc/SparseSolve.h	/^  solve_retval_with_guess(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<BinaryOp, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Dense, Sparse>$/;"	c	namespace:Eigen::internal
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Dense>$/;"	c	namespace:Eigen::internal
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::BinaryFunc	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef scalar_product_op<T> BinaryFunc;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::CwiseBinaryXpr	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryFunc, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::CwiseBinaryXpr	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::Index	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::IsRowMajor	src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Lhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon439
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::IsRowMajor	src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Rhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon440
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::LhsIterator	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _LhsNested::InnerIterator LhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::RhsIterator	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _RhsNested::InnerIterator RhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::RhsNested	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::RhsNested RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::Scalar	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename CwiseBinaryXpr::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::Scalar	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::_LhsNested	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_LhsNested _LhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::_RhsNested	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_RhsNested _RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::col	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return Lhs::IsRowMajor ? index() : m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::col	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::col	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_rhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::index	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_id; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::index	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_lhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::index	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_rhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_functor	src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_functor	src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_functor	src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_id	src/SparseCore/SparseCwiseBinaryOp.h	/^    Index m_id;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_lhsIter	src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_outer	src/SparseCore/SparseCwiseBinaryOp.h	/^    const Index m_outer;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_rhs	src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_rhsIter	src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_value	src/SparseCore/SparseCwiseBinaryOp.h	/^    Scalar m_value;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_xpr	src/SparseCore/SparseCwiseBinaryOp.h	/^    const CwiseBinaryXpr& m_xpr;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator ++	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Derived& operator++()$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:()
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator bool	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return (m_lhsIter && m_rhsIter); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator bool	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id>=0; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator bool	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_lhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator bool	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_rhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::row	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return Lhs::IsRowMajor ? m_lhsIter.row() : index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::row	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_lhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::row	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_rhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE sparse_cwise_binary_op_inner_iterator_selector(const CwiseBinaryXpr& xpr, Index outer)$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:(const CwiseBinaryXpr& xpr, Index outer)
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::value	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(m_lhsIter.value(), m_rhsIter.value()); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::value	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_value; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::value	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_diagonal_product_inner_iterator_selector	src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal	inherits:CwiseBinaryOp::InnerIterator
Eigen::internal::sparse_diagonal_product_inner_iterator_selector	src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal	inherits:CwiseUnaryOp::InnerIterator
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Base	src/SparseCore/SparseDiagonalProduct.h	/^      const Transpose<const typename Rhs::DiagonalVectorType> >::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Base	src/SparseCore/SparseDiagonalProduct.h	/^      const typename Lhs::DiagonalVectorType>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Base	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Lhs::Scalar>,const Rhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Base	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Rhs::Scalar>,const Lhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Index	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::col	src/SparseCore/SparseDiagonalProduct.h	/^    inline Index col() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::m_outer	src/SparseCore/SparseDiagonalProduct.h	/^    Index m_outer;$/;"	m	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::outer	src/SparseCore/SparseDiagonalProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::row	src/SparseCore/SparseDiagonalProduct.h	/^    inline Index row() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::sparse_diagonal_product_inner_iterator_selector	src/SparseCore/SparseDiagonalProduct.h	/^    inline sparse_diagonal_product_inner_iterator_selector($/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:( const SparseDiagonalProductType& expr, Index outer)
Eigen::internal::sparse_eval	src/SparseCore/SparseUtil.h	/^template<typename T,int Cols> struct sparse_eval<T,1,Cols> {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_eval	src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Cols> struct sparse_eval {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_eval	src/SparseCore/SparseUtil.h	/^template<typename T,int Rows> struct sparse_eval<T,Rows,1> {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_eval	src/SparseCore/SparseUtil.h	/^template<typename T> struct sparse_eval<T,1,1> {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_eval::_Index	src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Index _Index;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_eval::_Options	src/SparseCore/SparseUtil.h	/^    enum { _Options = ((traits<T>::Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::sparse_eval::__anon454
Eigen::internal::sparse_eval::_Scalar	src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_eval::type	src/SparseCore/SparseUtil.h	/^    typedef Matrix<_Scalar, 1, 1> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_eval::type	src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_eval::type	src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, ColMajor, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_eval::type	src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, RowMajor, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_solve_retval	src/CholmodSupport/CholmodSupport.h	/^struct sparse_solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct sparse_solve_retval<IterativeSolverBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	src/PaStiXSupport/PaStiXSupport.h	/^struct sparse_solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	src/PardisoSupport/PardisoSupport.h	/^struct sparse_solve_retval<PardisoImpl<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	src/SparseCholesky/SimplicialCholesky.h	/^struct sparse_solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	src/SparseLU/SparseLU.h	/^struct sparse_solve_retval<SparseLU<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	src/SparseQR/SparseQR.h	/^struct sparse_solve_retval<SparseQR<_MatrixType, OrderingType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	src/SuperLUSupport/SuperLUSupport.h	/^struct sparse_solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	src/UmfPackSupport/UmfPackSupport.h	/^struct sparse_solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval::Dec	src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef IterativeSolverBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	src/SparseLU/SparseLU.h	/^  typedef SparseLU<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	src/SparseQR/SparseQR.h	/^  typedef SparseQR<_MatrixType, OrderingType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::evalTo	src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	src/SparseLU/SparseLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval_base	src/misc/SparseSolve.h	/^template<typename _DecompositionType, typename Rhs> struct sparse_solve_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::sparse_solve_retval_base::Base	src/misc/SparseSolve.h	/^  typedef ReturnByValue<sparse_solve_retval_base> Base;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Eigen::internal::sparse_solve_retval_base::DecompositionType	src/misc/SparseSolve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Eigen::internal::sparse_solve_retval_base::Index	src/misc/SparseSolve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Eigen::internal::sparse_solve_retval_base::RhsNestedCleaned	src/misc/SparseSolve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Eigen::internal::sparse_solve_retval_base::cols	src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
Eigen::internal::sparse_solve_retval_base::dec	src/misc/SparseSolve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
Eigen::internal::sparse_solve_retval_base::defaultEvalTo	src/misc/SparseSolve.h	/^    inline void defaultEvalTo(SparseMatrix<DestScalar,DestOptions,DestIndex>& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:protected	signature:(SparseMatrix<DestScalar,DestOptions,DestIndex>& dst) const
Eigen::internal::sparse_solve_retval_base::evalTo	src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval_base::m_dec	src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base	access:protected
Eigen::internal::sparse_solve_retval_base::m_rhs	src/misc/SparseSolve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base	access:protected
Eigen::internal::sparse_solve_retval_base::rhs	src/misc/SparseSolve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
Eigen::internal::sparse_solve_retval_base::rows	src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
Eigen::internal::sparse_solve_retval_base::sparse_solve_retval_base	src/misc/SparseSolve.h	/^  sparse_solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:(const DecompositionType& dec, const Rhs& rhs)
Eigen::internal::sparse_solve_triangular_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_selector::Scalar	src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector	access:public
Eigen::internal::sparse_solve_triangular_selector::run	src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_selector	access:public	signature:(const Lhs& lhs, Rhs& other)
Eigen::internal::sparse_solve_triangular_sparse_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_sparse_selector<Lhs,Rhs,Mode,UpLo,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_sparse_selector::Index	src/SparseCore/TriangularSolver.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public
Eigen::internal::sparse_solve_triangular_sparse_selector::Scalar	src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public
Eigen::internal::sparse_solve_triangular_sparse_selector::run	src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public	signature:(const Lhs& lhs, Rhs& other)
Eigen::internal::sparse_sparse_product_with_pruning_impl	src/SparseCore/SparseSparseProductWithPruning.h	/^static void sparse_sparse_product_with_pruning_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, const typename ResultType::RealScalar& tolerance)$/;"	f	namespace:Eigen::internal	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res, const typename ResultType::RealScalar& tolerance)
Eigen::internal::sparse_sparse_product_with_pruning_selector	src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_sparse_product_with_pruning_selector	src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_sparse_product_with_pruning_selector	src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_sparse_product_with_pruning_selector	src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_sparse_product_with_pruning_selector::RealScalar	src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename ResultType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public
Eigen::internal::sparse_sparse_product_with_pruning_selector::Scalar	src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public
Eigen::internal::sparse_sparse_product_with_pruning_selector::run	src/SparseCore/SparseSparseProductWithPruning.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res, const RealScalar& tolerance)$/;"	f	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res, const RealScalar& tolerance)
Eigen::internal::sparse_time_dense_product	src/SparseCore/SparseDenseProduct.h	/^inline void sparse_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal	signature:(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)
Eigen::internal::sparse_time_dense_product_impl	src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_time_dense_product_impl	src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_time_dense_product_impl	src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_time_dense_product_impl	src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_time_dense_product_impl::Index	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::Lhs	src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<SparseLhsType>::type Lhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::LhsInnerIterator	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::InnerIterator LhsInnerIterator;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::Res	src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseResType>::type Res;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::Rhs	src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseRhsType>::type Rhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::run	src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl	access:public	signature:(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha)
Eigen::internal::sparse_vector_assign_selector	src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Inner> {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_vector_assign_selector	src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Outer> {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_vector_assign_selector	src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_RuntimeSwitch> {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_vector_assign_selector::run	src/SparseCore/SparseVector.h	/^  static void run(Dest& dst, const Src& src) {$/;"	f	struct:Eigen::internal::sparse_vector_assign_selector	access:public	signature:(Dest& dst, const Src& src)
Eigen::internal::sparselu_gemm	src/SparseLU/SparseLU_gemm_kernel.h	/^void sparselu_gemm(Index m, Index n, Index d, const Scalar* A, Index lda, const Scalar* B, Index ldb, Scalar* C, Index ldc)$/;"	f	namespace:Eigen::internal	signature:(Index m, Index n, Index d, const Scalar* A, Index lda, const Scalar* B, Index ldb, Scalar* C, Index ldc)
Eigen::internal::stable_norm_kernel	src/Core/StableNorm.h	/^inline void stable_norm_kernel(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)$/;"	f	namespace:Eigen::internal	signature:(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)
Eigen::internal::static_assertion	src/Core/util/StaticAssert.h	/^    struct static_assertion {};$/;"	s	namespace:Eigen::internal
Eigen::internal::static_assertion	src/Core/util/StaticAssert.h	/^    struct static_assertion<true>$/;"	s	namespace:Eigen::internal
Eigen::internal::static_assertion::BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER	src/Core/util/StaticAssert.h	/^        BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED	src/Core/util/StaticAssert.h	/^        COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE	src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT	src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED	src/Core/util/StaticAssert.h	/^        FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY	src/Core/util/StaticAssert.h	/^        IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::INVALID_MATRIXBASE_TEMPLATE_PARAMETERS	src/Core/util/StaticAssert.h	/^        INVALID_MATRIXBASE_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::INVALID_MATRIX_PRODUCT	src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION	src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::INVALID_MATRIX_TEMPLATE_PARAMETERS	src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION	src/Core/util/StaticAssert.h	/^        INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS	src/Core/util/StaticAssert.h	/^        INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::NUMERIC_TYPE_MUST_BE_REAL	src/Core/util/StaticAssert.h	/^        NUMERIC_TYPE_MUST_BE_REAL,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG	src/Core/util/StaticAssert.h	/^        OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1	src/Core/util/StaticAssert.h	/^        PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::STORAGE_LAYOUT_DOES_NOT_MATCH	src/Core/util/StaticAssert.h	/^        STORAGE_LAYOUT_DOES_NOT_MATCH$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD	src/Core/util/StaticAssert.h	/^        THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE	src/Core/util/StaticAssert.h	/^        THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE	src/Core/util/StaticAssert.h	/^        THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH	src/Core/util/StaticAssert.h	/^        THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY	src/Core/util/StaticAssert.h	/^        THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES	src/Core/util/StaticAssert.h	/^        THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC	src/Core/util/StaticAssert.h	/^        UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED	src/Core/util/StaticAssert.h	/^        WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_ALREADY_SPECIFIED_THIS_STRIDE	src/Core/util/StaticAssert.h	/^        YOU_ALREADY_SPECIFIED_THIS_STRIDE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT	src/Core/util/StaticAssert.h	/^        YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR	src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR	src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_CANNOT_MIX_ARRAYS_AND_MATRICES	src/Core/util/StaticAssert.h	/^        YOU_CANNOT_MIX_ARRAYS_AND_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_MADE_A_PROGRAMMING_MISTAKE	src/Core/util/StaticAssert.h	/^        YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY	src/Core/util/StaticAssert.h	/^        YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES	src/Core/util/StaticAssert.h	/^        YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES	src/Core/util/StaticAssert.h	/^        YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED	src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED	src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION	src/Core/util/StaticAssert.h	/^        YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::static_assertion::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX	src/Core/util/StaticAssert.h	/^        YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Eigen::internal::stem_function	src/Core/util/ForwardDeclarations.h	/^struct stem_function$/;"	s	namespace:Eigen::internal
Eigen::internal::stem_function::ComplexScalar	src/Core/util/ForwardDeclarations.h	/^  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	struct:Eigen::internal::stem_function	access:public
Eigen::internal::stem_function::type	src/Core/util/ForwardDeclarations.h	/^  typedef ComplexScalar type(ComplexScalar, int);$/;"	t	struct:Eigen::internal::stem_function	access:public
Eigen::internal::svd_precondition_2x2_block_to_be_real	src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real {};$/;"	s	namespace:Eigen::internal
Eigen::internal::svd_precondition_2x2_block_to_be_real	src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::svd_precondition_2x2_block_to_be_real	src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::svd_precondition_2x2_block_to_be_real::Index	src/SVD/JacobiSVD.h	/^  typedef typename SVD::Index Index;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Eigen::internal::svd_precondition_2x2_block_to_be_real::RealScalar	src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Eigen::internal::svd_precondition_2x2_block_to_be_real::SVD	src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Eigen::internal::svd_precondition_2x2_block_to_be_real::Scalar	src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Eigen::internal::svd_precondition_2x2_block_to_be_real::run	src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public	signature:(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)
Eigen::internal::svd_precondition_2x2_block_to_be_real::run	src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType&, SVD&, Index, Index) {}$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public	signature:(typename SVD::WorkMatrixType&, SVD&, Index, Index)
Eigen::internal::symm_pack_lhs	src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_lhs$/;"	s	namespace:Eigen::internal
Eigen::internal::symm_pack_lhs::operator ()	src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)$/;"	f	struct:Eigen::internal::symm_pack_lhs	access:public	signature:(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)
Eigen::internal::symm_pack_lhs::pack	src/Core/products/SelfadjointMatrixMatrix.h	/^  void pack(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)$/;"	f	struct:Eigen::internal::symm_pack_lhs	access:public	signature:(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)
Eigen::internal::symm_pack_rhs	src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_rhs$/;"	s	namespace:Eigen::internal
Eigen::internal::symm_pack_rhs::PacketSize	src/Core/products/SelfadjointMatrixMatrix.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::symm_pack_rhs::__anon48
Eigen::internal::symm_pack_rhs::operator ()	src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)$/;"	f	struct:Eigen::internal::symm_pack_rhs	access:public	signature:(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)
Eigen::internal::take_matrix_for_product	src/Geometry/Homogeneous.h	/^struct take_matrix_for_product$/;"	s	namespace:Eigen::internal
Eigen::internal::take_matrix_for_product	src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Mode, Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::take_matrix_for_product	src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Projective, Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::take_matrix_for_product::TransformType	src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Mode, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::take_matrix_for_product::TransformType	src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Projective, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::take_matrix_for_product::run	src/Geometry/Homogeneous.h	/^  static const type& run (const TransformType& x) { return x.matrix(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const TransformType& x)
Eigen::internal::take_matrix_for_product::run	src/Geometry/Homogeneous.h	/^  static const type& run(const type &x) { return x; }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const type &x)
Eigen::internal::take_matrix_for_product::run	src/Geometry/Homogeneous.h	/^  static type run (const TransformType& x) { return x.affine(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const TransformType& x)
Eigen::internal::take_matrix_for_product::type	src/Geometry/Homogeneous.h	/^  typedef MatrixOrTransformType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::take_matrix_for_product::type	src/Geometry/Homogeneous.h	/^  typedef typename TransformType::MatrixType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::take_matrix_for_product::type	src/Geometry/Homogeneous.h	/^  typedef typename internal::add_const<typename TransformType::ConstAffinePart>::type type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::throw_std_bad_alloc	src/Core/util/Memory.h	/^inline void throw_std_bad_alloc()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::toRotationMatrix	src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& s)
Eigen::internal::toRotationMatrix	src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen::internal	signature:(const RotationBase<OtherDerived,Dim>& r)
Eigen::internal::toRotationMatrix	src/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<OtherDerived>& mat)
Eigen::internal::traits	src/Core/Array.h	/^struct traits<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > : traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/ArrayWrapper.h	/^struct traits<ArrayWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/ArrayWrapper.h	/^struct traits<MatrixWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/BandMatrix.h	/^struct traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/BandMatrix.h	/^struct traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/Block.h	/^struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel> > : traits<XprType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/CwiseBinaryOp.h	/^struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/CwiseNullaryOp.h	/^struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/CwiseUnaryOp.h	/^struct traits<CwiseUnaryOp<UnaryOp, XprType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/CwiseUnaryView.h	/^struct traits<CwiseUnaryView<ViewOp, MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Diagonal.h	/^struct traits<Diagonal<MatrixType,DiagIndex> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/DiagonalMatrix.h	/^struct traits<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/DiagonalMatrix.h	/^struct traits<DiagonalWrapper<_DiagonalVectorType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/DiagonalProduct.h	/^struct traits<DiagonalProduct<MatrixType, DiagonalType, ProductOrder> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Flagged.h	/^struct traits<Flagged<ExpressionType, Added, Removed> > : traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/ForceAlignedAccess.h	/^struct traits<ForceAlignedAccess<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemvProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,InnerProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,OuterProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Map.h	/^struct traits<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Matrix.h	/^struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/NestByValue.h	/^struct traits<NestByValue<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/PermutationMatrix.h	/^struct traits<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/PermutationMatrix.h	/^struct traits<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/PermutationMatrix.h	/^struct traits<PermutationWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/PermutationMatrix.h	/^struct traits<Transpose<PermutationBase<Derived> > >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/PermutationMatrix.h	/^struct traits<permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/ProductBase.h	/^struct traits<ProductBase<Derived,_Lhs,_Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/Ref.h	/^struct traits<Ref<_PlainObjectType, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Ref.h	/^struct traits<RefBase<Derived> > : public traits<Derived> {};$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Replicate.h	/^struct traits<Replicate<MatrixType,RowFactor,ColFactor> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/ReturnByValue.h	/^struct traits<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Reverse.h	/^struct traits<Reverse<MatrixType, Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Select.h	/^struct traits<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/SelfAdjointView.h	/^struct traits<SelfAdjointView<MatrixType, UpLo> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/SelfCwiseBinaryOp.h	/^struct traits<SelfCwiseBinaryOp<BinaryOp,Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/SolveTriangular.h	/^struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/Swap.h	/^struct traits<SwapWrapper<ExpressionType> > : traits<ExpressionType> {};$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Transpose.h	/^struct traits<Transpose<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/Transpositions.h	/^struct traits<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/Transpositions.h	/^struct traits<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/Transpositions.h	/^struct traits<TranspositionsWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/Transpositions.h	/^struct traits<transposition_matrix_product_retval<TranspositionType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/TriangularMatrix.h	/^struct traits<TriangularView<MatrixType, _Mode> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/VectorBlock.h	/^struct traits<VectorBlock<VectorType, Size> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/VectorwiseOp.h	/^struct traits<PartialReduxExpr<MatrixType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/products/CoeffBasedProduct.h	/^struct traits<CoeffBasedProduct<LhsNested,RhsNested,NestingFlags> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Core/products/GeneralMatrixMatrix.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemmProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/products/SelfadjointMatrixMatrix.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/products/TriangularMatrixMatrix.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,true> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,true,Rhs,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Core/util/ForwardDeclarations.h	/^template<typename T> struct traits<const T> : traits<T> {};$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Eigen2Support/Minor.h	/^struct traits<Minor<MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Eigenvalues/HessenbergDecomposition.h	/^struct traits<HessenbergDecompositionMatrixHReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Eigenvalues/Tridiagonalization.h	/^struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Geometry/AngleAxis.h	/^template<typename _Scalar> struct traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Geometry/Homogeneous.h	/^struct traits<Homogeneous<MatrixType,Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Geometry/Homogeneous.h	/^struct traits<homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Geometry/Homogeneous.h	/^struct traits<homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Geometry/Quaternion.h	/^  struct traits<Map<Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Geometry/Quaternion.h	/^  struct traits<Map<const Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/Geometry/Quaternion.h	/^struct traits<Quaternion<_Scalar,_Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Geometry/Rotation2D.h	/^template<typename _Scalar> struct traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/Householder/HouseholderSequence.h	/^struct traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/IterativeLinearSolvers/BiCGSTAB.h	/^struct traits<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/IterativeLinearSolvers/ConjugateGradient.h	/^struct traits<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/LU/Inverse.h	/^struct traits<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/QR/FullPivHouseholderQR.h	/^struct traits<FullPivHouseholderQRMatrixQReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType, typename Derived> struct traits<SPQR_QProduct<SPQRType, Derived> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQTransposeReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType,int _UpLo, typename _Ordering> struct traits<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCore/MappedSparseMatrix.h	/^struct traits<MappedSparseMatrix<_Scalar, _Flags, _Index> > : traits<SparseMatrix<_Scalar, _Flags, _Index> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/SparseCore/SparseDenseProduct.h	/^struct traits<DenseTimeSparseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseDenseOuterProduct<Lhs,Rhs,Tr> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseTimeDenseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/SparseCore/SparseDiagonalProduct.h	/^struct traits<SparseDiagonalProduct<Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<const SparseMatrix<_Scalar, _Options, _Index>, DiagIndex> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCore/SparseMatrix.h	/^struct traits<SparseMatrix<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCore/SparsePermutation.h	/^struct traits<permut_sparsematrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCore/SparseProduct.h	/^struct traits<SparseSparseProduct<LhsNested, RhsNested> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCore/SparseSelfAdjointView.h	/^struct traits<DenseTimeSparseSelfAdjointProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointTimeDenseProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointView<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSymmetricPermutationProduct<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/SparseCore/SparseTriangularView.h	/^struct traits<SparseTriangularView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/SparseCore/SparseVector.h	/^struct traits<SparseVector<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseCore/SparseView.h	/^struct traits<SparseView<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	src/SparseQR/SparseQR.h	/^  template <typename SparseQRType, typename Derived> struct traits<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQTransposeReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/misc/Image.h	/^struct traits<image_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/misc/Kernel.h	/^struct traits<kernel_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/misc/Solve.h	/^struct traits<solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/misc/SparseSolve.h	/^struct traits<solve_retval_with_guess<DecompositionType, Rhs, Guess> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	src/misc/SparseSolve.h	/^struct traits<sparse_solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits::Ancestor	src/Core/CwiseBinaryOp.h	/^  typedef typename remove_all<Lhs>::type Ancestor;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CanVectorizeInner	src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner =    SameType$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::CanVectorizeLhs	src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::CanVectorizeRhs	src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeRhs = RhsRowMajor && (RhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>                   CholMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CholMatrixType	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>               CholMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CoeffReadCost	src/Core/BandMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::CoeffReadCost	src/Core/BandMatrix.h	/^    CoeffReadCost = internal::traits<_CoefficientsType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::CoeffReadCost	src/Core/CwiseBinaryOp.h	/^    CoeffReadCost = EIGEN_ADD_COST(Cost0,functor_traits<BinaryOp>::Cost)$/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::CoeffReadCost	src/Core/CwiseNullaryOp.h	/^    CoeffReadCost = functor_traits<NullaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon152
Eigen::internal::traits::CoeffReadCost	src/Core/CwiseUnaryOp.h	/^    CoeffReadCost = EIGEN_ADD_COST(_XprTypeNested::CoeffReadCost, functor_traits<UnaryOp>::Cost)$/;"	e	enum:Eigen::internal::traits::__anon153
Eigen::internal::traits::CoeffReadCost	src/Core/CwiseUnaryView.h	/^    CoeffReadCost = traits<_MatrixTypeNested>::CoeffReadCost + functor_traits<ViewOp>::Cost,$/;"	e	enum:Eigen::internal::traits::__anon154
Eigen::internal::traits::CoeffReadCost	src/Core/Diagonal.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::CoeffReadCost	src/Core/DiagonalProduct.h	/^    CoeffReadCost = EIGEN_ADD_COST(Cost0,DiagonalType::DiagonalVectorType::CoeffReadCost)$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::CoeffReadCost	src/Core/Matrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon282
Eigen::internal::traits::CoeffReadCost	src/Core/PermutationMatrix.h	/^    CoeffReadCost = _IndicesType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::CoeffReadCost	src/Core/ProductBase.h	/^    CoeffReadCost = 0 \/\/ FIXME why is it needed ?$/;"	e	enum:Eigen::internal::traits::__anon294
Eigen::internal::traits::CoeffReadCost	src/Core/Replicate.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon309
Eigen::internal::traits::CoeffReadCost	src/Core/Reverse.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon311
Eigen::internal::traits::CoeffReadCost	src/Core/Select.h	/^    CoeffReadCost = traits<typename remove_all<ConditionMatrixNested>::type>::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon313
Eigen::internal::traits::CoeffReadCost	src/Core/SelfAdjointView.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon314
Eigen::internal::traits::CoeffReadCost	src/Core/Transpose.h	/^    CoeffReadCost = MatrixTypeNestedPlain::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::CoeffReadCost	src/Core/TriangularMatrix.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon327
Eigen::internal::traits::CoeffReadCost	src/Core/VectorwiseOp.h	/^    CoeffReadCost = TraversalSize==Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon332
Eigen::internal::traits::CoeffReadCost	src/Core/products/CoeffBasedProduct.h	/^      CoeffReadCost = InnerSize == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::CoeffReadCost	src/Eigen2Support/Minor.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost \/\/ minor is used typically on tiny matrices,$/;"	e	enum:Eigen::internal::traits::__anon358
Eigen::internal::traits::CoeffReadCost	src/Geometry/Homogeneous.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon371
Eigen::internal::traits::CoeffReadCost	src/SparseCore/SparseDenseProduct.h	/^    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + NumTraits<Scalar>::MulCost$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::CoeffReadCost	src/SparseCore/SparseDiagonalProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon442
Eigen::internal::traits::CoeffReadCost	src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon445
Eigen::internal::traits::CoeffReadCost	src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost*10$/;"	e	enum:Eigen::internal::traits::__anon446
Eigen::internal::traits::CoeffReadCost	src/SparseCore/SparseProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::CoeffReadCost	src/SparseCore/SparseVector.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon456
Eigen::internal::traits::Coefficients	src/Geometry/Quaternion.h	/^    typedef Map<Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Coefficients	src/Geometry/Quaternion.h	/^    typedef Map<const Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Coefficients	src/Geometry/Quaternion.h	/^  typedef Matrix<_Scalar,4,1,_Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CoefficientsType	src/Core/BandMatrix.h	/^  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CoefficientsType	src/Core/BandMatrix.h	/^  typedef _CoefficientsType CoefficientsType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ColsAtCompileTime	src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::ColsAtCompileTime	src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::ColsAtCompileTime	src/Core/Block.h	/^    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::ColsAtCompileTime	src/Core/CwiseBinaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon150
Eigen::internal::traits::ColsAtCompileTime	src/Core/Diagonal.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::ColsAtCompileTime	src/Core/DiagonalMatrix.h	/^    ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
Eigen::internal::traits::ColsAtCompileTime	src/Core/DiagonalProduct.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::ColsAtCompileTime	src/Core/Matrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon282
Eigen::internal::traits::ColsAtCompileTime	src/Core/PermutationMatrix.h	/^    ColsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::ColsAtCompileTime	src/Core/ProductBase.h	/^    ColsAtCompileTime = traits<Rhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon294
Eigen::internal::traits::ColsAtCompileTime	src/Core/Replicate.h	/^    ColsAtCompileTime = ColFactor==Dynamic || int(MatrixType::ColsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon309
Eigen::internal::traits::ColsAtCompileTime	src/Core/Reverse.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon311
Eigen::internal::traits::ColsAtCompileTime	src/Core/Select.h	/^    ColsAtCompileTime = ConditionMatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
Eigen::internal::traits::ColsAtCompileTime	src/Core/Transpose.h	/^    ColsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::ColsAtCompileTime	src/Core/VectorwiseOp.h	/^    ColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon331
Eigen::internal::traits::ColsAtCompileTime	src/Core/products/CoeffBasedProduct.h	/^      ColsAtCompileTime = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::ColsAtCompileTime	src/Eigen2Support/Minor.h	/^    ColsAtCompileTime = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon358
Eigen::internal::traits::ColsAtCompileTime	src/Geometry/Homogeneous.h	/^    ColsAtCompileTime = Direction==Horizontal ? ColsPlusOne : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon371
Eigen::internal::traits::ColsAtCompileTime	src/Householder/HouseholderSequence.h	/^    ColsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon393
Eigen::internal::traits::ColsAtCompileTime	src/SparseCore/SparseDenseProduct.h	/^    ColsAtCompileTime    = Tr ? int(traits<Lhs>::ColsAtCompileTime)     : int(traits<Rhs>::ColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::ColsAtCompileTime	src/SparseCore/SparseDiagonalProduct.h	/^    ColsAtCompileTime = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon442
Eigen::internal::traits::ColsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon446
Eigen::internal::traits::ColsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon445
Eigen::internal::traits::ColsAtCompileTime	src/SparseCore/SparseProduct.h	/^    ColsAtCompileTime    = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::ColsAtCompileTime	src/SparseCore/SparseVector.h	/^    ColsAtCompileTime = IsColVector ? 1 : Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon456
Eigen::internal::traits::ColsPlusOne	src/Geometry/Homogeneous.h	/^    ColsPlusOne = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon371
Eigen::internal::traits::ConditionMatrixNested	src/Core/Select.h	/^  typedef typename ConditionMatrixType::Nested ConditionMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Cost0	src/Core/CwiseBinaryOp.h	/^    Cost0 = EIGEN_ADD_COST(LhsCoeffReadCost,RhsCoeffReadCost),$/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::Cost0	src/Core/DiagonalProduct.h	/^    Cost0 = EIGEN_ADD_COST(NumTraits<Scalar>::MulCost, MatrixType::CoeffReadCost),$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::CostOpType	src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,TraversalSize> CostOpType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CostOpType	src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::DataRowsAtCompileTime	src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::DataRowsAtCompileTime	src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::DenseMatrixType	src/Core/SelfAdjointView.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::DenseMatrixType	src/Core/TriangularMatrix.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::DiagonalVectorType	src/Core/DiagonalMatrix.h	/^  typedef Matrix<_Scalar,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::DiagonalVectorType	src/Core/DiagonalMatrix.h	/^  typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ElseMatrixNested	src/Core/Select.h	/^  typedef typename ElseMatrixType::Nested ElseMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::EvalToRowMajor	src/Core/products/CoeffBasedProduct.h	/^      EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::EvalToRowMajor	src/SparseCore/SparseProduct.h	/^    EvalToRowMajor = (RhsFlags & LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::ExpressionType	src/Core/SelfAdjointView.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ExpressionType	src/Core/TriangularMatrix.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Factor	src/Core/Replicate.h	/^    Factor = (RowFactor==Dynamic || ColFactor==Dynamic) ? Dynamic : RowFactor*ColFactor$/;"	e	enum:Eigen::internal::traits::__anon308
Eigen::internal::traits::Flags	src/Core/ArrayWrapper.h	/^    Flags = Flags0 & ~NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon128
Eigen::internal::traits::Flags	src/Core/ArrayWrapper.h	/^    Flags = Flags0 & ~NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon129
Eigen::internal::traits::Flags	src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::Flags	src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::Flags	src/Core/Block.h	/^    Flags = Flags0 | FlagsLinearAccessBit | FlagsLvalueBit | FlagsRowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::Flags	src/Core/CwiseBinaryOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::Flags	src/Core/CwiseNullaryOp.h	/^    Flags = (traits<PlainObjectType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon152
Eigen::internal::traits::Flags	src/Core/CwiseUnaryOp.h	/^    Flags = _XprTypeNested::Flags & ($/;"	e	enum:Eigen::internal::traits::__anon153
Eigen::internal::traits::Flags	src/Core/CwiseUnaryView.h	/^    Flags = (traits<_MatrixTypeNested>::Flags & (HereditaryBits | LvalueBit | LinearAccessBit | DirectAccessBit)),$/;"	e	enum:Eigen::internal::traits::__anon154
Eigen::internal::traits::Flags	src/Core/Diagonal.h	/^    Flags = (unsigned int)_MatrixTypeNested::Flags & (HereditaryBits | LinearAccessBit | MaskLvalueBit | DirectAccessBit) & ~RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::Flags	src/Core/DiagonalMatrix.h	/^    Flags =  traits<DiagonalVectorType>::Flags & LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon165
Eigen::internal::traits::Flags	src/Core/DiagonalMatrix.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon164
Eigen::internal::traits::Flags	src/Core/DiagonalProduct.h	/^    Flags = ((HereditaryBits|_LinearAccessMask|AlignedBit) & (unsigned int)(MatrixType::Flags)) | (_Vectorizable ? PacketAccessBit : 0),\/\/(int(MatrixType::Flags)&int(DiagonalType::DiagonalVectorType::Flags)&AlignedBit),$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::Flags	src/Core/Flagged.h	/^  enum { Flags = (ExpressionType::Flags | Added) & ~Removed };$/;"	e	enum:Eigen::internal::traits::__anon167
Eigen::internal::traits::Flags	src/Core/Map.h	/^    Flags = KeepsPacketAccess ? int(Flags3) : (int(Flags3) & ~PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::Flags	src/Core/Matrix.h	/^    Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,$/;"	e	enum:Eigen::internal::traits::__anon282
Eigen::internal::traits::Flags	src/Core/PermutationMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::Flags	src/Core/ProductBase.h	/^    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0)$/;"	e	enum:Eigen::internal::traits::__anon294
Eigen::internal::traits::Flags	src/Core/Ref.h	/^    Flags = traits<Map<_PlainObjectType, _Options, _StrideType> >::Flags | NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon306
Eigen::internal::traits::Flags	src/Core/Replicate.h	/^    Flags = (_MatrixTypeNested::Flags & HereditaryBits & ~RowMajorBit) | (IsRowMajor ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon309
Eigen::internal::traits::Flags	src/Core/ReturnByValue.h	/^    Flags = (traits<typename traits<Derived>::ReturnType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon310
Eigen::internal::traits::Flags	src/Core/Reverse.h	/^    Flags = int(_MatrixTypeNested::Flags) & (HereditaryBits | LvalueBit | PacketAccessBit | LinearAccess),$/;"	e	enum:Eigen::internal::traits::__anon311
Eigen::internal::traits::Flags	src/Core/Select.h	/^    Flags = (unsigned int)ThenMatrixType::Flags & ElseMatrixType::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon313
Eigen::internal::traits::Flags	src/Core/SelfAdjointView.h	/^    Flags =  MatrixTypeNestedCleaned::Flags & (HereditaryBits)$/;"	e	enum:Eigen::internal::traits::__anon314
Eigen::internal::traits::Flags	src/Core/SelfCwiseBinaryOp.h	/^    Flags = traits<CwiseBinaryOp<BinaryOp,Lhs,Rhs> >::Flags | (Lhs::Flags&DirectAccessBit) | (Lhs::Flags&LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon318
Eigen::internal::traits::Flags	src/Core/Transpose.h	/^    Flags = Flags1 ^ RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::Flags	src/Core/TriangularMatrix.h	/^    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit))) | Mode,$/;"	e	enum:Eigen::internal::traits::__anon327
Eigen::internal::traits::Flags	src/Core/VectorwiseOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (RowsAtCompileTime == 1 ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon331
Eigen::internal::traits::Flags	src/Core/products/CoeffBasedProduct.h	/^      Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::Flags	src/Eigen2Support/Minor.h	/^    Flags = _MatrixTypeNested::Flags & (HereditaryBits | LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon358
Eigen::internal::traits::Flags	src/Geometry/Homogeneous.h	/^    Flags = ColsAtCompileTime==1 ? (TmpFlags & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon371
Eigen::internal::traits::Flags	src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon378
Eigen::internal::traits::Flags	src/Geometry/Quaternion.h	/^    Flags = IsAligned ? (AlignedBit | LvalueBit) : LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon376
Eigen::internal::traits::Flags	src/Householder/HouseholderSequence.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon393
Eigen::internal::traits::Flags	src/SparseCore/SparseDenseProduct.h	/^    Flags = Tr ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::Flags	src/SparseCore/SparseDiagonalProduct.h	/^    Flags = (SparseFlags&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon442
Eigen::internal::traits::Flags	src/SparseCore/SparseMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon446
Eigen::internal::traits::Flags	src/SparseCore/SparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon445
Eigen::internal::traits::Flags	src/SparseCore/SparseProduct.h	/^    Flags = (int(LhsFlags | RhsFlags) & HereditaryBits & RemovedBits)$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::Flags	src/SparseCore/SparseVector.h	/^    Flags = _Options | NestByRefBit | LvalueBit | (IsColVector ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon456
Eigen::internal::traits::Flags	src/SparseCore/SparseView.h	/^    Flags = int(traits<MatrixType>::Flags) & (RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon460
Eigen::internal::traits::Flags0	src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon128
Eigen::internal::traits::Flags0	src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon129
Eigen::internal::traits::Flags0	src/Core/Block.h	/^    Flags0 = traits<XprType>::Flags & ( (HereditaryBits & ~RowMajorBit) |$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::Flags0	src/Core/CwiseBinaryOp.h	/^    Flags0 = (int(LhsFlags) | int(RhsFlags)) & ($/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::Flags0	src/Core/Map.h	/^    Flags0 = TraitsBase::Flags & (~NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::Flags0	src/Core/Transpose.h	/^    Flags0 = MatrixTypeNestedPlain::Flags & ~(LvalueBit | NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::Flags0	src/Core/VectorwiseOp.h	/^    Flags0 = (unsigned int)_MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon331
Eigen::internal::traits::Flags1	src/Core/Map.h	/^    Flags1 = IsAligned ? (int(Flags0) | AlignedBit) : (int(Flags0) & ~AlignedBit),$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::Flags1	src/Core/Transpose.h	/^    Flags1 = Flags0 | FlagsLvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::Flags2	src/Core/Map.h	/^    Flags2 = (bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime))$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::Flags3	src/Core/Map.h	/^    Flags3 = is_lvalue<PlainObjectType>::value ? int(Flags2) : (int(Flags2) & ~LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::FlagsLinearAccessBit	src/Core/Block.h	/^    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1 || (InnerPanel && (traits<XprType>::Flags&LinearAccessBit))) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::FlagsLvalueBit	src/Core/Block.h	/^    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::FlagsLvalueBit	src/Core/Transpose.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::FlagsRowMajorBit	src/Core/Block.h	/^    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::HasNoInnerStride	src/Core/Map.h	/^    HasNoInnerStride = InnerStrideAtCompileTime == 1,$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::HasNoOuterStride	src/Core/Map.h	/^    HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::HasNoStride	src/Core/Map.h	/^    HasNoStride = HasNoInnerStride && HasNoOuterStride,$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::HasSameStorageOrderAsXprType	src/Core/Block.h	/^    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::Index	src/Core/BandMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/CwiseBinaryOp.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/DiagonalMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/Map.h	/^  typedef typename PlainObjectType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/Matrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/PermutationMatrix.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/ProductBase.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/Transpositions.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/Transpositions.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Core/products/CoeffBasedProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                              Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                          Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseCore/SparseDiagonalProduct.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseCore/SparseMatrix.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseCore/SparseProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseCore/SparseVector.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	src/Core/PermutationMatrix.h	/^  typedef Map<const Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	src/Core/PermutationMatrix.h	/^  typedef Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	src/Core/PermutationMatrix.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	src/Core/Transpositions.h	/^  typedef Map<const Matrix<Index,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	src/Core/Transpositions.h	/^  typedef Matrix<Index, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	src/Core/Transpositions.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::InnerSize	src/Core/Block.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::InnerSize	src/Core/products/CoeffBasedProduct.h	/^      InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::InnerSize	src/SparseCore/SparseProduct.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::InnerStrideAtCompileTime	src/Core/Block.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::InnerStrideAtCompileTime	src/Core/CwiseUnaryView.h	/^    InnerStrideAtCompileTime = MatrixTypeInnerStride == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon154
Eigen::internal::traits::InnerStrideAtCompileTime	src/Core/Diagonal.h	/^    InnerStrideAtCompileTime = MatrixTypeOuterStride == Dynamic ? Dynamic : MatrixTypeOuterStride+1,$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::InnerStrideAtCompileTime	src/Core/Map.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::InnerStrideAtCompileTime	src/Core/Matrix.h	/^    InnerStrideAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon282
Eigen::internal::traits::InnerStrideAtCompileTime	src/Core/SelfCwiseBinaryOp.h	/^    InnerStrideAtCompileTime = Lhs::InnerStrideAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon318
Eigen::internal::traits::InnerStrideAtCompileTime	src/Core/Transpose.h	/^    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::InputScalar	src/Core/VectorwiseOp.h	/^  typedef typename MatrixType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IsAligned	src/Core/Map.h	/^    IsAligned = bool(EIGEN_ALIGN) && ((int(MapOptions)&Aligned)==Aligned),$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::IsAligned	src/Geometry/Quaternion.h	/^    IsAligned = internal::traits<Coefficients>::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::traits::__anon376
Eigen::internal::traits::IsColVector	src/SparseCore/SparseVector.h	/^    IsColVector = (_Options & RowMajorBit) ? 0 : 1,$/;"	e	enum:Eigen::internal::traits::__anon456
Eigen::internal::traits::IsDense	src/Core/Block.h	/^    IsDense = is_same<StorageKind,Dense>::value,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::IsDynamicSize	src/Core/Map.h	/^    IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::IsRowMajor	src/Core/Block.h	/^    IsRowMajor = (IsDense&&MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::IsRowMajor	src/Core/Replicate.h	/^    IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1$/;"	e	enum:Eigen::internal::traits::__anon309
Eigen::internal::traits::KeepsPacketAccess	src/Core/Map.h	/^    KeepsPacketAccess = bool(HasNoInnerStride)$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::Lhs	src/Core/ProductBase.h	/^  typedef typename remove_all<_Lhs>::type Lhs;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsCoeffReadCost	src/Core/CwiseBinaryOp.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::LhsCoeffReadCost	src/Core/products/CoeffBasedProduct.h	/^      LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::LhsCoeffReadCost	src/SparseCore/SparseDenseProduct.h	/^    LhsCoeffReadCost = traits<_LhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::LhsCoeffReadCost	src/SparseCore/SparseProduct.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::LhsFlags	src/Core/CwiseBinaryOp.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::LhsFlags	src/Core/products/CoeffBasedProduct.h	/^      LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::LhsFlags	src/SparseCore/SparseProduct.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::LhsMatrixType	src/Geometry/Homogeneous.h	/^  typedef typename take_matrix_for_product<Lhs>::type LhsMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsMatrixTypeCleaned	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsNested	src/Core/CwiseBinaryOp.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsNested	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsRowMajor	src/Core/products/CoeffBasedProduct.h	/^      LhsRowMajor = LhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::LinearAccess	src/Core/Reverse.h	/^    LinearAccess = ( (Direction==BothDirections) && (int(_MatrixTypeNested::Flags)&PacketAccessBit) )$/;"	e	enum:Eigen::internal::traits::__anon311
Eigen::internal::traits::MaskAlignedBit	src/Core/Block.h	/^    MaskAlignedBit = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic) && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % 16) == 0)) ? AlignedBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::MaskLvalueBit	src/Core/Diagonal.h	/^    MaskLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::MaskPacketAccessBit	src/Core/Block.h	/^    MaskPacketAccessBit = (InnerSize == Dynamic || (InnerSize % packet_traits<Scalar>::size) == 0)$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::MatrixCols	src/Core/Block.h	/^    MatrixCols = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::MatrixL	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::Lower>  MatrixL;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixL	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::UnitLower>  MatrixL;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixRows	src/Core/Block.h	/^    MatrixRows = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::MatrixType	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	src/misc/Kernel.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	src/misc/Solve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	src/misc/SparseSolve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeCleaned	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeInnerStride	src/Core/CwiseUnaryView.h	/^    MatrixTypeInnerStride =  inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon154
Eigen::internal::traits::MatrixTypeNested	src/Core/CwiseUnaryView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/Core/Diagonal.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/Core/Replicate.h	/^  typedef typename nested<MatrixType,Factor>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/Core/Reverse.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/Core/SelfAdjointView.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/Core/Transpose.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/Core/TriangularMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/Core/VectorwiseOp.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/Eigen2Support/Minor.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/Geometry/Homogeneous.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	src/SparseCore/SparseMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNestedCleaned	src/Core/SelfAdjointView.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNestedCleaned	src/Core/TriangularMatrix.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNestedCleaned	src/SparseCore/SparsePermutation.h	/^  typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNestedNonRef	src/Core/TriangularMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNestedPlain	src/Core/Transpose.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeOuterStride	src/Core/Diagonal.h	/^    MatrixTypeOuterStride = outer_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::MatrixU	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixU	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::Upper>   MatrixU;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/Block.h	/^    MaxColsAtCompileTime = BlockCols==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/CwiseBinaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon150
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/Diagonal.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/DiagonalMatrix.h	/^    MaxColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/DiagonalProduct.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/Matrix.h	/^    MaxColsAtCompileTime = _MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon282
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/PermutationMatrix.h	/^    MaxColsAtCompileTime = IndicesType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/ProductBase.h	/^    MaxColsAtCompileTime = traits<Rhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon294
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/Replicate.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon309
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/Reverse.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon311
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/Select.h	/^    MaxColsAtCompileTime = ConditionMatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/Transpose.h	/^    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/VectorwiseOp.h	/^    MaxColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon331
Eigen::internal::traits::MaxColsAtCompileTime	src/Core/products/CoeffBasedProduct.h	/^      MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::MaxColsAtCompileTime	src/Eigen2Support/Minor.h	/^    MaxColsAtCompileTime = (MatrixType::MaxColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon358
Eigen::internal::traits::MaxColsAtCompileTime	src/Geometry/Homogeneous.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon371
Eigen::internal::traits::MaxColsAtCompileTime	src/Householder/HouseholderSequence.h	/^    MaxColsAtCompileTime = MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon393
Eigen::internal::traits::MaxColsAtCompileTime	src/SparseCore/SparseDenseProduct.h	/^    MaxColsAtCompileTime = Tr ? int(traits<Lhs>::MaxColsAtCompileTime)  : int(traits<Rhs>::MaxColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::MaxColsAtCompileTime	src/SparseCore/SparseDiagonalProduct.h	/^    MaxColsAtCompileTime = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon442
Eigen::internal::traits::MaxColsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon446
Eigen::internal::traits::MaxColsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon445
Eigen::internal::traits::MaxColsAtCompileTime	src/SparseCore/SparseProduct.h	/^    MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::MaxColsAtCompileTime	src/SparseCore/SparseVector.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon456
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/Block.h	/^    MaxRowsAtCompileTime = BlockRows==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/CwiseBinaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon150
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/Diagonal.h	/^    MaxRowsAtCompileTime = int(MatrixType::MaxSizeAtCompileTime) == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/DiagonalMatrix.h	/^    MaxRowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/DiagonalProduct.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/Matrix.h	/^    MaxRowsAtCompileTime = _MaxRows,$/;"	e	enum:Eigen::internal::traits::__anon282
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/PermutationMatrix.h	/^    MaxRowsAtCompileTime = IndicesType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/ProductBase.h	/^    MaxRowsAtCompileTime = traits<Lhs>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon294
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/Replicate.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon309
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/Reverse.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon311
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/Select.h	/^    MaxRowsAtCompileTime = ConditionMatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/Transpose.h	/^    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/VectorwiseOp.h	/^    MaxRowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon331
Eigen::internal::traits::MaxRowsAtCompileTime	src/Core/products/CoeffBasedProduct.h	/^      MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::MaxRowsAtCompileTime	src/Eigen2Support/Minor.h	/^    MaxRowsAtCompileTime = (MatrixType::MaxRowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon358
Eigen::internal::traits::MaxRowsAtCompileTime	src/Geometry/Homogeneous.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon371
Eigen::internal::traits::MaxRowsAtCompileTime	src/Householder/HouseholderSequence.h	/^    MaxRowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon393
Eigen::internal::traits::MaxRowsAtCompileTime	src/SparseCore/SparseDenseProduct.h	/^    MaxRowsAtCompileTime = Tr ? int(traits<Rhs>::MaxRowsAtCompileTime)  : int(traits<Lhs>::MaxRowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::MaxRowsAtCompileTime	src/SparseCore/SparseDiagonalProduct.h	/^    MaxRowsAtCompileTime = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon442
Eigen::internal::traits::MaxRowsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon445
Eigen::internal::traits::MaxRowsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon446
Eigen::internal::traits::MaxRowsAtCompileTime	src/SparseCore/SparseProduct.h	/^    MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::MaxRowsAtCompileTime	src/SparseCore/SparseVector.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon456
Eigen::internal::traits::Mode	src/Core/SelfAdjointView.h	/^    Mode = UpLo | SelfAdjoint,$/;"	e	enum:Eigen::internal::traits::__anon314
Eigen::internal::traits::Mode	src/Core/TriangularMatrix.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::internal::traits::__anon327
Eigen::internal::traits::MoveOuter	src/SparseCore/SparsePermutation.h	/^    MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::traits::__anon449
Eigen::internal::traits::Options	src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::Options	src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::Options	src/Core/Map.h	/^  enum { Options }; \/\/ Expressions don't have Options$/;"	e	enum:Eigen::internal::traits::__anon275
Eigen::internal::traits::Options	src/Core/Matrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon282
Eigen::internal::traits::Options	src/Core/Ref.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon306
Eigen::internal::traits::OrderingType	src/SparseCholesky/SimplicialCholesky.h	/^  typedef _Ordering OrderingType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::OuterStrideAtCompileTime	src/Core/Block.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::OuterStrideAtCompileTime	src/Core/CwiseUnaryView.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon154
Eigen::internal::traits::OuterStrideAtCompileTime	src/Core/Diagonal.h	/^    OuterStrideAtCompileTime = 0$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::OuterStrideAtCompileTime	src/Core/Map.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon274
Eigen::internal::traits::OuterStrideAtCompileTime	src/Core/Matrix.h	/^    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon282
Eigen::internal::traits::OuterStrideAtCompileTime	src/Core/SelfCwiseBinaryOp.h	/^    OuterStrideAtCompileTime = Lhs::OuterStrideAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon318
Eigen::internal::traits::OuterStrideAtCompileTime	src/Core/Transpose.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::PlainObject	src/Geometry/Quaternion.h	/^  typedef Quaternion<_Scalar,_Options> PlainObject;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::PlainObjectType	src/Core/Ref.h	/^  typedef _PlainObjectType PlainObjectType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Preconditioner	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Preconditioner	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::RemovedBits	src/SparseCore/SparseProduct.h	/^    RemovedBits = ~(EvalToRowMajor ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::ReturnType	src/Core/PermutationMatrix.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/Core/SolveTriangular.h	/^  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/Core/Transpositions.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/Eigenvalues/HessenbergDecomposition.h	/^  typedef MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/Geometry/Homogeneous.h	/^                 MatrixTypeCleaned::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/Geometry/Homogeneous.h	/^                 Rhs::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/LU/Inverse.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename SPQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/SparseCore/SparsePermutation.h	/^        SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,Index> >::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/SparseQR/SparseQR.h	/^    typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/SparseQR/SparseQR.h	/^    typedef typename SparseQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/misc/Image.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/misc/Kernel.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/misc/Solve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/misc/SparseSolve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	src/misc/SparseSolve.h	/^  typedef SparseMatrix<typename Rhs::Scalar, Rhs::Options, typename Rhs::Index> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Rhs	src/Core/ProductBase.h	/^  typedef typename remove_all<_Rhs>::type Rhs;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::RhsCoeffReadCost	src/Core/CwiseBinaryOp.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::RhsCoeffReadCost	src/Core/products/CoeffBasedProduct.h	/^      RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::RhsCoeffReadCost	src/SparseCore/SparseDenseProduct.h	/^    RhsCoeffReadCost = traits<_RhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::RhsCoeffReadCost	src/SparseCore/SparseProduct.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::RhsFlags	src/Core/CwiseBinaryOp.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::RhsFlags	src/Core/products/CoeffBasedProduct.h	/^      RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::RhsFlags	src/SparseCore/SparseProduct.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::RhsNested	src/Core/CwiseBinaryOp.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::RhsNested	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::RhsRowMajor	src/Core/products/CoeffBasedProduct.h	/^      RhsRowMajor = RhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::RowsAtCompileTime	src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::RowsAtCompileTime	src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::RowsAtCompileTime	src/Core/Block.h	/^    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::RowsAtCompileTime	src/Core/CwiseBinaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon150
Eigen::internal::traits::RowsAtCompileTime	src/Core/Diagonal.h	/^    RowsAtCompileTime = (int(DiagIndex) == DynamicIndex || int(MatrixType::SizeAtCompileTime) == Dynamic) ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon161
Eigen::internal::traits::RowsAtCompileTime	src/Core/DiagonalMatrix.h	/^    RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
Eigen::internal::traits::RowsAtCompileTime	src/Core/DiagonalProduct.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::RowsAtCompileTime	src/Core/Matrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon282
Eigen::internal::traits::RowsAtCompileTime	src/Core/PermutationMatrix.h	/^    RowsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::RowsAtCompileTime	src/Core/ProductBase.h	/^    RowsAtCompileTime = traits<Lhs>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon294
Eigen::internal::traits::RowsAtCompileTime	src/Core/Replicate.h	/^    RowsAtCompileTime = RowFactor==Dynamic || int(MatrixType::RowsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon309
Eigen::internal::traits::RowsAtCompileTime	src/Core/Reverse.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon311
Eigen::internal::traits::RowsAtCompileTime	src/Core/Select.h	/^    RowsAtCompileTime = ConditionMatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
Eigen::internal::traits::RowsAtCompileTime	src/Core/Transpose.h	/^    RowsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon323
Eigen::internal::traits::RowsAtCompileTime	src/Core/VectorwiseOp.h	/^    RowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon331
Eigen::internal::traits::RowsAtCompileTime	src/Core/products/CoeffBasedProduct.h	/^      RowsAtCompileTime = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::RowsAtCompileTime	src/Eigen2Support/Minor.h	/^    RowsAtCompileTime = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon358
Eigen::internal::traits::RowsAtCompileTime	src/Geometry/Homogeneous.h	/^    RowsAtCompileTime = Direction==Vertical  ?  RowsPlusOne : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon371
Eigen::internal::traits::RowsAtCompileTime	src/Householder/HouseholderSequence.h	/^    RowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon393
Eigen::internal::traits::RowsAtCompileTime	src/SparseCore/SparseDenseProduct.h	/^    RowsAtCompileTime    = Tr ? int(traits<Rhs>::RowsAtCompileTime)     : int(traits<Lhs>::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::RowsAtCompileTime	src/SparseCore/SparseDiagonalProduct.h	/^    RowsAtCompileTime = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon442
Eigen::internal::traits::RowsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon445
Eigen::internal::traits::RowsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon446
Eigen::internal::traits::RowsAtCompileTime	src/SparseCore/SparseProduct.h	/^    RowsAtCompileTime    = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
Eigen::internal::traits::RowsAtCompileTime	src/SparseCore/SparseVector.h	/^    RowsAtCompileTime = IsColVector ? Dynamic : 1,$/;"	e	enum:Eigen::internal::traits::__anon456
Eigen::internal::traits::RowsPlusOne	src/Geometry/Homogeneous.h	/^    RowsPlusOne = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon371
Eigen::internal::traits::SameType	src/Core/CwiseBinaryOp.h	/^    SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::SameType	src/Core/products/CoeffBasedProduct.h	/^      SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::Scalar	src/Core/BandMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/Block.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/CwiseBinaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/CwiseUnaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/CwiseUnaryView.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/DiagonalProduct.h	/^  typedef typename scalar_product_traits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/Map.h	/^  typedef typename PlainObjectType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/Matrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/ProductBase.h	/^  typedef typename scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/Replicate.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/Reverse.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/Transpose.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::result_type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Core/products/CoeffBasedProduct.h	/^  typedef typename scalar_product_traits<typename _LhsNested::Scalar, typename _RhsNested::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                             Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                         Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/SparseCore/SparseDenseProduct.h	/^                                         typename traits<Rhs>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename _Lhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/SparseCore/SparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/SparseCore/SparseProduct.h	/^  typedef typename _LhsNested::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	src/SparseCore/SparseVector.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::SparseFlags	src/SparseCore/SparseDiagonalProduct.h	/^    SparseFlags = is_diagonal<_Lhs>::ret ? int(_Rhs::Flags) : int(_Lhs::Flags),$/;"	e	enum:Eigen::internal::traits::__anon442
Eigen::internal::traits::SrcStorageOrder	src/SparseCore/SparsePermutation.h	/^    SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon449
Eigen::internal::traits::StorageKind	src/Core/BandMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/Block.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/CwiseBinaryOp.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/Diagonal.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/DiagonalMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/Matrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/PermutationMatrix.h	/^  typedef PermutationStorage StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/ProductBase.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/Select.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Core/products/CoeffBasedProduct.h	/^                                           typename traits<_RhsNested>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Eigen2Support/Minor.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Geometry/Homogeneous.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseCore/SparseDenseProduct.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseCore/SparseDenseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseCore/SparseDiagonalProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseCore/SparseMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseCore/SparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseCore/SparseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseCore/SparseSelfAdjointView.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseCore/SparseVector.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseCore/SparseView.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageOrdersAgree	src/Core/CwiseBinaryOp.h	/^    StorageOrdersAgree = (int(Lhs::Flags)&RowMajorBit)==(int(Rhs::Flags)&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon151
Eigen::internal::traits::StrideType	src/Core/Ref.h	/^  typedef _StrideType StrideType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Subs	src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::Subs	src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::Supers	src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon144
Eigen::internal::traits::Supers	src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon145
Eigen::internal::traits::SupportedAccessPatterns	src/SparseCore/SparseMatrix.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon445
Eigen::internal::traits::SupportedAccessPatterns	src/SparseCore/SparseVector.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon456
Eigen::internal::traits::ThenMatrixNested	src/Core/Select.h	/^  typedef typename ThenMatrixType::Nested ThenMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::TmpFlags	src/Geometry/Homogeneous.h	/^    TmpFlags = _MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon371
Eigen::internal::traits::TraitsBase	src/Core/Map.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::TraitsBase	src/Geometry/Quaternion.h	/^    typedef traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> > TraitsBase;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::TraversalSize	src/Core/VectorwiseOp.h	/^    TraversalSize = Direction==Vertical ? MatrixType::RowsAtCompileTime :  MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon331
Eigen::internal::traits::UpLo	src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon425
Eigen::internal::traits::UpLo	src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon426
Eigen::internal::traits::UpLo	src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon427
Eigen::internal::traits::XprBase	src/Core/Array.h	/^  typedef ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > XprBase;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/Array.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/ArrayWrapper.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/ArrayWrapper.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/Block.h	/^  typedef typename traits<XprType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/CwiseBinaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/Matrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/ProductBase.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/Core/products/CoeffBasedProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/SparseCore/SparseDenseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/SparseCore/SparseDiagonalProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/SparseCore/SparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/SparseCore/SparseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	src/SparseCore/SparseVector.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprTypeIsRowMajor	src/Core/Block.h	/^    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::traits::__anon146
Eigen::internal::traits::XprTypeNested	src/Core/Block.h	/^  typedef typename nested<XprType>::type XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprTypeNested	src/Core/CwiseUnaryOp.h	/^  typedef typename XprType::Nested XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_Lhs	src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_LhsNested	src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_LhsNested	src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_LhsNested	src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_LhsNested	src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_LinearAccessMask	src/Core/DiagonalProduct.h	/^    _LinearAccessMask = (RowsAtCompileTime==1 || ColsAtCompileTime==1) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::_MatrixTypeNested	src/Core/CwiseUnaryView.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	src/Core/Diagonal.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	src/Core/Replicate.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	src/Core/Reverse.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	src/Core/VectorwiseOp.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	src/Eigen2Support/Minor.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	src/Geometry/Homogeneous.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	src/SparseCore/SparseMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_Rhs	src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_RhsNested	src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_RhsNested	src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_RhsNested	src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_RhsNested	src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_SameTypes	src/Core/DiagonalProduct.h	/^    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::_ScalarAccessOnDiag	src/Core/DiagonalProduct.h	/^    _ScalarAccessOnDiag =  !((int(_StorageOrder) == ColMajor && int(ProductOrder) == OnTheLeft)$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::_StorageOrder	src/Core/DiagonalProduct.h	/^    _StorageOrder = MatrixType::Flags & RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::_Vectorizable	src/Core/DiagonalProduct.h	/^    _Vectorizable = bool(int(MatrixType::Flags)&PacketAccessBit) && _SameTypes && (_ScalarAccessOnDiag || (bool(int(DiagonalType::DiagonalVectorType::Flags)&PacketAccessBit))),$/;"	e	enum:Eigen::internal::traits::__anon166
Eigen::internal::traits::_XprTypeNested	src/Core/Block.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_XprTypeNested	src/Core/CwiseUnaryOp.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::getL	src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::traits	access:public	signature:(const MatrixType& m)
Eigen::internal::traits::getU	src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::traits	access:public	signature:(const MatrixType& m)
Eigen::internal::traits::match	src/Core/Ref.h	/^  template<typename Derived> struct match {$/;"	s	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::match::AlignmentMatch	src/Core/Ref.h	/^      AlignmentMatch = (_Options!=Aligned) || ((PlainObjectType::Flags&AlignedBit)==0) || ((traits<Derived>::Flags&AlignedBit)==AlignedBit),$/;"	e	enum:Eigen::internal::traits::match::__anon307
Eigen::internal::traits::match::HasDirectAccess	src/Core/Ref.h	/^      HasDirectAccess = internal::has_direct_access<Derived>::ret,$/;"	e	enum:Eigen::internal::traits::match::__anon307
Eigen::internal::traits::match::InnerStrideMatch	src/Core/Ref.h	/^      InnerStrideMatch = int(StrideType::InnerStrideAtCompileTime)==int(Dynamic)$/;"	e	enum:Eigen::internal::traits::match::__anon307
Eigen::internal::traits::match::MatchAtCompileTime	src/Core/Ref.h	/^      MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && AlignmentMatch && ScalarTypeMatch$/;"	e	enum:Eigen::internal::traits::match::__anon307
Eigen::internal::traits::match::OuterStrideMatch	src/Core/Ref.h	/^      OuterStrideMatch = Derived::IsVectorAtCompileTime$/;"	e	enum:Eigen::internal::traits::match::__anon307
Eigen::internal::traits::match::ScalarTypeMatch	src/Core/Ref.h	/^      ScalarTypeMatch = internal::is_same<typename PlainObjectType::Scalar, typename Derived::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::match::__anon307
Eigen::internal::traits::match::StorageOrderMatch	src/Core/Ref.h	/^      StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),$/;"	e	enum:Eigen::internal::traits::match::__anon307
Eigen::internal::traits::match::type	src/Core/Ref.h	/^    typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type;$/;"	t	struct:Eigen::internal::traits::match	access:public
Eigen::internal::transform_construct_from_matrix	src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_construct_from_matrix	src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_construct_from_matrix	src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_construct_from_matrix	src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_construct_from_matrix::run	src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix	access:public	signature:(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)
Eigen::internal::transform_construct_from_matrix::run	src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix	access:public	signature:(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)
Eigen::internal::transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl::MatrixType	src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_left_product_impl::ResultType	src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Projective,Options> ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_left_product_impl::ResultType	src/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_left_product_impl::TransformType	src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,AffineCompact,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_left_product_impl::TransformType	src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_left_product_impl::run	src/Geometry/Transform.h	/^  static ResultType run(const Other& other, const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl	access:public	signature:(const Other& other, const TransformType& tr)
Eigen::internal::transform_left_product_impl::run	src/Geometry/Transform.h	/^  static ResultType run(const Other& other,const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl	access:public	signature:(const Other& other,const TransformType& tr)
Eigen::internal::transform_make_affine	src/Geometry/Transform.h	/^struct transform_make_affine$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_make_affine	src/Geometry/Transform.h	/^struct transform_make_affine<AffineCompact>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_make_affine::run	src/Geometry/Transform.h	/^  static void run(MatrixType &mat)$/;"	f	struct:Eigen::internal::transform_make_affine	access:public	signature:(MatrixType &mat)
Eigen::internal::transform_make_affine::run	src/Geometry/Transform.h	/^  template<typename MatrixType> static void run(MatrixType &) { }$/;"	f	struct:Eigen::internal::transform_make_affine	access:public	signature:(MatrixType &)
Eigen::internal::transform_product_result	src/Geometry/Transform.h	/^struct transform_product_result$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_product_result::Mode	src/Geometry/Transform.h	/^    Mode =$/;"	e	enum:Eigen::internal::transform_product_result::__anon386
Eigen::internal::transform_right_product_impl	src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 0 >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_right_product_impl	src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 1 >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_right_product_impl	src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2 >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_right_product_impl::Dim	src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon387
Eigen::internal::transform_right_product_impl::Dim	src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon388
Eigen::internal::transform_right_product_impl::HDim	src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon387
Eigen::internal::transform_right_product_impl::HDim	src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon388
Eigen::internal::transform_right_product_impl::OtherCols	src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon387
Eigen::internal::transform_right_product_impl::OtherCols	src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon388
Eigen::internal::transform_right_product_impl::OtherRows	src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon387
Eigen::internal::transform_right_product_impl::OtherRows	src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon388
Eigen::internal::transform_right_product_impl::ResultType	src/Geometry/Transform.h	/^  typedef typename MatrixType::PlainObject ResultType;$/;"	t	struct:Eigen::internal::transform_right_product_impl	access:public
Eigen::internal::transform_right_product_impl::run	src/Geometry/Transform.h	/^  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)$/;"	f	struct:Eigen::internal::transform_right_product_impl	access:public	signature:(const TransformType& T, const MatrixType& other)
Eigen::internal::transform_take_affine_part	src/Geometry/Transform.h	/^struct transform_take_affine_part<Transform<Scalar,Dim,AffineCompact, Options> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_take_affine_part	src/Geometry/Transform.h	/^template<typename TransformType> struct transform_take_affine_part {$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_take_affine_part::AffinePart	src/Geometry/Transform.h	/^  typedef typename TransformType::AffinePart AffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
Eigen::internal::transform_take_affine_part::ConstAffinePart	src/Geometry/Transform.h	/^  typedef typename TransformType::ConstAffinePart ConstAffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
Eigen::internal::transform_take_affine_part::MatrixType	src/Geometry/Transform.h	/^  typedef typename Transform<Scalar,Dim,AffineCompact,Options>::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
Eigen::internal::transform_take_affine_part::MatrixType	src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
Eigen::internal::transform_take_affine_part::run	src/Geometry/Transform.h	/^  static inline AffinePart run(MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(MatrixType& m)
Eigen::internal::transform_take_affine_part::run	src/Geometry/Transform.h	/^  static inline ConstAffinePart run(const MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(const MatrixType& m)
Eigen::internal::transform_take_affine_part::run	src/Geometry/Transform.h	/^  static inline MatrixType& run(MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(MatrixType& m)
Eigen::internal::transform_take_affine_part::run	src/Geometry/Transform.h	/^  static inline const MatrixType& run(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(const MatrixType& m)
Eigen::internal::transform_traits	src/Geometry/Transform.h	/^struct transform_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_traits::Dim	src/Geometry/Transform.h	/^    Dim = Transform::Dim,$/;"	e	enum:Eigen::internal::transform_traits::__anon383
Eigen::internal::transform_traits::HDim	src/Geometry/Transform.h	/^    HDim = Transform::HDim,$/;"	e	enum:Eigen::internal::transform_traits::__anon383
Eigen::internal::transform_traits::IsProjective	src/Geometry/Transform.h	/^    IsProjective = (int(Mode)==int(Projective))$/;"	e	enum:Eigen::internal::transform_traits::__anon383
Eigen::internal::transform_traits::Mode	src/Geometry/Transform.h	/^    Mode = Transform::Mode,$/;"	e	enum:Eigen::internal::transform_traits::__anon383
Eigen::internal::transform_transform_product_impl	src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,AffineCompact,LhsOptions>,Transform<Scalar,Dim,Projective,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_transform_product_impl	src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,false >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_transform_product_impl	src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_transform_product_impl	src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,Projective,LhsOptions>,Transform<Scalar,Dim,AffineCompact,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_transform_product_impl::Lhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Lhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,LhsMode,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Lhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::ResultMode	src/Geometry/Transform.h	/^  enum { ResultMode = transform_product_result<LhsMode,RhsMode>::Mode };$/;"	e	enum:Eigen::internal::transform_transform_product_impl::__anon389
Eigen::internal::transform_transform_product_impl::ResultType	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::ResultType	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,ResultMode,LhsOptions> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Rhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Rhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Rhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,RhsMode,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::run	src/Geometry/Transform.h	/^  static ResultType run(const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::transform_transform_product_impl	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::internal::transposition_matrix_product_retval	src/Core/Transpositions.h	/^struct transposition_matrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::transposition_matrix_product_retval::Index	src/Core/Transpositions.h	/^    typedef typename TranspositionType::Index Index;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval	access:public
Eigen::internal::transposition_matrix_product_retval::MatrixTypeNestedCleaned	src/Core/Transpositions.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval	access:public
Eigen::internal::transposition_matrix_product_retval::cols	src/Core/Transpositions.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:() const
Eigen::internal::transposition_matrix_product_retval::evalTo	src/Core/Transpositions.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:(Dest& dst) const
Eigen::internal::transposition_matrix_product_retval::m_matrix	src/Core/Transpositions.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval	access:protected
Eigen::internal::transposition_matrix_product_retval::m_transpositions	src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval	access:protected
Eigen::internal::transposition_matrix_product_retval::rows	src/Core/Transpositions.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:() const
Eigen::internal::transposition_matrix_product_retval::transposition_matrix_product_retval	src/Core/Transpositions.h	/^    transposition_matrix_product_retval(const TranspositionType& tr, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:(const TranspositionType& tr, const MatrixType& matrix)
Eigen::internal::treePostorder	src/SparseCore/SparseColEtree.h	/^void treePostorder(Index n, IndexVector& parent, IndexVector& post)$/;"	f	namespace:Eigen::internal	signature:(Index n, IndexVector& parent, IndexVector& post)
Eigen::internal::triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Lower), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Upper), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Mode, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector::Index	src/Core/SelfAdjointView.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Eigen::internal::triangular_assignment_selector::Index	src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Eigen::internal::triangular_assignment_selector::Scalar	src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Eigen::internal::triangular_assignment_selector::col	src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon316
Eigen::internal::triangular_assignment_selector::col	src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon317
Eigen::internal::triangular_assignment_selector::col	src/Core/TriangularMatrix.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon329
Eigen::internal::triangular_assignment_selector::row	src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon316
Eigen::internal::triangular_assignment_selector::row	src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon317
Eigen::internal::triangular_assignment_selector::row	src/Core/TriangularMatrix.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon329
Eigen::internal::triangular_assignment_selector::run	src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::triangular_assignment_selector::run	src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::triangular_assignment_selector::run	src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::triangular_assignment_selector::run	src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::triangular_matrix_vector_product	src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_matrix_vector_product	src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_matrix_vector_product::HasUnitDiag	src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon54
Eigen::internal::triangular_matrix_vector_product::HasUnitDiag	src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon55
Eigen::internal::triangular_matrix_vector_product::HasZeroDiag	src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon54
Eigen::internal::triangular_matrix_vector_product::HasZeroDiag	src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon55
Eigen::internal::triangular_matrix_vector_product::IsLower	src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon54
Eigen::internal::triangular_matrix_vector_product::IsLower	src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon55
Eigen::internal::triangular_matrix_vector_product::ResScalar	src/Core/products/TriangularMatrixVector.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::triangular_matrix_vector_product	access:public
Eigen::internal::triangular_matrix_vector_product::run	src/Core/products/TriangularMatrixVector.h	/^  ::run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	class:Eigen::internal::triangular_matrix_vector_product	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, const ResScalar& alpha)
Eigen::internal::triangular_matrix_vector_product::run	src/Core/products/TriangularMatrixVector.h	/^  static EIGEN_DONT_INLINE  void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	p	struct:Eigen::internal::triangular_matrix_vector_product	access:public	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, const ResScalar& alpha)
Eigen::internal::triangular_matrix_vector_product::run	src/Core/products/TriangularMatrixVector.h	/^  static EIGEN_DONT_INLINE void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	p	struct:Eigen::internal::triangular_matrix_vector_product	access:public	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, const ResScalar& alpha)
Eigen::internal::triangular_matrix_vector_product_trmv	src/Core/products/TriangularMatrixVector_MKL.h	/^struct triangular_matrix_vector_product_trmv :$/;"	s	namespace:Eigen::internal	inherits:triangular_matrix_vector_product
Eigen::internal::triangular_solve_matrix	src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_matrix	src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_matrix	src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_matrix::run	src/Core/products/TriangularSolverMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	p	struct:Eigen::internal::triangular_solve_matrix	access:public	signature:( Index size, Index otherSize, const Scalar* _tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
Eigen::internal::triangular_solve_matrix::run	src/Core/products/TriangularSolverMatrix.h	/^  static void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix	access:public	signature:( Index size, Index cols, const Scalar* tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
Eigen::internal::triangular_solve_matrix::run	src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix	signature:( Index size, Index otherSize, const Scalar* _tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
Eigen::internal::triangular_solve_matrix::run	src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix	signature:( Index size, Index otherSize, const Scalar* _tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
Eigen::internal::triangular_solve_retval	src/Core/SolveTriangular.h	/^template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::triangular_solve_retval::Base	src/Core/SolveTriangular.h	/^  typedef ReturnByValue<triangular_solve_retval> Base;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Eigen::internal::triangular_solve_retval::Index	src/Core/SolveTriangular.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Eigen::internal::triangular_solve_retval::RhsNestedCleaned	src/Core/SolveTriangular.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Eigen::internal::triangular_solve_retval::cols	src/Core/SolveTriangular.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:() const
Eigen::internal::triangular_solve_retval::evalTo	src/Core/SolveTriangular.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::triangular_solve_retval::m_rhs	src/Core/SolveTriangular.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::triangular_solve_retval	access:protected
Eigen::internal::triangular_solve_retval::m_triangularMatrix	src/Core/SolveTriangular.h	/^    const TriangularType& m_triangularMatrix;$/;"	m	struct:Eigen::internal::triangular_solve_retval	access:protected
Eigen::internal::triangular_solve_retval::rows	src/Core/SolveTriangular.h	/^  inline Index rows() const { return m_rhs.rows(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:() const
Eigen::internal::triangular_solve_retval::triangular_solve_retval	src/Core/SolveTriangular.h	/^  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:(const TriangularType& tri, const Rhs& rhs)
Eigen::internal::triangular_solve_vector	src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_vector	src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_vector	src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_vector::IsLower	src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon56
Eigen::internal::triangular_solve_vector::IsLower	src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon57
Eigen::internal::triangular_solve_vector::run	src/Core/products/TriangularSolverVector.h	/^  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)$/;"	f	struct:Eigen::internal::triangular_solve_vector	access:public	signature:(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)
Eigen::internal::triangular_solver_selector	src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_selector	src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_selector	src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_selector	src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_selector::ActualLhsType	src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::ActualLhsType	src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::ExtractType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::Index	src/Core/SolveTriangular.h	/^  typedef typename Rhs::Index Index;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::LhsProductTraits	src/Core/SolveTriangular.h	/^  typedef blas_traits<Lhs> LhsProductTraits;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::LhsScalar	src/Core/SolveTriangular.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::MappedRhs	src/Core/SolveTriangular.h	/^  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::RhsScalar	src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::Scalar	src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::run	src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_selector	access:public	signature:(const Lhs& lhs, Rhs& rhs)
Eigen::internal::triangular_solver_unroller	src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_unroller	src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_unroller::I	src/Core/SolveTriangular.h	/^    I = IsLower ? Index : Size - Index - 1,$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon321
Eigen::internal::triangular_solver_unroller::IsLower	src/Core/SolveTriangular.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon321
Eigen::internal::triangular_solver_unroller::S	src/Core/SolveTriangular.h	/^    S = IsLower ? 0     : I+1$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon321
Eigen::internal::triangular_solver_unroller::run	src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_unroller	access:public	signature:(const Lhs& lhs, Rhs& rhs)
Eigen::internal::triangular_solver_unroller::run	src/Core/SolveTriangular.h	/^  static void run(const Lhs&, Rhs&) {}$/;"	f	struct:Eigen::internal::triangular_solver_unroller	access:public	signature:(const Lhs&, Rhs&)
Eigen::internal::tribb_kernel	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct tribb_kernel$/;"	s	namespace:Eigen::internal
Eigen::internal::tribb_kernel::BlockSize	src/Core/products/GeneralMatrixMatrixTriangular.h	/^    BlockSize  = EIGEN_PLAIN_ENUM_MAX(mr,nr)$/;"	e	enum:Eigen::internal::tribb_kernel::__anon45
Eigen::internal::tribb_kernel::ResScalar	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::tribb_kernel	access:public
Eigen::internal::tribb_kernel::Traits	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;$/;"	t	struct:Eigen::internal::tribb_kernel	access:public
Eigen::internal::tribb_kernel::operator ()	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, const ResScalar& alpha, RhsScalar* workspace)$/;"	f	struct:Eigen::internal::tribb_kernel	access:public	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, const ResScalar& alpha, RhsScalar* workspace)
Eigen::internal::tridiagonal_qr_step	src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)$/;"	f	namespace:Eigen::internal	signature:(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
Eigen::internal::tridiagonal_qr_step	src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n);$/;"	p	namespace:Eigen::internal	signature:(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
Eigen::internal::tridiagonalization_inplace	src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
Eigen::internal::tridiagonalization_inplace	src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& matA, CoeffVectorType& hCoeffs)
Eigen::internal::tridiagonalization_inplace	src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs);$/;"	p	namespace:Eigen::internal	signature:(MatrixType& matA, CoeffVectorType& hCoeffs)
Eigen::internal::tridiagonalization_inplace_selector	src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::tridiagonalization_inplace_selector	src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>$/;"	s	namespace:Eigen::internal
Eigen::internal::tridiagonalization_inplace_selector	src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,3,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::tridiagonalization_inplace_selector::CoeffVectorType	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::tridiagonalization_inplace_selector::HouseholderSequenceType	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::tridiagonalization_inplace_selector::Index	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::tridiagonalization_inplace_selector::RealScalar	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::tridiagonalization_inplace_selector::Scalar	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::tridiagonalization_inplace_selector::run	src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
Eigen::internal::tridiagonalization_inplace_selector::run	src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)
Eigen::internal::trmv_selector	src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::trmv_selector	src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::trmv_selector::run	src/Core/products/TriangularMatrixVector.h	/^  static void run(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, const typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar& alpha)$/;"	f	struct:Eigen::internal::trmv_selector	access:public	signature:(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, const typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar& alpha)
Eigen::internal::trsolve_traits	src/Core/SolveTriangular.h	/^class trsolve_traits$/;"	c	namespace:Eigen::internal
Eigen::internal::trsolve_traits::RhsIsVectorAtCompileTime	src/Core/SolveTriangular.h	/^      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1$/;"	e	enum:Eigen::internal::trsolve_traits::__anon319
Eigen::internal::trsolve_traits::RhsVectors	src/Core/SolveTriangular.h	/^      RhsVectors  = RhsIsVectorAtCompileTime ? 1 : Dynamic$/;"	e	enum:Eigen::internal::trsolve_traits::__anon320
Eigen::internal::trsolve_traits::Unrolling	src/Core/SolveTriangular.h	/^      Unrolling   = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)$/;"	e	enum:Eigen::internal::trsolve_traits::__anon320
Eigen::internal::true_type	src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::true_type::value	src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	e	enum:Eigen::internal::true_type::__anon94
Eigen::internal::umeyama_transform_matrix_type	src/Geometry/Umeyama.h	/^struct umeyama_transform_matrix_type$/;"	s	namespace:Eigen::internal
Eigen::internal::umeyama_transform_matrix_type::HomogeneousDimension	src/Geometry/Umeyama.h	/^    HomogeneousDimension = int(MinRowsAtCompileTime) == Dynamic ? Dynamic : int(MinRowsAtCompileTime)+1$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon391
Eigen::internal::umeyama_transform_matrix_type::MinRowsAtCompileTime	src/Geometry/Umeyama.h	/^    MinRowsAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, OtherMatrixType::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon391
Eigen::internal::umeyama_transform_matrix_type::type	src/Geometry/Umeyama.h	/^  > type;$/;"	t	struct:Eigen::internal::umeyama_transform_matrix_type	access:public
Eigen::internal::umfpack_helper_is_sparse_plain	src/UmfPackSupport/UmfPackSupport.h	/^  struct umfpack_helper_is_sparse_plain<MappedSparseMatrix<Scalar,Options,StorageIndex> >$/;"	s	namespace:Eigen::internal	inherits:true_type
Eigen::internal::umfpack_helper_is_sparse_plain	src/UmfPackSupport/UmfPackSupport.h	/^  struct umfpack_helper_is_sparse_plain<SparseMatrix<Scalar,Options,StorageIndex> >$/;"	s	namespace:Eigen::internal	inherits:true_type
Eigen::internal::umfpack_helper_is_sparse_plain	src/UmfPackSupport/UmfPackSupport.h	/^  template<typename T> struct umfpack_helper_is_sparse_plain : false_type {};$/;"	s	namespace:Eigen::internal	inherits:false_type
Eigen::internal::unaligned_assign_impl	src/Core/Assign.h	/^struct unaligned_assign_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::unaligned_assign_impl	src/Core/Assign.h	/^struct unaligned_assign_impl<false>$/;"	s	namespace:Eigen::internal
Eigen::internal::unaligned_assign_impl::run	src/Core/Assign.h	/^  static EIGEN_DONT_INLINE void run(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)$/;"	f	struct:Eigen::internal::unaligned_assign_impl	access:public	signature:(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)
Eigen::internal::unaligned_assign_impl::run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index) {}$/;"	f	struct:Eigen::internal::unaligned_assign_impl	access:public	signature:(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index)
Eigen::internal::unary_result_of_select	src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	s	namespace:Eigen::internal
Eigen::internal::unary_result_of_select	src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	s	namespace:Eigen::internal
Eigen::internal::unary_result_of_select	src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	s	namespace:Eigen::internal
Eigen::internal::unary_result_of_select::type	src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
Eigen::internal::unary_result_of_select::type	src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
Eigen::internal::unary_result_of_select::type	src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
Eigen::internal::unitOrthogonal_selector	src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::unitOrthogonal_selector	src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,2>$/;"	s	namespace:Eigen::internal
Eigen::internal::unitOrthogonal_selector	src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,3>$/;"	s	namespace:Eigen::internal
Eigen::internal::unitOrthogonal_selector::Index	src/Geometry/OrthoMethods.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unitOrthogonal_selector::RealScalar	src/Geometry/OrthoMethods.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unitOrthogonal_selector::Scalar	src/Geometry/OrthoMethods.h	/^  typedef typename traits<Derived>::Scalar Scalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unitOrthogonal_selector::Vector2	src/Geometry/OrthoMethods.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unitOrthogonal_selector::VectorType	src/Geometry/OrthoMethods.h	/^  typedef typename plain_matrix_type<Derived>::type VectorType;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unitOrthogonal_selector::run	src/Geometry/OrthoMethods.h	/^  static inline VectorType run(const Derived& src)$/;"	f	struct:Eigen::internal::unitOrthogonal_selector	access:public	signature:(const Derived& src)
Eigen::internal::unpacket_traits	src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits::size	src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon6
Eigen::internal::unpacket_traits::size	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon9
Eigen::internal::unpacket_traits::size	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon10
Eigen::internal::unpacket_traits::size	src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon12
Eigen::internal::unpacket_traits::size	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon15
Eigen::internal::unpacket_traits::size	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon16
Eigen::internal::unpacket_traits::size	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon20
Eigen::internal::unpacket_traits::size	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon18
Eigen::internal::unpacket_traits::size	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon28
Eigen::internal::unpacket_traits::size	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon27
Eigen::internal::unpacket_traits::size	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon29
Eigen::internal::unpacket_traits::type	src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::visitor_impl	src/Core/Visitor.h	/^struct visitor_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::visitor_impl	src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::visitor_impl	src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, Dynamic>$/;"	s	namespace:Eigen::internal
Eigen::internal::visitor_impl::Index	src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::visitor_impl	access:public
Eigen::internal::visitor_impl::col	src/Core/Visitor.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_impl::__anon336
Eigen::internal::visitor_impl::row	src/Core/Visitor.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::visitor_impl::__anon336
Eigen::internal::visitor_impl::run	src/Core/Visitor.h	/^  static inline void run(const Derived &mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl	access:public	signature:(const Derived &mat, Visitor& visitor)
Eigen::internal::visitor_impl::run	src/Core/Visitor.h	/^  static inline void run(const Derived& mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl	access:public	signature:(const Derived& mat, Visitor& visitor)
Eigen::internal::vld1_f32	src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_f32 (const float* x) { return ::vld1_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal	signature:(const float* x)
Eigen::internal::vld1q_f32	src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x4_t vld1q_f32(const float* x) { return ::vld1q_f32((const float32_t*)x); }$/;"	f	namespace:Eigen::internal	signature:(const float* x)
Eigen::internal::vml_assign_impl	src/Core/Assign_MKL.h	/^struct vml_assign_impl$/;"	s	namespace:Eigen::internal	inherits:assign_impl
Eigen::internal::vml_assign_impl	src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, InnerVectorizedTraversal>$/;"	s	namespace:Eigen::internal
Eigen::internal::vml_assign_impl	src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, LinearVectorizedTraversal>$/;"	s	namespace:Eigen::internal
Eigen::internal::vml_assign_impl::Index	src/Core/Assign_MKL.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::vml_assign_impl	access:public
Eigen::internal::vml_assign_impl::Scalar	src/Core/Assign_MKL.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::vml_assign_impl	access:public
Eigen::internal::vml_assign_impl::run	src/Core/Assign_MKL.h	/^  static inline void run(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)$/;"	f	struct:Eigen::internal::vml_assign_impl	access:public	signature:(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)
Eigen::internal::vml_assign_traits	src/Core/Assign_MKL.h	/^class vml_assign_traits$/;"	c	namespace:Eigen::internal
Eigen::internal::vml_assign_traits::DstHasDirectAccess	src/Core/Assign_MKL.h	/^      DstHasDirectAccess = Dst::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::InnerMaxSize	src/Core/Assign_MKL.h	/^      InnerMaxSize  = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::InnerSize	src/Core/Assign_MKL.h	/^      InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::LargeEnough	src/Core/Assign_MKL.h	/^      LargeEnough = VmlSize==Dynamic || VmlSize>=EIGEN_MKL_VML_THRESHOLD,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::MaxSizeAtCompileTime	src/Core/Assign_MKL.h	/^      MaxSizeAtCompileTime = Dst::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::MayEnableVml	src/Core/Assign_MKL.h	/^      MayEnableVml = MightEnableVml && LargeEnough,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::MayLinearize	src/Core/Assign_MKL.h	/^      MayLinearize = MayEnableVml && MightLinearize$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::MightEnableVml	src/Core/Assign_MKL.h	/^      MightEnableVml =  vml_call<UnaryOp>::IsSupported && StorageOrdersAgree && DstHasDirectAccess && SrcHasDirectAccess$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::MightLinearize	src/Core/Assign_MKL.h	/^      MightLinearize = MightEnableVml && (int(Dst::Flags) & int(Src::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::SrcHasDirectAccess	src/Core/Assign_MKL.h	/^      SrcHasDirectAccess = Src::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::StorageOrdersAgree	src/Core/Assign_MKL.h	/^      StorageOrdersAgree = (int(Dst::IsRowMajor) == int(Src::IsRowMajor)),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_assign_traits::Traversal	src/Core/Assign_MKL.h	/^      Traversal = MayLinearize ? LinearVectorizedTraversal$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon140
Eigen::internal::vml_assign_traits::VmlSize	src/Core/Assign_MKL.h	/^      VmlSize = MightLinearize ? MaxSizeAtCompileTime : InnerMaxSize,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
Eigen::internal::vml_call	src/Core/Assign_MKL.h	/^template<typename Op> struct vml_call$/;"	s	namespace:Eigen::internal
Eigen::internal::vml_call::IsSupported	src/Core/Assign_MKL.h	/^{ enum { IsSupported = 0 }; };$/;"	e	enum:Eigen::internal::vml_call::__anon138
Eigen::internal::vst1_f32	src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1_f32 (float* to, float32x2_t from) { ::vst1_f32 ((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, float32x2_t from)
Eigen::internal::vst1q_f32	src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1q_f32(float* to, float32x4_t from) { ::vst1q_f32((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, float32x4_t from)
Eigen::internal::workaround_msvc_stl_support	src/StlSupport/details.h	/^  template<typename T> struct workaround_msvc_stl_support : public T$/;"	s	namespace:Eigen::internal	inherits:T
Eigen::internal::workaround_msvc_stl_support::operator =	src/StlSupport/details.h	/^    inline T& operator=(const OtherT& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const OtherT& other)
Eigen::internal::workaround_msvc_stl_support::operator =	src/StlSupport/details.h	/^    inline workaround_msvc_stl_support& operator=(const workaround_msvc_stl_support& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const workaround_msvc_stl_support& other)
Eigen::internal::workaround_msvc_stl_support::operator T&	src/StlSupport/details.h	/^    inline operator T& () { return *static_cast<T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:()
Eigen::internal::workaround_msvc_stl_support::operator const T&	src/StlSupport/details.h	/^    inline operator const T& () const { return *static_cast<const T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:() const
Eigen::internal::workaround_msvc_stl_support::workaround_msvc_stl_support	src/StlSupport/details.h	/^    inline workaround_msvc_stl_support() : T() {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:()
Eigen::internal::workaround_msvc_stl_support::workaround_msvc_stl_support	src/StlSupport/details.h	/^    inline workaround_msvc_stl_support(const T& other) : T(other) {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const T& other)
Eigen::is_diagonal	src/Core/util/Meta.h	/^template<typename T, int S> struct is_diagonal<DiagonalMatrix<T,S> >$/;"	s	namespace:Eigen
Eigen::is_diagonal	src/Core/util/Meta.h	/^template<typename T> struct is_diagonal$/;"	s	namespace:Eigen
Eigen::is_diagonal	src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalBase<T> >$/;"	s	namespace:Eigen
Eigen::is_diagonal	src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalWrapper<T> >$/;"	s	namespace:Eigen
Eigen::is_diagonal::ret	src/Core/util/Meta.h	/^{ enum { ret = false }; };$/;"	e	enum:Eigen::is_diagonal::__anon122
Eigen::is_diagonal::ret	src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon123
Eigen::is_diagonal::ret	src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon124
Eigen::is_diagonal::ret	src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon125
Eigen::l1CacheSize	src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l1CacheSize()$/;"	f	namespace:Eigen	signature:()
Eigen::l2CacheSize	src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l2CacheSize()$/;"	f	namespace:Eigen	signature:()
Eigen::linearRegression	src/Eigen2Support/LeastSquares.h	/^void linearRegression(int numPoints,$/;"	f	namespace:Eigen	signature:(int numPoints, VectorType **points, VectorType *result, int funcOfOthers )
Eigen::m_lhs	src/Core/ProductBase.h	/^    LhsNested m_lhs;$/;"	m	namespace:Eigen	access:protected
Eigen::m_result	src/Core/ProductBase.h	/^    mutable PlainObject m_result;$/;"	m	namespace:Eigen	access:protected
Eigen::m_rhs	src/Core/ProductBase.h	/^    RhsNested m_rhs;$/;"	m	namespace:Eigen	access:protected
Eigen::machine_epsilon	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T machine_epsilon () { return NumTraits<T>::epsilon(); }$/;"	f	namespace:Eigen	signature:()
Eigen::meta_sqrt	src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c	namespace:Eigen
Eigen::meta_sqrt::ret	src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:Eigen::meta_sqrt::__anon117
Eigen::nbThreads	src/Core/products/Parallelizer.h	/^inline int nbThreads()$/;"	f	namespace:Eigen	signature:()
Eigen::numext	src/Core/MathFunctions.h	/^namespace numext {$/;"	n	namespace:Eigen
Eigen::numext::abs2	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
Eigen::numext::atanh2	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(atanh2, Scalar) atanh2(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x, const Scalar& y)
Eigen::numext::conj	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(conj, Scalar) conj(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
Eigen::numext::hypot	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x, const Scalar& y)
Eigen::numext::imag	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag, Scalar) imag(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
Eigen::numext::imag_ref	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) imag_ref(Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(Scalar& x)
Eigen::numext::imag_ref	src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) >::type imag_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
Eigen::numext::isfinite	src/Core/MathFunctions.h	/^template<typename T> bool (isfinite)(const T& x)$/;"	f	namespace:Eigen::numext	signature:(const T& x)
Eigen::numext::norm1	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
Eigen::numext::pow	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(pow, Scalar) pow(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x, const Scalar& y)
Eigen::numext::real	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
Eigen::numext::real_ref	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) real_ref(Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(Scalar& x)
Eigen::numext::real_ref	src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) >::type real_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
Eigen::operator *	src/Core/PermutationMatrix.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& matrix, const PermutationBase<PermutationDerived> &permutation)
Eigen::operator *	src/Core/PermutationMatrix.h	/^operator*(const PermutationBase<PermutationDerived> &permutation,$/;"	f	namespace:Eigen	signature:(const PermutationBase<PermutationDerived> &permutation, const MatrixBase<Derived>& matrix)
Eigen::operator *	src/Core/Transpositions.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& matrix, const TranspositionsBase<TranspositionsDerived> &transpositions)
Eigen::operator *	src/Core/Transpositions.h	/^operator*(const TranspositionsBase<TranspositionDerived> &transpositions,$/;"	f	namespace:Eigen	signature:(const TranspositionsBase<TranspositionDerived> &transpositions, const MatrixBase<Derived>& matrix)
Eigen::operator *	src/Householder/HouseholderSequence.h	/^typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)$/;"	f	namespace:Eigen	signature:(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)
Eigen::operator *	src/SparseCore/SparsePermutation.h	/^operator*( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen	signature:( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)
Eigen::operator *	src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)$/;"	f	namespace:Eigen	signature:(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)
Eigen::operator *	src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)$/;"	f	namespace:Eigen	signature:(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)
Eigen::operator *	src/SparseCore/SparsePermutation.h	/^operator*(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen	signature:(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)
Eigen::operator /	src/Core/GlobalFunctions.h	/^    operator\/(const typename Derived::Scalar& s, const Eigen::ArrayBase<Derived>& a)$/;"	f	namespace:Eigen	signature:(const typename Derived::Scalar& s, const Eigen::ArrayBase<Derived>& a)
Eigen::operator <<	src/Core/IO.h	/^std::ostream & operator <<$/;"	f	namespace:Eigen	signature:(std::ostream & s, const DenseBase<Derived> & m)
Eigen::pow	src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents) $/;"	f	namespace:Eigen	signature:(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents)
Eigen::pow	src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent) {$/;"	f	namespace:Eigen	signature:(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent)
Eigen::precision	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T precision () { return NumTraits<T>::dummy_precision(); }$/;"	f	namespace:Eigen	signature:()
Eigen::ret	src/Eigen2Support/Meta.h	/^    enum { ret = ei_meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::__anon356
Eigen::rightHouseholderSequence	src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen	signature:(const VectorsType& v, const CoeffsType& h)
Eigen::scalar_product_traits	src/Core/util/Meta.h	/^template<typename T, typename U> struct scalar_product_traits$/;"	s	namespace:Eigen
Eigen::scalar_product_traits	src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,T>$/;"	s	namespace:Eigen
Eigen::scalar_product_traits	src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,std::complex<T> >$/;"	s	namespace:Eigen
Eigen::scalar_product_traits	src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<std::complex<T>, T>$/;"	s	namespace:Eigen
Eigen::scalar_product_traits::Defined	src/Core/util/Meta.h	/^    Defined = 1$/;"	e	enum:Eigen::scalar_product_traits::__anon119
Eigen::scalar_product_traits::Defined	src/Core/util/Meta.h	/^    Defined = 1$/;"	e	enum:Eigen::scalar_product_traits::__anon120
Eigen::scalar_product_traits::Defined	src/Core/util/Meta.h	/^    Defined = 1$/;"	e	enum:Eigen::scalar_product_traits::__anon121
Eigen::scalar_product_traits::Defined	src/Core/util/Meta.h	/^  enum { Defined = 0 };$/;"	e	enum:Eigen::scalar_product_traits::__anon118
Eigen::scalar_product_traits::ReturnType	src/Core/util/Meta.h	/^  typedef T ReturnType;$/;"	t	struct:Eigen::scalar_product_traits	access:public
Eigen::scalar_product_traits::ReturnType	src/Core/util/Meta.h	/^  typedef std::complex<T> ReturnType;$/;"	t	struct:Eigen::scalar_product_traits	access:public
Eigen::scomplex	src/Core/util/MKL_support.h	/^typedef std::complex<float>  scomplex;$/;"	t	namespace:Eigen
Eigen::selfadjoint_product_selector	src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,false>$/;"	s	namespace:Eigen
Eigen::selfadjoint_product_selector	src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>$/;"	s	namespace:Eigen
Eigen::selfadjoint_product_selector::run	src/Core/products/SelfadjointProduct.h	/^  static void run(MatrixType& mat, const OtherType& other, const typename MatrixType::Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_product_selector	access:public	signature:(MatrixType& mat, const OtherType& other, const typename MatrixType::Scalar& alpha)
Eigen::selfadjoint_rank1_update	src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
Eigen::selfadjoint_rank1_update	src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
Eigen::selfadjoint_rank1_update::run	src/Core/products/SelfadjointProduct.h	/^  static void run(Index size, Scalar* mat, Index stride, const Scalar* vecX, const Scalar* vecY, const Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_rank1_update	access:public	signature:(Index size, Scalar* mat, Index stride, const Scalar* vecX, const Scalar* vecY, const Scalar& alpha)
Eigen::setCpuCacheSizes	src/Core/products/GeneralBlockPanelKernel.h	/^inline void setCpuCacheSizes(std::ptrdiff_t l1, std::ptrdiff_t l2)$/;"	f	namespace:Eigen	signature:(std::ptrdiff_t l1, std::ptrdiff_t l2)
Eigen::setNbThreads	src/Core/products/Parallelizer.h	/^inline void setNbThreads(int v)$/;"	f	namespace:Eigen	signature:(int v)
Eigen::umeyama	src/Geometry/Umeyama.h	/^umeyama(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)
Eigen::umfpack_free_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, double)$/;"	f	namespace:Eigen	signature:(void **Numeric, double)
Eigen::umfpack_free_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, std::complex<double>)$/;"	f	namespace:Eigen	signature:(void **Numeric, std::complex<double>)
Eigen::umfpack_free_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, double)$/;"	f	namespace:Eigen	signature:(void **Symbolic, double)
Eigen::umfpack_free_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, std::complex<double>)$/;"	f	namespace:Eigen	signature:(void **Symbolic, std::complex<double>)
Eigen::umfpack_get_determinant	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen	signature:(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])
Eigen::umfpack_get_determinant	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen	signature:(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])
Eigen::umfpack_get_lunz	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)$/;"	f	namespace:Eigen	signature:(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)
Eigen::umfpack_get_lunz	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)$/;"	f	namespace:Eigen	signature:(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)
Eigen::umfpack_get_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[],$/;"	f	namespace:Eigen	signature:(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[], int P[], int Q[], double Dx[], int *do_recip, double Rs[], void *Numeric)
Eigen::umfpack_get_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[],$/;"	f	namespace:Eigen	signature:(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[], int P[], int Q[], std::complex<double> Dx[], int *do_recip, double Rs[], void *Numeric)
Eigen::umfpack_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen	signature:( const int Ap[], const int Ai[], const double Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])
Eigen::umfpack_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen	signature:( const int Ap[], const int Ai[], const std::complex<double> Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])
Eigen::umfpack_solve	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen	signature:( int sys, const int Ap[], const int Ai[], const double Ax[], double X[], const double B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])
Eigen::umfpack_solve	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen	signature:( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[], std::complex<double> X[], const std::complex<double> B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])
Eigen::umfpack_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen	signature:(int n_row,int n_col, const int Ap[], const int Ai[], const double Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])
Eigen::umfpack_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen	signature:(int n_row,int n_col, const int Ap[], const int Ai[], const std::complex<double> Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])
Eigen::viewAsCholmod	src/CholmodSupport/CholmodSupport.h	/^cholmod_dense viewAsCholmod(MatrixBase<Derived>& mat)$/;"	f	namespace:Eigen	signature:(MatrixBase<Derived>& mat)
Eigen::viewAsCholmod	src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen	signature:(SparseMatrix<_Scalar,_Options,_Index>& mat)
Eigen::viewAsCholmod	src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)$/;"	f	namespace:Eigen	signature:(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)
Eigen::viewAsCholmod	src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen	signature:(const SparseMatrix<_Scalar,_Options,_Index>& mat)
Eigen::viewAsEigen	src/CholmodSupport/CholmodSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> viewAsEigen(cholmod_sparse& cm)$/;"	f	namespace:Eigen	signature:(cholmod_sparse& cm)
EigenBase	src/Core/EigenBase.h	/^template<typename Derived> struct EigenBase$/;"	s	namespace:Eigen
EigenSolver	src/Eigenvalues/EigenSolver.h	/^    EigenSolver(Index size)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(Index size)
EigenSolver	src/Eigenvalues/EigenSolver.h	/^    EigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
EigenSolver	src/Eigenvalues/EigenSolver.h	/^ EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}$/;"	f	class:Eigen::EigenSolver	access:public	signature:()
EigenSolver	src/Eigenvalues/EigenSolver.h	/^template<typename _MatrixType> class EigenSolver$/;"	c	namespace:Eigen
Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl	src/Core/ArrayBase.h	/^    typedef ArrayBase Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl;$/;"	t	class:Eigen::ArrayBase	access:public
EigenvalueType	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options&(~RowMajor), MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
EigenvalueType	src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::EigenSolver	access:public
EigenvalueType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef CwiseBinaryOp<internal::scalar_quotient_op<ComplexScalar,Scalar>,ComplexVectorType,VectorType> EigenvalueType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
EigenvalueType	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealQZ	access:public
EigenvalueType	src/Eigenvalues/RealSchur.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealSchur	access:public
EigenvaluesOnly	src/Core/util/Constants.h	/^  EigenvaluesOnly     = 0x40,$/;"	e	enum:Eigen::DecompositionOptions
EigenvaluesReturnType	src/Core/DenseBase.h	/^    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::DenseBase	access:public
EigenvaluesReturnType	src/Core/MatrixBase.h	/^    typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMajor> EigenvaluesReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
EigenvaluesReturnType	src/Core/SelfAdjointView.h	/^    typedef Matrix<RealScalar, internal::traits<MatrixType>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::SelfAdjointView	access:public
EigenvectorType	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
EigenvectorsType	src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::EigenSolver	access:public
EigenvectorsType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
EigenvectorsType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Matrix<Scalar,Size,Size,ColMajor,MaxColsAtCompileTime,MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
EigenvectorsType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::EigenvectorsType EigenvectorsType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
ElseMatrixNested	src/Core/Select.h	/^  typedef typename ElseMatrixType::Nested ElseMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
EssentialVectorType	src/Householder/HouseholderSequence.h	/^    typedef typename internal::hseq_side_dependent_impl<VectorsType,CoeffsType,Side>::EssentialVectorType EssentialVectorType;$/;"	t	class:Eigen::HouseholderSequence	access:private
EssentialVectorType	src/Householder/HouseholderSequence.h	/^  typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
EssentialVectorType	src/Householder/HouseholderSequence.h	/^  typedef Transpose<Block<const VectorsType, 1, Dynamic> > EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
EvalBeforeAssigningBit	src/Core/util/Constants.h	/^const unsigned int EvalBeforeAssigningBit = 0x4;$/;"	m	namespace:Eigen
EvalBeforeNestingBit	src/Core/util/Constants.h	/^const unsigned int EvalBeforeNestingBit = 0x2;$/;"	m	namespace:Eigen
EvalReturnType	src/Core/DenseBase.h	/^    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;$/;"	t	class:Eigen::DenseBase	access:public
EvalToRowMajor	src/Core/products/CoeffBasedProduct.h	/^      EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon30
EvalToRowMajor	src/SparseCore/SparseProduct.h	/^    EvalToRowMajor = (RhsFlags & LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon452
ExpandMem	src/SparseLU/SparseLU_column_dfs.h	/^  enum { ExpandMem = true };$/;"	e	enum:Eigen::internal::column_dfs_traits::__anon464
ExpandMem	src/SparseLU/SparseLU_panel_dfs.h	/^  enum { ExpandMem = false };$/;"	e	enum:Eigen::internal::panel_dfs_traits::__anon465
ExpressionType	src/Core/SelfAdjointView.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits	access:public
ExpressionType	src/Core/TriangularMatrix.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits	access:public
ExpressionTypeNested	src/Core/Flagged.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Flagged	access:public
ExpressionTypeNested	src/Core/VectorwiseOp.h	/^        ExpressionType, ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::VectorwiseOp	access:public
ExpressionTypeNested	src/Eigen2Support/Cwise.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Cwise	access:public
ExpressionTypeNestedCleaned	src/Core/VectorwiseOp.h	/^    typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;$/;"	t	class:Eigen::VectorwiseOp	access:public
ExtendedType	src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct ExtendedType {$/;"	s	class:Eigen::VectorwiseOp	access:protected
ExtractType	src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType>  ExtractType; \/\/ const to get rid of a compile error; anyway blas traits are only used on the RHS$/;"	t	struct:Eigen::internal::blas_traits	access:public
ExtractType	src/Core/util/BlasUtil.h	/^  typedef const XprType& ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
ExtractType	src/Core/util/BlasUtil.h	/^  typedef typename Base::ExtractType ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED	src/Core/util/StaticAssert.h	/^        FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Factor	src/Core/Replicate.h	/^    Factor = (RowFactor==Dynamic || ColFactor==Dynamic) ? Dynamic : RowFactor*ColFactor$/;"	e	enum:Eigen::internal::traits::__anon308
FactorType	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,RowMajor> FactorType;$/;"	t	class:Eigen::IncompleteLUT	access:private
FixedSegmentReturnType	src/plugins/BlockMethods.h	/^template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	s
FixedSegmentReturnType::Type	src/plugins/BlockMethods.h	/^template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	t	struct:FixedSegmentReturnType	access:public
Flagged	src/Core/Flagged.h	/^    inline Flagged(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Flagged	access:public	signature:(const ExpressionType& matrix)
Flagged	src/Core/Flagged.h	/^template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged$/;"	c	namespace:Eigen	inherits:MatrixBase
Flags	src/Core/ArrayWrapper.h	/^    Flags = Flags0 & ~NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon128
Flags	src/Core/ArrayWrapper.h	/^    Flags = Flags0 & ~NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon129
Flags	src/Core/BandMatrix.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Flags	src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon144
Flags	src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon145
Flags	src/Core/Block.h	/^    Flags = Flags0 | FlagsLinearAccessBit | FlagsLvalueBit | FlagsRowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon146
Flags	src/Core/CwiseBinaryOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon151
Flags	src/Core/CwiseNullaryOp.h	/^    Flags = (traits<PlainObjectType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon152
Flags	src/Core/CwiseUnaryOp.h	/^    Flags = _XprTypeNested::Flags & ($/;"	e	enum:Eigen::internal::traits::__anon153
Flags	src/Core/CwiseUnaryView.h	/^    Flags = (traits<_MatrixTypeNested>::Flags & (HereditaryBits | LvalueBit | LinearAccessBit | DirectAccessBit)),$/;"	e	enum:Eigen::internal::traits::__anon154
Flags	src/Core/DenseBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::DenseBase::__anon155
Flags	src/Core/Diagonal.h	/^    Flags = (unsigned int)_MatrixTypeNested::Flags & (HereditaryBits | LinearAccessBit | MaskLvalueBit | DirectAccessBit) & ~RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon161
Flags	src/Core/DiagonalMatrix.h	/^      Flags = 0$/;"	e	enum:Eigen::DiagonalBase::__anon163
Flags	src/Core/DiagonalMatrix.h	/^    Flags =  traits<DiagonalVectorType>::Flags & LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon165
Flags	src/Core/DiagonalMatrix.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon164
Flags	src/Core/DiagonalProduct.h	/^    Flags = ((HereditaryBits|_LinearAccessMask|AlignedBit) & (unsigned int)(MatrixType::Flags)) | (_Vectorizable ? PacketAccessBit : 0),\/\/(int(MatrixType::Flags)&int(DiagonalType::DiagonalVectorType::Flags)&AlignedBit),$/;"	e	enum:Eigen::internal::traits::__anon166
Flags	src/Core/Flagged.h	/^  enum { Flags = (ExpressionType::Flags | Added) & ~Removed };$/;"	e	enum:Eigen::internal::traits::__anon167
Flags	src/Core/Map.h	/^    Flags = KeepsPacketAccess ? int(Flags3) : (int(Flags3) & ~PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon274
Flags	src/Core/Matrix.h	/^    Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,$/;"	e	enum:Eigen::internal::traits::__anon282
Flags	src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::PermutationBase::__anon287
Flags	src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::Transpose::__anon289
Flags	src/Core/PermutationMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon288
Flags	src/Core/ProductBase.h	/^    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0)$/;"	e	enum:Eigen::internal::traits::__anon294
Flags	src/Core/Ref.h	/^    Flags = traits<Map<_PlainObjectType, _Options, _StrideType> >::Flags | NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon306
Flags	src/Core/Replicate.h	/^    Flags = (_MatrixTypeNested::Flags & HereditaryBits & ~RowMajorBit) | (IsRowMajor ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon309
Flags	src/Core/ReturnByValue.h	/^    Flags = (traits<typename traits<Derived>::ReturnType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon310
Flags	src/Core/Reverse.h	/^    Flags = int(_MatrixTypeNested::Flags) & (HereditaryBits | LvalueBit | PacketAccessBit | LinearAccess),$/;"	e	enum:Eigen::internal::traits::__anon311
Flags	src/Core/Select.h	/^    Flags = (unsigned int)ThenMatrixType::Flags & ElseMatrixType::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon313
Flags	src/Core/SelfAdjointView.h	/^    Flags =  MatrixTypeNestedCleaned::Flags & (HereditaryBits)$/;"	e	enum:Eigen::internal::traits::__anon314
Flags	src/Core/SelfCwiseBinaryOp.h	/^    Flags = traits<CwiseBinaryOp<BinaryOp,Lhs,Rhs> >::Flags | (Lhs::Flags&DirectAccessBit) | (Lhs::Flags&LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon318
Flags	src/Core/Transpose.h	/^    Flags = Flags1 ^ RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon323
Flags	src/Core/TriangularMatrix.h	/^    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit))) | Mode,$/;"	e	enum:Eigen::internal::traits::__anon327
Flags	src/Core/VectorwiseOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (RowsAtCompileTime == 1 ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon331
Flags	src/Core/products/CoeffBasedProduct.h	/^      Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon30
Flags	src/Eigen2Support/Minor.h	/^    Flags = _MatrixTypeNested::Flags & (HereditaryBits | LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon358
Flags	src/Geometry/Homogeneous.h	/^    Flags = ColsAtCompileTime==1 ? (TmpFlags & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon371
Flags	src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon378
Flags	src/Geometry/Quaternion.h	/^    Flags = Eigen::internal::traits<Derived>::Flags$/;"	e	enum:Eigen::QuaternionBase::__anon375
Flags	src/Geometry/Quaternion.h	/^    Flags = IsAligned ? (AlignedBit | LvalueBit) : LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon376
Flags	src/Householder/HouseholderSequence.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon393
Flags	src/SparseCore/SparseDenseProduct.h	/^    Flags = Tr ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon441
Flags	src/SparseCore/SparseDiagonalProduct.h	/^    Flags = (SparseFlags&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon442
Flags	src/SparseCore/SparseMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon446
Flags	src/SparseCore/SparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon445
Flags	src/SparseCore/SparseMatrixBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
Flags	src/SparseCore/SparseProduct.h	/^    Flags = (int(LhsFlags | RhsFlags) & HereditaryBits & RemovedBits)$/;"	e	enum:Eigen::internal::traits::__anon452
Flags	src/SparseCore/SparseVector.h	/^    Flags = _Options | NestByRefBit | LvalueBit | (IsColVector ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon456
Flags	src/SparseCore/SparseView.h	/^    Flags = int(traits<MatrixType>::Flags) & (RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon460
Flags0	src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon128
Flags0	src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon129
Flags0	src/Core/Block.h	/^    Flags0 = traits<XprType>::Flags & ( (HereditaryBits & ~RowMajorBit) |$/;"	e	enum:Eigen::internal::traits::__anon146
Flags0	src/Core/CwiseBinaryOp.h	/^    Flags0 = (int(LhsFlags) | int(RhsFlags)) & ($/;"	e	enum:Eigen::internal::traits::__anon151
Flags0	src/Core/Map.h	/^    Flags0 = TraitsBase::Flags & (~NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon274
Flags0	src/Core/Transpose.h	/^    Flags0 = MatrixTypeNestedPlain::Flags & ~(LvalueBit | NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon323
Flags0	src/Core/VectorwiseOp.h	/^    Flags0 = (unsigned int)_MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon331
Flags1	src/Core/Map.h	/^    Flags1 = IsAligned ? (int(Flags0) | AlignedBit) : (int(Flags0) & ~AlignedBit),$/;"	e	enum:Eigen::internal::traits::__anon274
Flags1	src/Core/Transpose.h	/^    Flags1 = Flags0 | FlagsLvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon323
Flags2	src/Core/Map.h	/^    Flags2 = (bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime))$/;"	e	enum:Eigen::internal::traits::__anon274
Flags3	src/Core/Map.h	/^    Flags3 = is_lvalue<PlainObjectType>::value ? int(Flags2) : (int(Flags2) & ~LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon274
FlagsLinearAccessBit	src/Core/Block.h	/^    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1 || (InnerPanel && (traits<XprType>::Flags&LinearAccessBit))) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon146
FlagsLvalueBit	src/Core/Block.h	/^    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon146
FlagsLvalueBit	src/Core/Transpose.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon323
FlagsRowMajorBit	src/Core/Block.h	/^    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon146
ForceAlignedAccess	src/Core/ForceAlignedAccess.h	/^    inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(const ExpressionType& matrix)
ForceAlignedAccess	src/Core/ForceAlignedAccess.h	/^template<typename ExpressionType> class ForceAlignedAccess$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
FromTwoVectors	src/Geometry/Quaternion.h	/^  static Quaternion FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
FromTwoVectors	src/Geometry/Quaternion.h	/^Quaternion<Scalar,Options> Quaternion<Scalar,Options>::FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
FullPivHouseholderQR	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR()$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:()
FullPivHouseholderQR	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(Index rows, Index cols)
FullPivHouseholderQR	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
FullPivHouseholderQR	src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> class FullPivHouseholderQR$/;"	c	namespace:Eigen
FullPivHouseholderQRMatrixQReturnType	src/QR/FullPivHouseholderQR.h	/^  FullPivHouseholderQRMatrixQReturnType(const MatrixType&       qr,$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(const MatrixType& qr, const HCoeffsType& hCoeffs, const IntDiagSizeVectorType& rowsTranspositions)
FullPivHouseholderQRMatrixQReturnType	src/QR/FullPivHouseholderQR.h	/^template<typename MatrixType> struct FullPivHouseholderQRMatrixQReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
FullPivHouseholderQRPreconditioner	src/Core/util/Constants.h	/^  FullPivHouseholderQRPreconditioner$/;"	e	enum:Eigen::QRPreconditioners
FullPivLU	src/LU/FullPivLU.h	/^    FullPivLU();$/;"	p	class:Eigen::FullPivLU	access:public	signature:()
FullPivLU	src/LU/FullPivLU.h	/^    FullPivLU(Index rows, Index cols);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(Index rows, Index cols)
FullPivLU	src/LU/FullPivLU.h	/^    FullPivLU(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& matrix)
FullPivLU	src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU()$/;"	f	class:Eigen::FullPivLU	signature:()
FullPivLU	src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(Index rows, Index cols)$/;"	f	class:Eigen::FullPivLU	signature:(Index rows, Index cols)
FullPivLU	src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU	signature:(const MatrixType& matrix)
FullPivLU	src/LU/FullPivLU.h	/^template<typename _MatrixType> class FullPivLU$/;"	c	namespace:Eigen
FullPrecision	src/Core/IO.h	/^       FullPrecision = -2 };$/;"	e	enum:Eigen::__anon273
FullyLazyCoeffBaseProductType	src/Core/ProductBase.h	/^    typedef CoeffBasedProduct<LhsNested, RhsNested, 0> FullyLazyCoeffBaseProductType;$/;"	t	class:Eigen::ProductBase	access:public
FunctorType	src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon114
FunctorType	src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon115
GEMM_SPECIALIZATION	src/Core/products/GeneralMatrixMatrix_MKL.h	49;"	d
GemmParallelInfo	src/Core/products/Parallelizer.h	/^  GemmParallelInfo() : sync(-1), users(0), rhs_start(0), rhs_length(0) {}$/;"	f	struct:Eigen::internal::GemmParallelInfo	access:public	signature:()
GemmParallelInfo	src/Core/products/Parallelizer.h	/^template<typename Index> struct GemmParallelInfo$/;"	s	namespace:Eigen::internal
GemmProduct	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
GemvProduct	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
GenEigMask	src/Core/util/Constants.h	/^  GenEigMask = Ax_lBx | ABx_lx | BAx_lx$/;"	e	enum:Eigen::DecompositionOptions
GeneralProduct	src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& a_lhs, const Rhs& a_rhs) : Base(a_lhs,a_rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& a_lhs, const Rhs& a_rhs)
GeneralProduct	src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
GeneralProduct	src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
GeneralProduct	src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, GemvProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
GeneralProduct	src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, InnerProduct>$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,Matrix
GeneralProduct	src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, OuterProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
GeneralProduct	src/Core/products/GeneralMatrixMatrix.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
GeneralProduct	src/Core/products/GeneralMatrixMatrix.h	/^class GeneralProduct<Lhs, Rhs, GemmProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
GeneralizedEigenSolver	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver() : m_eivec(), m_alphas(), m_betas(), m_isInitialized(false), m_realQZ(), m_matS(), m_tmp() {}$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:()
GeneralizedEigenSolver	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:(Index size)
GeneralizedEigenSolver	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true)$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true)
GeneralizedEigenSolver	src/Eigenvalues/GeneralizedEigenSolver.h	/^template<typename _MatrixType> class GeneralizedEigenSolver$/;"	c	namespace:Eigen
GeneralizedSelfAdjointEigenSolver	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver() : Base() {}$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:()
GeneralizedSelfAdjointEigenSolver	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(Index size)
GeneralizedSelfAdjointEigenSolver	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB,$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, int options = ComputeEigenvectors|Ax_lBx)
GeneralizedSelfAdjointEigenSolver	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^class GeneralizedSelfAdjointEigenSolver : public SelfAdjointEigenSolver<_MatrixType>$/;"	c	namespace:Eigen	inherits:SelfAdjointEigenSolver
Generic	src/Core/util/Constants.h	/^    Generic = 0x0,$/;"	e	enum:Eigen::Architecture::Type
GenericNumTraits	src/Core/NumTraits.h	/^template<typename T> struct GenericNumTraits$/;"	s	namespace:Eigen
GetAction	src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
GlobalLU_t	src/SparseLU/SparseLUImpl.h	/^    typedef LU_GlobalLU_t<IndexVector, ScalarVector> GlobalLU_t; $/;"	t	class:Eigen::internal::SparseLUImpl	access:public
HCoeffsType	src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
HCoeffsType	src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
HCoeffsType	src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
HCoeffsType	src/QR/HouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::HouseholderQR	access:public
HDim	src/Eigen2Support/Geometry/Transform.h	/^    HDim = _Dim+1   \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon346
HDim	src/Geometry/Transform.h	/^    HDim = Transform::HDim,$/;"	e	enum:Eigen::internal::transform_traits::__anon383
HDim	src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon387
HDim	src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon388
HDim	src/Geometry/Transform.h	/^    HDim = _Dim+1,  \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon384
HNormalizedReturnType	src/Core/MatrixBase.h	/^                const ConstStartMinusOne > HNormalizedReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
HNormalizedReturnType	src/Core/VectorwiseOp.h	/^            HNormalizedReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
HNormalized_Block	src/Core/VectorwiseOp.h	/^            HNormalized_Block;$/;"	t	class:Eigen::VectorwiseOp	access:public
HNormalized_Factors	src/Core/VectorwiseOp.h	/^            HNormalized_Factors;$/;"	t	class:Eigen::VectorwiseOp	access:public
HNormalized_Size	src/Core/VectorwiseOp.h	/^      HNormalized_Size = Direction==Vertical ? internal::traits<ExpressionType>::RowsAtCompileTime$/;"	e	enum:Eigen::VectorwiseOp::__anon335
HNormalized_SizeMinusOne	src/Core/VectorwiseOp.h	/^      HNormalized_SizeMinusOne = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1$/;"	e	enum:Eigen::VectorwiseOp::__anon335
HalfLength	src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon301
HalfLength	src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon303
HasACos	src/Core/GenericPacketMath.h	/^    HasACos   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasASin	src/Core/GenericPacketMath.h	/^    HasASin   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasATan	src/Core/GenericPacketMath.h	/^    HasATan   = 0$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasAbs	src/Core/GenericPacketMath.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasAbs	src/Core/GenericPacketMath.h	/^    HasAbs    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasAbs	src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasAbs	src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasAbs	src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasAbs	src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasAbs2	src/Core/GenericPacketMath.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasAbs2	src/Core/GenericPacketMath.h	/^    HasAbs2   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasAbs2	src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasAbs2	src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasAbs2	src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasAbs2	src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasAdd	src/Core/GenericPacketMath.h	/^    HasAdd    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasAdd	src/Core/GenericPacketMath.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasAdd	src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasAdd	src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasAdd	src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasAdd	src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasConj	src/Core/GenericPacketMath.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasConj	src/Core/GenericPacketMath.h	/^    HasConj   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasCos	src/Core/GenericPacketMath.h	/^    HasCos    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasCos	src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
HasCos	src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
HasCos	src/Core/arch/SSE/PacketMath.h	/^    HasCos  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
HasDirectAccess	src/Core/Ref.h	/^      HasDirectAccess = internal::has_direct_access<Derived>::ret,$/;"	e	enum:Eigen::internal::traits::match::__anon307
HasDiv	src/Core/GenericPacketMath.h	/^    HasDiv    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasDiv	src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasDiv	src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasDiv	src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
HasDiv	src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasDiv	src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasDiv	src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
HasDiv	src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
HasExp	src/Core/GenericPacketMath.h	/^    HasExp    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasExp	src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
HasExp	src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
HasExp	src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
HasExp	src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
HasLog	src/Core/GenericPacketMath.h	/^    HasLog    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasLog	src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
HasLog	src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
HasLog	src/Core/arch/SSE/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
HasMax	src/Core/GenericPacketMath.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasMax	src/Core/GenericPacketMath.h	/^    HasMax    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasMax	src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasMax	src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasMax	src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasMax	src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasMin	src/Core/GenericPacketMath.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasMin	src/Core/GenericPacketMath.h	/^    HasMin    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasMin	src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasMin	src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasMin	src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasMin	src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasMul	src/Core/GenericPacketMath.h	/^    HasMul    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasMul	src/Core/GenericPacketMath.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasMul	src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasMul	src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasMul	src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasMul	src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasNegate	src/Core/GenericPacketMath.h	/^    HasNegate = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasNegate	src/Core/GenericPacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasNegate	src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasNegate	src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasNegate	src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasNegate	src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasNoInnerStride	src/Core/Map.h	/^    HasNoInnerStride = InnerStrideAtCompileTime == 1,$/;"	e	enum:Eigen::internal::traits::__anon274
HasNoOuterStride	src/Core/Map.h	/^    HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,$/;"	e	enum:Eigen::internal::traits::__anon274
HasNoStride	src/Core/Map.h	/^    HasNoStride = HasNoInnerStride && HasNoOuterStride,$/;"	e	enum:Eigen::internal::traits::__anon274
HasPow	src/Core/GenericPacketMath.h	/^    HasPow    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasSameStorageOrderAsXprType	src/Core/Block.h	/^    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),$/;"	e	enum:Eigen::internal::traits::__anon146
HasSetLinear	src/Core/GenericPacketMath.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasSetLinear	src/Core/GenericPacketMath.h	/^    HasSetLinear = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasSetLinear	src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasSetLinear	src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasSetLinear	src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasSetLinear	src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasSin	src/Core/GenericPacketMath.h	/^    HasSin    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasSin	src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
HasSin	src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
HasSin	src/Core/arch/SSE/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
HasSqrt	src/Core/GenericPacketMath.h	/^    HasSqrt   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasSqrt	src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon7
HasSqrt	src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon13
HasSqrt	src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon24
HasSqrt	src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon25
HasSub	src/Core/GenericPacketMath.h	/^    HasSub    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon271
HasSub	src/Core/GenericPacketMath.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasSub	src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
HasSub	src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
HasSub	src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
HasSub	src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
HasTan	src/Core/GenericPacketMath.h	/^    HasTan    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon269
HasUnitDiag	src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon54
HasUnitDiag	src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon55
HasUnitDiag	src/SparseCore/SparseTriangularView.h	/^           HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::SparseTriangularView::__anon453
HasUsableDirectAccess	src/Core/util/BlasUtil.h	/^    HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)$/;"	e	enum:Eigen::internal::blas_traits::__anon58
HasZeroDiag	src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon54
HasZeroDiag	src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon55
HereditaryBits	src/Core/util/Constants.h	/^const unsigned int HereditaryBits = RowMajorBit$/;"	m	namespace:Eigen
HessenbergDecomposition	src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(Index size = Size==Dynamic ? 2 : Size)
HessenbergDecomposition	src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(const MatrixType& matrix)
HessenbergDecomposition	src/Eigenvalues/HessenbergDecomposition.h	/^template<typename _MatrixType> class HessenbergDecomposition$/;"	c	namespace:Eigen
HessenbergDecompositionMatrixHReturnType	src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecompositionMatrixHReturnType(const HessenbergDecomposition<MatrixType>& hess) : m_hess(hess) { }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:(const HessenbergDecomposition<MatrixType>& hess)
HessenbergDecompositionMatrixHReturnType	src/Eigenvalues/HessenbergDecomposition.h	/^template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Homogeneous	src/Geometry/Homogeneous.h	/^    inline Homogeneous(const MatrixType& matrix)$/;"	f	class:Eigen::Homogeneous	access:public	signature:(const MatrixType& matrix)
Homogeneous	src/Geometry/Homogeneous.h	/^template<typename MatrixType,int _Direction> class Homogeneous$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
HomogeneousDimension	src/Geometry/Umeyama.h	/^    HomogeneousDimension = int(MinRowsAtCompileTime) == Dynamic ? Dynamic : int(MinRowsAtCompileTime)+1$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon391
HomogeneousReturnType	src/Core/MatrixBase.h	/^    typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
HomogeneousReturnTypeDirection	src/Core/MatrixBase.h	/^    enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1?Vertical:Horizontal };$/;"	e	enum:Eigen::MatrixBase::__anon284
Horizontal	src/Core/util/Constants.h	/^  Horizontal, $/;"	e	enum:Eigen::DirectionType
HouseholderQR	src/QR/HouseholderQR.h	/^    HouseholderQR() : m_qr(), m_hCoeffs(), m_temp(), m_isInitialized(false) {}$/;"	f	class:Eigen::HouseholderQR	access:public	signature:()
HouseholderQR	src/QR/HouseholderQR.h	/^    HouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(Index rows, Index cols)
HouseholderQR	src/QR/HouseholderQR.h	/^    HouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(const MatrixType& matrix)
HouseholderQR	src/QR/HouseholderQR.h	/^template<typename _MatrixType> class HouseholderQR$/;"	c	namespace:Eigen
HouseholderQRPreconditioner	src/Core/util/Constants.h	/^  HouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
HouseholderSequence	src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const HouseholderSequence& other)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const HouseholderSequence& other)
HouseholderSequence	src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const VectorsType& v, const CoeffsType& h)
HouseholderSequence	src/Householder/HouseholderSequence.h	/^template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence$/;"	c	namespace:Eigen	inherits:EigenBase
HouseholderSequenceType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
HouseholderSequenceType	src/Eigenvalues/Tridiagonalization.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::Tridiagonalization	access:public
HouseholderSequenceType	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
HouseholderSequenceType	src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
HouseholderSequenceType	src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheRight> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
HouseholderSequenceType	src/QR/ColPivHouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
HouseholderSequenceType	src/QR/HouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HouseholderQR	access:public
HouseholderUSequenceType	src/SVD/UpperBidiagonalization.h	/^            > HouseholderUSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
HouseholderVSequenceType	src/SVD/UpperBidiagonalization.h	/^            > HouseholderVSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Hyperplane	src/Eigen2Support/Geometry/All.h	112;"	d
Hyperplane	src/Eigen2Support/Geometry/All.h	57;"	d
Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)
Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, Scalar d)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, Scalar d)
Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const VectorType& e)
Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)
Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(int _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:(int _dim)
Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
Hyperplane	src/Geometry/Hyperplane.h	/^  Hyperplane(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)
Hyperplane	src/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)
Hyperplane	src/Geometry/Hyperplane.h	/^  inline Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Hyperplane	src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const Scalar& d)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const Scalar& d)
Hyperplane	src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const VectorType& e)
Hyperplane	src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(Index _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:(Index _dim)
Hyperplane	src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)
Hyperplane	src/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
I	src/Core/SolveTriangular.h	/^    I = IsLower ? Index : Size - Index - 1,$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon321
IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY	src/Core/util/StaticAssert.h	/^        IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
INVALID_MATRIXBASE_TEMPLATE_PARAMETERS	src/Core/util/StaticAssert.h	/^        INVALID_MATRIXBASE_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
INVALID_MATRIX_PRODUCT	src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION	src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
INVALID_MATRIX_TEMPLATE_PARAMETERS	src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION	src/Core/util/StaticAssert.h	/^        INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS	src/Core/util/StaticAssert.h	/^        INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
IOFormat	src/Core/IO.h	/^  IOFormat(int _precision = StreamPrecision, int _flags = 0,$/;"	f	struct:Eigen::IOFormat	access:public	signature:(int _precision = StreamPrecision, int _flags = 0, const std::string& _coeffSeparator = , const std::string& _rowSeparator = , const std::string& _rowPrefix=, const std::string& _rowSuffix=, const std::string& _matPrefix=, const std::string& _matSuffix=)
IOFormat	src/Core/IO.h	/^struct IOFormat$/;"	s	namespace:Eigen
Identity	src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity()$/;"	f	class:Eigen::MatrixBase	signature:()
Identity	src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity(Index nbRows, Index nbCols)$/;"	f	class:Eigen::MatrixBase	signature:(Index nbRows, Index nbCols)
Identity	src/Core/MatrixBase.h	/^    static const IdentityReturnType Identity();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Identity	src/Core/MatrixBase.h	/^    static const IdentityReturnType Identity(Index rows, Index cols);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index rows, Index cols)
Identity	src/Eigen2Support/Geometry/Quaternion.h	/^  static inline Quaternion Identity() { return Quaternion(1, 0, 0, 0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Identity	src/Eigen2Support/Geometry/Transform.h	/^  static const typename MatrixType::IdentityReturnType Identity()$/;"	f	class:Eigen::Transform	access:public	signature:()
Identity	src/Geometry/AngleAxis.h	/^  static inline const AngleAxis Identity() { return AngleAxis(Scalar(0), Vector3::UnitX()); }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Identity	src/Geometry/Quaternion.h	/^  static inline Quaternion<Scalar> Identity() { return Quaternion<Scalar>(Scalar(1), Scalar(0), Scalar(0), Scalar(0)); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Identity	src/Geometry/Rotation2D.h	/^  static inline Rotation2D Identity() { return Rotation2D(0); }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Identity	src/Geometry/Transform.h	/^  static const Transform Identity()$/;"	f	class:Eigen::Transform	access:public	signature:()
Identity	src/Geometry/Translation.h	/^  static const Translation Identity() { return Translation(VectorType::Zero()); }$/;"	f	class:Eigen::Translation	access:public	signature:()
IdentityPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner() {}$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:()
IdentityPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner(const MatrixType& ) {}$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
IdentityPreconditioner	src/IterativeLinearSolvers/BasicPreconditioners.h	/^class IdentityPreconditioner$/;"	c	namespace:Eigen
IdentityReturnType	src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,Derived> IdentityReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
ImagReturnType	src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_imag_op<Scalar>, const Derived> ImagReturnType;$/;"	t
ImageResultType	src/Eigen2Support/LU.h	/^    > ImageResultType;$/;"	t	class:Eigen::LU	access:public
Impl	src/Core/Block.h	/^    typedef BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, typename internal::traits<XprType>::StorageKind> Impl;$/;"	t	class:Eigen::Block	access:private
Impl	src/Core/Block.h	/^    typedef internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel> Impl;$/;"	t	class:Eigen::BlockImpl	access:private
IncompleteLUT	src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT()$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:()
IncompleteLUT	src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT(const MatrixType& mat, const RealScalar& droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& mat, const RealScalar& droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)
IncompleteLUT	src/IterativeLinearSolvers/IncompleteLUT.h	/^class IncompleteLUT : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Indefinite	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Index	src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LDLT	access:public
Index	src/Cholesky/LLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LLT	access:public
Index	src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::CholmodBase	access:public
Index	src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::ArrayBase	access:public
Index	src/Core/Assign.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::assign_impl	access:public
Index	src/Core/Assign_MKL.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::vml_assign_impl	access:public
Index	src/Core/BandMatrix.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::internal::TridiagonalMatrix	access:private
Index	src/Core/BandMatrix.h	/^    typedef typename DenseMatrixType::Index Index;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Index	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Index Index;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Index	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Index Index;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Index	src/Core/BandMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/Block.h	/^    typedef typename XprType::Index Index;$/;"	t	class:Eigen::BlockImpl	access:private
Index	src/Core/CommaInitializer.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::CommaInitializer	access:public
Index	src/Core/CoreIterators.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::DenseBase::InnerIterator	access:protected
Index	src/Core/CwiseBinaryOp.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/CwiseNullaryOp.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::setIdentity_impl	access:public
Index	src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Index Index; $/;"	t	class:Eigen::DenseBase	access:public
Index	src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Index	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DiagonalBase	access:public
Index	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::Index Index;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Index	src/Core/DiagonalMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::Index Index;$/;"	t	struct:Eigen::EigenBase	access:public
Index	src/Core/Map.h	/^  typedef typename PlainObjectType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/MapBase.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::MapBase	access:public
Index	src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MapBase	access:public
Index	src/Core/Matrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MatrixBase	access:public
Index	src/Core/PermutationMatrix.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map	access:public
Index	src/Core/PermutationMatrix.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::permut_matrix_product_retval	access:public
Index	src/Core/PermutationMatrix.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PermutationBase	access:public
Index	src/Core/PermutationMatrix.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::PlainObjectBase	access:public
Index	src/Core/PlainObjectBase.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::conservative_resize_like_impl	access:public
Index	src/Core/ProductBase.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/Redux.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Index	src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointView	access:public
Index	src/Core/SelfAdjointView.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Index	src/Core/SolveTriangular.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Index	src/Core/SolveTriangular.h	/^  typedef typename Rhs::Index Index;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Index	src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::InnerStride	access:public
Index	src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::OuterStride	access:public
Index	src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::Stride	access:public
Index	src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map	access:public
Index	src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Transpositions	access:public
Index	src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsBase	access:public
Index	src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Index	src/Core/Transpositions.h	/^    typedef typename TranspositionType::Index Index;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval	access:public
Index	src/Core/Transpositions.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/Transpositions.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::TriangularBase	access:public
Index	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Index Index;$/;"	t	class:Eigen::TriangularView	access:public
Index	src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Index	src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Index Index;$/;"	t	class:Eigen::VectorwiseOp	access:public
Index	src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::coeff_visitor	access:public
Index	src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::max_coeff_visitor	access:public
Index	src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::min_coeff_visitor	access:public
Index	src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::visitor_impl	access:public
Index	src/Core/products/CoeffBasedProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_impl	access:public
Index	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public
Index	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_unroller	access:public
Index	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_packet_impl	access:public
Index	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Index	src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexSchur	access:public
Index	src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::EigenSolver	access:public
Index	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Index	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public
Index	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Index	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public
Index	src/Eigenvalues/RealQZ.h	/^      typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::RealQZ	access:public
Index	src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::RealSchur	access:public
Index	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Index	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Index	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::Tridiagonalization	access:public
Index	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public
Index	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Index	src/Geometry/AlignedBox.h	/^  typedef DenseIndex                                Index;$/;"	t	class:Eigen::AlignedBox	access:public
Index	src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Index	src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Index	src/Geometry/Hyperplane.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Hyperplane	access:public
Index	src/Geometry/OrthoMethods.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Index	src/Geometry/ParametrizedLine.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::ParametrizedLine	access:public
Index	src/Geometry/Quaternion.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl	access:public
Index	src/Geometry/Transform.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Transform	access:public
Index	src/Householder/HouseholderSequence.h	/^    typedef typename VectorsType::Index Index;$/;"	t	class:Eigen::HouseholderSequence	access:public
Index	src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Index	src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename Vector::Index Index;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Index	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::BiCGSTAB	access:public
Index	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ConjugateGradient	access:public
Index	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename FactorType::Index Index;$/;"	t	class:Eigen::IncompleteLUT	access:private
Index	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Index	src/LU/FullPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivLU	access:public
Index	src/LU/Inverse.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
Index	src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PartialPivLU	access:public
Index	src/LU/PartialPivLU.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Index	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixBase	access:public
Index	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixLU	access:public
Index	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Index	src/PardisoSupport/PardisoSupport.h	/^    typedef long long int Index;$/;"	t	struct:Eigen::internal::pardiso_run_selector	access:public
Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLLT	access:protected
Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PardisoImpl	access:public
Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;    $/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Index	src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Index	src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Index	src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Index	src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Index	src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HouseholderQR	access:public
Index	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SuiteSparse_long Index ;$/;"	t	class:Eigen::SPQR	access:public
Index	src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::Index Index;$/;"	t	struct:Eigen::SPQR_QProduct	access:public
Index	src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::JacobiSVD	access:public
Index	src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Index	src/SVD/JacobiSVD.h	/^  typedef typename SVD::Index Index;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Index	src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Index	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Index	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Index	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Index	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLLT	access:public
Index	src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                              Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                          Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseCore/AmbiVector.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::AmbiVector	access:public
Index	src/SparseCore/CompressedStorage.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::CompressedStorage	access:public
Index	src/SparseCore/SparseBlock.h	/^        typedef typename BlockImpl::Index Index;$/;"	t	class:Eigen::BlockImpl::InnerIterator	access:private
Index	src/SparseCore/SparseBlock.h	/^        typedef typename BlockImpl::Index Index;$/;"	t	class:Eigen::BlockImpl::ReverseInnerIterator	access:private
Index	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public
Index	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Index	src/SparseCore/SparseDenseProduct.h	/^    typedef typename SparseDenseOuterProduct::Index Index;$/;"	t	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:private
Index	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Index	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseCore/SparseDiagonalProduct.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Index	src/SparseCore/SparseMatrix.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Index	src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Index	src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseCore/SparseProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseCore/SparseProduct.h	/^  typedef typename internal::traits<Lhs>::Index Index;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Index	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Index	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Index	src/SparseCore/SparseTranspose.h	/^    typedef typename TransposeImpl::Index Index;$/;"	t	class:Eigen::TransposeImpl::InnerIterator	access:private
Index	src/SparseCore/SparseTranspose.h	/^    typedef typename TransposeImpl::Index Index;$/;"	t	class:Eigen::TransposeImpl::ReverseInnerIterator	access:private
Index	src/SparseCore/SparseTriangularView.h	/^    typedef typename SparseTriangularView::Index Index;$/;"	t	class:Eigen::SparseTriangularView::InnerIterator	access:private
Index	src/SparseCore/SparseTriangularView.h	/^    typedef typename SparseTriangularView::Index Index;$/;"	t	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:private
Index	src/SparseCore/SparseVector.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseCore/SparseView.h	/^  typedef typename SparseView::Index Index;$/;"	t	class:Eigen::SparseView::InnerIterator	access:private
Index	src/SparseCore/TriangularSolver.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public
Index	src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::Index Index; $/;"	t	class:Eigen::SparseLU	access:public
Index	src/SparseLU/SparseLU.h	/^  typedef typename MappedSupernodalType::Index Index;$/;"	t	struct:Eigen::SparseLUMatrixLReturnType	access:public
Index	src/SparseLU/SparseLU.h	/^  typedef typename MatrixLType::Index Index;$/;"	t	struct:Eigen::SparseLUMatrixUReturnType	access:public
Index	src/SparseLU/SparseLU_Structs.h	/^  typedef typename IndexVector::Scalar Index; $/;"	t	struct:Eigen::internal::LU_GlobalLU_t	access:public
Index	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix	access:public
Index	src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename IndexVector::Scalar Index;$/;"	t	struct:Eigen::internal::column_dfs_traits	access:public
Index	src/SparseLU/SparseLU_panel_dfs.h	/^  typedef typename IndexVector::Scalar Index;$/;"	t	struct:Eigen::internal::panel_dfs_traits	access:public
Index	src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseQR	access:public
Index	src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Index Index;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType	access:public
Index	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Index Index;$/;"	t	struct:Eigen::SparseQR_QProduct	access:public
Index	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperILU	access:public
Index	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperLU	access:public
Index	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SuperLUBase	access:public
Index	src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::UmfPackLU	access:public
Index	src/misc/Image.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Index	src/misc/Kernel.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Index	src/misc/Solve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Index	src/misc/SparseSolve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Index	src/misc/SparseSolve.h	/^  typedef typename DecompositionType::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_with_guess	access:public
IndexVector	src/MetisSupport/MetisSupport.h	/^  typedef Matrix<Index,Dynamic,1> IndexVector; $/;"	t	class:Eigen::MetisOrdering	access:public
IndexVector	src/OrderingMethods/Ordering.h	/^    typedef Matrix<Index, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::COLAMDOrdering	access:public
IndexVector	src/SparseLU/SparseLU.h	/^    typedef Matrix<Index,Dynamic,1> IndexVector;$/;"	t	class:Eigen::SparseLU	access:public
IndexVector	src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Index,Dynamic,1> IndexVector; $/;"	t	class:Eigen::internal::SparseLUImpl	access:public
IndexVector	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<Index,Dynamic,1> IndexVector; $/;"	t	class:Eigen::internal::MappedSuperNodalMatrix	access:public
IndexVector	src/SparseQR/SparseQR.h	/^    typedef Matrix<Index, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::SparseQR	access:public
IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose	access:private
IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map	access:public
IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationBase	access:public
IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationMatrix	access:public
IndicesType	src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationWrapper	access:public
IndicesType	src/Core/PermutationMatrix.h	/^  typedef Map<const Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	src/Core/PermutationMatrix.h	/^  typedef Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	src/Core/PermutationMatrix.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map	access:public
IndicesType	src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Transpositions	access:public
IndicesType	src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsBase	access:public
IndicesType	src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
IndicesType	src/Core/Transpositions.h	/^    typedef typename TranspositionType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose	access:private
IndicesType	src/Core/Transpositions.h	/^  typedef Map<const Matrix<Index,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	src/Core/Transpositions.h	/^  typedef Matrix<Index, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	src/Core/Transpositions.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Infinity	src/Core/util/Constants.h	/^const int Infinity = -1;$/;"	m	namespace:Eigen
InnerIterator	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator(const Derived& expr, Index outer)$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:(const Derived& expr, Index outer)
InnerIterator	src/Core/CoreIterators.h	/^template<typename Derived> class DenseBase<Derived>::InnerIterator$/;"	c	class:Eigen::DenseBase
InnerIterator	src/Core/Flagged.h	/^    typedef typename ExpressionType::InnerIterator InnerIterator;$/;"	t	class:Eigen::Flagged	access:public
InnerIterator	src/SparseCore/MappedSparseMatrix.h	/^    InnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:(const MappedSparseMatrix& mat, Index outer)
InnerIterator	src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::InnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
InnerIterator	src/SparseCore/SparseBlock.h	/^        inline InnerIterator(const BlockType& xpr, Index outer)$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:(const BlockType& xpr, Index outer)
InnerIterator	src/SparseCore/SparseBlock.h	/^      EIGEN_STRONG_INLINE InnerIterator(const BlockType& block, Index outer)$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:(const BlockType& block, Index outer)
InnerIterator	src/SparseCore/SparseBlock.h	/^    class InnerIterator : public _MatrixTypeNested::InnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:_MatrixTypeNested::InnerIterator	access:public
InnerIterator	src/SparseCore/SparseBlock.h	/^    class InnerIterator: public SparseMatrixType::InnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:SparseMatrixType::InnerIterator	access:public
InnerIterator	src/SparseCore/SparseBlock.h	/^    class InnerIterator: public XprType::InnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:XprType::InnerIterator	access:public
InnerIterator	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseBinaryOpImpl& binOp, typename Lhs::Index outer)$/;"	f	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public	signature:(const CwiseBinaryOpImpl& binOp, typename Lhs::Index outer)
InnerIterator	src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp,Lhs,Rhs,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseBinaryOpImpl	inherits:internal::sparse_cwise_binary_op_inner_iterator_selector
InnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)
InnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)
InnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl	inherits:CwiseUnaryOpImpl::MatrixTypeIterator
InnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl	inherits:CwiseUnaryViewImpl::MatrixTypeIterator
InnerIterator	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseDenseOuterProduct& prod, Index outer)$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:(const SparseDenseOuterProduct& prod, Index outer)
InnerIterator	src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct<Lhs,Rhs,Transpose>::InnerIterator : public _LhsNested::InnerIterator$/;"	c	class:Eigen::SparseDenseOuterProduct	inherits:_LhsNested::InnerIterator
InnerIterator	src/SparseCore/SparseDiagonalProduct.h	/^                      <_LhsNested,_RhsNested,SparseDiagonalProduct,LhsMode,RhsMode> InnerIterator;$/;"	t	class:Eigen::SparseDiagonalProduct	access:public
InnerIterator	src/SparseCore/SparseMatrix.h	/^    InnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:(const SparseMatrix& mat, Index outer)
InnerIterator	src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseMatrix
InnerIterator	src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE InnerIterator(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)
InnerIterator	src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::TransposeImpl	inherits:_MatrixTypeNested::InnerIterator
InnerIterator	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:(const SparseTriangularView& view, Index outer)
InnerIterator	src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::InnerIterator : public MatrixTypeNestedCleaned::InnerIterator$/;"	c	class:Eigen::SparseTriangularView	inherits:MatrixTypeNestedCleaned::InnerIterator
InnerIterator	src/SparseCore/SparseVector.h	/^    InnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:(const SparseVector& vec, Index outer=0)
InnerIterator	src/SparseCore/SparseVector.h	/^    InnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:(const internal::CompressedStorage<Scalar,Index>& data)
InnerIterator	src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseVector
InnerIterator	src/SparseCore/SparseView.h	/^  InnerIterator(const SparseView& view, Index outer) :$/;"	f	class:Eigen::SparseView::InnerIterator	access:public	signature:(const SparseView& view, Index outer)
InnerIterator	src/SparseCore/SparseView.h	/^class SparseView<MatrixType>::InnerIterator : public _MatrixTypeNested::InnerIterator$/;"	c	class:Eigen::SparseView	inherits:_MatrixTypeNested::InnerIterator
InnerIterator	src/SparseLU/SparseLU_SupernodalMatrix.h	/^     InnerIterator(const MappedSuperNodalMatrix& mat, Index outer)$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:(const MappedSuperNodalMatrix& mat, Index outer)
InnerIterator	src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix<Scalar,Index>::InnerIterator$/;"	c	class:Eigen::internal::MappedSuperNodalMatrix
InnerMaxSize	src/Core/Assign.h	/^    InnerMaxSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon131
InnerMaxSize	src/Core/Assign_MKL.h	/^      InnerMaxSize  = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
InnerMaxSize	src/Core/Redux.h	/^    InnerMaxSize = int(Derived::IsRowMajor)$/;"	e	enum:Eigen::internal::redux_traits::__anon296
InnerProduct	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
InnerRandomAccessPattern	src/SparseCore/SparseUtil.h	/^const int InnerRandomAccessPattern  = 0x2 | CoherentAccessPattern;$/;"	m	namespace:Eigen
InnerSize	src/Core/Assign.h	/^    InnerSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon131
InnerSize	src/Core/Assign_MKL.h	/^      InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
InnerSize	src/Core/Block.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon146
InnerSize	src/Core/products/CoeffBasedProduct.h	/^      InnerSize  = internal::traits<CoeffBasedProduct>::InnerSize,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon31
InnerSize	src/Core/products/CoeffBasedProduct.h	/^      InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
InnerSize	src/SparseCore/SparseProduct.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon452
InnerSizeAtCompileTime	src/Core/DenseBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::DenseBase::__anon155
InnerSizeAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
InnerStride	src/Core/Stride.h	/^    InnerStride() : Base() {}$/;"	f	class:Eigen::InnerStride	access:public	signature:()
InnerStride	src/Core/Stride.h	/^    InnerStride(Index v) : Base(0, v) {}$/;"	f	class:Eigen::InnerStride	access:public	signature:(Index v)
InnerStride	src/Core/Stride.h	/^class InnerStride : public Stride<0, Value>$/;"	c	namespace:Eigen	inherits:Stride
InnerStrideAtCompileTime	src/Core/Block.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon146
InnerStrideAtCompileTime	src/Core/CwiseUnaryView.h	/^    InnerStrideAtCompileTime = MatrixTypeInnerStride == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon154
InnerStrideAtCompileTime	src/Core/DenseBase.h	/^      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,$/;"	e	enum:Eigen::DenseBase::__anon155
InnerStrideAtCompileTime	src/Core/Diagonal.h	/^    InnerStrideAtCompileTime = MatrixTypeOuterStride == Dynamic ? Dynamic : MatrixTypeOuterStride+1,$/;"	e	enum:Eigen::internal::traits::__anon161
InnerStrideAtCompileTime	src/Core/Map.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon274
InnerStrideAtCompileTime	src/Core/Matrix.h	/^    InnerStrideAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon282
InnerStrideAtCompileTime	src/Core/SelfCwiseBinaryOp.h	/^    InnerStrideAtCompileTime = Lhs::InnerStrideAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon318
InnerStrideAtCompileTime	src/Core/Stride.h	/^      InnerStrideAtCompileTime = _InnerStrideAtCompileTime,$/;"	e	enum:Eigen::Stride::__anon322
InnerStrideAtCompileTime	src/Core/Transpose.h	/^    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon323
InnerStrideMatch	src/Core/Ref.h	/^      InnerStrideMatch = int(StrideType::InnerStrideAtCompileTime)==int(Dynamic)$/;"	e	enum:Eigen::internal::traits::match::__anon307
InnerUnrolling	src/Core/util/Constants.h	/^  InnerUnrolling,$/;"	e	enum:Eigen::__anon64
InnerVectorReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true>       InnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
InnerVectorizedTraversal	src/Core/util/Constants.h	/^  InnerVectorizedTraversal,$/;"	e	enum:Eigen::__anon63
InnerVectorsReturnType	src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,Dynamic,Dynamic,true> InnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
InputScalar	src/Core/VectorwiseOp.h	/^  typedef typename MatrixType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::traits	access:public
IntColVectorType	src/Eigen2Support/LU.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::LU	access:public
IntColVectorType	src/LU/FullPivLU.h	/^    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	class:Eigen::FullPivLU	access:public
IntColVectorType	src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
IntColVectorType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;    $/;"	t	class:Eigen::SuperLUBase	access:public
IntColVectorType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntColVectorType IntColVectorType;    $/;"	t	class:Eigen::SuperLU	access:public
IntColVectorType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::UmfPackLU	access:public
IntDiagSizeVectorType	src/QR/FullPivHouseholderQR.h	/^                   EIGEN_SIZE_MIN_PREFER_FIXED(MaxColsAtCompileTime,MaxRowsAtCompileTime)> IntDiagSizeVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
IntDiagSizeVectorType	src/QR/FullPivHouseholderQR.h	/^  typedef typename FullPivHouseholderQR<MatrixType>::IntDiagSizeVectorType IntDiagSizeVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
IntRowVectorType	src/Eigen2Support/LU.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::LU	access:public
IntRowVectorType	src/LU/FullPivLU.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::FullPivLU	access:public
IntRowVectorType	src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
IntRowVectorType	src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
IntRowVectorType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::SuperLUBase	access:public
IntRowVectorType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntRowVectorType IntRowVectorType;$/;"	t	class:Eigen::SuperLU	access:public
IntRowVectorType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::UmfPackLU	access:public
InvalidInput	src/Core/util/Constants.h	/^  InvalidInput = 3$/;"	e	enum:Eigen::ComputationInfo
InvalidTraversal	src/Core/util/Constants.h	/^  InvalidTraversal,$/;"	e	enum:Eigen::__anon63
IsAligned	src/Core/Map.h	/^    IsAligned = bool(EIGEN_ALIGN) && ((int(MapOptions)&Aligned)==Aligned),$/;"	e	enum:Eigen::internal::traits::__anon274
IsAligned	src/Geometry/Quaternion.h	/^    IsAligned = internal::traits<Coefficients>::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::traits::__anon376
IsAligned	src/Geometry/Quaternion.h	/^  enum { IsAligned = internal::traits<Quaternion>::IsAligned };$/;"	e	enum:Eigen::Quaternion::__anon377
IsColMajor	src/Core/Reverse.h	/^      IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::Reverse::__anon312
IsColVector	src/Core/VectorBlock.h	/^      IsColVector = !(internal::traits<VectorType>::Flags & RowMajorBit)$/;"	e	enum:Eigen::VectorBlock::__anon330
IsColVector	src/SparseCore/SparseVector.h	/^    IsColVector = (_Options & RowMajorBit) ? 0 : 1,$/;"	e	enum:Eigen::internal::traits::__anon456
IsColVector	src/SparseCore/SparseVector.h	/^    enum { IsColVector = internal::traits<SparseVector>::IsColVector };$/;"	e	enum:Eigen::SparseVector::__anon458
IsComplex	src/Core/NumTraits.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
IsComplex	src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon58
IsComplex	src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon59
IsDense	src/Core/Block.h	/^    IsDense = is_same<StorageKind,Dense>::value,$/;"	e	enum:Eigen::internal::traits::__anon146
IsDense	src/Core/util/Constants.h	/^  IsDense         = 0,$/;"	e	enum:Eigen::__anon68
IsDynamicSize	src/Core/Map.h	/^    IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon274
IsHorizontal	src/Core/VectorwiseOp.h	/^      IsHorizontal = (Direction==Horizontal) ? 1 : 0$/;"	e	enum:Eigen::VectorwiseOp::__anon334
IsInteger	src/Core/NumTraits.h	/^    IsInteger = std::numeric_limits<T>::is_integer,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
IsLower	src/Core/SolveTriangular.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon321
IsLower	src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon52
IsLower	src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon53
IsLower	src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon54
IsLower	src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon55
IsLower	src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon56
IsLower	src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon57
IsProjective	src/Geometry/Transform.h	/^    IsProjective = (int(Mode)==int(Projective))$/;"	e	enum:Eigen::internal::transform_traits::__anon383
IsRepeatable	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon199
IsRepeatable	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon197
IsRepeatable	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon198
IsRepeatable	src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon295
IsRowMajor	src/Core/Block.h	/^    IsRowMajor = (IsDense&&MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon146
IsRowMajor	src/Core/CoreIterators.h	/^    enum { IsRowMajor = (Derived::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::DenseBase::InnerIterator::__anon149
IsRowMajor	src/Core/DenseBase.h	/^      IsRowMajor = int(Flags) & RowMajorBit, \/**< True if this expression has row-major storage order. *\/$/;"	e	enum:Eigen::DenseBase::__anon155
IsRowMajor	src/Core/Replicate.h	/^    IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1$/;"	e	enum:Eigen::internal::traits::__anon309
IsRowMajor	src/SparseCore/MappedSparseMatrix.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::MappedSparseMatrix::__anon431
IsRowMajor	src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon432
IsRowMajor	src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon434
IsRowMajor	src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon436
IsRowMajor	src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon438
IsRowMajor	src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Lhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon439
IsRowMajor	src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Rhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon440
IsRowMajor	src/SparseCore/SparseMatrixBase.h	/^      IsRowMajor = Flags&RowMajorBit ? 1 : 0,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
IsSigned	src/Core/NumTraits.h	/^    IsSigned = std::numeric_limits<T>::is_signed,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
IsSparse	src/Core/util/Constants.h	/^  IsSparse$/;"	e	enum:Eigen::__anon68
IsSupported	src/Core/Assign_MKL.h	/^{ enum { IsSupported = 0 }; };$/;"	e	enum:Eigen::internal::vml_call::__anon138
IsTransposed	src/Core/util/BlasUtil.h	/^    IsTransposed = Base::IsTransposed ? 0 : 1$/;"	e	enum:Eigen::internal::blas_traits::__anon60
IsTransposed	src/Core/util/BlasUtil.h	/^    IsTransposed = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon58
IsVectorAtCompileTime	src/Core/DenseBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::DenseBase::__anon155
IsVectorAtCompileTime	src/Core/DiagonalMatrix.h	/^      IsVectorAtCompileTime = 0,$/;"	e	enum:Eigen::DiagonalBase::__anon163
IsVectorAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
IsVertical	src/Core/VectorwiseOp.h	/^      IsVertical   = (Direction==Vertical) ? 1 : 0,$/;"	e	enum:Eigen::VectorwiseOp::__anon334
Isometry	src/Core/util/Constants.h	/^  Isometry      = 0x1,$/;"	e	enum:Eigen::TransformTraits
Isometry2d	src/Geometry/Transform.h	/^typedef Transform<double,2,Isometry> Isometry2d;$/;"	t	namespace:Eigen
Isometry2f	src/Geometry/Transform.h	/^typedef Transform<float,2,Isometry> Isometry2f;$/;"	t	namespace:Eigen
Isometry3d	src/Geometry/Transform.h	/^typedef Transform<double,3,Isometry> Isometry3d;$/;"	t	namespace:Eigen
Isometry3f	src/Geometry/Transform.h	/^typedef Transform<float,3,Isometry> Isometry3f;$/;"	t	namespace:Eigen
IsometryTransformType	src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Isometry> IsometryTransformType;$/;"	t	class:Eigen::Translation	access:public
IterBase	src/SparseCore/SparseView.h	/^  typedef typename _MatrixTypeNested::InnerIterator IterBase;$/;"	t	class:Eigen::SparseView::InnerIterator	access:public
IterativeSolverBase	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase()$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
IterativeSolverBase	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const EigenBase<InputDerived>& A)
IterativeSolverBase	src/IterativeLinearSolvers/IterativeSolverBase.h	/^class IterativeSolverBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Iterator	src/SparseCore/AmbiVector.h	/^    Iterator(const AmbiVector& vec, const RealScalar& epsilon = 0)$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:(const AmbiVector& vec, const RealScalar& epsilon = 0)
Iterator	src/SparseCore/AmbiVector.h	/^class AmbiVector<_Scalar,_Index>::Iterator$/;"	c	class:Eigen::internal::AmbiVector
JRs	src/Eigenvalues/RealQZ.h	/^      typedef JacobiRotation<Scalar> JRs;$/;"	t	class:Eigen::RealQZ	access:private
JacobiRotation	src/Jacobi/Jacobi.h	/^    JacobiRotation() {}$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
JacobiRotation	src/Jacobi/Jacobi.h	/^    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}$/;"	f	class:Eigen::JacobiRotation	access:public	signature:(const Scalar& c, const Scalar& s)
JacobiRotation	src/Jacobi/Jacobi.h	/^template<typename Scalar> class JacobiRotation$/;"	c	namespace:Eigen
JacobiSVD	src/SVD/JacobiSVD.h	/^    JacobiSVD()$/;"	f	class:Eigen::JacobiSVD	access:public	signature:()
JacobiSVD	src/SVD/JacobiSVD.h	/^    JacobiSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(Index rows, Index cols, unsigned int computationOptions = 0)
JacobiSVD	src/SVD/JacobiSVD.h	/^    JacobiSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix, unsigned int computationOptions = 0)
JacobiSVD	src/SVD/JacobiSVD.h	/^template<typename _MatrixType, int QRPreconditioner> class JacobiSVD$/;"	c	namespace:Eigen
JacobiSVDType	src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<_MatrixType, QRPreconditioner> JacobiSVDType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
JointAlignment	src/Core/Assign.h	/^    JointAlignment = assign_traits<Derived1,Derived2>::JointAlignment$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon137
JointAlignment	src/Core/Assign.h	/^    JointAlignment = bool(DstIsAligned) && bool(SrcIsAligned) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::assign_traits::__anon130
KILL_NON_PRINCIPAL_COL	src/OrderingMethods/Eigen_Colamd.h	131;"	d
KILL_PRINCIPAL_COL	src/OrderingMethods/Eigen_Colamd.h	130;"	d
KILL_ROW	src/OrderingMethods/Eigen_Colamd.h	129;"	d
KMADD	src/SparseLU/SparseLU_gemm_kernel.h	107;"	d
KMADD	src/SparseLU/SparseLU_gemm_kernel.h	273;"	d
KeepsPacketAccess	src/Core/Map.h	/^    KeepsPacketAccess = bool(HasNoInnerStride)$/;"	e	enum:Eigen::internal::traits::__anon274
KernelResultType	src/Eigen2Support/LU.h	/^    > KernelResultType;$/;"	t	class:Eigen::LU	access:public
LDLT	src/Cholesky/LDLT.h	/^    LDLT() $/;"	f	class:Eigen::LDLT	access:public	signature:()
LDLT	src/Cholesky/LDLT.h	/^    LDLT(Index size)$/;"	f	class:Eigen::LDLT	access:public	signature:(Index size)
LDLT	src/Cholesky/LDLT.h	/^    LDLT(const MatrixType& matrix)$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixType& matrix)
LDLT	src/Cholesky/LDLT.h	/^template<typename _MatrixType, int _UpLo> class LDLT$/;"	c	namespace:Eigen
LDLTTraits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT<MatrixType,UpLo> > LDLTTraits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
LDLTType	src/Cholesky/LDLT.h	/^  typedef LDLT<_MatrixType,_UpLo> LDLTType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
LDLT_Traits	src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LDLT_Traits	src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LLT	src/Cholesky/LLT.h	/^    LLT() : m_matrix(), m_isInitialized(false) {}$/;"	f	class:Eigen::LLT	access:public	signature:()
LLT	src/Cholesky/LLT.h	/^    LLT(Index size) : m_matrix(size, size),$/;"	f	class:Eigen::LLT	access:public	signature:(Index size)
LLT	src/Cholesky/LLT.h	/^    LLT(const MatrixType& matrix)$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixType& matrix)
LLT	src/Cholesky/LLT.h	/^template<typename _MatrixType, int _UpLo> class LLT$/;"	c	namespace:Eigen
LLTTraits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT<MatrixType,UpLo>  > LLTTraits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
LLTType	src/Cholesky/LLT.h	/^  typedef LLT<_MatrixType,UpLo> LLTType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
LLT_Traits	src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LLT_Traits	src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LLVL	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
LMatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType, Lower|UnitDiag>  LMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
LSUB	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
LU	src/Eigen2Support/LU.h	/^    explicit LU(const T& t) : Base(t), m_originalMatrix(t) {}$/;"	f	class:Eigen::LU	access:public	signature:(const T& t)
LU	src/Eigen2Support/LU.h	/^class LU : public FullPivLU<MatrixType>$/;"	c	namespace:Eigen	inherits:FullPivLU
LUMatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::SuperLUBase	access:public
LUMatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::LUMatrixType LUMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
LUMatrixType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
LUNoMarker	src/SparseLU/SparseLU_Memory.h	/^enum { LUNoMarker = 3 };$/;"	e	enum:Eigen::internal::__anon461
LUSUP	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
LUTempSpace	src/SparseLU/SparseLU_Memory.h	/^inline Index LUTempSpace(Index&m, Index& w)$/;"	f	namespace:Eigen::internal	signature:(Index&m, Index& w)
LU_GlobalLU_t	src/SparseLU/SparseLU_Structs.h	/^struct LU_GlobalLU_t {$/;"	s	namespace:Eigen::internal
LU_kernel_bmod	src/SparseLU/SparseLU_kernel_bmod.h	/^template <> struct LU_kernel_bmod<1>$/;"	s	namespace:Eigen::internal
LU_kernel_bmod	src/SparseLU/SparseLU_kernel_bmod.h	/^template <int SegSizeAtCompileTime> struct LU_kernel_bmod$/;"	s	namespace:Eigen::internal
LUnumTempV	src/SparseLU/SparseLU_Memory.h	/^inline Index LUnumTempV(Index& m, Index& w, Index& t, Index& b)$/;"	f	namespace:Eigen::internal	signature:(Index& m, Index& w, Index& t, Index& b)
Large	src/Core/GeneralProduct.h	/^  Large = 2,$/;"	e	enum:Eigen::__anon241
LargeEnough	src/Core/Assign_MKL.h	/^      LargeEnough = VmlSize==Dynamic || VmlSize>=EIGEN_MKL_VML_THRESHOLD,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
LargeThreshold	src/Core/GeneralProduct.h	/^    LargeThreshold = EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD$/;"	e	enum:Eigen::internal::product_type::__anon243
LazyCoeffBasedProductMode	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
LazyCoeffBasedProductType	src/Core/products/CoeffBasedProduct.h	/^    typedef CoeffBasedProduct<LhsNested,RhsNested,NestByRefBit> LazyCoeffBasedProductType;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
LazyProductReturnType	src/Core/GeneralProduct.h	/^struct LazyProductReturnType : public ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen	inherits:ProductReturnType
Lhs	src/Core/ProductBase.h	/^  typedef typename remove_all<_Lhs>::type Lhs;$/;"	t	struct:Eigen::internal::traits	access:public
Lhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Lhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,LhsMode,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Lhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Lhs	src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<SparseLhsType>::type Lhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
LhsBlasTraits	src/Core/ProductBase.h	/^    typedef internal::blas_traits<_LhsNested> LhsBlasTraits;$/;"	t	class:Eigen::ProductBase	access:public
LhsCleaned	src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
LhsCoeffReadCost	src/Core/CwiseBinaryOp.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon151
LhsCoeffReadCost	src/Core/products/CoeffBasedProduct.h	/^      LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon30
LhsCoeffReadCost	src/SparseCore/SparseDenseProduct.h	/^    LhsCoeffReadCost = traits<_LhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon441
LhsCoeffReadCost	src/SparseCore/SparseProduct.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon452
LhsFlags	src/Core/CwiseBinaryOp.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon151
LhsFlags	src/Core/products/CoeffBasedProduct.h	/^      LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon30
LhsFlags	src/SparseCore/SparseProduct.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon452
LhsInnerIterator	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::InnerIterator LhsInnerIterator;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
LhsIsSelfAdjoint	src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsSelfAdjoint = (LhsMode&SelfAdjoint)==SelfAdjoint,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon49
LhsIsUpper	src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsUpper = (LhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon49
LhsIterator	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _LhsNested::InnerIterator LhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
LhsMatrixType	src/Geometry/Homogeneous.h	/^  typedef typename take_matrix_for_product<Lhs>::type LhsMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
LhsMatrixType	src/Geometry/Homogeneous.h	/^  typedef typename traits<homogeneous_left_product_impl>::LhsMatrixType LhsMatrixType;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
LhsMatrixTypeCleaned	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
LhsMatrixTypeCleaned	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
LhsMatrixTypeNested	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename LhsMatrixTypeCleaned::Nested>::type LhsMatrixTypeNested;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
LhsMode	src/SparseCore/SparseDiagonalProduct.h	/^      LhsMode = internal::is_diagonal<_LhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon444
LhsNested	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Lhs>::type LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
LhsNested	src/Core/CwiseBinaryOp.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
LhsNested	src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Lhs, Rhs::ColsAtCompileTime, typename internal::plain_matrix_type<Lhs>::type >::type LhsNested;$/;"	t	struct:Eigen::ProductReturnType	access:public
LhsNested	src/Core/ProductBase.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::ProductBase	access:public
LhsNested	src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::LhsNested LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
LhsNested	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
LhsNested	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
LhsNested	src/SparseCore/SparseProduct.h	/^    typename internal::nested<Lhs,Rhs::RowsAtCompileTime>::type>::type LhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
LhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::LhsPacket LhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
LhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,RealPacket,  Scalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
LhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
LhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
LhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
LhsPacketSize	src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon46
LhsPacketSize	src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon47
LhsProductTraits	src/Core/SolveTriangular.h	/^  typedef blas_traits<Lhs> LhsProductTraits;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress   = Traits::LhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon38
LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
LhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
LhsRowMajor	src/Core/products/CoeffBasedProduct.h	/^      LhsRowMajor = LhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon30
LhsRowMajor	src/SparseCore/SparseProduct.h	/^    LhsRowMajor = internal::traits<Lhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon451
LhsScalar	src/Core/GeneralProduct.h	/^    typedef typename Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
LhsScalar	src/Core/ProductBase.h	/^    typedef typename internal::traits<Lhs>::Scalar LhsScalar;$/;"	t	class:Eigen::ProductBase	access:public
LhsScalar	src/Core/SolveTriangular.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
LhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar> LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::level3_blocking	access:private
LhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
LhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
LhsUpLo	src/Core/products/SelfadjointMatrixVector.h	/^    LhsUpLo = LhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon50
LinSpaced	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& low, const Scalar& high)
LinSpaced	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Sequential_t, Index size, const Scalar& low, const Scalar& high)
LinSpaced	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Sequential_t, const Scalar& low, const Scalar& high)
LinSpaced	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& low, const Scalar& high)
LinSpaced	src/Core/DenseBase.h	/^    LinSpaced(Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& low, const Scalar& high)
LinSpaced	src/Core/DenseBase.h	/^    LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Sequential_t, Index size, const Scalar& low, const Scalar& high)
LinSpaced	src/Core/DenseBase.h	/^    LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Sequential_t, const Scalar& low, const Scalar& high)
LinSpaced	src/Core/DenseBase.h	/^    LinSpaced(const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& low, const Scalar& high)
LinearAccess	src/Core/Reverse.h	/^    LinearAccess = ( (Direction==BothDirections) && (int(_MatrixTypeNested::Flags)&PacketAccessBit) )$/;"	e	enum:Eigen::internal::traits::__anon311
LinearAccessBit	src/Core/util/Constants.h	/^const unsigned int LinearAccessBit = 0x10;$/;"	m	namespace:Eigen
LinearMatrixType	src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Scaling	access:public
LinearMatrixType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Transform	access:public
LinearMatrixType	src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation	access:public
LinearMatrixType	src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim,Options> LinearMatrixType;$/;"	t	class:Eigen::Transform	access:public
LinearMatrixType	src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation	access:public
LinearPart	src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim> LinearPart;$/;"	t	class:Eigen::Transform	access:public
LinearPart	src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> LinearPart;$/;"	t	class:Eigen::Transform	access:public
LinearTraversal	src/Core/util/Constants.h	/^  LinearTraversal,$/;"	e	enum:Eigen::__anon63
LinearVectorizedTraversal	src/Core/util/Constants.h	/^  LinearVectorizedTraversal,$/;"	e	enum:Eigen::__anon63
ListEl	src/SparseCore/AmbiVector.h	/^    struct ListEl$/;"	s	class:Eigen::internal::AmbiVector	access:protected
Lower	src/Core/util/Constants.h	/^  Lower=0x1,                      $/;"	e	enum:Eigen::__anon61
LowerTriangular	src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangular = Lower;$/;"	m	namespace:Eigen
LowerTriangularBit	src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangularBit = Lower;$/;"	m	namespace:Eigen
LvalueBit	src/Core/util/Constants.h	/^const unsigned int LvalueBit = 0x20;$/;"	m	namespace:Eigen
MADD	src/Core/products/GeneralBlockPanelKernel.h	106;"	d
MADD	src/Core/products/GeneralBlockPanelKernel.h	131;"	d
METIS_SUPPORT_H	src/MetisSupport/MetisSupport.h	10;"	d
M_PI	src/Eigen2Support/Geometry/All.h	7;"	d
Map	src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index a_size, const StrideType& a_stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType dataPtr, Index a_size, const StrideType& a_stride = StrideType())
Map	src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index nbRows, Index nbCols, const StrideType& a_stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType dataPtr, Index nbRows, Index nbCols, const StrideType& a_stride = StrideType())
Map	src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, const StrideType& a_stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType dataPtr, const StrideType& a_stride = StrideType())
Map	src/Core/Map.h	/^template<typename PlainObjectType, int MapOptions, typename StrideType> class Map$/;"	c	namespace:Eigen	inherits:MapBase
Map	src/Core/PermutationMatrix.h	/^    inline Map(const Index* indicesPtr)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indicesPtr)
Map	src/Core/PermutationMatrix.h	/^    inline Map(const Index* indicesPtr, Index size)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indicesPtr, Index size)
Map	src/Core/PermutationMatrix.h	/^class Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess>$/;"	c	namespace:Eigen	inherits:PermutationBase
Map	src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data)
Map	src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols)
Map	src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size)
Map	src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data)
Map	src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols)
Map	src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size)
Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, const Stride<Outer, Inner>& stride)
Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Map	src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, const Stride<Outer, Inner>& stride)
Map	src/Core/Transpositions.h	/^    inline Map(const Index* indicesPtr)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indicesPtr)
Map	src/Core/Transpositions.h	/^    inline Map(const Index* indicesPtr, Index size)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indicesPtr, Index size)
Map	src/Core/Transpositions.h	/^class Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,PacketAccess>$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Map	src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map	access:public	signature:(Scalar* coeffs)
Map	src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(const Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map	access:public	signature:(const Scalar* coeffs)
Map	src/Geometry/Quaternion.h	/^class Map<Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Map	src/Geometry/Quaternion.h	/^class Map<const Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Map	src/SparseCore/CompressedStorage.h	/^    static CompressedStorage Map(Index* indices, Scalar* values, size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index* indices, Scalar* values, size_t size)
Map	src/SparseCore/SparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::SparseMatrix	access:public
Map	src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(MatrixBase<MatrixType>& _mat)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(MatrixBase<MatrixType>& _mat)
Map	src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(SparseMatrixBase<MatrixType>& mat)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(SparseMatrixBase<MatrixType>& mat)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, const Stride<Outer, Inner>& stride)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
MapAligned	src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, const Stride<Outer, Inner>& stride)
MapBase	src/Core/MapBase.h	/^    explicit inline MapBase(PointerType dataPtr) : Base(dataPtr) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr)
MapBase	src/Core/MapBase.h	/^    explicit inline MapBase(PointerType dataPtr) : m_data(dataPtr), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr)
MapBase	src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols) : Base(dataPtr, nbRows, nbCols) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr, Index nbRows, Index nbCols)
MapBase	src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr, Index nbRows, Index nbCols)
MapBase	src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index vecSize) : Base(dataPtr, vecSize) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr, Index vecSize)
MapBase	src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index vecSize)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType dataPtr, Index vecSize)
MapBase	src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
MapBase	src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, WriteAccessors>$/;"	c	namespace:Eigen	inherits:MapBase
MapLU	src/LU/PartialPivLU.h	/^  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
MapType	src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Unaligned>  MapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
MappedMatrixBlock	src/SparseLU/SparseLUImpl.h	/^    typedef Map<ScalarMatrix, 0,  OuterStride<> > MappedMatrixBlock;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
MappedRhs	src/Core/SolveTriangular.h	/^  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
MappedSparseMatrix	src/SparseCore/MappedSparseMatrix.h	/^    inline MappedSparseMatrix(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)
MappedSparseMatrix	src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
MappedSuperNodalMatrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
MappedSuperNodalMatrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix(Index m, Index n,  ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:(Index m, Index n, ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, IndexVector& rowind_colptr, IndexVector& col_to_sup, IndexVector& sup_to_col )
MappedSuperNodalMatrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix$/;"	c	namespace:Eigen::internal
MaskAlignedBit	src/Core/Block.h	/^    MaskAlignedBit = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic) && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % 16) == 0)) ? AlignedBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon146
MaskLvalueBit	src/Core/Diagonal.h	/^    MaskLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon161
MaskPacketAccessBit	src/Core/Block.h	/^    MaskPacketAccessBit = (InnerSize == Dynamic || (InnerSize % packet_traits<Scalar>::size) == 0)$/;"	e	enum:Eigen::internal::traits::__anon146
MatchAtCompileTime	src/Core/Ref.h	/^      MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && AlignmentMatch && ScalarTypeMatch$/;"	e	enum:Eigen::internal::traits::match::__anon307
Matrix	src/Core/Map.h	/^  ::Matrix(const Scalar *data)$/;"	f	class:Eigen::Matrix	signature:(const Scalar *data)
Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix() : Base()$/;"	f	class:Eigen::Matrix	access:public	signature:()
Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const EigenBase<OtherDerived> &other)
Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Matrix& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Matrix& other)
Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)$/;"	f	class:Eigen::Matrix	access:public	signature:(const T0& x, const T1& y)
Matrix	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix(Index dim)$/;"	f	class:Eigen::Matrix	access:public	signature:(Index dim)
Matrix	src/Core/Matrix.h	/^    Matrix(Index rows, Index cols);$/;"	p	class:Eigen::Matrix	access:public	signature:(Index rows, Index cols)
Matrix	src/Core/Matrix.h	/^    Matrix(Matrix&& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(Matrix&& other)
Matrix	src/Core/Matrix.h	/^    Matrix(const Scalar& x, const Scalar& y);$/;"	p	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y)
Matrix	src/Core/Matrix.h	/^    Matrix(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Matrix	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Matrix	src/Core/Matrix.h	/^    explicit Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Matrix	src/Core/Matrix.h	/^    explicit Matrix(const Scalar *data);$/;"	p	class:Eigen::Matrix	access:public	signature:(const Scalar *data)
Matrix	src/Core/Matrix.h	/^    explicit Matrix(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r)
Matrix	src/Core/Matrix.h	/^class Matrix$/;"	c	namespace:Eigen	inherits:PlainObjectBase
Matrix	src/Eigen2Support/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Matrix	src/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Matrix2	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D	access:public
Matrix2	src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D	access:public
Matrix2s	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,2> Matrix2s;$/;"	t	class:Eigen::RealQZ	access:private
Matrix3	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis	access:public
Matrix3	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::Quaternion	access:public
Matrix3	src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis	access:public
Matrix3	src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::QuaternionBase	access:public
MatrixAlignment	src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon396
MatrixAlignment	src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon397
MatrixBase	src/Core/MatrixBase.h	/^    MatrixBase() : Base() {}$/;"	f	class:Eigen::MatrixBase	access:protected	signature:()
MatrixBase	src/Core/MatrixBase.h	/^    MatrixBase(int,int);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(int,int)
MatrixBase	src/Core/MatrixBase.h	/^    explicit MatrixBase(int);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(int)
MatrixBase	src/Core/MatrixBase.h	/^    template<typename OtherDerived> explicit MatrixBase(const MatrixBase<OtherDerived>&);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(const MatrixBase<OtherDerived>&)
MatrixBase	src/Core/MatrixBase.h	/^template<typename Derived> class MatrixBase$/;"	c	namespace:Eigen	inherits:DenseBase
MatrixBase::lazyAssign	src/Core/ProductBase.h	/^Derived& MatrixBase<Derived>::lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:MatrixBase	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
MatrixCols	src/Core/Block.h	/^    MatrixCols = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon146
MatrixConjugateReturnType	src/Core/TriangularMatrix.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::TriangularView	access:protected
MatrixHReturnType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef internal::HessenbergDecompositionMatrixHReturnType<MatrixType> MatrixHReturnType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
MatrixL	src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
MatrixL	src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
MatrixL	src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
MatrixL	src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
MatrixL	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLDLT	access:public
MatrixL	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLLT	access:public
MatrixL	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::Lower>  MatrixL;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixL	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::UnitLower>  MatrixL;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixOptions	src/SVD/JacobiSVD.h	/^      MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::JacobiSVD::__anon422
MatrixQReturnType	src/QR/FullPivHouseholderQR.h	/^    typedef internal::FullPivHouseholderQRMatrixQReturnType<MatrixType> MatrixQReturnType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
MatrixQType	src/QR/ColPivHouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, Options, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
MatrixQType	src/QR/HouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::HouseholderQR	access:public
MatrixRBlockType	src/Eigen2Support/QR.h	/^    typedef Block<const MatrixType, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixRBlockType;$/;"	t	class:Eigen::QR	access:public
MatrixRows	src/Core/Block.h	/^    MatrixRows = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon146
MatrixTReturnType	src/Eigenvalues/Tridiagonalization.h	/^    typedef internal::TridiagonalizationMatrixTReturnType<MatrixTypeRealView> MatrixTReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
MatrixType	src/Cholesky/LDLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LDLT	access:public
MatrixType	src/Cholesky/LLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LLT	access:public
MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodBase	access:public
MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodDecomposition	access:public
MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLDLT	access:public
MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLLT	access:public
MatrixType	src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSupernodalLLT	access:public
MatrixType	src/Core/GeneralProduct.h	/^    typedef typename internal::conditional<int(Side)==OnTheRight,_LhsNested,_RhsNested>::type MatrixType;$/;"	t	class:Eigen::GeneralProduct	access:public
MatrixType	src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularView	access:public
MatrixType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,HDim,HDim> MatrixType;$/;"	t	class:Eigen::Transform	access:public
MatrixType	src/Eigen2Support/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
MatrixType	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
MatrixType	src/Eigenvalues/ComplexSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexSchur	access:public
MatrixType	src/Eigenvalues/EigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::EigenSolver	access:public
MatrixType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
MatrixType	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public
MatrixType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
MatrixType	src/Eigenvalues/RealQZ.h	/^      typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealQZ	access:public
MatrixType	src/Eigenvalues/RealSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealSchur	access:public
MatrixType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
MatrixType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
MatrixType	src/Eigenvalues/Tridiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::Tridiagonalization	access:public
MatrixType	src/Geometry/Transform.h	/^  typedef typename Transform<Scalar,Dim,AffineCompact,Options>::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
MatrixType	src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
MatrixType	src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
MatrixType	src/Geometry/Transform.h	/^  typedef typename internal::make_proper_matrix_type<Scalar,Rows,HDim,Options>::type MatrixType;$/;"	t	class:Eigen::Transform	access:public
MatrixType	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::DiagonalPreconditioner	access:public
MatrixType	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BiCGSTAB	access:public
MatrixType	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ConjugateGradient	access:public
MatrixType	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::IncompleteLUT	access:public
MatrixType	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::IterativeSolverBase	access:public
MatrixType	src/LU/FullPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivLU	access:public
MatrixType	src/LU/PartialPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PartialPivLU	access:public
MatrixType	src/LU/PartialPivLU.h	/^  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixBase	access:public
MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLDLT	access:public
MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLLT	access:public
MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLU	access:public
MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
MatrixType	src/PardisoSupport/PardisoSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
MatrixType	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::MatrixType MatrixType;$/;"	t	class:Eigen::PardisoImpl	access:public
MatrixType	src/QR/ColPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
MatrixType	src/QR/FullPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
MatrixType	src/QR/HouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HouseholderQR	access:public
MatrixType	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor, Index> MatrixType;$/;"	t	class:Eigen::SPQR	access:public
MatrixType	src/SVD/JacobiSVD.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::JacobiSVD	access:public
MatrixType	src/SVD/UpperBidiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLLT	access:public
MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
MatrixType	src/SparseCholesky/SimplicialCholesky.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	src/SparseLU/SparseLU.h	/^    typedef _MatrixType MatrixType; $/;"	t	class:Eigen::SparseLU	access:public
MatrixType	src/SparseLU/SparseLUImpl.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> MatrixType; $/;"	t	class:Eigen::internal::SparseLUImpl	access:public
MatrixType	src/SparseQR/SparseQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SparseQR	access:public
MatrixType	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::QRMatrixType MatrixType;$/;"	t	struct:Eigen::SparseQR_QProduct	access:public
MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperILU	access:public
MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLU	access:public
MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLUBase	access:public
MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^  typedef Derived MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper	access:public
MatrixType	src/SuperLUSupport/SuperLUSupport.h	/^  typedef Matrix<Scalar,Rows,Cols,Options,MRows,MCols> MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper	access:public
MatrixType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
MatrixType	src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
MatrixType	src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	src/misc/Kernel.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	src/misc/Solve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	src/misc/SparseSolve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeCleaned	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeInnerStride	src/Core/CwiseUnaryView.h	/^    MatrixTypeInnerStride =  inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon154
MatrixTypeIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
MatrixTypeIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
MatrixTypeNested	src/Core/CwiseUnaryView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/Core/Diagonal.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::Replicate	access:private
MatrixTypeNested	src/Core/Replicate.h	/^  typedef typename nested<MatrixType,Factor>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/Core/Reverse.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::SelfAdjointView	access:public
MatrixTypeNested	src/Core/SelfAdjointView.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/Core/Transpose.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::TriangularView	access:protected
MatrixTypeNested	src/Core/TriangularMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr	access:public
MatrixTypeNested	src/Core/VectorwiseOp.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/Eigen2Support/Minor.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/Geometry/Homogeneous.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/LU/Inverse.h	/^  typedef typename internal::eval<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
MatrixTypeNested	src/SparseCore/SparseMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
MatrixTypeNested	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
MatrixTypeNested	src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseTriangularView	access:public
MatrixTypeNested	src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseView	access:private
MatrixTypeNestedCleaned	src/Core/PermutationMatrix.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_matrix_product_retval	access:public
MatrixTypeNestedCleaned	src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SelfAdjointView	access:public
MatrixTypeNestedCleaned	src/Core/SelfAdjointView.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNestedCleaned	src/Core/Transpositions.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval	access:public
MatrixTypeNestedCleaned	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::TriangularView	access:protected
MatrixTypeNestedCleaned	src/Core/TriangularMatrix.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNestedCleaned	src/LU/Inverse.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
MatrixTypeNestedCleaned	src/SparseCore/SparsePermutation.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
MatrixTypeNestedCleaned	src/SparseCore/SparsePermutation.h	/^  typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNestedCleaned	src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SparseTriangularView	access:public
MatrixTypeNestedNonRef	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularView	access:protected
MatrixTypeNestedNonRef	src/Core/TriangularMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNestedNonRef	src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	class:Eigen::SparseTriangularView	access:public
MatrixTypeNestedPlain	src/Core/Transpose.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeOuterStride	src/Core/Diagonal.h	/^    MatrixTypeOuterStride = outer_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon161
MatrixTypeRealView	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::remove_all<typename MatrixType::RealReturnType>::type MatrixTypeRealView;$/;"	t	class:Eigen::Tridiagonalization	access:public
MatrixTypeReverseIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
MatrixTypeReverseIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
MatrixU	src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
MatrixU	src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
MatrixU	src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
MatrixU	src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
MatrixU	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLDLT	access:public
MatrixU	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLLT	access:public
MatrixU	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixU	src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::Upper>   MatrixU;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixUType	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, MinSize> MatrixUType;$/;"	t	class:Eigen::SVD	access:private
MatrixUType	src/SVD/JacobiSVD.h	/^            MatrixUType;$/;"	t	class:Eigen::JacobiSVD	access:public
MatrixVType	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixVType;$/;"	t	class:Eigen::SVD	access:private
MatrixVType	src/SVD/JacobiSVD.h	/^            MatrixVType;$/;"	t	class:Eigen::JacobiSVD	access:public
MatrixWrapper	src/Core/ArrayWrapper.h	/^    inline MatrixWrapper(ExpressionType& a_matrix) : m_expression(a_matrix) {}$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(ExpressionType& a_matrix)
MatrixWrapper	src/Core/ArrayWrapper.h	/^class MatrixWrapper : public MatrixBase<MatrixWrapper<ExpressionType> >$/;"	c	namespace:Eigen	inherits:MatrixBase
MatrixXpr	src/Core/util/Constants.h	/^struct MatrixXpr {};$/;"	s	namespace:Eigen
Max	src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
MaxCols	src/Core/GeneralProduct.h	/^    MaxCols  = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
MaxColsAtCompileTime	src/Cholesky/LDLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon1
MaxColsAtCompileTime	src/Cholesky/LLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::LLT::__anon2
MaxColsAtCompileTime	src/Core/BandMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
MaxColsAtCompileTime	src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon144
MaxColsAtCompileTime	src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon145
MaxColsAtCompileTime	src/Core/Block.h	/^    MaxColsAtCompileTime = BlockCols==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon146
MaxColsAtCompileTime	src/Core/CwiseBinaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon150
MaxColsAtCompileTime	src/Core/DenseBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
MaxColsAtCompileTime	src/Core/Diagonal.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon161
MaxColsAtCompileTime	src/Core/DiagonalMatrix.h	/^      MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon163
MaxColsAtCompileTime	src/Core/DiagonalMatrix.h	/^    MaxColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
MaxColsAtCompileTime	src/Core/DiagonalProduct.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon166
MaxColsAtCompileTime	src/Core/Matrix.h	/^    MaxColsAtCompileTime = _MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon282
MaxColsAtCompileTime	src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::PermutationBase::__anon287
MaxColsAtCompileTime	src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::Transpose::__anon289
MaxColsAtCompileTime	src/Core/PermutationMatrix.h	/^    MaxColsAtCompileTime = IndicesType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
MaxColsAtCompileTime	src/Core/ProductBase.h	/^    MaxColsAtCompileTime = traits<Rhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon294
MaxColsAtCompileTime	src/Core/Replicate.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon309
MaxColsAtCompileTime	src/Core/Reverse.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon311
MaxColsAtCompileTime	src/Core/Select.h	/^    MaxColsAtCompileTime = ConditionMatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
MaxColsAtCompileTime	src/Core/Transpose.h	/^    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon323
MaxColsAtCompileTime	src/Core/TriangularMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime$/;"	e	enum:Eigen::TriangularBase::__anon326
MaxColsAtCompileTime	src/Core/VectorwiseOp.h	/^    MaxColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon331
MaxColsAtCompileTime	src/Core/products/CoeffBasedProduct.h	/^      MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon30
MaxColsAtCompileTime	src/Eigen2Support/Minor.h	/^    MaxColsAtCompileTime = (MatrixType::MaxColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon358
MaxColsAtCompileTime	src/Eigenvalues/ComplexEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
MaxColsAtCompileTime	src/Eigenvalues/ComplexSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexSchur::__anon361
MaxColsAtCompileTime	src/Eigenvalues/EigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::EigenSolver::__anon362
MaxColsAtCompileTime	src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
MaxColsAtCompileTime	src/Eigenvalues/RealQZ.h	/^        MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealQZ::__anon365
MaxColsAtCompileTime	src/Eigenvalues/RealSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealSchur::__anon366
MaxColsAtCompileTime	src/Eigenvalues/SelfAdjointEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon367
MaxColsAtCompileTime	src/Geometry/Homogeneous.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon371
MaxColsAtCompileTime	src/Householder/HouseholderSequence.h	/^      MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderSequence::__anon394
MaxColsAtCompileTime	src/Householder/HouseholderSequence.h	/^    MaxColsAtCompileTime = MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon393
MaxColsAtCompileTime	src/LU/FullPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivLU::__anon398
MaxColsAtCompileTime	src/LU/PartialPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PartialPivLU::__anon401
MaxColsAtCompileTime	src/QR/ColPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
MaxColsAtCompileTime	src/QR/FullPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
MaxColsAtCompileTime	src/QR/HouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderQR::__anon415
MaxColsAtCompileTime	src/SVD/JacobiSVD.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon422
MaxColsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
MaxColsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
MaxColsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
MaxColsAtCompileTime	src/SparseCore/SparseDenseProduct.h	/^    MaxColsAtCompileTime = Tr ? int(traits<Lhs>::MaxColsAtCompileTime)  : int(traits<Rhs>::MaxColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon441
MaxColsAtCompileTime	src/SparseCore/SparseDiagonalProduct.h	/^    MaxColsAtCompileTime = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon442
MaxColsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon446
MaxColsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon445
MaxColsAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
MaxColsAtCompileTime	src/SparseCore/SparseProduct.h	/^    MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
MaxColsAtCompileTime	src/SparseCore/SparseVector.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon456
MaxDepth	src/Core/GeneralProduct.h	/^    MaxDepth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
MaxDepthAtCompileTime	src/Core/products/GeneralMatrixMatrix.h	/^      MaxDepthAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime)$/;"	e	enum:Eigen::GeneralProduct::__anon44
MaxDiagSizeAtCompileTime	src/SVD/JacobiSVD.h	/^      MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon422
MaxRows	src/Core/GeneralProduct.h	/^    MaxRows  = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
MaxRowsAtCompileTime	src/Cholesky/LDLT.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon1
MaxRowsAtCompileTime	src/Core/BandMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
MaxRowsAtCompileTime	src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon144
MaxRowsAtCompileTime	src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon145
MaxRowsAtCompileTime	src/Core/Block.h	/^    MaxRowsAtCompileTime = BlockRows==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon146
MaxRowsAtCompileTime	src/Core/CwiseBinaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon150
MaxRowsAtCompileTime	src/Core/DenseBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
MaxRowsAtCompileTime	src/Core/Diagonal.h	/^    MaxRowsAtCompileTime = int(MatrixType::MaxSizeAtCompileTime) == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon161
MaxRowsAtCompileTime	src/Core/DiagonalMatrix.h	/^      MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon163
MaxRowsAtCompileTime	src/Core/DiagonalMatrix.h	/^    MaxRowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
MaxRowsAtCompileTime	src/Core/DiagonalProduct.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon166
MaxRowsAtCompileTime	src/Core/Matrix.h	/^    MaxRowsAtCompileTime = _MaxRows,$/;"	e	enum:Eigen::internal::traits::__anon282
MaxRowsAtCompileTime	src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon287
MaxRowsAtCompileTime	src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon289
MaxRowsAtCompileTime	src/Core/PermutationMatrix.h	/^    MaxRowsAtCompileTime = IndicesType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
MaxRowsAtCompileTime	src/Core/ProductBase.h	/^    MaxRowsAtCompileTime = traits<Lhs>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon294
MaxRowsAtCompileTime	src/Core/Replicate.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon309
MaxRowsAtCompileTime	src/Core/Reverse.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon311
MaxRowsAtCompileTime	src/Core/Select.h	/^    MaxRowsAtCompileTime = ConditionMatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
MaxRowsAtCompileTime	src/Core/Transpose.h	/^    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon323
MaxRowsAtCompileTime	src/Core/TriangularMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon326
MaxRowsAtCompileTime	src/Core/VectorwiseOp.h	/^    MaxRowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon331
MaxRowsAtCompileTime	src/Core/products/CoeffBasedProduct.h	/^      MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon30
MaxRowsAtCompileTime	src/Eigen2Support/Minor.h	/^    MaxRowsAtCompileTime = (MatrixType::MaxRowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon358
MaxRowsAtCompileTime	src/Eigenvalues/ComplexEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
MaxRowsAtCompileTime	src/Eigenvalues/ComplexSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon361
MaxRowsAtCompileTime	src/Eigenvalues/EigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon362
MaxRowsAtCompileTime	src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
MaxRowsAtCompileTime	src/Eigenvalues/RealQZ.h	/^        MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon365
MaxRowsAtCompileTime	src/Eigenvalues/RealSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon366
MaxRowsAtCompileTime	src/Geometry/Homogeneous.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon371
MaxRowsAtCompileTime	src/Householder/HouseholderSequence.h	/^      MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon394
MaxRowsAtCompileTime	src/Householder/HouseholderSequence.h	/^    MaxRowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon393
MaxRowsAtCompileTime	src/LU/FullPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon398
MaxRowsAtCompileTime	src/LU/PartialPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon401
MaxRowsAtCompileTime	src/QR/ColPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
MaxRowsAtCompileTime	src/QR/FullPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
MaxRowsAtCompileTime	src/QR/HouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon415
MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon422
MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
MaxRowsAtCompileTime	src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
MaxRowsAtCompileTime	src/SparseCore/SparseDenseProduct.h	/^    MaxRowsAtCompileTime = Tr ? int(traits<Rhs>::MaxRowsAtCompileTime)  : int(traits<Lhs>::MaxRowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon441
MaxRowsAtCompileTime	src/SparseCore/SparseDiagonalProduct.h	/^    MaxRowsAtCompileTime = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon442
MaxRowsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon445
MaxRowsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon446
MaxRowsAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
MaxRowsAtCompileTime	src/SparseCore/SparseProduct.h	/^    MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
MaxRowsAtCompileTime	src/SparseCore/SparseVector.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon456
MaxSize	src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
MaxSize	src/Eigenvalues/Tridiagonalization.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon368
MaxSizeAtCompileTime	src/Core/Assign.h	/^    MaxSizeAtCompileTime = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_traits::__anon131
MaxSizeAtCompileTime	src/Core/Assign_MKL.h	/^      MaxSizeAtCompileTime = Dst::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
MaxSizeAtCompileTime	src/Core/DenseBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
MaxSizeAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
MaxSizeMinusOne	src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : MaxSize - 1$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
MaxSizeMinusOne	src/Eigenvalues/Tridiagonalization.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : (MaxSize > 1 ? MaxSize - 1 : 1)$/;"	e	enum:Eigen::Tridiagonalization::__anon368
MaxSmallDimAtCompileTime	src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::image_retval::__anon400
MaxSmallDimAtCompileTime	src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::kernel_retval::__anon399
MayEnableVml	src/Core/Assign_MKL.h	/^      MayEnableVml = MightEnableVml && LargeEnough,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
MayInnerVectorize	src/Core/Assign.h	/^    MayInnerVectorize  = MightVectorize && int(InnerSize)!=Dynamic && int(InnerSize)%int(PacketSize)==0$/;"	e	enum:Eigen::internal::assign_traits::__anon132
MayLinearVectorize	src/Core/Assign.h	/^    MayLinearVectorize = MightVectorize && MayLinearize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon132
MayLinearVectorize	src/Core/Redux.h	/^    MayLinearVectorize = MightVectorize && (int(Derived::Flags)&LinearAccessBit),$/;"	e	enum:Eigen::internal::redux_traits::__anon297
MayLinearize	src/Core/Assign.h	/^    MayLinearize = StorageOrdersAgree && (int(Derived::Flags) & int(OtherDerived::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::assign_traits::__anon132
MayLinearize	src/Core/Assign_MKL.h	/^      MayLinearize = MayEnableVml && MightLinearize$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
MaySliceVectorize	src/Core/Assign.h	/^    MaySliceVectorize  = MightVectorize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon132
MaySliceVectorize	src/Core/Redux.h	/^    MaySliceVectorize  = MightVectorize && int(InnerMaxSize)>=3*PacketSize$/;"	e	enum:Eigen::internal::redux_traits::__anon297
MayUnrollCompletely	src/Core/Assign.h	/^    MayUnrollCompletely = int(Derived::SizeAtCompileTime) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon134
MayUnrollInner	src/Core/Assign.h	/^    MayUnrollInner      = int(InnerSize) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon134
MemType	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	t	namespace:Eigen::internal	typeref:enum:Eigen::internal::__anon463
MetisOrdering	src/MetisSupport/MetisSupport.h	/^class MetisOrdering$/;"	c	namespace:Eigen
MightEnableVml	src/Core/Assign_MKL.h	/^      MightEnableVml =  vml_call<UnaryOp>::IsSupported && StorageOrdersAgree && DstHasDirectAccess && SrcHasDirectAccess$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
MightLinearize	src/Core/Assign_MKL.h	/^      MightLinearize = MightEnableVml && (int(Dst::Flags) & int(Src::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
MightVectorize	src/Core/Assign.h	/^    MightVectorize = StorageOrdersAgree$/;"	e	enum:Eigen::internal::assign_traits::__anon132
MightVectorize	src/Core/Redux.h	/^    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)$/;"	e	enum:Eigen::internal::redux_traits::__anon297
Min	src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
MinRowsAtCompileTime	src/Geometry/Umeyama.h	/^    MinRowsAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, OtherMatrixType::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon391
MinSize	src/Eigen2Support/SVD.h	/^      MinSize = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime)$/;"	e	enum:Eigen::SVD::__anon359
Minor	src/Eigen2Support/Minor.h	/^    inline Minor(const MatrixType& matrix,$/;"	f	class:Eigen::Minor	access:public	signature:(const MatrixType& matrix, Index row, Index col)
Minor	src/Eigen2Support/Minor.h	/^template<typename MatrixType> class Minor$/;"	c	namespace:Eigen	inherits:MatrixBase
Mode	src/Core/SelfAdjointView.h	/^      Mode = internal::traits<SelfAdjointView>::Mode$/;"	e	enum:Eigen::SelfAdjointView::__anon315
Mode	src/Core/SelfAdjointView.h	/^    Mode = UpLo | SelfAdjoint,$/;"	e	enum:Eigen::internal::traits::__anon314
Mode	src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularView::__anon328
Mode	src/Core/TriangularMatrix.h	/^      Mode = internal::traits<Derived>::Mode,$/;"	e	enum:Eigen::TriangularBase::__anon326
Mode	src/Core/TriangularMatrix.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::internal::traits::__anon327
Mode	src/Geometry/Transform.h	/^    Mode = Transform::Mode,$/;"	e	enum:Eigen::internal::transform_traits::__anon383
Mode	src/Geometry/Transform.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::Transform::__anon384
Mode	src/Geometry/Transform.h	/^    Mode =$/;"	e	enum:Eigen::internal::transform_product_result::__anon386
MoveOuter	src/SparseCore/SparsePermutation.h	/^      MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon450
MoveOuter	src/SparseCore/SparsePermutation.h	/^    MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::traits::__anon449
MulCost	src/Core/NumTraits.h	/^    MulCost = 1$/;"	e	enum:Eigen::GenericNumTraits::__anon286
NCMatrix	src/SparseLU/SparseLU.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> NCMatrix;$/;"	t	class:Eigen::SparseLU	access:public
NColsBlockXpr	src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
NColsBlockXpr::Type	src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:NColsBlockXpr	access:public
NRowsBlockXpr	src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
NRowsBlockXpr::Type	src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:NRowsBlockXpr	access:public
NUMERIC_TYPE_MUST_BE_REAL	src/Core/util/StaticAssert.h	/^        NUMERIC_TYPE_MUST_BE_REAL,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
NaturalOrdering	src/OrderingMethods/Ordering.h	/^class NaturalOrdering$/;"	c	namespace:Eigen
NeedToConjugate	src/Core/util/BlasUtil.h	/^    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex$/;"	e	enum:Eigen::internal::blas_traits::__anon59
NeedToConjugate	src/Core/util/BlasUtil.h	/^    NeedToConjugate = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon58
NeedsToAlign	src/Core/PlainObjectBase.h	/^    enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };$/;"	e	enum:Eigen::PlainObjectBase::__anon291
NegativeSemiDef	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
NestByRefBit	src/Core/util/Constants.h	/^const unsigned int NestByRefBit = 0x100;$/;"	m	namespace:Eigen
NestByValue	src/Core/NestByValue.h	/^    inline NestByValue(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::NestByValue	access:public	signature:(const ExpressionType& matrix)
NestByValue	src/Core/NestByValue.h	/^template<typename ExpressionType> class NestByValue$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Nested	src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper Nested;$/;"	t	class:Eigen::DiagonalWrapper	access:public
Nested	src/Core/DiagonalMatrix.h	/^    typedef const DiagonalMatrix& Nested;$/;"	t	class:Eigen::DiagonalMatrix	access:public
NestedExpressionType	src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::ArrayWrapper	access:public
NestedExpressionType	src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::MatrixWrapper	access:public
NewInf	src/Core/util/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen::internal
NewInf	src/Eigen2Support/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen
NewSup	src/Core/util/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen::internal
NewSup	src/Eigen2Support/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen
NoAlias	src/Core/NoAlias.h	/^    NoAlias(ExpressionType& expression) : m_expression(expression) {}$/;"	f	class:Eigen::NoAlias	access:public	signature:(ExpressionType& expression)
NoAlias	src/Core/NoAlias.h	/^class NoAlias$/;"	c	namespace:Eigen
NoChange	src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	e	enum:Eigen::NoChange_t
NoChange_t	src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	g	namespace:Eigen
NoConvergence	src/Core/util/Constants.h	/^  NoConvergence = 2,$/;"	e	enum:Eigen::ComputationInfo
NoPivoting	src/Core/util/Constants.h	/^  NoPivoting          = 0x02, $/;"	e	enum:Eigen::DecompositionOptions
NoQRPreconditioner	src/Core/util/Constants.h	/^  NoQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
NoUnrolling	src/Core/util/Constants.h	/^  NoUnrolling,$/;"	e	enum:Eigen::__anon64
NonConstImagReturnType	src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryView<internal::scalar_imag_ref_op<Scalar>, Derived> NonConstImagReturnType;$/;"	t
NonConstRealReturnType	src/plugins/CommonCwiseUnaryOps.h	/^                  >::type NonConstRealReturnType;$/;"	t
NonInteger	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::NonInteger NonInteger;$/;"	t	struct:Eigen::internal::random_default_impl	access:public
NonInteger	src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::NonInteger      NonInteger;$/;"	t	class:Eigen::AlignedBox	access:public
NormalReturnType	src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
NormalReturnType	src/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
NullaryExpr	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols, const CustomNullaryOp& func)
NullaryExpr	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const CustomNullaryOp& func)
NullaryExpr	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(const CustomNullaryOp& func)
NullaryExpr	src/Core/DenseBase.h	/^    NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols, const CustomNullaryOp& func)
NullaryExpr	src/Core/DenseBase.h	/^    NullaryExpr(Index size, const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const CustomNullaryOp& func)
NullaryExpr	src/Core/DenseBase.h	/^    NullaryExpr(const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const CustomNullaryOp& func)
NumberOfRegisters	src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
NumberOfRegisters	src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
NumberOfRegisters	src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
NumericalIssue	src/Core/util/Constants.h	/^  NumericalIssue = 1, $/;"	e	enum:Eigen::ComputationInfo
OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG	src/Core/util/StaticAssert.h	/^        OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
ONES_COMPLEMENT	src/OrderingMethods/Eigen_Colamd.h	108;"	d
OffsetCol	src/Core/Reverse.h	/^      OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon312
OffsetRow	src/Core/Reverse.h	/^      OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon312
OnTheLeft	src/Core/util/Constants.h	/^  OnTheLeft = 1,  $/;"	e	enum:Eigen::__anon67
OnTheRight	src/Core/util/Constants.h	/^  OnTheRight = 2  $/;"	e	enum:Eigen::__anon67
Ones	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones()$/;"	f	class:Eigen::DenseBase	signature:()
Ones	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index nbRows, Index nbCols)$/;"	f	class:Eigen::DenseBase	signature:(Index nbRows, Index nbCols)
Ones	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index newSize)$/;"	f	class:Eigen::DenseBase	signature:(Index newSize)
Ones	src/Core/DenseBase.h	/^    static const ConstantReturnType Ones();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Ones	src/Core/DenseBase.h	/^    static const ConstantReturnType Ones(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Ones	src/Core/DenseBase.h	/^    static const ConstantReturnType Ones(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
OppositeExtendedType	src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct OppositeExtendedType {$/;"	s	class:Eigen::VectorwiseOp	access:protected
Options	src/Cholesky/LDLT.h	/^      Options = MatrixType::Options & ~RowMajorBit, \/\/ these are the options for the TmpMatrixType, we need a ColMajor matrix here!$/;"	e	enum:Eigen::LDLT::__anon1
Options	src/Cholesky/LLT.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::LLT::__anon2
Options	src/Core/Array.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Array::__anon127
Options	src/Core/BandMatrix.h	/^      Options = internal::traits<Derived>::Options$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Options	src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon144
Options	src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon145
Options	src/Core/Map.h	/^  enum { Options }; \/\/ Expressions don't have Options$/;"	e	enum:Eigen::internal::traits::__anon275
Options	src/Core/Matrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon282
Options	src/Core/Matrix.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Matrix::__anon283
Options	src/Core/PlainObjectBase.h	/^    enum { Options = internal::traits<Derived>::Options };$/;"	e	enum:Eigen::PlainObjectBase::__anon290
Options	src/Core/Ref.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon306
Options	src/Eigenvalues/ComplexEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
Options	src/Eigenvalues/ComplexSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexSchur::__anon361
Options	src/Eigenvalues/EigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::EigenSolver::__anon362
Options	src/Eigenvalues/GeneralizedEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
Options	src/Eigenvalues/HessenbergDecomposition.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
Options	src/Eigenvalues/RealQZ.h	/^        Options = MatrixType::Options,$/;"	e	enum:Eigen::RealQZ::__anon365
Options	src/Eigenvalues/RealSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::RealSchur::__anon366
Options	src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon367
Options	src/Eigenvalues/Tridiagonalization.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::Tridiagonalization::__anon368
Options	src/Geometry/Hyperplane.h	/^    Options = _Options$/;"	e	enum:Eigen::Hyperplane::__anon373
Options	src/Geometry/ParametrizedLine.h	/^    Options = _Options$/;"	e	enum:Eigen::ParametrizedLine::__anon374
Options	src/Geometry/Transform.h	/^    Options = _Options,$/;"	e	enum:Eigen::Transform::__anon384
Options	src/LU/FullPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivLU::__anon398
Options	src/LU/PartialPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::PartialPivLU::__anon401
Options	src/QR/ColPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
Options	src/QR/FullPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
Options	src/QR/HouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HouseholderQR::__anon415
Options	src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
Options	src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
Options	src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
Options	src/SparseCore/SparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseMatrix::__anon447
Options	src/SparseCore/SparseVector.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseVector::__anon459
OrderingType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::OrderingType OrderingType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
OrderingType	src/SparseCholesky/SimplicialCholesky.h	/^  typedef _Ordering OrderingType;$/;"	t	struct:Eigen::internal::traits	access:public
OrderingType	src/SparseLU/SparseLU.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseLU	access:public
OrderingType	src/SparseQR/SparseQR.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseQR	access:public
OtherCols	src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon387
OtherCols	src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon388
OtherPlainObject	src/Core/TriangularMatrix.h	/^      typedef typename OtherDerived::PlainObject::DenseType OtherPlainObject;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
OtherRows	src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon387
OtherRows	src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon388
OuterProduct	src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon69
OuterRandomAccessPattern	src/SparseCore/SparseUtil.h	/^const int OuterRandomAccessPattern  = 0x4 | CoherentAccessPattern;$/;"	m	namespace:Eigen
OuterSize	src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon433
OuterSize	src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon435
OuterSize	src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon437
OuterStride	src/Core/Stride.h	/^    OuterStride() : Base() {}$/;"	f	class:Eigen::OuterStride	access:public	signature:()
OuterStride	src/Core/Stride.h	/^    OuterStride(Index v) : Base(v,0) {}$/;"	f	class:Eigen::OuterStride	access:public	signature:(Index v)
OuterStride	src/Core/Stride.h	/^class OuterStride : public Stride<Value, 0>$/;"	c	namespace:Eigen	inherits:Stride
OuterStrideAtCompileTime	src/Core/Block.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon146
OuterStrideAtCompileTime	src/Core/CwiseUnaryView.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon154
OuterStrideAtCompileTime	src/Core/DenseBase.h	/^      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret$/;"	e	enum:Eigen::DenseBase::__anon155
OuterStrideAtCompileTime	src/Core/Diagonal.h	/^    OuterStrideAtCompileTime = 0$/;"	e	enum:Eigen::internal::traits::__anon161
OuterStrideAtCompileTime	src/Core/Map.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon274
OuterStrideAtCompileTime	src/Core/Matrix.h	/^    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon282
OuterStrideAtCompileTime	src/Core/SelfCwiseBinaryOp.h	/^    OuterStrideAtCompileTime = Lhs::OuterStrideAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon318
OuterStrideAtCompileTime	src/Core/Stride.h	/^      OuterStrideAtCompileTime = _OuterStrideAtCompileTime$/;"	e	enum:Eigen::Stride::__anon322
OuterStrideAtCompileTime	src/Core/Transpose.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon323
OuterStrideMatch	src/Core/Ref.h	/^      OuterStrideMatch = Derived::IsVectorAtCompileTime$/;"	e	enum:Eigen::internal::traits::match::__anon307
PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1	src/Core/util/StaticAssert.h	/^        PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
PALIGN_NEON	src/Core/arch/NEON/PacketMath.h	394;"	d
PALIGN_NEON	src/Core/arch/NEON/PacketMath.h	414;"	d
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op_impl	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_acos_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_add_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_asin_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_constant_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_cos_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_exp_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_log_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_multiple_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_quotient1_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sin_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sqrt_op	access:public
Packet	src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_tan_op	access:public
Packet	src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SelfCwiseBinaryOp	access:public
Packet	src/Core/Swap.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SwapWrapper	access:public
Packet	src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::PacketScalar Packet;$/;"	t	struct:Eigen::internal::product_coeff_impl	access:public
Packet	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::gemm_pack_rhs	access:public
Packet16uc	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned char  Packet16uc;$/;"	t	namespace:Eigen::internal
Packet1cd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd	access:public	signature:()
Packet1cd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const __m128d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd	access:public	signature:(const __m128d& a)
Packet1cd	src/Core/arch/SSE/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet2cf	src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Packet2cf	src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const Packet4f& a)
Packet2cf	src/Core/arch/AltiVec/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Packet2cf	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const Packet4f& a)
Packet2cf	src/Core/arch/NEON/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Packet2cf	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const __m128& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const __m128& a)
Packet2cf	src/Core/arch/SSE/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2d	src/Core/arch/SSE/PacketMath.h	/^typedef __m128d Packet2d;$/;"	t	namespace:Eigen::internal
Packet4bi	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool int     Packet4bi;$/;"	t	namespace:Eigen::internal
Packet4f	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector float          Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	src/Core/arch/NEON/PacketMath.h	/^typedef float32x4_t Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	src/Core/arch/SSE/PacketMath.h	/^typedef __m128  Packet4f;$/;"	t	namespace:Eigen::internal
Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector int            Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	src/Core/arch/NEON/PacketMath.h	/^typedef int32x4_t   Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	src/Core/arch/SSE/PacketMath.h	/^typedef __m128i Packet4i;$/;"	t	namespace:Eigen::internal
Packet4ui	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned int   Packet4ui;$/;"	t	namespace:Eigen::internal
Packet4ui	src/Core/arch/NEON/PacketMath.h	/^typedef uint32x4_t  Packet4ui;$/;"	t	namespace:Eigen::internal
Packet8i	src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector short int      Packet8i;$/;"	t	namespace:Eigen::internal
PacketAccess	src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon180
PacketAccess	src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon181
PacketAccess	src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon182
PacketAccess	src/Core/Functors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon172
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasACos$/;"	e	enum:Eigen::internal::functor_traits::__anon211
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasASin$/;"	e	enum:Eigen::internal::functor_traits::__anon212
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAbs$/;"	e	enum:Eigen::internal::functor_traits::__anon184
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon168
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasConj$/;"	e	enum:Eigen::internal::functor_traits::__anon186
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasCos$/;"	e	enum:Eigen::internal::functor_traits::__anon208
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMax$/;"	e	enum:Eigen::internal::functor_traits::__anon174
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMin$/;"	e	enum:Eigen::internal::functor_traits::__anon173
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasNegate };$/;"	e	enum:Eigen::internal::functor_traits::__anon183
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSin$/;"	e	enum:Eigen::internal::functor_traits::__anon209
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon207
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon177
PacketAccess	src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasTan$/;"	e	enum:Eigen::internal::functor_traits::__anon210
PacketAccess	src/Core/Functors.h	/^    PacketAccess = scalar_product_op<LhsScalar,RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon170
PacketAccess	src/Core/Functors.h	/^    PacketAccess = scalar_quotient_op<LhsScalar,RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon179
PacketAccess	src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon176
PacketAccess	src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon175
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon188
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon189
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon190
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon191
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon235
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon236
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon237
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon238
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon233
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon234
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon222
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon223
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon224
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon225
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon226
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon227
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon228
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon229
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon230
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon199
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon197
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon196
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon216
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon213
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon192
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon193
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon195
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon198
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon206
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon185
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon214
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon194
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon215
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon219
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon220
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon221
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon217
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon218
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon240
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon239
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon231
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon232
PacketAccess	src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon187
PacketAccess	src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon295
PacketAccessBit	src/Core/util/Constants.h	/^const unsigned int PacketAccessBit = 0x8;$/;"	m	namespace:Eigen
PacketReturnType	src/Core/DenseCoeffsBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
PacketReturnType	src/SparseCore/SparseMatrixBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
PacketScalar	src/Core/ArrayBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::ArrayBase	access:public
PacketScalar	src/Core/DenseBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseBase	access:public
PacketScalar	src/Core/DenseCoeffsBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
PacketScalar	src/Core/MapBase.h	/^    typedef typename Base::PacketScalar PacketScalar;$/;"	t	class:Eigen::MapBase	access:public
PacketScalar	src/Core/MapBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MapBase	access:public
PacketScalar	src/Core/MatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MatrixBase	access:public
PacketScalar	src/Core/PlainObjectBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
PacketScalar	src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_impl	access:public
PacketScalar	src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller	access:public
PacketScalar	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
PacketSize	src/Cholesky/LLT.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::LLT::__anon3
PacketSize	src/Core/Assign.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size$/;"	e	enum:Eigen::internal::assign_traits::__anon131
PacketSize	src/Core/Redux.h	/^    PacketSize = packet_traits<Scalar>::size,$/;"	e	enum:Eigen::internal::redux_impl::__anon305
PacketSize	src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_traits::__anon296
PacketSize	src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon303
PacketSize	src/Core/Reverse.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::Reverse::__anon312
PacketSize	src/Core/products/CoeffBasedProduct.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon31
PacketSize	src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_impl::__anon33
PacketSize	src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_vectorized_unroller::__anon32
PacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon39
PacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon40
PacketSize	src/Core/products/SelfadjointMatrixMatrix.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::symm_pack_rhs::__anon48
PacketSize	src/Eigen2Support/SVD.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::SVD::__anon359
ParameterType	src/PardisoSupport/PardisoSupport.h	/^    typedef Array<Index,64,1,DontAlign> ParameterType;$/;"	t	class:Eigen::PardisoImpl	access:public
ParametrizedLine	src/Eigen2Support/Geometry/All.h	113;"	d
ParametrizedLine	src/Eigen2Support/Geometry/All.h	58;"	d
ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& origin, const VectorType& direction)
ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  explicit ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)
ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(int _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(int _dim)
ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)
ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& origin, const VectorType& direction)
ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  explicit ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane)
ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  inline ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(Index _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(Index _dim)
ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)
ParametrizedLine	src/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
ParametrizedLine	src/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim,_Options>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)
PardisoImpl	src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
PardisoImpl	src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl(PardisoImpl &) {}$/;"	f	class:Eigen::PardisoImpl	access:private	signature:(PardisoImpl &)
PardisoImpl	src/PardisoSupport/PardisoSupport.h	/^class PardisoImpl$/;"	c	namespace:Eigen
PardisoLDLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT()$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:()
PardisoLDLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(PardisoLDLT& ) {}$/;"	f	class:Eigen::PardisoLDLT	access:private	signature:(PardisoLDLT& )
PardisoLDLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:(const MatrixType& matrix)
PardisoLDLT	src/PardisoSupport/PardisoSupport.h	/^class PardisoLDLT : public PardisoImpl< PardisoLDLT<MatrixType,Options> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
PardisoLLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT()$/;"	f	class:Eigen::PardisoLLT	access:public	signature:()
PardisoLLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(PardisoLLT& ) {}$/;"	f	class:Eigen::PardisoLLT	access:private	signature:(PardisoLLT& )
PardisoLLT	src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT	access:public	signature:(const MatrixType& matrix)
PardisoLLT	src/PardisoSupport/PardisoSupport.h	/^class PardisoLLT : public PardisoImpl< PardisoLLT<MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
PardisoLU	src/PardisoSupport/PardisoSupport.h	/^    PardisoLU()$/;"	f	class:Eigen::PardisoLU	access:public	signature:()
PardisoLU	src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(PardisoLU& ) {}$/;"	f	class:Eigen::PardisoLU	access:private	signature:(PardisoLU& )
PardisoLU	src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU	access:public	signature:(const MatrixType& matrix)
PardisoLU	src/PardisoSupport/PardisoSupport.h	/^class PardisoLU : public PardisoImpl< PardisoLU<MatrixType> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
PartialPivLU	src/LU/PartialPivLU.h	/^    PartialPivLU();$/;"	p	class:Eigen::PartialPivLU	access:public	signature:()
PartialPivLU	src/LU/PartialPivLU.h	/^    PartialPivLU(Index size);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(Index size)
PartialPivLU	src/LU/PartialPivLU.h	/^    PartialPivLU(const MatrixType& matrix);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(const MatrixType& matrix)
PartialPivLU	src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU()$/;"	f	class:Eigen::PartialPivLU	signature:()
PartialPivLU	src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(Index size)$/;"	f	class:Eigen::PartialPivLU	signature:(Index size)
PartialPivLU	src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU	signature:(const MatrixType& matrix)
PartialPivLU	src/LU/PartialPivLU.h	/^template<typename _MatrixType> class PartialPivLU$/;"	c	namespace:Eigen
PartialReduxExpr	src/Core/VectorwiseOp.h	/^    PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(const MatrixType& mat, const MemberOp& func = MemberOp())
PartialReduxExpr	src/Core/VectorwiseOp.h	/^class PartialReduxExpr : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
PastixBase	src/PaStiXSupport/PaStiXSupport.h	/^    PastixBase() : m_initisOk(false), m_analysisIsOk(false), m_factorizationIsOk(false), m_isInitialized(false), m_pastixdata(0), m_size(0)$/;"	f	class:Eigen::PastixBase	access:public	signature:()
PastixBase	src/PaStiXSupport/PaStiXSupport.h	/^class PastixBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
PastixLDLT	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT():Base()$/;"	f	class:Eigen::PastixLDLT	access:public	signature:()
PastixLDLT	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
PastixLDLT	src/PaStiXSupport/PaStiXSupport.h	/^class PastixLDLT : public PastixBase< PastixLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:PastixBase
PastixLLT	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT() : Base()$/;"	f	class:Eigen::PastixLLT	access:public	signature:()
PastixLLT	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
PastixLLT	src/PaStiXSupport/PaStiXSupport.h	/^class PastixLLT : public PastixBase< PastixLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:PastixBase
PastixLU	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU() : Base()$/;"	f	class:Eigen::PastixLU	access:public	signature:()
PastixLU	src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
PastixLU	src/PaStiXSupport/PaStiXSupport.h	/^class PastixLU : public PastixBase< PastixLU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:PastixBase
Perm	src/SparseCore/SparseSelfAdjointView.h	/^    typedef PermutationMatrix<Dynamic,Dynamic,Index> Perm;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:protected
PermIndexType	src/QR/ColPivHouseholderQR.h	/^    typedef typename PermutationType::Index PermIndexType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:private
PermPermProduct	src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	e	enum:Eigen::internal::PermPermProduct_t
PermPermProduct_t	src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	g	namespace:Eigen::internal
PermutType	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,ColMajor> PermutType;$/;"	t	class:Eigen::IncompleteLUT	access:private
PermutationBase	src/Core/PermutationMatrix.h	/^class PermutationBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
PermutationMatrix	src/Core/PermutationMatrix.h	/^    PermutationMatrix(const Transpose<PermutationBase<Other> >& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const Transpose<PermutationBase<Other> >& other)
PermutationMatrix	src/Core/PermutationMatrix.h	/^    PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)
PermutationMatrix	src/Core/PermutationMatrix.h	/^    explicit PermutationMatrix(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const TranspositionsBase<Other>& tr)
PermutationMatrix	src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(const MatrixBase<Other>& a_indices) : m_indices(a_indices)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const MatrixBase<Other>& a_indices)
PermutationMatrix	src/Core/PermutationMatrix.h	/^    inline PermutationMatrix()$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:()
PermutationMatrix	src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationBase<OtherDerived>& other)
PermutationMatrix	src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationMatrix& other)
PermutationMatrix	src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(int size) : m_indices(size)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(int size)
PermutationMatrix	src/Core/PermutationMatrix.h	/^class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	c	namespace:Eigen	inherits:PermutationBase
PermutationPType	src/LU/FullPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationPType;$/;"	t	class:Eigen::FullPivLU	access:public
PermutationQType	src/LU/FullPivLU.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;$/;"	t	class:Eigen::FullPivLU	access:public
PermutationStorage	src/Core/PermutationMatrix.h	/^struct PermutationStorage {};$/;"	s	namespace:Eigen
PermutationType	src/Cholesky/LDLT.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::LDLT	access:public
PermutationType	src/Core/PermutationMatrix.h	/^    typedef Derived PermutationType;$/;"	t	class:Eigen::Transpose	access:private
PermutationType	src/LU/PartialPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::PartialPivLU	access:public
PermutationType	src/MetisSupport/MetisSupport.h	/^  typedef PermutationMatrix<Dynamic,Dynamic,Index> PermutationType;$/;"	t	class:Eigen::MetisOrdering	access:public
PermutationType	src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType; $/;"	t	class:Eigen::COLAMDOrdering	access:public
PermutationType	src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::AMDOrdering	access:public
PermutationType	src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::NaturalOrdering	access:public
PermutationType	src/QR/ColPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
PermutationType	src/QR/FullPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
PermutationType	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef PermutationMatrix<Dynamic, Dynamic> PermutationType;$/;"	t	class:Eigen::SPQR	access:public
PermutationType	src/SparseLU/SparseLU.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::SparseLU	access:public
PermutationType	src/SparseQR/SparseQR.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::SparseQR	access:public
PermutationWrapper	src/Core/PermutationMatrix.h	/^    inline PermutationWrapper(const IndicesType& a_indices)$/;"	f	class:Eigen::PermutationWrapper	access:public	signature:(const IndicesType& a_indices)
PermutationWrapper	src/Core/PermutationMatrix.h	/^class PermutationWrapper : public PermutationBase<PermutationWrapper<_IndicesType> >$/;"	c	namespace:Eigen	inherits:PermutationBase
Pivoting	src/Core/util/Constants.h	/^  Pivoting            = 0x01, $/;"	e	enum:Eigen::DecompositionOptions
PlainObject	src/Core/Array.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Array	access:public
PlainObject	src/Core/ArrayBase.h	/^          > PlainObject;$/;"	t	class:Eigen::ArrayBase	access:public
PlainObject	src/Core/DiagonalMatrix.h	/^    typedef DiagonalMatrix<Scalar,DiagonalVectorType::SizeAtCompileTime,DiagonalVectorType::MaxSizeAtCompileTime> PlainObject;$/;"	t	class:Eigen::DiagonalBase	access:public
PlainObject	src/Core/Matrix.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Matrix	access:public
PlainObject	src/Core/MatrixBase.h	/^          > PlainObject;$/;"	t	class:Eigen::MatrixBase	access:public
PlainObject	src/Core/ProductBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:ScaledProduct	access:public
PlainObject	src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::SelfAdjointView	access:public
PlainObject	src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType PlainObject;$/;"	t	class:Eigen::TriangularView	access:public
PlainObject	src/Core/products/CoeffBasedProduct.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::CoeffBasedProduct	access:public
PlainObject	src/Geometry/Quaternion.h	/^  typedef Quaternion<_Scalar,_Options> PlainObject;$/;"	t	struct:Eigen::internal::traits	access:public
PlainObject	src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrix<Scalar, Flags&RowMajorBit ? RowMajor : ColMajor, Index> PlainObject;$/;"	t	class:Eigen::SparseMatrixBase	access:public
PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase() : m_storage()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(Index a_size, Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index a_size, Index nbRows, Index nbCols)
PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived> &other)
PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived> &other)
PlainObjectBase	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const PlainObjectBase& other)
PlainObjectBase	src/Core/PlainObjectBase.h	/^    PlainObjectBase(PlainObjectBase&& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(PlainObjectBase&& other)
PlainObjectBase	src/Core/PlainObjectBase.h	/^    PlainObjectBase(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(internal::constructor_without_unaligned_array_assert)
PlainObjectBase	src/Core/PlainObjectBase.h	/^class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base_dispatcher_for_doxygen
PlainObjectType	src/Core/Ref.h	/^  typedef _PlainObjectType PlainObjectType;$/;"	t	struct:Eigen::internal::traits	access:public
PlainObjectType	src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::PlainObjectType PlainObjectType;$/;"	t	class:Eigen::RefBase	access:private
PlainPermutationType	src/Core/PermutationMatrix.h	/^            PlainPermutationType;$/;"	t	class:Eigen::PermutationBase	access:public
PlainPermutationType	src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::PlainPermutationType PlainPermutationType;$/;"	t	class:Eigen::Transpose	access:private
PointerArgType	src/Core/Map.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::Map	access:public
PointerArgType	src/Core/Map.h	/^    typedef const Scalar* PointerArgType;$/;"	t	class:Eigen::Map	access:public
PointerType	src/Core/Map.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::Map	access:public
PointerType	src/Core/MapBase.h	/^                     PointerType;$/;"	t	class:Eigen::MapBase	access:public
PointerType	src/Core/MapBase.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::MapBase	access:public
PositiveSemiDef	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
PreconditionIfMoreColsThanRows	src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon416
PreconditionIfMoreRowsThanCols	src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon416
Preconditioner	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::BiCGSTAB	access:public
Preconditioner	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits	access:public
Preconditioner	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::ConjugateGradient	access:public
Preconditioner	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits	access:public
Preconditioner	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::Preconditioner Preconditioner;$/;"	t	class:Eigen::IterativeSolverBase	access:public
ProdRetType	src/Core/TriangularMatrix.h	/^      typedef typename ProductReturnType<DenseMatrixType, OtherPlainObject>::Type ProdRetType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
ProductBase	src/Core/ProductBase.h	/^class ProductBase : public MatrixBase<Derived>$/;"	c	namespace:Eigen	inherits:MatrixBase
ProductReturnType	src/Core/GeneralProduct.h	/^struct ProductReturnType$/;"	s	namespace:Eigen
ProductReturnType	src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,CoeffBasedProductMode>$/;"	s	namespace:Eigen
ProductReturnType	src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen
ProductType	src/Geometry/Transform.h	/^    typedef internal::transform_transform_product_impl<Transform,Transform<Scalar,Dim,OtherMode,OtherOptions> > ProductType;$/;"	t	struct:Eigen::Transform::icc_11_workaround	access:public
Projective	src/Core/util/Constants.h	/^  Projective    = 0x20$/;"	e	enum:Eigen::TransformTraits
Projective2d	src/Geometry/Transform.h	/^typedef Transform<double,2,Projective> Projective2d;$/;"	t	namespace:Eigen
Projective2f	src/Geometry/Transform.h	/^typedef Transform<float,2,Projective> Projective2f;$/;"	t	namespace:Eigen
Projective3d	src/Geometry/Transform.h	/^typedef Transform<double,3,Projective> Projective3d;$/;"	t	namespace:Eigen
Projective3f	src/Geometry/Transform.h	/^typedef Transform<float,3,Projective> Projective3f;$/;"	t	namespace:Eigen
QR	src/Eigen2Support/QR.h	/^    QR() : Base() {}$/;"	f	class:Eigen::QR	access:public	signature:()
QR	src/Eigen2Support/QR.h	/^    explicit QR(const T& t) : Base(t) {}$/;"	f	class:Eigen::QR	access:public	signature:(const T& t)
QR	src/Eigen2Support/QR.h	/^class QR : public HouseholderQR<MatrixType>$/;"	c	namespace:Eigen	inherits:HouseholderQR
QRMatrixType	src/SparseQR/SparseQR.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> QRMatrixType;$/;"	t	class:Eigen::SparseQR	access:public
QRPreconditioners	src/Core/util/Constants.h	/^enum QRPreconditioners {$/;"	g	namespace:Eigen
QRType	src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
QRType	src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
QRType	src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
QRType	src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
QRType	src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
QRType	src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:private
Quaternion	src/Eigen2Support/Geometry/All.h	29;"	d
Quaternion	src/Eigen2Support/Geometry/All.h	84;"	d
Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& other)
Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(Scalar w, Scalar x, Scalar y, Scalar z)$/;"	f	class:Eigen::Quaternion	access:public	signature:(Scalar w, Scalar x, Scalar y, Scalar z)
Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(const Quaternion& other) { m_coeffs = other.m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other)
Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^  inline explicit Quaternion(const Quaternion<OtherScalarType>& other)$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion<OtherScalarType>& other)
Quaternion	src/Eigen2Support/Geometry/Quaternion.h	/^class Quaternion : public RotationBase<Quaternion<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
Quaternion	src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Quaternion	src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& other)
Quaternion	src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const Quaternion<OtherScalar, OtherOptions>& other)$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion<OtherScalar, OtherOptions>& other)
Quaternion	src/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Quaternion	src/Geometry/Quaternion.h	/^  inline Quaternion(const Scalar& w, const Scalar& x, const Scalar& y, const Scalar& z) : m_coeffs(x, y, z, w){}$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Scalar& w, const Scalar& x, const Scalar& y, const Scalar& z)
Quaternion	src/Geometry/Quaternion.h	/^  inline Quaternion(const Scalar* data) : m_coeffs(data) {}$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Scalar* data)
Quaternion	src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_STRONG_INLINE Quaternion(const QuaternionBase<Derived>& other) { this->Base::operator=(other); }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const QuaternionBase<Derived>& other)
Quaternion	src/Geometry/Quaternion.h	/^class Quaternion : public QuaternionBase<Quaternion<_Scalar,_Options> >$/;"	c	namespace:Eigen	inherits:QuaternionBase
QuaternionBase	src/Geometry/Quaternion.h	/^class QuaternionBase : public RotationBase<Derived, 3>$/;"	c	namespace:Eigen	inherits:RotationBase
QuaternionMapAlignedd	src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, Aligned>  QuaternionMapAlignedd;$/;"	t	namespace:Eigen
QuaternionMapAlignedf	src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, Aligned>   QuaternionMapAlignedf;$/;"	t	namespace:Eigen
QuaternionMapd	src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, 0>        QuaternionMapd;$/;"	t	namespace:Eigen
QuaternionMapf	src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, 0>         QuaternionMapf;$/;"	t	namespace:Eigen
QuaternionType	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis	access:public
QuaternionType	src/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis	access:public
Quaterniond	src/Eigen2Support/Geometry/All.h	31;"	d
Quaterniond	src/Eigen2Support/Geometry/All.h	86;"	d
Quaterniond	src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaterniond	src/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaternionf	src/Eigen2Support/Geometry/All.h	30;"	d
Quaternionf	src/Eigen2Support/Geometry/All.h	85;"	d
Quaternionf	src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Quaternionf	src/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
QuickSplit	src/IterativeLinearSolvers/IncompleteLUT.h	/^Index QuickSplit(VectorV &row, VectorI &ind, Index ncut)$/;"	f	namespace:Eigen::internal	signature:(VectorV &row, VectorI &ind, Index ncut)
ROW_IS_ALIVE	src/OrderingMethods/Eigen_Colamd.h	125;"	d
ROW_IS_DEAD	src/OrderingMethods/Eigen_Colamd.h	123;"	d
ROW_IS_MARKED_DEAD	src/OrderingMethods/Eigen_Colamd.h	124;"	d
Random	src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Random	src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Random	src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Random	src/Core/Random.h	/^DenseBase<Derived>::Random()$/;"	f	class:Eigen::DenseBase	signature:()
Random	src/Core/Random.h	/^DenseBase<Derived>::Random(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols)
Random	src/Core/Random.h	/^DenseBase<Derived>::Random(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
RandomAccessLinSpacedReturnType	src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,true>,Derived> RandomAccessLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase	access:public
RandomAccessPattern	src/SparseCore/SparseUtil.h	/^const int RandomAccessPattern       = 0x8 | OuterRandomAccessPattern | InnerRandomAccessPattern;$/;"	m	namespace:Eigen
ReadCost	src/Core/NumTraits.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
ReadOnlyAccessors	src/Core/util/Constants.h	/^  ReadOnlyAccessors, $/;"	e	enum:Eigen::AccessorLevels
ReadOnlyMapBase	src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> ReadOnlyMapBase;$/;"	t	class:Eigen::MapBase	access:private
Real	src/Core/NumTraits.h	/^  typedef T Real;$/;"	t	struct:Eigen::GenericNumTraits	access:public
RealPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RealScalar>::type RealPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RealPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacketSize  = Vectorizable ? packet_traits<RealScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
RealQZ	src/Eigenvalues/RealQZ.h	/^      RealQZ(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime) : $/;"	f	class:Eigen::RealQZ	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
RealQZ	src/Eigenvalues/RealQZ.h	/^      RealQZ(const MatrixType& A, const MatrixType& B, bool computeQZ = true) :$/;"	f	class:Eigen::RealQZ	access:public	signature:(const MatrixType& A, const MatrixType& B, bool computeQZ = true)
RealQZ	src/Eigenvalues/RealQZ.h	/^  template<typename _MatrixType> class RealQZ$/;"	c	namespace:Eigen
RealReturnType	src/plugins/CommonCwiseUnaryOps.h	/^                  >::type RealReturnType;$/;"	t
RealRowVectorType	src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
RealScalar	src/Cholesky/LDLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LDLT	access:public
RealScalar	src/Cholesky/LLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LLT	access:public
RealScalar	src/Cholesky/LLT.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::llt_inplace	access:public
RealScalar	src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CholmodBase	access:public
RealScalar	src/Core/ArrayBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ArrayBase	access:public
RealScalar	src/Core/DenseBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseBase	access:public
RealScalar	src/Core/DenseCoeffsBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
RealScalar	src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::RealScalar RealScalar;$/;"	t	class:Eigen::DiagonalBase	access:public
RealScalar	src/Core/Dot.h	/^  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::lpNorm_selector	access:public
RealScalar	src/Core/IO.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::significant_decimals_default_impl	access:public
RealScalar	src/Core/MapBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MapBase	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef bool RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_impl	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::atanh2_default_impl	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::hypot_impl	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_default_impl	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_ref_default_impl	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::norm1_default_impl	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_default_impl	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_ref_impl	access:public
RealScalar	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public
RealScalar	src/Core/MatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixBase	access:public
RealScalar	src/Core/PlainObjectBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
RealScalar	src/Core/SelfAdjointView.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointView	access:public
RealScalar	src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::RealScalar RealScalar;$/;"	t	class:Eigen::VectorwiseOp	access:public
RealScalar	src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::AlignedBox	access:public
RealScalar	src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane	access:public
RealScalar	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
RealScalar	src/Eigen2Support/LU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LU	access:public
RealScalar	src/Eigen2Support/SVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SVD	access:private
RealScalar	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
RealScalar	src/Eigenvalues/ComplexSchur.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexSchur	access:public
RealScalar	src/Eigenvalues/EigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::EigenSolver	access:public
RealScalar	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
RealScalar	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::HessenbergDecomposition	access:private
RealScalar	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
RealScalar	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Tridiagonalization	access:public
RealScalar	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
RealScalar	src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::Real               RealScalar;$/;"	t	class:Eigen::AlignedBox	access:public
RealScalar	src/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane	access:public
RealScalar	src/Geometry/OrthoMethods.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
RealScalar	src/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
RealScalar	src/Geometry/Quaternion.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::QuaternionBase	access:public
RealScalar	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::BiCGSTAB	access:public
RealScalar	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ConjugateGradient	access:public
RealScalar	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::IncompleteLUT	access:private
RealScalar	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::IterativeSolverBase	access:public
RealScalar	src/Jacobi/Jacobi.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiRotation	access:public
RealScalar	src/LU/FullPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::FullPivLU	access:public
RealScalar	src/LU/PartialPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::PartialPivLU	access:public
RealScalar	src/LU/PartialPivLU.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
RealScalar	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::PastixBase	access:public
RealScalar	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLDLT	access:protected
RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLLT	access:protected
RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLU	access:protected
RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoImpl	access:public
RealScalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
RealScalar	src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
RealScalar	src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
RealScalar	src/QR/HouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::HouseholderQR	access:public
RealScalar	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SPQR	access:public
RealScalar	src/SVD/JacobiSVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiSVD	access:public
RealScalar	src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
RealScalar	src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
RealScalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholesky	access:public
RealScalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
RealScalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLDLT	access:public
RealScalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLLT	access:public
RealScalar	src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector	access:public
RealScalar	src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator	access:public
RealScalar	src/SparseCore/CompressedStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::CompressedStorage	access:protected
RealScalar	src/SparseCore/SparseMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
RealScalar	src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename ResultType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public
RealScalar	src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::RealScalar RealScalar; $/;"	t	class:Eigen::SparseLU	access:public
RealScalar	src/SparseLU/SparseLUImpl.h	/^    typedef typename ScalarVector::RealScalar RealScalar; $/;"	t	class:Eigen::internal::SparseLUImpl	access:public
RealScalar	src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SparseQR	access:public
RealScalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperILU	access:public
RealScalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLU	access:public
RealScalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLUBase	access:public
RealScalar	src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::UmfPackLU	access:public
RealSchur	src/Eigenvalues/RealSchur.h	/^    RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::RealSchur	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
RealSchur	src/Eigenvalues/RealSchur.h	/^    RealSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::RealSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
RealSchur	src/Eigenvalues/RealSchur.h	/^template<typename _MatrixType> class RealSchur$/;"	c	namespace:Eigen
RealVectorType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
ReduxReturnType	src/Core/VectorwiseOp.h	/^    template<typename BinaryOp> struct ReduxReturnType$/;"	s	class:Eigen::VectorwiseOp	access:public
Ref	src/Core/Ref.h	/^    inline Ref(PlainObjectBase<Derived>& expr,$/;"	f	class:Eigen::Ref	access:public	signature:(PlainObjectBase<Derived>& expr, typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
Ref	src/Core/Ref.h	/^    inline Ref(const DenseBase<Derived>& expr,$/;"	f	class:Eigen::Ref	access:public	signature:(const DenseBase<Derived>& expr, typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
Ref	src/Core/Ref.h	/^    inline Ref(const DenseBase<Derived>& expr,$/;"	f	class:Eigen::Ref	access:public	signature:(const DenseBase<Derived>& expr, typename internal::enable_if<bool(Traits::template match<Derived>::ScalarTypeMatch),Derived>::type* = 0)
Ref	src/Core/Ref.h	/^    inline Ref(const PlainObjectBase<Derived>& expr,$/;"	p	class:Eigen::Ref	access:private	signature:(const PlainObjectBase<Derived>& expr, typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
Ref	src/Core/Ref.h	/^    inline Ref(const Ref& other) : Base(other) {$/;"	f	class:Eigen::Ref	access:public	signature:(const Ref& other)
Ref	src/Core/Ref.h	/^    inline Ref(const RefBase<OtherRef>& other) {$/;"	f	class:Eigen::Ref	access:public	signature:(const RefBase<OtherRef>& other)
Ref	src/Core/Ref.h	/^template<typename PlainObjectType, int Options, typename StrideType> class Ref$/;"	c	namespace:Eigen	inherits:RefBase
Ref	src/Core/Ref.h	/^template<typename TPlainObjectType, int Options, typename StrideType> class Ref<const TPlainObjectType, Options, StrideType>$/;"	c	namespace:Eigen	inherits:RefBase
RefBase	src/Core/Ref.h	/^  RefBase()$/;"	f	class:Eigen::RefBase	access:public	signature:()
RefBase	src/Core/Ref.h	/^template<typename Derived> class RefBase$/;"	c	namespace:Eigen	inherits:MapBase
RemovedBits	src/SparseCore/SparseProduct.h	/^    RemovedBits = ~(EvalToRowMajor ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon452
Replicate	src/Core/Replicate.h	/^    inline Replicate(const OriginalMatrixType& a_matrix, Index rowFactor, Index colFactor)$/;"	f	class:Eigen::Replicate	access:public	signature:(const OriginalMatrixType& a_matrix, Index rowFactor, Index colFactor)
Replicate	src/Core/Replicate.h	/^    inline explicit Replicate(const OriginalMatrixType& a_matrix)$/;"	f	class:Eigen::Replicate	access:public	signature:(const OriginalMatrixType& a_matrix)
Replicate	src/Core/Replicate.h	/^template<typename MatrixType,int RowFactor,int ColFactor> class Replicate$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
ReplicateReturnType	src/Core/DenseBase.h	/^    typedef Replicate<Derived,Dynamic,Dynamic> ReplicateReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ReplicateReturnType	src/Core/VectorwiseOp.h	/^    typedef Replicate<ExpressionType,Direction==Vertical?Dynamic:1,Direction==Horizontal?Dynamic:1> ReplicateReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
RequireInitialization	src/Core/NumTraits.h	/^    RequireInitialization = internal::is_arithmetic<T>::value ? 0 : 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon286
Res	src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseResType>::type Res;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
ResPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResPacket ResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
ResPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize   = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Traits::ResPacketSize$/;"	e	enum:Eigen::internal::gebp_kernel::__anon38
ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
ResPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
ResPacketSize	src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon46
ResPacketSize	src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon47
ResScalar	src/Core/Dot.h	/^  typedef typename scalar_product_traits<typename traits<T>::Scalar,typename traits<U>::Scalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::dot_nocheck	access:public
ResScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
ResScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef           Scalar      ResScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
ResScalar	src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product	access:public
ResScalar	src/Core/products/GeneralMatrixMatrix.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product	access:public
ResScalar	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::tribb_kernel	access:public
ResScalar	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public
ResScalar	src/Core/products/GeneralMatrixVector.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
ResScalar	src/Core/products/TriangularMatrixVector.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::triangular_matrix_vector_product	access:public
ResultAlignment	src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon396
ResultAlignment	src/LU/arch/Inverse_SSE.h	/^    ResultAlignment = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon397
ResultMode	src/Geometry/Transform.h	/^  enum { ResultMode = transform_product_result<LhsMode,RhsMode>::Mode };$/;"	e	enum:Eigen::internal::transform_transform_product_impl::__anon389
ResultScalar	src/Householder/HouseholderSequence.h	/^    ResultScalar;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type	access:public
ResultType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
ResultType	src/Eigen2Support/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
ResultType	src/Eigen2Support/Geometry/Transform.h	/^  typedef typename ProductReturnType<MatrixType,Other>::Type ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
ResultType	src/Geometry/Transform.h	/^    typedef typename ProductType::ResultType ResultType;$/;"	t	struct:Eigen::Transform::icc_11_workaround	access:public
ResultType	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
ResultType	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,ResultMode,LhsOptions> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
ResultType	src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Projective,Options> ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
ResultType	src/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
ResultType	src/Geometry/Transform.h	/^  typedef typename MatrixType::PlainObject ResultType;$/;"	t	struct:Eigen::internal::transform_right_product_impl	access:public
ReturnByValue	src/Core/ReturnByValue.h	/^template<typename Derived> class ReturnByValue$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
ReturnOpposite	src/Core/BandMatrix.h	/^        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon143
ReturnType	src/Core/PermutationMatrix.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/Core/ReturnByValue.h	/^    typedef typename internal::traits<Derived>::ReturnType ReturnType;$/;"	t	class:Eigen::ReturnByValue	access:public
ReturnType	src/Core/SolveTriangular.h	/^  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/Core/Transpositions.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/Core/VectorwiseOp.h	/^                      typename Scalar=typename internal::traits<ExpressionType>::Scalar> struct ReturnType$/;"	s	class:Eigen::VectorwiseOp	access:public
ReturnType	src/Core/util/Meta.h	/^  typedef T ReturnType;$/;"	t	struct:Eigen::scalar_product_traits	access:public
ReturnType	src/Core/util/Meta.h	/^  typedef std::complex<T> ReturnType;$/;"	t	struct:Eigen::scalar_product_traits	access:public
ReturnType	src/Eigenvalues/HessenbergDecomposition.h	/^  typedef MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/Geometry/Homogeneous.h	/^                 MatrixTypeCleaned::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/Geometry/Homogeneous.h	/^                 Rhs::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,1> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
ReturnType	src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,Dim> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
ReturnType	src/Geometry/RotationBase.h	/^  typedef Transform<Scalar,Dim,Affine> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
ReturnType	src/LU/Inverse.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename SPQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/SparseCore/SparsePermutation.h	/^        SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,Index> >::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/SparseQR/SparseQR.h	/^    typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/SparseQR/SparseQR.h	/^    typedef typename SparseQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/misc/Image.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/misc/Kernel.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/misc/Solve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/misc/SparseSolve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	src/misc/SparseSolve.h	/^  typedef SparseMatrix<typename Rhs::Scalar, Rhs::Options, typename Rhs::Index> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Reverse	src/Core/Reverse.h	/^    inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }$/;"	f	class:Eigen::Reverse	access:public	signature:(const MatrixType& matrix)
Reverse	src/Core/Reverse.h	/^template<typename MatrixType, int Direction> class Reverse$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
ReverseCol	src/Core/Reverse.h	/^      ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon312
ReverseInnerIterator	src/SparseCore/MappedSparseMatrix.h	/^    ReverseInnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:(const MappedSparseMatrix& mat, Index outer)
ReverseInnerIterator	src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^        inline ReverseInnerIterator(const BlockType& xpr, Index outer)$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:(const BlockType& xpr, Index outer)
ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^      EIGEN_STRONG_INLINE ReverseInnerIterator(const BlockType& block, Index outer)$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:(const BlockType& block, Index outer)
ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator : public _MatrixTypeNested::ReverseInnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:_MatrixTypeNested::ReverseInnerIterator	access:public
ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator: public SparseMatrixType::ReverseInnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:SparseMatrixType::ReverseInnerIterator	access:public
ReverseInnerIterator	src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator: public XprType::ReverseInnerIterator$/;"	c	class:Eigen::BlockImpl	inherits:XprType::ReverseInnerIterator	access:public
ReverseInnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)
ReverseInnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)
ReverseInnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl	inherits:CwiseUnaryOpImpl::MatrixTypeReverseIterator
ReverseInnerIterator	src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl	inherits:CwiseUnaryViewImpl::MatrixTypeReverseIterator
ReverseInnerIterator	src/SparseCore/SparseMatrix.h	/^    ReverseInnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:(const SparseMatrix& mat, Index outer)
ReverseInnerIterator	src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseMatrix
ReverseInnerIterator	src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)
ReverseInnerIterator	src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::TransposeImpl	inherits:_MatrixTypeNested::ReverseInnerIterator
ReverseInnerIterator	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:(const SparseTriangularView& view, Index outer)
ReverseInnerIterator	src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::ReverseInnerIterator : public MatrixTypeNestedCleaned::ReverseInnerIterator$/;"	c	class:Eigen::SparseTriangularView	inherits:MatrixTypeNestedCleaned::ReverseInnerIterator
ReverseInnerIterator	src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:(const SparseVector& vec, Index outer=0)
ReverseInnerIterator	src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:(const internal::CompressedStorage<Scalar,Index>& data)
ReverseInnerIterator	src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseVector
ReversePacket	src/Core/Reverse.h	/^      ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::Reverse::__anon312
ReverseReturnType	src/Core/DenseBase.h	/^    typedef Reverse<Derived, BothDirections> ReverseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ReverseRow	src/Core/Reverse.h	/^      ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon312
Rhs	src/Core/ProductBase.h	/^  typedef typename remove_all<_Rhs>::type Rhs;$/;"	t	struct:Eigen::internal::traits	access:public
Rhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Rhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Rhs	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,RhsMode,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Rhs	src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseRhsType>::type Rhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
RhsBlasTraits	src/Core/ProductBase.h	/^    typedef internal::blas_traits<_RhsNested> RhsBlasTraits;$/;"	t	class:Eigen::ProductBase	access:public
RhsCoeffReadCost	src/Core/CwiseBinaryOp.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon151
RhsCoeffReadCost	src/Core/products/CoeffBasedProduct.h	/^      RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon30
RhsCoeffReadCost	src/SparseCore/SparseDenseProduct.h	/^    RhsCoeffReadCost = traits<_RhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon441
RhsCoeffReadCost	src/SparseCore/SparseProduct.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon452
RhsFlags	src/Core/CwiseBinaryOp.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon151
RhsFlags	src/Core/products/CoeffBasedProduct.h	/^      RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon30
RhsFlags	src/SparseCore/SparseProduct.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon452
RhsIsSelfAdjoint	src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsSelfAdjoint = (RhsMode&SelfAdjoint)==SelfAdjoint$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon49
RhsIsUpper	src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsUpper = (RhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon49
RhsIsVectorAtCompileTime	src/Core/SolveTriangular.h	/^      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1$/;"	e	enum:Eigen::internal::trsolve_traits::__anon319
RhsIterator	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _RhsNested::InnerIterator RhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
RhsMode	src/SparseCore/SparseDiagonalProduct.h	/^      RhsMode = internal::is_diagonal<_RhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon444
RhsNested	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Rhs>::type RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
RhsNested	src/Core/CwiseBinaryOp.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
RhsNested	src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Rhs, Lhs::RowsAtCompileTime, typename internal::plain_matrix_type<Rhs>::type >::type RhsNested;$/;"	t	struct:Eigen::ProductReturnType	access:public
RhsNested	src/Core/ProductBase.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::ProductBase	access:public
RhsNested	src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNested;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl	access:public
RhsNested	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::RhsNested RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
RhsNested	src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::RhsNested RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
RhsNested	src/SparseCore/SparseDenseProduct.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
RhsNested	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
RhsNested	src/SparseCore/SparseProduct.h	/^    typename internal::nested<Rhs,Lhs::RowsAtCompileTime>::type>::type RhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
RhsNestedCleaned	src/Core/SolveTriangular.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
RhsNestedCleaned	src/misc/Solve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
RhsNestedCleaned	src/misc/SparseSolve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
RhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::RhsPacket RhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
RhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
RhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
RhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
RhsPacketSize	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
RhsPacketSize	src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon46
RhsPacketSize	src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon47
RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress   = Traits::RhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon38
RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = ResPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
RhsProgress	src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = Vectorizable ? 2*ResPacketSize : 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
RhsRowMajor	src/Core/products/CoeffBasedProduct.h	/^      RhsRowMajor = RhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon30
RhsRowMajor	src/SparseCore/SparseProduct.h	/^    RhsRowMajor = internal::traits<Rhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon451
RhsScalar	src/Core/GeneralProduct.h	/^    typedef typename Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
RhsScalar	src/Core/ProductBase.h	/^    typedef typename internal::traits<Rhs>::Scalar RhsScalar;$/;"	t	class:Eigen::ProductBase	access:public
RhsScalar	src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
RhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsScalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::level3_blocking	access:private
RhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
RhsScalar	src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
RhsUpLo	src/Core/products/SelfadjointMatrixVector.h	/^    RhsUpLo = RhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon51
RhsVectors	src/Core/SolveTriangular.h	/^      RhsVectors  = RhsIsVectorAtCompileTime ? 1 : Dynamic$/;"	e	enum:Eigen::internal::trsolve_traits::__anon320
Rotation2D	src/Eigen2Support/Geometry/All.h	25;"	d
Rotation2D	src/Eigen2Support/Geometry/All.h	80;"	d
Rotation2D	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D(Scalar a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar a)
Rotation2D	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D<OtherScalarType>& other)
Rotation2D	src/Eigen2Support/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen	inherits:RotationBase
Rotation2D	src/Geometry/Rotation2D.h	/^  Rotation2D() {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Rotation2D	src/Geometry/Rotation2D.h	/^  inline Rotation2D(const Scalar& a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Scalar& a)
Rotation2D	src/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D<OtherScalarType>& other)
Rotation2D	src/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen	inherits:RotationBase
Rotation2Dd	src/Eigen2Support/Geometry/All.h	27;"	d
Rotation2Dd	src/Eigen2Support/Geometry/All.h	82;"	d
Rotation2Dd	src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Dd	src/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Df	src/Eigen2Support/Geometry/All.h	26;"	d
Rotation2Df	src/Eigen2Support/Geometry/All.h	81;"	d
Rotation2Df	src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
Rotation2Df	src/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
RotationBase	src/Eigen2Support/Geometry/All.h	24;"	d
RotationBase	src/Eigen2Support/Geometry/All.h	79;"	d
RotationBase	src/Eigen2Support/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
RotationBase	src/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
RotationMatrixType	src/Eigen2Support/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase	access:public
RotationMatrixType	src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase	access:public
RowMajor	src/Core/util/Constants.h	/^  RowMajor = 0x1,  \/\/ it is only a coincidence that this is equal to RowMajorBit -- don't rely on that$/;"	e	enum:Eigen::__anon66
RowMajorBit	src/Core/util/Constants.h	/^const unsigned int RowMajorBit = 0x1;$/;"	m	namespace:Eigen
RowType	src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowType;$/;"	t	class:Eigen::JacobiSVD	access:public
RowVector	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, 1> RowVector;$/;"	t	class:Eigen::SVD	access:private
RowVectorType	src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::LU	access:public
RowVectorType	src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
RowVectorType	src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
RowVectorType	src/QR/HouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::HouseholderQR	access:public
RowVectorType	src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, 1, ColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
RowXpr	src/Core/MatrixBase.h	/^    typedef typename Base::RowXpr RowXpr;$/;"	t	class:Eigen::MatrixBase	access:public
RowXpr	src/plugins/BlockMethods.h	/^typedef Block<Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowXpr;$/;"	t
Rows	src/Core/GeneralProduct.h	/^    Rows  = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon243
Rows	src/Geometry/Transform.h	/^    Rows = int(Mode)==(AffineCompact) ? Dim : HDim$/;"	e	enum:Eigen::Transform::__anon384
RowsAtCompileTime	src/Cholesky/LDLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon1
RowsAtCompileTime	src/Cholesky/LLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon2
RowsAtCompileTime	src/Core/BandMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
RowsAtCompileTime	src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon144
RowsAtCompileTime	src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon145
RowsAtCompileTime	src/Core/Block.h	/^    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,$/;"	e	enum:Eigen::internal::traits::__anon146
RowsAtCompileTime	src/Core/CwiseBinaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon150
RowsAtCompileTime	src/Core/DenseBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
RowsAtCompileTime	src/Core/Diagonal.h	/^    RowsAtCompileTime = (int(DiagIndex) == DynamicIndex || int(MatrixType::SizeAtCompileTime) == Dynamic) ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon161
RowsAtCompileTime	src/Core/DiagonalMatrix.h	/^      RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon163
RowsAtCompileTime	src/Core/DiagonalMatrix.h	/^    RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
RowsAtCompileTime	src/Core/DiagonalProduct.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon166
RowsAtCompileTime	src/Core/MapBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon276
RowsAtCompileTime	src/Core/Matrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon282
RowsAtCompileTime	src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon287
RowsAtCompileTime	src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon289
RowsAtCompileTime	src/Core/PermutationMatrix.h	/^    RowsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
RowsAtCompileTime	src/Core/ProductBase.h	/^    RowsAtCompileTime = traits<Lhs>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon294
RowsAtCompileTime	src/Core/Replicate.h	/^    RowsAtCompileTime = RowFactor==Dynamic || int(MatrixType::RowsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon309
RowsAtCompileTime	src/Core/Reverse.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon311
RowsAtCompileTime	src/Core/Select.h	/^    RowsAtCompileTime = ConditionMatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
RowsAtCompileTime	src/Core/Transpose.h	/^    RowsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon323
RowsAtCompileTime	src/Core/TriangularMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon326
RowsAtCompileTime	src/Core/VectorwiseOp.h	/^    RowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon331
RowsAtCompileTime	src/Core/products/CoeffBasedProduct.h	/^      RowsAtCompileTime = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon30
RowsAtCompileTime	src/Eigen2Support/Minor.h	/^    RowsAtCompileTime = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon358
RowsAtCompileTime	src/Eigenvalues/ComplexEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon360
RowsAtCompileTime	src/Eigenvalues/ComplexSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon361
RowsAtCompileTime	src/Eigenvalues/EigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon362
RowsAtCompileTime	src/Eigenvalues/GeneralizedEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon363
RowsAtCompileTime	src/Eigenvalues/RealQZ.h	/^        RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon365
RowsAtCompileTime	src/Eigenvalues/RealSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon366
RowsAtCompileTime	src/Geometry/Homogeneous.h	/^    RowsAtCompileTime = Direction==Vertical  ?  RowsPlusOne : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon371
RowsAtCompileTime	src/Householder/HouseholderSequence.h	/^      RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon394
RowsAtCompileTime	src/Householder/HouseholderSequence.h	/^    RowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon393
RowsAtCompileTime	src/LU/FullPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon398
RowsAtCompileTime	src/LU/PartialPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon401
RowsAtCompileTime	src/QR/ColPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon413
RowsAtCompileTime	src/QR/FullPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon414
RowsAtCompileTime	src/QR/HouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon415
RowsAtCompileTime	src/SVD/JacobiSVD.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon422
RowsAtCompileTime	src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
RowsAtCompileTime	src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
RowsAtCompileTime	src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
RowsAtCompileTime	src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
RowsAtCompileTime	src/SVD/UpperBidiagonalization.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon423
RowsAtCompileTime	src/SparseCore/SparseDenseProduct.h	/^    RowsAtCompileTime    = Tr ? int(traits<Rhs>::RowsAtCompileTime)     : int(traits<Lhs>::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon441
RowsAtCompileTime	src/SparseCore/SparseDiagonalProduct.h	/^    RowsAtCompileTime = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon442
RowsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon445
RowsAtCompileTime	src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon446
RowsAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
RowsAtCompileTime	src/SparseCore/SparseProduct.h	/^    RowsAtCompileTime    = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
RowsAtCompileTime	src/SparseCore/SparseVector.h	/^    RowsAtCompileTime = IsColVector ? Dynamic : 1,$/;"	e	enum:Eigen::internal::traits::__anon456
RowsBlockXpr	src/plugins/BlockMethods.h	/^typedef Block<Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowsBlockXpr;$/;"	t
RowsPlusOne	src/Geometry/Homogeneous.h	/^    RowsPlusOne = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon371
RowwiseReturnType	src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
S	src/Core/SolveTriangular.h	/^    S = IsLower ? 0     : I+1$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon321
SCMatrix	src/SparseLU/SparseLU.h	/^    typedef internal::MappedSuperNodalMatrix<Scalar, Index> SCMatrix; $/;"	t	class:Eigen::SparseLU	access:public
SDP_IsDiagonal	src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon443
SDP_IsSparseColMajor	src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon443
SDP_IsSparseRowMajor	src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon443
SPARSELU_COLUMN_BMOD_H	src/SparseLU/SparseLU_column_bmod.h	32;"	d
SPARSELU_COLUMN_DFS_H	src/SparseLU/SparseLU_column_dfs.h	31;"	d
SPARSELU_COPY_TO_UCOL_H	src/SparseLU/SparseLU_copy_to_ucol.h	30;"	d
SPARSELU_HEAP_RELAX_SNODE_H	src/SparseLU/SparseLU_heap_relax_snode.h	29;"	d
SPARSELU_IMPL_H	src/SparseLU/SparseLUImpl.h	10;"	d
SPARSELU_KERNEL_BMOD_H	src/SparseLU/SparseLU_kernel_bmod.h	12;"	d
SPARSELU_PANEL_BMOD_H	src/SparseLU/SparseLU_panel_bmod.h	32;"	d
SPARSELU_PANEL_DFS_H	src/SparseLU/SparseLU_panel_dfs.h	31;"	d
SPARSELU_PIVOTL_H	src/SparseLU/SparseLU_pivotL.h	31;"	d
SPARSELU_PRUNEL_H	src/SparseLU/SparseLU_pruneL.h	31;"	d
SPARSELU_RELAX_SNODE_H	src/SparseLU/SparseLU_relax_snode.h	29;"	d
SPARSE_COLETREE_H	src/SparseCore/SparseColEtree.h	32;"	d
SPQR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQR() $/;"	f	class:Eigen::SPQR	access:public	signature:()
SPQR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQR(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR	access:public	signature:(const _MatrixType& matrix)
SPQR	src/SPQRSupport/SuiteSparseQRSupport.h	/^class SPQR$/;"	c	namespace:Eigen
SPQRMatrixQReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQReturnType	access:public	signature:(const SPQRType& spqr)
SPQRMatrixQReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQReturnType{$/;"	s	namespace:Eigen
SPQRMatrixQTransposeReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType	access:public	signature:(const SPQRType& spqr)
SPQRMatrixQTransposeReturnType	src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQTransposeReturnType{$/;"	s	namespace:Eigen
SPQR_QProduct	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct(const SPQRType& spqr, const Derived& other, bool transpose) : m_spqr(spqr),m_other(other),m_transpose(transpose) {}$/;"	f	struct:Eigen::SPQR_QProduct	access:public	signature:(const SPQRType& spqr, const Derived& other, bool transpose)
SPQR_QProduct	src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQR_QProduct : ReturnByValue<SPQR_QProduct<SPQRType,Derived> >$/;"	s	namespace:Eigen	inherits:ReturnByValue
SPQR_free	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void SPQR_free()$/;"	f	class:Eigen::SPQR	access:public	signature:()
SSE	src/Core/util/Constants.h	/^    SSE = 0x1,$/;"	e	enum:Eigen::Architecture::Type
STORAGE_LAYOUT_DOES_NOT_MATCH	src/Core/util/StaticAssert.h	/^        STORAGE_LAYOUT_DOES_NOT_MATCH$/;"	e	enum:Eigen::internal::static_assertion::__anon126
SVA_Inner	src/SparseCore/SparseVector.h	/^  SVA_Inner,$/;"	e	enum:Eigen::internal::__anon457
SVA_Outer	src/SparseCore/SparseVector.h	/^  SVA_Outer$/;"	e	enum:Eigen::internal::__anon457
SVA_RuntimeSwitch	src/SparseCore/SparseVector.h	/^  SVA_RuntimeSwitch,$/;"	e	enum:Eigen::internal::__anon457
SVD	src/Eigen2Support/SVD.h	/^    SVD() {} \/\/ a user who relied on compiler-generated default compiler reported problems with MSVC in 2.0.7$/;"	f	class:Eigen::SVD	access:public	signature:()
SVD	src/Eigen2Support/SVD.h	/^    SVD(const MatrixType& matrix)$/;"	f	class:Eigen::SVD	access:public	signature:(const MatrixType& matrix)
SVD	src/Eigen2Support/SVD.h	/^template<typename MatrixType> class SVD$/;"	c	namespace:Eigen
SVD	src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
SameType	src/Core/CwiseBinaryOp.h	/^    SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon151
SameType	src/Core/products/CoeffBasedProduct.h	/^      SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon30
Scalar	src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LDLT	access:public
Scalar	src/Cholesky/LLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LLT	access:public
Scalar	src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CholmodBase	access:public
Scalar	src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::ArrayBase	access:public
Scalar	src/Core/Assign_MKL.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::vml_assign_impl	access:public
Scalar	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Scalar	src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Scalar	src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Scalar	src/Core/BandMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/Block.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/CommaInitializer.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::CommaInitializer	access:public
Scalar	src/Core/CoreIterators.h	/^    typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::DenseBase::InnerIterator	access:protected
Scalar	src/Core/CwiseBinaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/CwiseUnaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/CwiseUnaryView.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseBase	access:public
Scalar	src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Scalar	src/Core/DiagonalMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Scalar	src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	class:Eigen::DiagonalBase	access:public
Scalar	src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/DiagonalProduct.h	/^  typedef typename scalar_product_traits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/Map.h	/^  typedef typename PlainObjectType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/MapBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MapBase	access:public
Scalar	src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MapBase	access:public
Scalar	src/Core/Matrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/MatrixBase.h	/^      typedef typename internal::scalar_product_traits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type	access:public
Scalar	src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MatrixBase	access:public
Scalar	src/Core/NoAlias.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::NoAlias	access:private
Scalar	src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PermutationBase	access:public
Scalar	src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::Transpose	access:public
Scalar	src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
Scalar	src/Core/ProductBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:ScaledProduct	access:public
Scalar	src/Core/ProductBase.h	/^  typedef typename scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Scalar	src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_novec_unroller	access:public
Scalar	src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller	access:public
Scalar	src/Core/Replicate.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/Reverse.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar; $/;"	t	class:Eigen::SelfAdjointView	access:public
Scalar	src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Scalar	src/Core/Transpose.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::TriangularBase	access:public
Scalar	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Scalar Scalar;$/;"	t	class:Eigen::TriangularView	access:public
Scalar	src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Scalar	src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::VectorwiseOp	access:public
Scalar	src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::result_type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::coeff_visitor	access:public
Scalar	src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::max_coeff_visitor	access:public
Scalar	src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::min_coeff_visitor	access:public
Scalar	src/Core/products/CoeffBasedProduct.h	/^  typedef typename scalar_product_traits<typename _LhsNested::Scalar, typename _RhsNested::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  Scalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Scalar	src/Core/util/BlasUtil.h	/^  typedef std::complex<RealScalar> Scalar;$/;"	t	struct:Eigen::internal::conj_helper	access:public
Scalar	src/Core/util/BlasUtil.h	/^  typedef typename NestedXpr::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Scalar	src/Core/util/BlasUtil.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Scalar	src/Eigen2Support/Cwise.h	/^    typedef typename internal::traits<ExpressionType>::Scalar Scalar;$/;"	t	class:Eigen::Cwise	access:public
Scalar	src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AlignedBox	access:public
Scalar	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis	access:public
Scalar	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Scalar	src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane	access:public
Scalar	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Scalar	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion	access:public
Scalar	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Scalar	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_quaternion_assign_impl	access:public
Scalar	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D	access:public
Scalar	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Scalar	src/Eigen2Support/Geometry/RotationBase.h	/^    typedef typename ei_traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase	access:public
Scalar	src/Eigen2Support/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Scaling	access:public
Scalar	src/Eigen2Support/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform	access:public
Scalar	src/Eigen2Support/Geometry/Transform.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Scalar	src/Eigen2Support/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation	access:public
Scalar	src/Eigen2Support/LU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LU	access:public
Scalar	src/Eigen2Support/SVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SVD	access:private
Scalar	src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Scalar	src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexSchur	access:public
Scalar	src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::EigenSolver	access:public
Scalar	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
Scalar	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Scalar	src/Eigenvalues/RealQZ.h	/^      typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealQZ	access:public
Scalar	src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealSchur	access:public
Scalar	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Scalar	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::Scalar Scalar;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Scalar	src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::Tridiagonalization	access:public
Scalar	src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Scalar	src/Geometry/AlignedBox.h	/^  typedef _Scalar                                   Scalar;$/;"	t	class:Eigen::AlignedBox	access:public
Scalar	src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis	access:public
Scalar	src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane	access:public
Scalar	src/Geometry/OrthoMethods.h	/^  typedef typename traits<Derived>::Scalar Scalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Scalar	src/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Scalar	src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::Map	access:public
Scalar	src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion	access:public
Scalar	src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl	access:public
Scalar	src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::QuaternionBase	access:public
Scalar	src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D	access:public
Scalar	src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/Geometry/RotationBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase	access:public
Scalar	src/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::UniformScaling	access:public
Scalar	src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform	access:public
Scalar	src/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation	access:public
Scalar	src/Householder/HouseholderSequence.h	/^    typedef typename internal::traits<HouseholderSequence>::Scalar Scalar;$/;"	t	class:Eigen::HouseholderSequence	access:public
Scalar	src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Scalar	src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BiCGSTAB	access:public
Scalar	src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ConjugateGradient	access:public
Scalar	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLUT	access:private
Scalar	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Scalar	src/LU/FullPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivLU	access:public
Scalar	src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PartialPivLU	access:public
Scalar	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PastixBase	access:public
Scalar	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLLT	access:protected
Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLU	access:protected
Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PardisoImpl	access:public
Scalar	src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Scalar	src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Scalar	src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Scalar	src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HouseholderQR	access:public
Scalar	src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SPQR	access:public
Scalar	src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::Scalar Scalar;$/;"	t	struct:Eigen::SPQR_QProduct	access:public
Scalar	src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::JacobiSVD	access:public
Scalar	src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Scalar	src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Scalar	src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Scalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Scalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Scalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Scalar	src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLLT	access:public
Scalar	src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                             Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                         Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector	access:public
Scalar	src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator	access:public
Scalar	src/SparseCore/CompressedStorage.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::CompressedStorage	access:public
Scalar	src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename LhsCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Scalar	src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Scalar	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename CwiseBinaryXpr::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Scalar	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Scalar	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private
Scalar	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private
Scalar	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:private
Scalar	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:private
Scalar	src/SparseCore/SparseDenseProduct.h	/^                                         typename traits<Rhs>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename _Lhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/SparseCore/SparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Scalar	src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Scalar	src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/SparseCore/SparseProduct.h	/^  typedef typename _LhsNested::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/SparseCore/SparseProduct.h	/^  typedef typename internal::traits<Lhs>::Scalar Scalar;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Scalar	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Scalar	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Scalar	src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public
Scalar	src/SparseCore/SparseVector.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector	access:public
Scalar	src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public
Scalar	src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::Scalar Scalar; $/;"	t	class:Eigen::SparseLU	access:public
Scalar	src/SparseLU/SparseLU.h	/^  typedef typename MappedSupernodalType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixLReturnType	access:public
Scalar	src/SparseLU/SparseLU.h	/^  typedef typename MatrixLType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixUReturnType	access:public
Scalar	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _Scalar Scalar; $/;"	t	class:Eigen::internal::MappedSuperNodalMatrix	access:public
Scalar	src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename ScalarVector::Scalar Scalar;$/;"	t	struct:Eigen::internal::column_dfs_traits	access:public
Scalar	src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseQR	access:public
Scalar	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType	access:public
Scalar	src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQR_QProduct	access:public
Scalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperILU	access:public
Scalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperLU	access:public
Scalar	src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SuperLUBase	access:public
Scalar	src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::UmfPackLU	access:public
ScalarAddReturnType	src/Eigen2Support/Cwise.h	/^    typedef CwiseUnaryOp<internal::scalar_add_op<Scalar>, ExpressionType> ScalarAddReturnType;$/;"	t	class:Eigen::Cwise	access:public
ScalarCoeffImpl	src/Core/products/CoeffBasedProduct.h	/^                                   _LhsNested, _RhsNested, Scalar> ScalarCoeffImpl;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
ScalarIsComplex	src/PardisoSupport/PardisoSupport.h	/^      ScalarIsComplex = NumTraits<Scalar>::IsComplex$/;"	e	enum:Eigen::PardisoImpl::__anon410
ScalarMatrix	src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic,ColMajor> ScalarMatrix;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
ScalarMultipleReturnType	src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_multiple_op<Scalar>, const Derived> ScalarMultipleReturnType;$/;"	t
ScalarPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type     ScalarPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ScalarQuotient1ReturnType	src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_quotient1_op<Scalar>, const Derived> ScalarQuotient1ReturnType;$/;"	t
ScalarTraits	src/Geometry/AlignedBox.h	/^  typedef NumTraits<Scalar>                         ScalarTraits;$/;"	t	class:Eigen::AlignedBox	access:public
ScalarTypeMatch	src/Core/Ref.h	/^      ScalarTypeMatch = internal::is_same<typename PlainObjectType::Scalar, typename Derived::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::match::__anon307
ScalarVector	src/SparseLU/SparseLU.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::SparseLU	access:public
ScalarVector	src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl	access:public
ScalarVector	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix	access:public
ScalarVector	src/SparseQR/SparseQR.h	/^    typedef Matrix<Scalar, Dynamic, 1> ScalarVector;$/;"	t	class:Eigen::SparseQR	access:public
ScalarWithConstIfNotLvalue	src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::ArrayWrapper	access:public
ScalarWithConstIfNotLvalue	src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MatrixWrapper	access:public
ScalarWithConstIfNotLvalue	src/Core/Diagonal.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::Diagonal	access:public
ScalarWithConstIfNotLvalue	src/Core/MapBase.h	/^                  >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MapBase	access:public
ScalarWithConstIfNotLvalue	src/Core/Swap.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::SwapWrapper	access:public
ScalarWithConstIfNotLvalue	src/Core/Transpose.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::TransposeImpl	access:public
ScaledProduct	src/Core/ProductBase.h	/^    ScaledProduct(const NestedProduct& prod, const Scalar& x)$/;"	f	class:ScaledProduct	access:public	signature:(const NestedProduct& prod, const Scalar& x)
ScaledProduct	src/Core/ProductBase.h	/^class ScaledProduct$/;"	c	inherits:ProductBase
ScaledProduct::Base	src/Core/ProductBase.h	/^                       typename NestedProduct::_RhsNested> Base;$/;"	t	class:ScaledProduct	access:public
ScaledProduct::PlainObject	src/Core/ProductBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:ScaledProduct	access:public
ScaledProduct::Scalar	src/Core/ProductBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:ScaledProduct	access:public
ScaledProduct::ScaledProduct	src/Core/ProductBase.h	/^    ScaledProduct(const NestedProduct& prod, const Scalar& x)$/;"	f	class:ScaledProduct	access:public	signature:(const NestedProduct& prod, const Scalar& x)
ScaledProduct::addTo	src/Core/ProductBase.h	/^    inline void addTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:ScaledProduct	access:public	signature:(Dest& dst) const
ScaledProduct::alpha	src/Core/ProductBase.h	/^    const Scalar& alpha() const { return m_alpha; }$/;"	f	class:ScaledProduct	access:public	signature:() const
ScaledProduct::evalTo	src/Core/ProductBase.h	/^    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:ScaledProduct	access:public	signature:(Dest& dst) const
ScaledProduct::m_alpha	src/Core/ProductBase.h	/^    Scalar m_alpha;$/;"	m	class:ScaledProduct	access:protected
ScaledProduct::m_prod	src/Core/ProductBase.h	/^    const NestedProduct& m_prod;$/;"	m	class:ScaledProduct	access:protected
ScaledProduct::scaleAndAddTo	src/Core/ProductBase.h	/^    inline void scaleAndAddTo(Dest& dst, const Scalar& a_alpha) const { m_prod.derived().scaleAndAddTo(dst,a_alpha * m_alpha); }$/;"	f	class:ScaledProduct	access:public	signature:(Dest& dst, const Scalar& a_alpha) const
ScaledProduct::subTo	src/Core/ProductBase.h	/^    inline void subTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(-1)); }$/;"	f	class:ScaledProduct	access:public	signature:(Dest& dst) const
Scaling	src/Eigen2Support/Geometry/All.h	104;"	d
Scaling	src/Eigen2Support/Geometry/All.h	49;"	d
Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  Scaling() {}$/;"	f	class:Eigen::Scaling	access:public	signature:()
Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const Scalar& s) { m_coeffs.setConstant(s); }$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& s)
Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const VectorType& coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Scaling	access:public	signature:(const VectorType& coeffs)
Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& sx, const Scalar& sy)
Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Scaling	src/Eigen2Support/Geometry/Scaling.h	/^  inline explicit Scaling(const Scaling<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling<OtherScalarType,Dim>& other)
Scaling	src/Eigen2Support/Geometry/Scaling.h	/^class Scaling$/;"	c	namespace:Eigen
Scaling	src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,2> Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	namespace:Eigen	signature:(const Scalar& sx, const Scalar& sy)
Scaling	src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,3> Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	namespace:Eigen	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Scaling	src/Geometry/Scaling.h	/^static inline UniformScaling<double> Scaling(double s) { return UniformScaling<double>(s); }$/;"	f	namespace:Eigen	signature:(double s)
Scaling	src/Geometry/Scaling.h	/^static inline UniformScaling<float> Scaling(float s) { return UniformScaling<float>(s); }$/;"	f	namespace:Eigen	signature:(float s)
Scaling	src/Geometry/Scaling.h	/^static inline UniformScaling<std::complex<RealScalar> > Scaling(const std::complex<RealScalar>& s)$/;"	f	namespace:Eigen	signature:(const std::complex<RealScalar>& s)
Scaling	src/Geometry/Scaling.h	/^static inline const DiagonalWrapper<const Derived> Scaling(const MatrixBase<Derived>& coeffs)$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& coeffs)
Scaling2d	src/Eigen2Support/Geometry/All.h	106;"	d
Scaling2d	src/Eigen2Support/Geometry/All.h	51;"	d
Scaling2d	src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,2> Scaling2d;$/;"	t	namespace:Eigen
Scaling2f	src/Eigen2Support/Geometry/All.h	105;"	d
Scaling2f	src/Eigen2Support/Geometry/All.h	50;"	d
Scaling2f	src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 2> Scaling2f;$/;"	t	namespace:Eigen
Scaling3d	src/Eigen2Support/Geometry/All.h	108;"	d
Scaling3d	src/Eigen2Support/Geometry/All.h	53;"	d
Scaling3d	src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,3> Scaling3d;$/;"	t	namespace:Eigen
Scaling3f	src/Eigen2Support/Geometry/All.h	107;"	d
Scaling3f	src/Eigen2Support/Geometry/All.h	52;"	d
Scaling3f	src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 3> Scaling3f;$/;"	t	namespace:Eigen
ScalingType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Transform	access:public
ScalingType	src/Eigen2Support/Geometry/Translation.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Translation	access:public
SegmentReturnType	src/plugins/BlockMethods.h	/^typedef VectorBlock<Derived> SegmentReturnType;$/;"	t
Select	src/Core/Select.h	/^    Select(const ConditionMatrixType& a_conditionMatrix,$/;"	f	class:Eigen::Select	access:public	signature:(const ConditionMatrixType& a_conditionMatrix, const ThenMatrixType& a_thenMatrix, const ElseMatrixType& a_elseMatrix)
Select	src/Core/Select.h	/^class Select : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
SelfAdjoint	src/Core/util/Constants.h	/^  SelfAdjoint=0x10,$/;"	e	enum:Eigen::__anon61
SelfAdjointBit	src/Eigen2Support/TriangularSolver.h	/^const unsigned int SelfAdjointBit = SelfAdjoint;$/;"	m	namespace:Eigen
SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver()$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:()
SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(Index size)
SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)
SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors)
SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, int options = ComputeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
SelfAdjointEigenSolver	src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename _MatrixType> class SelfAdjointEigenSolver$/;"	c	namespace:Eigen
SelfAdjointView	src/Core/SelfAdjointView.h	/^    inline SelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(MatrixType& matrix)
SelfAdjointView	src/Core/SelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SelfAdjointView$/;"	c	namespace:Eigen	inherits:TriangularBase
SelfAdjointViewReturnType	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
SelfCwiseBinaryOp	src/Core/SelfCwiseBinaryOp.h	/^    inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Lhs& xpr, const BinaryOp& func = BinaryOp())
SelfCwiseBinaryOp	src/Core/SelfCwiseBinaryOp.h	/^template<typename BinaryOp, typename Lhs, typename Rhs> class SelfCwiseBinaryOp$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixMatrix.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixMatrix.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false>$/;"	s	namespace:Eigen	inherits:ProductBase
SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixVector.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false>$/;"	s	namespace:Eigen	inherits:ProductBase
SelfadjointProductMatrix	src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true>$/;"	s	namespace:Eigen	inherits:ProductBase
Sequential	src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	e	enum:Eigen::Sequential_t
SequentialLinSpacedReturnType	src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,false>,Derived> SequentialLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Sequential_t	src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	g	namespace:Eigen
SetAction	src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
SetDiag	src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon52
SetDiag	src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon53
Side	src/Core/GeneralProduct.h	/^    enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };$/;"	e	enum:Eigen::GeneralProduct::__anon268
SignMatrix	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	g	namespace:Eigen::internal
SimplicialCholesky	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky() : Base(), m_LDLT(true) {}$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:()
SimplicialCholesky	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& matrix)
SimplicialCholesky	src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialCholesky : public SimplicialCholeskyBase<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
SimplicialCholeskyBase	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
SimplicialCholeskyBase	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixType& matrix)
SimplicialCholeskyBase	src/SparseCholesky/SimplicialCholesky.h	/^class SimplicialCholeskyBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
SimplicialCholeskyLDLT	src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLDLT$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyLLT	src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLLT,$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyMode	src/SparseCholesky/SimplicialCholesky.h	/^enum SimplicialCholeskyMode {$/;"	g	namespace:Eigen
SimplicialLDLT	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT() : Base() {}$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:()
SimplicialLDLT	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& matrix)
SimplicialLDLT	src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLDLT : public SimplicialCholeskyBase<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
SimplicialLLT	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT() : Base() {}$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:()
SimplicialLLT	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& matrix)
SimplicialLLT	src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLLT : public SimplicialCholeskyBase<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
SingletonVector	src/SparseCore/SparseMatrix.h	/^        SingletonVector(Index i, Index v)$/;"	f	class:Eigen::SparseMatrix::SingletonVector	access:public	signature:(Index i, Index v)
SingletonVector	src/SparseCore/SparseMatrix.h	/^    class SingletonVector$/;"	c	class:Eigen::SparseMatrix	access:protected
SingularValuesType	src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MinSize, 1> SingularValuesType;$/;"	t	class:Eigen::SVD	access:private
SingularValuesType	src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_diag_type<MatrixType, RealScalar>::type SingularValuesType;$/;"	t	class:Eigen::JacobiSVD	access:public
Size	src/Core/Redux.h	/^    Size = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_impl::__anon305
Size	src/Eigenvalues/HessenbergDecomposition.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
Size	src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon367
Size	src/Eigenvalues/Tridiagonalization.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon368
SizeA	src/Core/products/GeneralMatrixMatrix.h	/^      SizeA = ActualRows * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon42
SizeAtCompileTime	src/Core/BandMatrix.h	/^      SizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime)$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon142
SizeAtCompileTime	src/Core/DenseBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon155
SizeAtCompileTime	src/Core/MapBase.h	/^      SizeAtCompileTime = Base::SizeAtCompileTime$/;"	e	enum:Eigen::MapBase::__anon276
SizeAtCompileTime	src/SparseCore/SparseMatrixBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
SizeB	src/Core/products/GeneralMatrixMatrix.h	/^      SizeB = ActualCols * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon42
SizeMinusOne	src/Core/MatrixBase.h	/^      SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1$/;"	e	enum:Eigen::MatrixBase::__anon285
SizeMinusOne	src/Eigenvalues/HessenbergDecomposition.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : Size - 1,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon364
SizeMinusOne	src/Eigenvalues/Tridiagonalization.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : (Size > 1 ? Size - 1 : 1),$/;"	e	enum:Eigen::Tridiagonalization::__anon368
SizeW	src/Core/products/GeneralMatrixMatrix.h	/^      SizeW = MaxDepth * Traits::WorkSpaceFactor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon42
SkipDiag	src/SparseCore/SparseTriangularView.h	/^           SkipDiag = (Mode&ZeroDiag) ? 1 : 0,$/;"	e	enum:Eigen::SparseTriangularView::__anon453
SkipFirst	src/SparseCore/SparseTriangularView.h	/^    enum { SkipFirst = ((Mode&Lower) && !(MatrixType::Flags&RowMajorBit))$/;"	e	enum:Eigen::SparseTriangularView::__anon453
SkipLast	src/SparseCore/SparseTriangularView.h	/^           SkipLast = !SkipFirst,$/;"	e	enum:Eigen::SparseTriangularView::__anon453
SliceVectorizedTraversal	src/Core/util/Constants.h	/^  SliceVectorizedTraversal,$/;"	e	enum:Eigen::__anon63
SluMatrix	src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix()$/;"	f	struct:Eigen::SluMatrix	access:public	signature:()
SluMatrix	src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(const SluMatrix& other)
SluMatrix	src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrix : SuperMatrix$/;"	s	namespace:Eigen	inherits:SuperMatrix
SluMatrixMapHelper	src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<Matrix<Scalar,Rows,Cols,Options,MRows,MCols> >$/;"	s	namespace:Eigen
SluMatrixMapHelper	src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<SparseMatrixBase<Derived> >$/;"	s	namespace:Eigen
Small	src/Core/GeneralProduct.h	/^  Small = 3$/;"	e	enum:Eigen::__anon241
SmallPanelWidth	src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon52
SmallPanelWidth	src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon53
SparseBase	src/SparseCore/SparseVector.h	/^    typedef SparseMatrixBase<SparseVector> SparseBase;$/;"	t	class:Eigen::SparseVector	access:private
SparseDenseOuterProduct	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SparseDenseOuterProduct	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Rhs& rhs, const Lhs& lhs)$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:(const Rhs& rhs, const Lhs& lhs)
SparseDenseOuterProduct	src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
SparseDenseProductReturnType	src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct SparseDenseProductReturnType$/;"	s	namespace:Eigen
SparseDenseProductReturnType	src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct SparseDenseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
SparseDiagonalProduct	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE SparseDiagonalProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SparseDiagonalProduct	src/SparseCore/SparseDiagonalProduct.h	/^class SparseDiagonalProduct$/;"	c	namespace:Eigen	inherits:SparseMatrixBase,internal::no_assignment_operator
SparseFlags	src/SparseCore/SparseDiagonalProduct.h	/^    SparseFlags = is_diagonal<_Lhs>::ret ? int(_Rhs::Flags) : int(_Lhs::Flags),$/;"	e	enum:Eigen::internal::traits::__anon442
SparseLU	src/SparseLU/SparseLU.h	/^    SparseLU (const SparseLU& );$/;"	p	class:Eigen::SparseLU	access:private	signature:(const SparseLU& )
SparseLU	src/SparseLU/SparseLU.h	/^    SparseLU():m_isInitialized(true),m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)$/;"	f	class:Eigen::SparseLU	access:public	signature:()
SparseLU	src/SparseLU/SparseLU.h	/^    SparseLU(const MatrixType& matrix):m_isInitialized(true),m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)$/;"	f	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
SparseLU	src/SparseLU/SparseLU.h	/^class SparseLU : public internal::SparseLUImpl<typename _MatrixType::Scalar, typename _MatrixType::Index>$/;"	c	namespace:Eigen	inherits:internal::SparseLUImpl
SparseLUImpl	src/SparseLU/SparseLUImpl.h	/^class SparseLUImpl$/;"	c	namespace:Eigen::internal
SparseLUMatrixLReturnType	src/SparseLU/SparseLU.h	/^  SparseLUMatrixLReturnType(const MappedSupernodalType& mapL) : m_mapL(mapL)$/;"	f	struct:Eigen::SparseLUMatrixLReturnType	access:public	signature:(const MappedSupernodalType& mapL)
SparseLUMatrixLReturnType	src/SparseLU/SparseLU.h	/^struct SparseLUMatrixLReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen	inherits:internal::no_assignment_operator
SparseLUMatrixUReturnType	src/SparseLU/SparseLU.h	/^  SparseLUMatrixUReturnType(const MatrixLType& mapL, const MatrixUType& mapU)$/;"	f	struct:Eigen::SparseLUMatrixUReturnType	access:public	signature:(const MatrixLType& mapL, const MatrixUType& mapU)
SparseLUMatrixUReturnType	src/SparseLU/SparseLU.h	/^struct SparseLUMatrixUReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen	inherits:internal::no_assignment_operator
SparseMatrix	src/SparseCore/SparseMatrix.h	/^    SparseMatrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrix& other)
SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseSelfAdjointView<OtherDerived, UpLo>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseSelfAdjointView<OtherDerived, UpLo>& other)
SparseMatrix	src/SparseCore/SparseMatrix.h	/^class SparseMatrix$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
SparseMatrixBase	src/SparseCore/SparseMatrixBase.h	/^    SparseMatrixBase() : m_isRValue(false) { \/* TODO check flags *\/ }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
SparseMatrixBase	src/SparseCore/SparseMatrixBase.h	/^template<typename Derived> class SparseMatrixBase$/;"	c	namespace:Eigen	inherits:internal::special_scalar_op_base
SparseMatrixType	src/PardisoSupport/PardisoSupport.h	/^    typedef SparseMatrix<Scalar,RowMajor,Index> SparseMatrixType;$/;"	t	class:Eigen::PardisoImpl	access:public
SparseMatrixType	src/SparseCore/SparseBlock.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> SparseMatrixType;$/;"	t	class:Eigen::BlockImpl	access:private
SparseQR	src/SparseQR/SparseQR.h	/^    SparseQR () : m_isInitialized(false), m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR	access:public	signature:()
SparseQR	src/SparseQR/SparseQR.h	/^    SparseQR(const MatrixType& mat) : m_isInitialized(false), m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR	access:public	signature:(const MatrixType& mat)
SparseQR	src/SparseQR/SparseQR.h	/^class SparseQR$/;"	c	namespace:Eigen
SparseQRMatrixQReturnType	src/SparseQR/SparseQR.h	/^  SparseQRMatrixQReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:(const SparseQRType& qr)
SparseQRMatrixQReturnType	src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQReturnType : public EigenBase<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen	inherits:EigenBase
SparseQRMatrixQTransposeReturnType	src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType	access:public	signature:(const SparseQRType& qr)
SparseQRMatrixQTransposeReturnType	src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQTransposeReturnType$/;"	s	namespace:Eigen
SparseQR_QProduct	src/SparseQR/SparseQR.h	/^  SparseQR_QProduct(const SparseQRType& qr, const Derived& other, bool transpose) : $/;"	f	struct:Eigen::SparseQR_QProduct	access:public	signature:(const SparseQRType& qr, const Derived& other, bool transpose)
SparseQR_QProduct	src/SparseQR/SparseQR.h	/^struct SparseQR_QProduct : ReturnByValue<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen	inherits:ReturnByValue
SparseSelfAdjointTimeDenseProduct	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SparseSelfAdjointTimeDenseProduct	src/SparseCore/SparseSelfAdjointView.h	/^class SparseSelfAdjointTimeDenseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
SparseSelfAdjointView	src/SparseCore/SparseSelfAdjointView.h	/^    inline SparseSelfAdjointView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const MatrixType& matrix)
SparseSelfAdjointView	src/SparseCore/SparseSelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SparseSelfAdjointView$/;"	c	namespace:Eigen	inherits:EigenBase
SparseSparseProduct	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SparseSparseProduct	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs, const RealScalar& tolerance)$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs, const RealScalar& tolerance)
SparseSparseProduct	src/SparseCore/SparseProduct.h	/^class SparseSparseProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,SparseMatrixBase
SparseSparseProductReturnType	src/SparseCore/SparseProduct.h	/^struct SparseSparseProductReturnType$/;"	s	namespace:Eigen
SparseSymmetricPermutationProduct	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct(const MatrixType& mat, const Perm& perm)$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(const MatrixType& mat, const Perm& perm)
SparseSymmetricPermutationProduct	src/SparseCore/SparseSelfAdjointView.h	/^class SparseSymmetricPermutationProduct$/;"	c	namespace:Eigen	inherits:EigenBase
SparseTimeDenseProduct	src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseTimeDenseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SparseTimeDenseProduct	src/SparseCore/SparseDenseProduct.h	/^class SparseTimeDenseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
SparseTriangularView	src/SparseCore/SparseTriangularView.h	/^    inline SparseTriangularView(const MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:(const MatrixType& matrix)
SparseTriangularView	src/SparseCore/SparseTriangularView.h	/^template<typename MatrixType, int Mode> class SparseTriangularView$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector() : m_size(0) { check_template_parameters(); resize(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector(Index rows, Index cols) : m_size(0) { check_template_parameters(); resize(rows,cols); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index rows, Index cols)
SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector(Index size) : m_size(0) { check_template_parameters(); resize(size); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index size)
SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
SparseVector	src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseVector& other)
SparseVector	src/SparseCore/SparseVector.h	/^class SparseVector$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
SparseView	src/SparseCore/SparseView.h	/^  SparseView(const MatrixType& mat, const Scalar& m_reference = Scalar(0),$/;"	f	class:Eigen::SparseView	access:public	signature:(const MatrixType& mat, const Scalar& m_reference = Scalar(0), typename NumTraits<Scalar>::Real m_epsilon = NumTraits<Scalar>::dummy_precision())
SparseView	src/SparseCore/SparseView.h	/^class SparseView : public SparseMatrixBase<SparseView<MatrixType> >$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Specialized	src/Core/util/Constants.h	/^  Specialized,$/;"	e	enum:Eigen::__anon65
SquareMatrixType	src/Core/MatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::MatrixBase	access:public
SquareMatrixType	src/SparseCore/SparseMatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
SrcHasDirectAccess	src/Core/Assign_MKL.h	/^      SrcHasDirectAccess = Src::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
SrcIsAligned	src/Core/Assign.h	/^    SrcIsAligned = OtherDerived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon130
SrcStorageOrder	src/SparseCore/SparsePermutation.h	/^      SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon450
SrcStorageOrder	src/SparseCore/SparsePermutation.h	/^    SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon449
StemFunction	src/Core/MatrixBase.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixBase	access:public
Storage	src/SparseCore/SparseMatrix.h	/^    typedef internal::CompressedStorage<Scalar,Index> Storage;$/;"	t	class:Eigen::SparseMatrix	access:public
Storage	src/SparseCore/SparseVector.h	/^    typedef internal::CompressedStorage<Scalar,Index> Storage;$/;"	t	class:Eigen::SparseVector	access:public
StorageBaseType	src/Core/ArrayBase.h	/^    typedef ArrayBase StorageBaseType;$/;"	t	class:Eigen::ArrayBase	access:public
StorageBaseType	src/Core/MatrixBase.h	/^    typedef MatrixBase StorageBaseType;$/;"	t	class:Eigen::MatrixBase	access:public
StorageBaseType	src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrixBase StorageBaseType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
StorageKind	src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::ArrayBase	access:public
StorageKind	src/Core/BandMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/Block.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/CwiseBinaryOp.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseBase	access:public
StorageKind	src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
StorageKind	src/Core/Diagonal.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalBase	access:public
StorageKind	src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalMatrix	access:public
StorageKind	src/Core/DiagonalMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	struct:Eigen::EigenBase	access:public
StorageKind	src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MapBase	access:public
StorageKind	src/Core/Matrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MatrixBase	access:public
StorageKind	src/Core/PermutationMatrix.h	/^  typedef PermutationStorage StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::PlainObjectBase	access:public
StorageKind	src/Core/ProductBase.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/ProductBase.h	/^  typedef typename traits<NestedProduct>::StorageKind StorageKind;$/;"	t	struct:internal::traits	access:public
StorageKind	src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/Select.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularBase	access:public
StorageKind	src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularView	access:public
StorageKind	src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Core/products/CoeffBasedProduct.h	/^                                           typename traits<_RhsNested>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Eigen2Support/Minor.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Geometry/Homogeneous.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/LU/FullPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::FullPivLU	access:public
StorageKind	src/LU/PartialPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::PartialPivLU	access:public
StorageKind	src/SparseCore/SparseDenseProduct.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/SparseCore/SparseDenseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/SparseCore/SparseDiagonalProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/SparseCore/SparseMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/SparseCore/SparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SparseMatrixBase	access:public
StorageKind	src/SparseCore/SparseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/SparseCore/SparseSelfAdjointView.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/SparseCore/SparseVector.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/SparseCore/SparseView.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageOrderMatch	src/Core/Ref.h	/^      StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),$/;"	e	enum:Eigen::internal::traits::match::__anon307
StorageOrdersAgree	src/Core/Assign.h	/^    StorageOrdersAgree = (int(Derived::IsRowMajor) == int(OtherDerived::IsRowMajor)),$/;"	e	enum:Eigen::internal::assign_traits::__anon132
StorageOrdersAgree	src/Core/Assign_MKL.h	/^      StorageOrdersAgree = (int(Dst::IsRowMajor) == int(Src::IsRowMajor)),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
StorageOrdersAgree	src/Core/CwiseBinaryOp.h	/^    StorageOrdersAgree = (int(Lhs::Flags)&RowMajorBit)==(int(Rhs::Flags)&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon151
StorageOrdersMatch	src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon396
StorageOrdersMatch	src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon397
StreamPrecision	src/Core/IO.h	/^enum { StreamPrecision = -1,$/;"	e	enum:Eigen::__anon273
StrictlyLower	src/Core/util/Constants.h	/^  StrictlyLower=ZeroDiag|Lower, $/;"	e	enum:Eigen::__anon61
StrictlyUpper	src/Core/util/Constants.h	/^  StrictlyUpper=ZeroDiag|Upper,$/;"	e	enum:Eigen::__anon61
Stride	src/Core/Stride.h	/^    Stride()$/;"	f	class:Eigen::Stride	access:public	signature:()
Stride	src/Core/Stride.h	/^    Stride(Index outerStride, Index innerStride)$/;"	f	class:Eigen::Stride	access:public	signature:(Index outerStride, Index innerStride)
Stride	src/Core/Stride.h	/^    Stride(const Stride& other)$/;"	f	class:Eigen::Stride	access:public	signature:(const Stride& other)
Stride	src/Core/Stride.h	/^class Stride$/;"	c	namespace:Eigen
StrideBase	src/Core/Ref.h	/^  typedef Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime> StrideBase;$/;"	t	class:Eigen::RefBase	access:protected
StrideType	src/Core/Ref.h	/^  typedef _StrideType StrideType;$/;"	t	struct:Eigen::internal::traits	access:public
StrideType	src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::StrideType StrideType;$/;"	t	class:Eigen::RefBase	access:private
StridedAlignedMapType	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
StridedConstAlignedMapType	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
StridedConstMapType	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
StridedMapType	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
SubDiagonalReturnType	src/Eigenvalues/Tridiagonalization.h	/^            >::type SubDiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
SubDiagonalType	src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<RealScalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> SubDiagonalType;$/;"	t	class:Eigen::Tridiagonalization	access:public
SubVector	src/Core/VectorwiseOp.h	/^                               typename ExpressionType::RowXpr>::type SubVector;$/;"	t	class:Eigen::VectorwiseOp	access:protected
Subs	src/Core/BandMatrix.h	/^      Subs   = internal::traits<Derived>::Subs,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Subs	src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon144
Subs	src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon145
Success	src/Core/util/Constants.h	/^  Success = 0,        $/;"	e	enum:Eigen::ComputationInfo
SuperDiagVectorType	src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTimeMinusOne, 1> SuperDiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU() : Base() { init(); }$/;"	f	class:Eigen::SuperILU	access:public	signature:()
SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(SuperILU& ) { }$/;"	f	class:Eigen::SuperILU	access:private	signature:(SuperILU& )
SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^class SuperILU : public SuperLUBase<_MatrixType,SuperILU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:SuperLUBase
SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU() : Base() { init(); }$/;"	f	class:Eigen::SuperLU	access:public	signature:()
SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(SuperLU& ) { }$/;"	f	class:Eigen::SuperLU	access:private	signature:(SuperLU& )
SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^class SuperLU : public SuperLUBase<_MatrixType,SuperLU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:SuperLUBase
SuperLUBase	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase() {}$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
SuperLUBase	src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase(SuperLUBase& ) { }$/;"	f	class:Eigen::SuperLUBase	access:private	signature:(SuperLUBase& )
SuperLUBase	src/SuperLUSupport/SuperLUSupport.h	/^class SuperLUBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Supers	src/Core/BandMatrix.h	/^      Supers = internal::traits<Derived>::Supers,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon141
Supers	src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon144
Supers	src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon145
SupportedAccessPatterns	src/SparseCore/SparseMatrix.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon445
SupportedAccessPatterns	src/SparseCore/SparseVector.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon456
SwapWrapper	src/Core/Swap.h	/^    inline SwapWrapper(ExpressionType& xpr) : m_expression(xpr) {}$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(ExpressionType& xpr)
SwapWrapper	src/Core/Swap.h	/^template<typename ExpressionType> class SwapWrapper$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Symmetric	src/Core/util/Constants.h	/^  Symmetric=0x20$/;"	e	enum:Eigen::__anon61
THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD	src/Core/util/StaticAssert.h	/^        THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE	src/Core/util/StaticAssert.h	/^        THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE	src/Core/util/StaticAssert.h	/^        THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH	src/Core/util/StaticAssert.h	/^        THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY	src/Core/util/StaticAssert.h	/^        THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES	src/Core/util/StaticAssert.h	/^        THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE	src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Target	src/Core/util/Constants.h	/^    Target = SSE$/;"	e	enum:Eigen::Architecture::Type
ThenMatrixNested	src/Core/Select.h	/^  typedef typename ThenMatrixType::Nested ThenMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
ThisConstantIsPrivateInPlainObjectBase	src/Core/DenseBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::DenseBase::__anon156
ThisConstantIsPrivateInPlainObjectBase	src/Core/PlainObjectBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::PlainObjectBase::__anon292
Through	src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1)
Through	src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1, const VectorType& p2)
Through	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p0, const VectorType& p1)
Through	src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1)
Through	src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1, const VectorType& p2)
Through	src/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p0, const VectorType& p1)
TmpFlags	src/Geometry/Homogeneous.h	/^    TmpFlags = _MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon371
TmpMatrixType	src/Cholesky/LDLT.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1, Options, MaxRowsAtCompileTime, 1> TmpMatrixType;$/;"	t	class:Eigen::LDLT	access:public
TopLeft	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopLeft	src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftCeil	src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftFloor	src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRight	src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopRight	src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightCeil	src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightFloor	src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
Traits	src/Cholesky/LDLT.h	/^    typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LDLT	access:public
Traits	src/Cholesky/LLT.h	/^    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LLT	access:public
Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::PermutationBase	access:private
Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map	access:private
Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationMatrix> Traits;$/;"	t	class:Eigen::PermutationMatrix	access:private
Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationType> Traits;$/;"	t	class:Eigen::Transpose	access:public
Traits	src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationWrapper> Traits;$/;"	t	class:Eigen::PermutationWrapper	access:private
Traits	src/Core/Ref.h	/^    typedef internal::traits<Ref> Traits;$/;"	t	class:Eigen::Ref	access:private
Traits	src/Core/Transpositions.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::TranspositionsBase	access:private
Traits	src/Core/Transpositions.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map	access:private
Traits	src/Core/Transpositions.h	/^    typedef internal::traits<Transpositions> Traits;$/;"	t	class:Eigen::Transpositions	access:private
Traits	src/Core/Transpositions.h	/^    typedef internal::traits<TranspositionsWrapper> Traits;$/;"	t	class:Eigen::TranspositionsWrapper	access:private
Traits	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Traits	src/Core/products/GeneralMatrixMatrix.h	/^    typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
Traits	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;$/;"	t	struct:Eigen::internal::tribb_kernel	access:public
Traits	src/Core/products/TriangularMatrixMatrix.h	/^  typedef gebp_traits<Scalar,Scalar> Traits;$/;"	t	struct:Eigen::internal::product_triangular_matrix_matrix	access:public
Traits	src/PardisoSupport/PardisoSupport.h	/^    typedef internal::pardiso_traits<Derived> Traits;$/;"	t	class:Eigen::PardisoImpl	access:private
Traits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialCholesky> Traits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Traits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT> Traits;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Traits	src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT> Traits;$/;"	t	class:Eigen::SimplicialLLT	access:public
Traits	src/SparseCore/SparseDenseProduct.h	/^    typedef internal::traits<SparseDenseOuterProduct> Traits;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:public
TraitsBase	src/Core/Map.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits	access:public
TraitsBase	src/Geometry/Quaternion.h	/^    typedef traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> > TraitsBase;$/;"	t	struct:Eigen::internal::traits	access:public
Transform	src/Eigen2Support/Geometry/All.h	37;"	d
Transform	src/Eigen2Support/Geometry/All.h	92;"	d
Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform() { }$/;"	f	class:Eigen::Transform	access:public	signature:()
Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived>& other)
Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r) { *this = r; }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived, Dim>& r)
Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const ScalingType& s) { *this = s; }$/;"	f	class:Eigen::Transform	access:public	signature:(const ScalingType& s)
Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<OtherScalarType,Dim>& other)
Transform	src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t) { *this = t; }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Transform	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Transform	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Transform	src/Eigen2Support/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Transform	src/Geometry/Transform.h	/^  Transform(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Transform	src/Geometry/Transform.h	/^  inline Transform()$/;"	f	class:Eigen::Transform	access:public	signature:()
Transform	src/Geometry/Transform.h	/^  inline Transform(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Transform	src/Geometry/Transform.h	/^  inline Transform(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Transform	src/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Transform	src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,Mode,OtherOptions>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,Mode,OtherOptions>& other)
Transform	src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)
Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r)$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived, Dim>& r)
Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim,Mode,Options>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<OtherScalarType,Dim,Mode,Options>& other)
Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t)$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Transform	src/Geometry/Transform.h	/^  inline explicit Transform(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s)
Transform	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Transform	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Transform	src/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Transform2d	src/Eigen2Support/Geometry/All.h	39;"	d
Transform2d	src/Eigen2Support/Geometry/All.h	94;"	d
Transform2d	src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,2> Transform2d;$/;"	t	namespace:Eigen
Transform2f	src/Eigen2Support/Geometry/All.h	38;"	d
Transform2f	src/Eigen2Support/Geometry/All.h	93;"	d
Transform2f	src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,2> Transform2f;$/;"	t	namespace:Eigen
Transform3d	src/Eigen2Support/Geometry/All.h	41;"	d
Transform3d	src/Eigen2Support/Geometry/All.h	96;"	d
Transform3d	src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,3> Transform3d;$/;"	t	namespace:Eigen
Transform3f	src/Eigen2Support/Geometry/All.h	40;"	d
Transform3f	src/Eigen2Support/Geometry/All.h	95;"	d
Transform3f	src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,3> Transform3f;$/;"	t	namespace:Eigen
TransformTimeDiagonalMode	src/Geometry/Transform.h	/^  enum { TransformTimeDiagonalMode = ((Mode==int(Isometry))?Affine:int(Mode)) };$/;"	e	enum:Eigen::Transform::__anon385
TransformTimeDiagonalReturnType	src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,TransformTimeDiagonalMode> TransformTimeDiagonalReturnType;$/;"	t	class:Eigen::Transform	access:public
TransformTraits	src/Core/util/Constants.h	/^enum TransformTraits {$/;"	g	namespace:Eigen
TransformType	src/Eigen2Support/Geometry/Scaling.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Scaling	access:public
TransformType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
TransformType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
TransformType	src/Eigen2Support/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Translation	access:public
TransformType	src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Mode, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
TransformType	src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Projective, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
TransformType	src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,AffineCompact,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
TransformType	src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Translation	src/Eigen2Support/Geometry/All.h	43;"	d
Translation	src/Eigen2Support/Geometry/All.h	98;"	d
Translation	src/Eigen2Support/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation	access:public	signature:()
Translation	src/Eigen2Support/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& vector)
Translation	src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy)
Translation	src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Translation	src/Eigen2Support/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation<OtherScalarType,Dim>& other)
Translation	src/Eigen2Support/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Translation	src/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation	access:public	signature:()
Translation	src/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& vector)
Translation	src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy)
Translation	src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Translation	src/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation<OtherScalarType,Dim>& other)
Translation	src/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Translation2d	src/Eigen2Support/Geometry/All.h	100;"	d
Translation2d	src/Eigen2Support/Geometry/All.h	45;"	d
Translation2d	src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2d	src/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2f	src/Eigen2Support/Geometry/All.h	44;"	d
Translation2f	src/Eigen2Support/Geometry/All.h	99;"	d
Translation2f	src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation2f	src/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation3d	src/Eigen2Support/Geometry/All.h	102;"	d
Translation3d	src/Eigen2Support/Geometry/All.h	47;"	d
Translation3d	src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3d	src/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3f	src/Eigen2Support/Geometry/All.h	101;"	d
Translation3f	src/Eigen2Support/Geometry/All.h	46;"	d
Translation3f	src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
Translation3f	src/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
TranslationPart	src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1> TranslationPart;$/;"	t	class:Eigen::Transform	access:public
TranslationPart	src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1,int(Mode)==(AffineCompact)> TranslationPart;$/;"	t	class:Eigen::Transform	access:public
TranslationType	src/Eigen2Support/Geometry/Scaling.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Scaling	access:public
TranslationType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform	access:public
TranslationType	src/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform	access:public
Transpose	src/Core/PermutationMatrix.h	/^    Transpose(const PermutationType& p) : m_permutation(p) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(const PermutationType& p)
Transpose	src/Core/PermutationMatrix.h	/^class Transpose<PermutationBase<Derived> >$/;"	c	namespace:Eigen	inherits:EigenBase
Transpose	src/Core/Transpose.h	/^    inline Transpose(MatrixType& a_matrix) : m_matrix(a_matrix) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(MatrixType& a_matrix)
Transpose	src/Core/Transpose.h	/^template<typename MatrixType> class Transpose$/;"	c	namespace:Eigen	inherits:TransposeImpl
Transpose	src/Core/Transpositions.h	/^    Transpose(const TranspositionType& t) : m_transpositions(t) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(const TranspositionType& t)
Transpose	src/Core/Transpositions.h	/^class Transpose<TranspositionsBase<TranspositionsDerived> >$/;"	c	namespace:Eigen
Transpose	src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon43
Transpose	src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon41
TransposeImpl	src/Core/Transpose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Dense>$/;"	c	namespace:Eigen	inherits:internal::TransposeImpl_base::type
TransposeImpl	src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
TransposeImpl_base	src/Core/Transpose.h	/^struct TransposeImpl_base$/;"	s	namespace:Eigen::internal
TransposeImpl_base	src/Core/Transpose.h	/^struct TransposeImpl_base<MatrixType, false>$/;"	s	namespace:Eigen::internal
TransposeLhs	src/SparseCore/SparseProduct.h	/^    TransposeLhs = LhsRowMajor && (!RhsRowMajor)$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon451
TransposeMode	src/Core/TriangularMatrix.h	/^      TransposeMode = (Mode & Upper ? Lower : 0)$/;"	e	enum:Eigen::TriangularView::__anon328
TransposeRhs	src/SparseCore/SparseProduct.h	/^    TransposeRhs = (!LhsRowMajor) && RhsRowMajor,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon451
TransposeTypeWithSameStorageOrder	src/SVD/JacobiSVD.h	/^          TransposeTypeWithSameStorageOrder;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
TransposedSparseMatrix	src/SparseCore/SparseMatrix.h	/^    typedef SparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;$/;"	t	class:Eigen::SparseMatrix	access:protected
TranspositionType	src/Cholesky/LDLT.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::LDLT	access:public
TranspositionType	src/Core/Transpositions.h	/^    typedef TranspositionsDerived TranspositionType;$/;"	t	class:Eigen::Transpose	access:private
TranspositionType	src/LU/PartialPivLU.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::PartialPivLU	access:public
Transpositions	src/Core/Transpositions.h	/^    explicit inline Transpositions(const MatrixBase<Other>& a_indices) : m_indices(a_indices)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const MatrixBase<Other>& a_indices)
Transpositions	src/Core/Transpositions.h	/^    inline Transpositions() {}$/;"	f	class:Eigen::Transpositions	access:public	signature:()
Transpositions	src/Core/Transpositions.h	/^    inline Transpositions(Index size) : m_indices(size)$/;"	f	class:Eigen::Transpositions	access:public	signature:(Index size)
Transpositions	src/Core/Transpositions.h	/^    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::Transpositions	access:public	signature:(const Transpositions& other)
Transpositions	src/Core/Transpositions.h	/^    inline Transpositions(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Transpositions	src/Core/Transpositions.h	/^class Transpositions : public TranspositionsBase<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	c	namespace:Eigen	inherits:TranspositionsBase
TranspositionsBase	src/Core/Transpositions.h	/^class TranspositionsBase$/;"	c	namespace:Eigen
TranspositionsWrapper	src/Core/Transpositions.h	/^    inline TranspositionsWrapper(IndicesType& a_indices)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(IndicesType& a_indices)
TranspositionsWrapper	src/Core/Transpositions.h	/^class TranspositionsWrapper$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Traversal	src/Core/Assign.h	/^    Traversal = int(MayInnerVectorize)  ? int(InnerVectorizedTraversal)$/;"	e	enum:Eigen::internal::assign_traits::__anon133
Traversal	src/Core/Assign_MKL.h	/^      Traversal = MayLinearize ? LinearVectorizedTraversal$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon140
Traversal	src/Core/Redux.h	/^    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::redux_traits::__anon298
TraversalSize	src/Core/VectorwiseOp.h	/^    TraversalSize = Direction==Vertical ? MatrixType::RowsAtCompileTime :  MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon331
TriangularBase	src/Core/TriangularMatrix.h	/^    inline TriangularBase() { eigen_assert(!((Mode&UnitDiag) && (Mode&ZeroDiag))); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:()
TriangularBase	src/Core/TriangularMatrix.h	/^template<typename Derived> class TriangularBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
TriangularProduct	src/Core/products/TriangularMatrixMatrix.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
TriangularProduct	src/Core/products/TriangularMatrixMatrix.h	/^struct TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false>$/;"	s	namespace:Eigen	inherits:ProductBase
TriangularProduct	src/Core/products/TriangularMatrixVector.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
TriangularProduct	src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,false,Lhs,true,Rhs,false>$/;"	s	namespace:Eigen	inherits:ProductBase
TriangularProduct	src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,true,Lhs,false,Rhs,true>$/;"	s	namespace:Eigen	inherits:ProductBase
TriangularView	src/Core/TriangularMatrix.h	/^    inline TriangularView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixType& matrix)
TriangularView	src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularView$/;"	c	namespace:Eigen	inherits:TriangularBase
TriangularViewReturnType	src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
TridiagonalMatrix	src/Core/BandMatrix.h	/^    TridiagonalMatrix(Index size = Size) : Base(size,size,Options&SelfAdjoint?0:1,1) {}$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:(Index size = Size)
TridiagonalMatrix	src/Core/BandMatrix.h	/^class TridiagonalMatrix : public BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor>$/;"	c	namespace:Eigen::internal	inherits:BandMatrix
Tridiagonalization	src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(Index size = Size==Dynamic ? 2 : Size)
Tridiagonalization	src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(const MatrixType& matrix)
Tridiagonalization	src/Eigenvalues/Tridiagonalization.h	/^template<typename _MatrixType> class Tridiagonalization$/;"	c	namespace:Eigen
TridiagonalizationMatrixTReturnType	src/Eigenvalues/Tridiagonalization.h	/^    TridiagonalizationMatrixTReturnType(const MatrixType& mat) : m_matrix(mat) { }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:(const MatrixType& mat)
TridiagonalizationMatrixTReturnType	src/Eigenvalues/Tridiagonalization.h	/^template<typename MatrixType> struct TridiagonalizationMatrixTReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
TridiagonalizationType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Tridiagonalization<MatrixType> TridiagonalizationType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Triplet	src/SparseCore/SparseUtil.h	/^  Triplet() : m_row(0), m_col(0), m_value(0) {}$/;"	f	class:Eigen::Triplet	access:public	signature:()
Triplet	src/SparseCore/SparseUtil.h	/^  Triplet(const Index& i, const Index& j, const Scalar& v = Scalar(0))$/;"	f	class:Eigen::Triplet	access:public	signature:(const Index& i, const Index& j, const Scalar& v = Scalar(0))
Triplet	src/SparseCore/SparseUtil.h	/^class Triplet$/;"	c	namespace:Eigen
Type	src/Core/BandMatrix.h	/^                 BuildType>::type Type;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType	access:public
Type	src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, EvalBeforeAssigningBit | EvalBeforeNestingBit> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Type	src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, NestByRefBit> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Type	src/Core/GeneralProduct.h	/^  typedef GeneralProduct<Lhs\/*Nested*\/, Rhs\/*Nested*\/, ProductType> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Type	src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstDiagonalIndexReturnType	access:public
Type	src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::DiagonalIndexReturnType	access:public
Type	src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstTriangularViewReturnType	access:public
Type	src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::TriangularViewReturnType	access:public
Type	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstSelfAdjointViewReturnType	access:public
Type	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::SelfAdjointViewReturnType	access:public
Type	src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReduxReturnType	access:public
Type	src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReturnType	access:public
Type	src/Core/VectorwiseOp.h	/^                        Direction==Horizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::ExtendedType	access:public
Type	src/Core/VectorwiseOp.h	/^                        Direction==Vertical   ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::OppositeExtendedType	access:public
Type	src/Core/util/Constants.h	/^  enum Type {$/;"	g	namespace:Eigen::Architecture
Type	src/Householder/HouseholderSequence.h	/^                 0, MatrixType::MaxRowsAtCompileTime, MatrixType::MaxColsAtCompileTime> Type;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type	access:public
Type	src/SparseCore/SparseDenseProduct.h	/^    SparseDenseOuterProduct<Lhs,Rhs,false> >::type Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType	access:public
Type	src/SparseCore/SparseDenseProduct.h	/^    SparseDenseOuterProduct<Lhs,Rhs,false> >::type Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType	access:public
Type	src/SparseCore/SparseDenseProduct.h	/^  typedef DenseTimeSparseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType	access:public
Type	src/SparseCore/SparseDenseProduct.h	/^  typedef SparseTimeDenseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType	access:public
Type	src/SparseCore/SparseMatrixBase.h	/^                          > Type;$/;"	t	struct:Eigen::SparseMatrixBase::CwiseProductDenseReturnType	access:public
Type	src/SparseCore/SparseProduct.h	/^  typedef SparseSparseProduct<LhsNested, RhsNested> Type;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Type	src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:ConstNColsBlockXpr	access:public
Type	src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:ConstNRowsBlockXpr	access:public
Type	src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:NColsBlockXpr	access:public
Type	src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:NRowsBlockXpr	access:public
Type	src/plugins/BlockMethods.h	/^template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	t	struct:ConstFixedSegmentReturnType	access:public
Type	src/plugins/BlockMethods.h	/^template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	t	struct:FixedSegmentReturnType	access:public
UCOL	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
ULVL	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
UMatrixType	src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType,  Upper>           UMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC	src/Core/util/StaticAssert.h	/^        UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
USUB	src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon463
UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU() { init(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:()
UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(UmfPackLU& ) { }$/;"	f	class:Eigen::UmfPackLU	access:private	signature:(UmfPackLU& )
UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^class UmfPackLU : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
UmfpackMatrixType	src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar,ColMajor,int> UmfpackMatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
Unaligned	src/Core/util/Constants.h	/^  Unaligned=0, $/;"	e	enum:Eigen::__anon62
UniformScaling	src/Geometry/Scaling.h	/^  UniformScaling() {}$/;"	f	class:Eigen::UniformScaling	access:public	signature:()
UniformScaling	src/Geometry/Scaling.h	/^  explicit inline UniformScaling(const Scalar& s) : m_factor(s) {}$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const Scalar& s)
UniformScaling	src/Geometry/Scaling.h	/^  inline explicit UniformScaling(const UniformScaling<OtherScalarType>& other)$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling<OtherScalarType>& other)
UniformScaling	src/Geometry/Scaling.h	/^class UniformScaling$/;"	c	namespace:Eigen
Unit	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index i)$/;"	f	class:Eigen::MatrixBase	signature:(Index i)
Unit	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index newSize, Index i)$/;"	f	class:Eigen::MatrixBase	signature:(Index newSize, Index i)
Unit	src/Core/MatrixBase.h	/^    static const BasisReturnType Unit(Index i);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index i)
Unit	src/Core/MatrixBase.h	/^    static const BasisReturnType Unit(Index size, Index i);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size, Index i)
UnitDiag	src/Core/util/Constants.h	/^  UnitDiag=0x4, $/;"	e	enum:Eigen::__anon61
UnitDiagBit	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitDiagBit = UnitDiag;$/;"	m	namespace:Eigen
UnitLower	src/Core/util/Constants.h	/^  UnitLower=UnitDiag|Lower, $/;"	e	enum:Eigen::__anon61
UnitLowerTriangular	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitLowerTriangular = UnitLower;$/;"	m	namespace:Eigen
UnitUpper	src/Core/util/Constants.h	/^  UnitUpper=UnitDiag|Upper,$/;"	e	enum:Eigen::__anon61
UnitUpperTriangular	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitUpperTriangular = UnitUpper;$/;"	m	namespace:Eigen
UnitW	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()$/;"	f	class:Eigen::MatrixBase	signature:()
UnitW	src/Core/MatrixBase.h	/^    static const BasisReturnType UnitW();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
UnitX	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitX()$/;"	f	class:Eigen::MatrixBase	signature:()
UnitX	src/Core/MatrixBase.h	/^    static const BasisReturnType UnitX();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
UnitY	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitY()$/;"	f	class:Eigen::MatrixBase	signature:()
UnitY	src/Core/MatrixBase.h	/^    static const BasisReturnType UnitY();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
UnitZ	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitZ()$/;"	f	class:Eigen::MatrixBase	signature:()
UnitZ	src/Core/MatrixBase.h	/^    static const BasisReturnType UnitZ();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Unroll	src/Core/products/CoeffBasedProduct.h	/^      Unroll = CoeffReadCost != Dynamic && CoeffReadCost <= EIGEN_UNROLLING_LIMIT,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon31
Unrolling	src/Core/Assign.h	/^    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))$/;"	e	enum:Eigen::internal::assign_traits::__anon135
Unrolling	src/Core/Redux.h	/^    Unrolling = Cost != Dynamic && Cost <= UnrollingLimit$/;"	e	enum:Eigen::internal::redux_traits::__anon300
Unrolling	src/Core/SolveTriangular.h	/^      Unrolling   = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)$/;"	e	enum:Eigen::internal::trsolve_traits::__anon320
UnrollingLimit	src/Core/Assign.h	/^    UnrollingLimit      = EIGEN_UNROLLING_LIMIT * (Vectorized ? int(PacketSize) : 1),$/;"	e	enum:Eigen::internal::assign_traits::__anon134
UnrollingLimit	src/Core/Redux.h	/^    UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))$/;"	e	enum:Eigen::internal::redux_traits::__anon299
Unusable	src/Core/ReturnByValue.h	/^      Unusable(const Unusable&) {}$/;"	f	class:Eigen::ReturnByValue::Unusable	access:private	signature:(const Unusable&)
Unusable	src/Core/ReturnByValue.h	/^    class Unusable{$/;"	c	class:Eigen::ReturnByValue	access:public
Unusable	src/Core/ReturnByValue.h	66;"	d
UpLo	src/Cholesky/LDLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LDLT::__anon1
UpLo	src/Cholesky/LLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LLT::__anon3
UpLo	src/CholmodSupport/CholmodSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::CholmodBase::__anon4
UpLo	src/IterativeLinearSolvers/ConjugateGradient.h	/^    UpLo = _UpLo$/;"	e	enum:Eigen::ConjugateGradient::__anon395
UpLo	src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLDLT::__anon409
UpLo	src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLLT::__anon408
UpLo	src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = Options&(Upper|Lower) };$/;"	e	enum:Eigen::PardisoLDLT::__anon412
UpLo	src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PardisoLLT::__anon411
UpLo	src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialCholesky::__anon430
UpLo	src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLDLT::__anon429
UpLo	src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLLT::__anon428
UpLo	src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = internal::traits<Derived>::UpLo };$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon424
UpLo	src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon425
UpLo	src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon426
UpLo	src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon427
Upper	src/Core/util/Constants.h	/^  Upper=0x2,                      $/;"	e	enum:Eigen::__anon61
UpperBidiagonalization	src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization() : m_householder(), m_bidiagonal(), m_isInitialized(false) {}$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:()
UpperBidiagonalization	src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:(const MatrixType& matrix)
UpperBidiagonalization	src/SVD/UpperBidiagonalization.h	/^template<typename _MatrixType> class UpperBidiagonalization$/;"	c	namespace:Eigen::internal
UpperTriangular	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangular = Upper;$/;"	m	namespace:Eigen
UpperTriangularBit	src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangularBit = Upper;$/;"	m	namespace:Eigen
Vector	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Vector	src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLUT	access:private
Vector	src/PaStiXSupport/PaStiXSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::PastixBase	access:public
Vector	src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::SuperLUBase	access:public
Vector	src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::UmfPackLU	access:public
Vector2	src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D	access:public
Vector2	src/Geometry/OrthoMethods.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Vector2	src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D	access:public
Vector2s	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,1> Vector2s;$/;"	t	class:Eigen::RealQZ	access:private
Vector3	src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis	access:public
Vector3	src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::Quaternion	access:public
Vector3	src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis	access:public
Vector3	src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::QuaternionBase	access:public
Vector3s	src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealQZ	access:private
Vector3s	src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealSchur	access:private
VectorBlock	src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start)$/;"	f	class:Eigen::VectorBlock	access:public	signature:(VectorType& vector, Index start)
VectorBlock	src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start, Index size)$/;"	f	class:Eigen::VectorBlock	access:public	signature:(VectorType& vector, Index start, Index size)
VectorBlock	src/Core/VectorBlock.h	/^template<typename VectorType, int Size> class VectorBlock$/;"	c	namespace:Eigen	inherits:Block
VectorI	src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
VectorI	src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
VectorType	src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::AlignedBox	access:public
VectorType	src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane	access:public
VectorType	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::ParametrizedLine	access:public
VectorType	src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Scaling	access:public
VectorType	src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform	access:public
VectorType	src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation	access:public
VectorType	src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> VectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver	access:public
VectorType	src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;$/;"	t	class:Eigen::HessenbergDecomposition	access:private
VectorType	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::RealVectorType VectorType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
VectorType	src/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1>  VectorType;$/;"	t	class:Eigen::AlignedBox	access:public
VectorType	src/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane	access:public
VectorType	src/Geometry/OrthoMethods.h	/^  typedef typename plain_matrix_type<Derived>::type VectorType;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
VectorType	src/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1,Options> VectorType;$/;"	t	class:Eigen::ParametrizedLine	access:public
VectorType	src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::RotationBase	access:public
VectorType	src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform	access:public
VectorType	src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation	access:public
VectorType	src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
VectorType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
VectorType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
VectorType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
VectorType	src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLLT	access:public
Vectorizable	src/Core/Functors.h	/^    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasDiv && packet_traits<RhsScalar>::HasDiv$/;"	e	enum:Eigen::internal::scalar_quotient_op::__anon178
Vectorizable	src/Core/Functors.h	/^    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul$/;"	e	enum:Eigen::internal::scalar_product_op::__anon169
Vectorizable	src/Core/GenericPacketMath.h	/^    Vectorizable = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon270
Vectorizable	src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
Vectorizable	src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
Vectorizable	src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
Vectorizable	src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Vectorizable	src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
Vectorizable	src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
Vectorizable	src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Vectorizable	src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
Vectorizable	src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
Vectorizable	src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
Vectorizable	src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon26
Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable  = Traits::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon38
Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
Vectorizable	src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
Vectorizable	src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon46
Vectorizable	src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon47
Vectorized	src/Core/Assign.h	/^    Vectorized = int(Traversal) == InnerVectorizedTraversal$/;"	e	enum:Eigen::internal::assign_traits::__anon133
VectorizedSize	src/Core/Redux.h	/^    VectorizedSize = (Size \/ PacketSize) * PacketSize$/;"	e	enum:Eigen::internal::redux_impl::__anon305
VectorwiseOp	src/Core/VectorwiseOp.h	/^    inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(ExpressionType& matrix)
VectorwiseOp	src/Core/VectorwiseOp.h	/^template<typename ExpressionType, int Direction> class VectorwiseOp$/;"	c	namespace:Eigen
Vertical	src/Core/util/Constants.h	/^  Vertical, $/;"	e	enum:Eigen::DirectionType
VmlSize	src/Core/Assign_MKL.h	/^      VmlSize = MightLinearize ? MaxSizeAtCompileTime : InnerMaxSize,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon139
WORK	src/SparseLU/SparseLU_gemm_kernel.h	108;"	d
WORK	src/SparseLU/SparseLU_gemm_kernel.h	148;"	d
WORK	src/SparseLU/SparseLU_gemm_kernel.h	205;"	d
WORK	src/SparseLU/SparseLU_gemm_kernel.h	245;"	d
WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED	src/Core/util/StaticAssert.h	/^        WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
WithFormat	src/Core/IO.h	/^    WithFormat(const ExpressionType& matrix, const IOFormat& format)$/;"	f	class:Eigen::WithFormat	access:public	signature:(const ExpressionType& matrix, const IOFormat& format)
WithFormat	src/Core/IO.h	/^class WithFormat$/;"	c	namespace:Eigen
WorkMatrixType	src/SVD/JacobiSVD.h	/^            WorkMatrixType;$/;"	t	class:Eigen::JacobiSVD	access:public
WorkSpaceFactor	src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = Vectorizable ? 2*nr*RealPacketSize : nr,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
WorkSpaceFactor	src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr * RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
WorkSpaceFactor	src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
WorkSpaceFactor	src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
WorkVectorType	src/QR/FullPivHouseholderQR.h	/^                 MatrixType::MaxRowsAtCompileTime> WorkVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
WorkspaceType	src/SVD/JacobiSVD.h	/^  typedef Matrix<Scalar, 1, RowsAtCompileTime, RowMajor, 1, MaxRowsAtCompileTime> WorkspaceType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
WriteAccessors	src/Core/util/Constants.h	/^  WriteAccessors, $/;"	e	enum:Eigen::AccessorLevels
XprBase	src/Core/Array.h	/^  typedef ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > XprBase;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/Array.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/ArrayWrapper.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/ArrayWrapper.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/Block.h	/^  typedef typename traits<XprType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/CwiseBinaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/Matrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/ProductBase.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/Core/products/CoeffBasedProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/SparseCore/SparseDenseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/SparseCore/SparseDiagonalProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/SparseCore/SparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/SparseCore/SparseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	src/SparseCore/SparseVector.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprType	src/Core/Transpose.h	/^  typedef SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprType	src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprType	src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprType	src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprType	src/Core/util/BlasUtil.h	/^  typedef Transpose<NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprTypeIsRowMajor	src/Core/Block.h	/^    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::traits::__anon146
XprTypeNested	src/Core/Block.h	/^  typedef typename nested<XprType>::type XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
XprTypeNested	src/Core/CwiseUnaryOp.h	/^  typedef typename XprType::Nested XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
YOU_ALREADY_SPECIFIED_THIS_STRIDE	src/Core/util/StaticAssert.h	/^        YOU_ALREADY_SPECIFIED_THIS_STRIDE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT	src/Core/util/StaticAssert.h	/^        YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR	src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR	src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_CANNOT_MIX_ARRAYS_AND_MATRICES	src/Core/util/StaticAssert.h	/^        YOU_CANNOT_MIX_ARRAYS_AND_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_MADE_A_PROGRAMMING_MISTAKE	src/Core/util/StaticAssert.h	/^        YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY	src/Core/util/StaticAssert.h	/^        YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES	src/Core/util/StaticAssert.h	/^        YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES	src/Core/util/StaticAssert.h	/^        YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED	src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED	src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION	src/Core/util/StaticAssert.h	/^        YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX	src/Core/util/StaticAssert.h	/^        YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon126
Zero	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero()$/;"	f	class:Eigen::DenseBase	signature:()
Zero	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index nbRows, Index nbCols)$/;"	f	class:Eigen::DenseBase	signature:(Index nbRows, Index nbCols)
Zero	src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
Zero	src/Core/DenseBase.h	/^    static const ConstantReturnType Zero();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Zero	src/Core/DenseBase.h	/^    static const ConstantReturnType Zero(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Zero	src/Core/DenseBase.h	/^    static const ConstantReturnType Zero(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
ZeroDiag	src/Core/util/Constants.h	/^  ZeroDiag=0x8,$/;"	e	enum:Eigen::__anon61
ZeroSign	src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
_ActualLhsType	src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualLhsType>::type _ActualLhsType;$/;"	t	class:Eigen::ProductBase	access:public
_ActualRhsType	src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualRhsType>::type _ActualRhsType;$/;"	t	class:Eigen::ProductBase	access:public
_EIGEN_ACCUMULATE_PACKETS	src/Core/products/GeneralMatrixVector.h	280;"	d
_EIGEN_ACCUMULATE_PACKETS	src/Core/products/GeneralMatrixVector.h	336;"	d
_EIGEN_ACCUMULATE_PACKETS	src/Core/products/GeneralMatrixVector.h	559;"	d
_EIGEN_ACCUMULATE_PACKETS	src/Core/products/GeneralMatrixVector.h	70;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4f	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4f(ZERO, 0);$/;"	p	namespace:Eigen::internal	signature:(ZERO, 0)
_EIGEN_DECLARE_CONST_FAST_Packet4f	src/Core/arch/AltiVec/PacketMath.h	40;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS1,-1);$/;"	p	namespace:Eigen::internal	signature:(MINUS1,-1)
_EIGEN_DECLARE_CONST_FAST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS16,-16);$/;"	p	namespace:Eigen::internal	signature:(MINUS16,-16)
_EIGEN_DECLARE_CONST_FAST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(ONE,1);$/;"	p	namespace:Eigen::internal	signature:(ONE,1)
_EIGEN_DECLARE_CONST_FAST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(ZERO, 0);$/;"	p	namespace:Eigen::internal	signature:(ZERO, 0)
_EIGEN_DECLARE_CONST_FAST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	43;"	d
_EIGEN_DECLARE_CONST_Packet2d	src/Core/arch/SSE/PacketMath.h	51;"	d
_EIGEN_DECLARE_CONST_Packet4f	src/Core/arch/AltiVec/PacketMath.h	46;"	d
_EIGEN_DECLARE_CONST_Packet4f	src/Core/arch/NEON/PacketMath.h	33;"	d
_EIGEN_DECLARE_CONST_Packet4f	src/Core/arch/SSE/PacketMath.h	48;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	src/Core/arch/AltiVec/PacketMath.h	49;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	src/Core/arch/NEON/PacketMath.h	36;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	src/Core/arch/SSE/PacketMath.h	54;"	d
_EIGEN_DECLARE_CONST_Packet4i	src/Core/arch/AltiVec/PacketMath.h	52;"	d
_EIGEN_DECLARE_CONST_Packet4i	src/Core/arch/NEON/PacketMath.h	39;"	d
_EIGEN_DECLARE_CONST_Packet4i	src/Core/arch/SSE/PacketMath.h	57;"	d
_EIGEN_SPARSE_PUBLIC_INTERFACE	src/SparseCore/SparseUtil.h	46;"	d
_ExtractType	src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType> _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
_ExtractType	src/Core/util/BlasUtil.h	/^  typedef XprType _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
_HasDirectAccess	src/SparseCore/SparseMatrixBase.h	/^      _HasDirectAccess = (int(Flags)&DirectAccessBit) ? 1 : 0 \/\/ workaround sunCC$/;"	e	enum:Eigen::SparseMatrixBase::__anon448
_Index	src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Index _Index;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
_Index	src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Index _Index;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
_Lhs	src/Core/GeneralProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::product_type	access:public
_Lhs	src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::traits	access:public
_LhsNested	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
_LhsNested	src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_LhsNested	src/Core/ProductBase.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::ProductBase	access:public
_LhsNested	src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
_LhsNested	src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_LhsNested	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_LhsNested _LhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
_LhsNested	src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
_LhsNested	src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_LhsNested	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
_LhsNested	src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseSparseProduct	access:private
_LhsNested	src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_LhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
_LhsPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
_LinearAccessMask	src/Core/DiagonalProduct.h	/^    _LinearAccessMask = (RowsAtCompileTime==1 || ColsAtCompileTime==1) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon166
_MatrixType	src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename internal::pastix_traits<Derived>::MatrixType _MatrixType;$/;"	t	class:Eigen::PastixBase	access:public
_MatrixTypeNested	src/Core/CwiseUnaryView.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	src/Core/Diagonal.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::Replicate	access:private
_MatrixTypeNested	src/Core/Replicate.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	src/Core/Reverse.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr	access:public
_MatrixTypeNested	src/Core/VectorwiseOp.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	src/Eigen2Support/Minor.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	src/Geometry/Homogeneous.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename SparseMatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl	access:private
_MatrixTypeNested	src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename XprType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl	access:private
_MatrixTypeNested	src/SparseCore/SparseBlock.h	/^  typedef typename internal::remove_all<typename XprType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl	access:private
_MatrixTypeNested	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
_MatrixTypeNested	src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_XprTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
_MatrixTypeNested	src/SparseCore/SparseMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
_MatrixTypeNested	src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
_MatrixTypeNested	src/SparseCore/SparseTranspose.h	/^    typedef typename internal::remove_all<typename MatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::TransposeImpl	access:private
_MatrixTypeNested	src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseView	access:private
_Options	src/SparseCore/SparseUtil.h	/^    enum { _Options = ((traits<T>::Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::sparse_eval::__anon454
_Options	src/SparseCore/SparseUtil.h	/^  enum { _Options = ((traits<T>::Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::plain_matrix_type::__anon455
_ResPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
_ResPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
_Rhs	src/Core/GeneralProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::product_type	access:public
_Rhs	src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::traits	access:public
_RhsNested	src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
_RhsNested	src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_RhsNested	src/Core/ProductBase.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::ProductBase	access:public
_RhsNested	src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
_RhsNested	src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_RhsNested	src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_RhsNested _RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
_RhsNested	src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
_RhsNested	src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_RhsNested	src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
_RhsNested	src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseSparseProduct	access:private
_RhsNested	src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_RhsPacket	src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
_RhsPacket	src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
_SameTypes	src/Core/DiagonalProduct.h	/^    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon166
_Scalar	src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
_Scalar	src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
_ScalarAccessOnDiag	src/Core/DiagonalProduct.h	/^    _ScalarAccessOnDiag =  !((int(_StorageOrder) == ColMajor && int(ProductOrder) == OnTheLeft)$/;"	e	enum:Eigen::internal::traits::__anon166
_StorageOrder	src/Core/DiagonalProduct.h	/^    _StorageOrder = MatrixType::Flags & RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon166
_Vectorizable	src/Core/DiagonalProduct.h	/^    _Vectorizable = bool(int(MatrixType::Flags)&PacketAccessBit) && _SameTypes && (_ScalarAccessOnDiag || (bool(int(DiagonalType::DiagonalVectorType::Flags)&PacketAccessBit))),$/;"	e	enum:Eigen::internal::traits::__anon166
_XprTypeNested	src/Core/Block.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_XprTypeNested	src/Core/CwiseUnaryOp.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
__has_feature	src/Core/util/Macros.h	102;"	d
_check_template_params	src/Core/PlainObjectBase.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
_check_template_params	src/Geometry/Quaternion.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::Quaternion	access:protected	signature:()
_compute	src/Eigenvalues/HessenbergDecomposition.h	/^    static void _compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp);$/;"	p	class:Eigen::HessenbergDecomposition	access:private	signature:(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)
_compute	src/Eigenvalues/HessenbergDecomposition.h	/^void HessenbergDecomposition<MatrixType>::_compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)$/;"	f	class:Eigen::HessenbergDecomposition	signature:(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)
_data	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Storage& _data() { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
_data	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED const Storage& _data() const { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
_expression	src/Core/Flagged.h	/^    const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
_expression	src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& _expression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
_expression	src/Core/VectorwiseOp.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
_expression	src/Eigen2Support/Cwise.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Cwise	access:public	signature:() const
_init2	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(Index nbRows, Index nbCols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(Index nbRows, Index nbCols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)
_init2	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const Scalar& val0, const Scalar& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const Scalar& val0, const Scalar& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)
_resize_to_match	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const EigenBase<OtherDerived>& other)
_set	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const DenseBase<OtherDerived>& other)
_set_noalias	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const DenseBase<OtherDerived>& other)
_set_selector	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const OtherDerived& other, const internal::false_type&)
_set_selector	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const OtherDerived& other, const internal::true_type&)
_solve	src/CholmodSupport/CholmodSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	src/CholmodSupport/CholmodSupport.h	/^    void _solve(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
_solve	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const Rhs& b, Dest& x) const
_solve	src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const Rhs& b, Dest& x) const
_solve	src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const Rhs& b, Dest& x) const
_solve	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const Rhs& b, Dest& x) const
_solve	src/PaStiXSupport/PaStiXSupport.h	/^    bool _solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const;$/;"	p	class:Eigen::PastixBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const
_solve	src/PaStiXSupport/PaStiXSupport.h	/^bool PastixBase<Base>::_solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::PastixBase	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const
_solve	src/PardisoSupport/PardisoSupport.h	/^    bool _solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const;$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const
_solve	src/PardisoSupport/PardisoSupport.h	/^bool PardisoImpl<Base>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const
_solve	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SPQR	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	src/SparseLU/SparseLU.h	/^    bool _solve(const MatrixBase<Rhs> &B, MatrixBase<Dest> &X_base) const$/;"	f	class:Eigen::SparseLU	access:public	signature:(const MatrixBase<Rhs> &B, MatrixBase<Dest> &X_base) const
_solve	src/SparseQR/SparseQR.h	/^    bool _solve(const MatrixBase<Rhs> &B, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SparseQR	access:public	signature:(const MatrixBase<Rhs> &B, MatrixBase<Dest> &dest) const
_solve	src/SuperLUSupport/SuperLUSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const;$/;"	p	class:Eigen::SuperILU	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	src/SuperLUSupport/SuperLUSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const;$/;"	p	class:Eigen::SuperLU	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperILU	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
_solve	src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperLU	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
_solve	src/UmfPackSupport/UmfPackSupport.h	/^    bool _solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const
_solve	src/UmfPackSupport/UmfPackSupport.h	/^bool UmfPackLU<MatrixType>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const$/;"	f	class:Eigen::UmfPackLU	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const
_solveWithGuess	src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const Rhs& b, Dest& x) const
_solveWithGuess	src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const Rhs& b, Dest& x) const
_solve_sparse	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
_swap	src/Core/PlainObjectBase.h	/^    void _swap(DenseBase<OtherDerived> const & other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(DenseBase<OtherDerived> const & other)
_transformVector	src/Geometry/Quaternion.h	/^  EIGEN_STRONG_INLINE Vector3 _transformVector(const Vector3& v) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const Vector3& v) const
_transformVector	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::_transformVector(const Vector3& v) const$/;"	f	class:Eigen::QuaternionBase	signature:(const Vector3& v) const
_transformVector	src/Geometry/RotationBase.h	/^    inline VectorType _transformVector(const OtherVectorType& v) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const OtherVectorType& v) const
a	src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	m	struct:Eigen::internal::has_none	access:public
a	src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	m	struct:Eigen::internal::has_std_result_type	access:public
a	src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	m	struct:Eigen::internal::has_tr1_result	access:public
a	src/SVD/JacobiSVD.h	/^  enum { a = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon417
abs	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_abs_op)      abs() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
abs	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs() const$/;"	f	class:Eigen::Cwise	signature:() const
abs	src/plugins/ArrayCwiseUnaryOps.h	/^abs() const$/;"	f	signature:() const
abs2	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
abs2	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_abs2_op)     abs2() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
abs2	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs2() const$/;"	f	class:Eigen::Cwise	signature:() const
abs2	src/plugins/ArrayCwiseUnaryOps.h	/^abs2() const$/;"	f	signature:() const
abs2_impl	src/Core/MathFunctions.h	/^struct abs2_impl$/;"	s	namespace:Eigen::internal
abs2_impl	src/Core/MathFunctions.h	/^struct abs2_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
abs2_retval	src/Core/MathFunctions.h	/^struct abs2_retval$/;"	s	namespace:Eigen::internal
absDeterminant	src/QR/ColPivHouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
absDeterminant	src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
absDeterminant	src/QR/FullPivHouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
absDeterminant	src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
absDeterminant	src/QR/HouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::HouseholderQR	access:public	signature:() const
absDeterminant	src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::HouseholderQR	signature:() const
absDeterminant	src/SparseLU/SparseLU.h	/^     Scalar absDeterminant()$/;"	f	class:Eigen::SparseLU	access:public	signature:()
absDiagIndex	src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index absDiagIndex() const { return m_index.value()>0 ? m_index.value() : -m_index.value(); }$/;"	f	class:Eigen::Diagonal	access:private	signature:() const
absDistance	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { return ei_abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
absDistance	src/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { using std::abs; return abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
acc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const
acc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const
acc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const Scalar& c, const Scalar& alpha, Scalar& r) const { r += alpha * c; }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const Scalar& c, const Scalar& alpha, Scalar& r) const
accessors_level	src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct accessors_level$/;"	s	namespace:Eigen::internal
acos	src/plugins/ArrayCwiseUnaryOps.h	/^acos() const$/;"	f	signature:() const
add	src/Core/GeneralProduct.h	/^    struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	s	class:Eigen::GeneralProduct	access:public
addTo	src/Core/DiagonalMatrix.h	/^    void addTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
addTo	src/Core/EigenBase.h	/^  template<typename Dest> inline void addTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
addTo	src/Core/GeneralProduct.h	/^    inline void addTo(Dest& dest) const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest) const
addTo	src/Core/ProductBase.h	/^    inline void addTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:ScaledProduct	access:public	signature:(Dest& dst) const
add_const	src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	s	namespace:Eigen::internal
add_const	src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type_if_arithmetic	src/Core/DenseCoeffsBase.h	/^template<typename T> struct add_const_on_value_type_if_arithmetic$/;"	s	namespace:Eigen::internal
address	src/Core/util/Memory.h	/^    const_pointer address( const_reference value ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const_reference value ) const
address	src/Core/util/Memory.h	/^    pointer address( reference value ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( reference value ) const
adds	src/Core/GeneralProduct.h	/^      adds(const Scalar& s) : m_scale(s) {}$/;"	f	struct:Eigen::GeneralProduct::adds	access:public	signature:(const Scalar& s)
adds	src/Core/GeneralProduct.h	/^    struct adds {$/;"	s	class:Eigen::GeneralProduct	access:public
adjoint	src/Core/MatrixBase.h	/^    const AdjointReturnType adjoint() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
adjoint	src/Core/Transpose.h	/^MatrixBase<Derived>::adjoint() const$/;"	f	class:Eigen::MatrixBase	signature:() const
adjoint	src/Core/TriangularMatrix.h	/^    inline const TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> adjoint() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
adjoint	src/Householder/HouseholderSequence.h	/^    ConjugateReturnType adjoint() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
adjoint	src/Jacobi/Jacobi.h	/^    JacobiRotation adjoint() const { using numext::conj; return JacobiRotation(conj(m_c), -m_s); }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
adjoint	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> adjoint() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType	access:public	signature:() const
adjoint	src/SparseCore/SparseMatrixBase.h	/^    const AdjointReturnType adjoint() const { return transpose(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
adjoint	src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> adjoint() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:() const
adjointInPlace	src/Core/MatrixBase.h	/^    void adjointInPlace();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
adjointInPlace	src/Core/Transpose.h	/^inline void MatrixBase<Derived>::adjointInPlace()$/;"	f	class:Eigen::MatrixBase	signature:()
affine	src/Geometry/Transform.h	/^  inline AffinePart affine() { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform	access:public	signature:()
affine	src/Geometry/Transform.h	/^  inline ConstAffinePart affine() const { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
aligned_allocator	src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator& )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const aligned_allocator& )
aligned_allocator	src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator<U>& )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const aligned_allocator<U>& )
aligned_allocator	src/Core/util/Memory.h	/^    aligned_allocator()$/;"	f	class:Eigen::aligned_allocator	access:public	signature:()
aligned_allocator	src/Core/util/Memory.h	/^class aligned_allocator$/;"	c	namespace:Eigen
aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:()
aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<T>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const EIGEN_ALIGNED_ALLOCATOR<T>& )
aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const EIGEN_ALIGNED_ALLOCATOR<U>& )
aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection& ) : EIGEN_ALIGNED_ALLOCATOR<T>() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const aligned_allocator_indirection& )
aligned_allocator_indirection	src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const aligned_allocator_indirection<U>& )
aligned_allocator_indirection	src/StlSupport/details.h	/^  class aligned_allocator_indirection : public EIGEN_ALIGNED_ALLOCATOR<T>$/;"	c	namespace:Eigen	inherits:EIGEN_ALIGNED_ALLOCATOR
aligned_delete	src/Core/util/Memory.h	/^template<typename T> inline void aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
aligned_free	src/Core/util/Memory.h	/^inline void aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
aligned_free	src/Core/util/Memory.h	/^void  aligned_free(void *ptr);$/;"	p	namespace:Eigen::internal	signature:(void *ptr)
aligned_malloc	src/Core/util/Memory.h	/^inline void* aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
aligned_malloc	src/Core/util/Memory.h	/^void* aligned_malloc(std::size_t size);$/;"	p	namespace:Eigen::internal	signature:(std::size_t size)
aligned_new	src/Core/util/Memory.h	/^template<typename T> inline T* aligned_new(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
aligned_realloc	src/Core/util/Memory.h	/^inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void *ptr, size_t new_size, size_t old_size)
aligned_stack_memory_handler	src/Core/util/Memory.h	/^    aligned_stack_memory_handler(T* ptr, size_t size, bool dealloc)$/;"	f	class:Eigen::internal::aligned_stack_memory_handler	access:public	signature:(T* ptr, size_t size, bool dealloc)
aligned_stack_memory_handler	src/Core/util/Memory.h	/^template<typename T> class aligned_stack_memory_handler$/;"	c	namespace:Eigen::internal
alignment	src/Core/Redux.h	/^    alignment = (Derived::Flags & AlignedBit) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon304
all	src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::all() const$/;"	f	class:Eigen::DenseBase	signature:() const
all	src/Core/DenseBase.h	/^    bool all(void) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(void) const
all	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_all>::Type all() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
allFinite	src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::allFinite() const$/;"	f	class:Eigen::DenseBase	signature:() const
allFinite	src/Core/DenseBase.h	/^    inline bool allFinite() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
all_unroller	src/Core/BooleanRedux.h	/^struct all_unroller$/;"	s	namespace:Eigen::internal
all_unroller	src/Core/BooleanRedux.h	/^struct all_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
all_unroller	src/Core/BooleanRedux.h	/^struct all_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
allocate	src/Core/util/Memory.h	/^    pointer allocate( size_type num, const void* hint = 0 )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( size_type num, const void* hint = 0 )
allocate	src/SVD/JacobiSVD.h	/^    void allocate(Index rows, Index cols, unsigned int computationOptions);$/;"	p	class:Eigen::JacobiSVD	access:private	signature:(Index rows, Index cols, unsigned int computationOptions)
allocate	src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)
allocate	src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)
allocate	src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)
allocate	src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, QRPreconditioner>&) {}$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, QRPreconditioner>&)
allocate	src/SVD/JacobiSVD.h	/^void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD	signature:(Index rows, Index cols, unsigned int computationOptions)
allocateA	src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateA() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateA	src/Core/products/GeneralMatrixMatrix.h	/^    void allocateA()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateAll	src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateAll() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateAll	src/Core/products/GeneralMatrixMatrix.h	/^    void allocateAll()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateB	src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateB() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateB	src/Core/products/GeneralMatrixMatrix.h	/^    void allocateB()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateW	src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateW() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateW	src/Core/products/GeneralMatrixMatrix.h	/^    void allocateW()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocatedSize	src/SparseCore/CompressedStorage.h	/^    inline size_t allocatedSize() const { return m_allocatedSize; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:() const
alpha	src/Core/ProductBase.h	/^    const Scalar& alpha() const { return m_alpha; }$/;"	f	class:ScaledProduct	access:public	signature:() const
alphas	src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType alphas() const$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:() const
always_void	src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	s	namespace:Eigen::internal
amd_flip	src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_flip(const T& i) { return -i-2; }$/;"	f	namespace:Eigen::internal	signature:(const T& i)
amd_mark	src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline void amd_mark(const T0* w, const T1& j) { return w[j] = amd_flip(w[j]); }$/;"	f	namespace:Eigen::internal	signature:(const T0* w, const T1& j)
amd_marked	src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline bool amd_marked(const T0* w, const T1& j) { return w[j]<0; }$/;"	f	namespace:Eigen::internal	signature:(const T0* w, const T1& j)
amd_unflip	src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_unflip(const T& i) { return i<0 ? amd_flip(i) : i; }$/;"	f	namespace:Eigen::internal	signature:(const T& i)
analyzePattern	src/CholmodSupport/CholmodSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
analyzePattern	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& analyzePattern(const MatType& )$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatType& )
analyzePattern	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& analyzePattern(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
analyzePattern	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void analyzePattern(const MatrixType& amat);$/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
analyzePattern	src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::analyzePattern(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	signature:(const _MatrixType& amat)
analyzePattern	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& analyzePattern(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const EigenBase<InputDerived>& A)
analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
analyzePattern	src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::analyzePattern(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
analyzePattern	src/PardisoSupport/PardisoSupport.h	/^    Derived& analyzePattern(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
analyzePattern	src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
analyzePattern	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& a)
analyzePattern	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& a)
analyzePattern	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& a)
analyzePattern	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a, bool doLDLT)
analyzePattern	src/SparseLU/SparseLU.h	/^    void analyzePattern (const MatrixType& matrix);$/;"	p	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
analyzePattern	src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseLU	signature:(const MatrixType& mat)
analyzePattern	src/SparseQR/SparseQR.h	/^    void analyzePattern(const MatrixType& mat);$/;"	p	class:Eigen::SparseQR	access:public	signature:(const MatrixType& mat)
analyzePattern	src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR	signature:(const MatrixType& mat)
analyzePattern	src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& \/*matrix*\/)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixType& )
analyzePattern	src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
analyzePattern	src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
analyzePattern	src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const InputMatrixType& matrix)
analyzePattern_impl	src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern_impl()$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:()
analyzePattern_preordered	src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern_preordered(const CholMatrixType& a, bool doLDLT);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const CholMatrixType& a, bool doLDLT)
analyzePattern_preordered	src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::analyzePattern_preordered(const CholMatrixType& ap, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const CholMatrixType& ap, bool doLDLT)
angle	src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
angle	src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
angle	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
angle	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
angle	src/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
angle	src/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
angle	src/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
angle	src/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
angularDistance	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar angularDistance(const Quaternion& other) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other) const
angularDistance	src/Eigen2Support/Geometry/Quaternion.h	/^inline Scalar Quaternion<Scalar>::angularDistance(const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other) const
angularDistance	src/Geometry/Quaternion.h	/^  template<class OtherDerived> Scalar angularDistance(const QuaternionBase<OtherDerived>& other) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other) const
angularDistance	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::angularDistance(const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other) const
any	src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::any() const$/;"	f	class:Eigen::DenseBase	signature:() const
any	src/Core/DenseBase.h	/^    bool any(void) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(void) const
any	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_any>::Type any() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
any_unroller	src/Core/BooleanRedux.h	/^struct any_unroller$/;"	s	namespace:Eigen::internal
any_unroller	src/Core/BooleanRedux.h	/^struct any_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
any_unroller	src/Core/BooleanRedux.h	/^struct any_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
append	src/SparseCore/CompressedStorage.h	/^    void append(const Scalar& v, Index i)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const Scalar& v, Index i)
applyHouseholderOnTheLeft	src/Core/MatrixBase.h	/^    void applyHouseholderOnTheLeft(const EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
applyHouseholderOnTheLeft	src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheLeft($/;"	f	class:Eigen::MatrixBase	signature:( const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
applyHouseholderOnTheRight	src/Core/MatrixBase.h	/^    void applyHouseholderOnTheRight(const EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
applyHouseholderOnTheRight	src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheRight($/;"	f	class:Eigen::MatrixBase	signature:( const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
applyOnTheLeft	src/Core/MatrixBase.h	/^    void applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
applyOnTheLeft	src/Core/MatrixBase.h	/^    void applyOnTheLeft(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
applyOnTheLeft	src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
applyOnTheLeft	src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
applyOnTheRight	src/Core/MatrixBase.h	/^    void applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
applyOnTheRight	src/Core/MatrixBase.h	/^    void applyOnTheRight(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
applyOnTheRight	src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheRight(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
applyOnTheRight	src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
applyThisOnTheLeft	src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
applyThisOnTheLeft	src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
applyThisOnTheLeft	src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst) const
applyThisOnTheRight	src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
applyThisOnTheRight	src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheRight(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
applyThisOnTheRight	src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst) const
applyTranspositionOnTheLeft	src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheLeft(Index i, Index j)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index i, Index j)
applyTranspositionOnTheRight	src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheRight(Index i, Index j)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index i, Index j)
apply_block_householder_on_the_left	src/Householder/BlockHouseholder.h	/^void apply_block_householder_on_the_left(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)
apply_rotation_in_the_plane	src/Jacobi/Jacobi.h	/^void \/*EIGEN_DONT_INLINE*\/ apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)$/;"	f	namespace:Eigen::internal	signature:(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)
apply_rotation_in_the_plane	src/Jacobi/Jacobi.h	/^void apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j);$/;"	p	namespace:Eigen::internal	signature:(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)
array	src/Core/ArrayBase.h	/^    ArrayBase<Derived>& array() { return *this; }$/;"	f	class:Eigen::ArrayBase	access:public	signature:()
array	src/Core/ArrayBase.h	/^    const ArrayBase<Derived>& array() const { return *this; }$/;"	f	class:Eigen::ArrayBase	access:public	signature:() const
array	src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[1];$/;"	m	struct:Eigen::internal::plain_array	access:public
array	src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[Size];$/;"	m	struct:Eigen::internal::plain_array	access:public
array	src/Core/DenseStorage.h	/^  T array[Size];$/;"	m	struct:Eigen::internal::plain_array	access:public
array	src/Core/MatrixBase.h	/^    ArrayWrapper<Derived> array() { return derived(); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:()
array	src/Core/MatrixBase.h	/^    const ArrayWrapper<const Derived> array() const { return derived(); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
asDiagonal	src/Core/DiagonalMatrix.h	/^MatrixBase<Derived>::asDiagonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
asDiagonal	src/Core/MatrixBase.h	/^    const DiagonalWrapper<const Derived> asDiagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
asPermutation	src/Core/MatrixBase.h	/^    const PermutationWrapper<const Derived> asPermutation() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
asPermutation	src/Core/PermutationMatrix.h	/^const PermutationWrapper<const Derived> MatrixBase<Derived>::asPermutation() const$/;"	f	class:Eigen::MatrixBase	signature:() const
asSluMatrix	src/SuperLUSupport/SuperLUSupport.h	/^SluMatrix asSluMatrix(MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
asin	src/plugins/ArrayCwiseUnaryOps.h	/^asin() const$/;"	f	signature:() const
assign	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& assign(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:protected	signature:(const OtherDerived& other)
assignGeneric	src/SparseCore/SparseMatrixBase.h	/^    inline void assignGeneric(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:protected	signature:(const OtherDerived& other)
assignProduct	src/Core/PermutationMatrix.h	/^    void assignProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationBase	access:protected	signature:(const Lhs& lhs, const Rhs& rhs)
assignProduct	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& assignProduct(const ProductBase<ProductDerived, Lhs,Rhs>& prod, const Scalar& alpha);$/;"	p	class:Eigen::TriangularView	access:protected	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& prod, const Scalar& alpha)
assignProduct	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& assignProduct(const TriangularProduct<Mode, LhsIsTriangular, Lhs, LhsIsVector, Rhs, RhsIsVector>& prod, const Scalar& alpha)$/;"	f	class:Eigen::TriangularView	access:protected	signature:(const TriangularProduct<Mode, LhsIsTriangular, Lhs, LhsIsVector, Rhs, RhsIsVector>& prod, const Scalar& alpha)
assignProduct	src/Core/products/GeneralMatrixMatrixTriangular.h	/^TriangularView<MatrixType,UpLo>& TriangularView<MatrixType,UpLo>::assignProduct(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)$/;"	f	class:Eigen::TriangularView	signature:(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)
assignTranspose	src/Core/PermutationMatrix.h	/^    void assignTranspose(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase	access:protected	signature:(const PermutationBase<OtherDerived>& other)
assign_DefaultTraversal_CompleteUnrolling	src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_CompleteUnrolling	src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_InnerUnrolling	src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_InnerUnrolling	src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_LinearTraversal_CompleteUnrolling	src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_LinearTraversal_CompleteUnrolling	src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_conj_scalar_eig2mkl	src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex16& mklScalar, const dcomplex& eigenScalar)
assign_conj_scalar_eig2mkl	src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex8& mklScalar, const scomplex& eigenScalar)
assign_conj_scalar_eig2mkl	src/Core/util/MKL_support.h	/^static inline void assign_conj_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKLType& mklScalar, const EigenType& eigenScalar)
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InvalidTraversal, Unrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, SliceVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_innervec_CompleteUnrolling	src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_innervec_CompleteUnrolling	src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_innervec_InnerUnrolling	src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling$/;"	s	namespace:Eigen::internal
assign_innervec_InnerUnrolling	src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_scalar_eig2mkl	src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex16& mklScalar, const dcomplex& eigenScalar)
assign_scalar_eig2mkl	src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex8& mklScalar, const scomplex& eigenScalar)
assign_scalar_eig2mkl	src/Core/util/MKL_support.h	/^static inline void assign_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKLType& mklScalar, const EigenType& eigenScalar)
assign_selector	src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,false> {$/;"	s	namespace:Eigen::internal
assign_selector	src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,true> {$/;"	s	namespace:Eigen::internal
assign_selector	src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,false> {$/;"	s	namespace:Eigen::internal
assign_selector	src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,true> {$/;"	s	namespace:Eigen::internal
assign_traits	src/Core/Assign.h	/^struct assign_traits$/;"	s	namespace:Eigen::internal
at	src/SparseCore/CompressedStorage.h	/^    inline Scalar at(Index key, const Scalar& defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key, const Scalar& defaultValue = Scalar(0)) const
atInRange	src/SparseCore/CompressedStorage.h	/^    inline Scalar atInRange(size_t start, size_t end, Index key, const Scalar& defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t start, size_t end, Index key, const Scalar& defaultValue = Scalar(0)) const
atWithInsertion	src/SparseCore/CompressedStorage.h	/^    inline Scalar& atWithInsertion(Index key, const Scalar& defaultValue = Scalar(0))$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key, const Scalar& defaultValue = Scalar(0))
atanh2	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(atanh2, Scalar) atanh2(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x, const Scalar& y)
atanh2_default_impl	src/Core/MathFunctions.h	/^struct atanh2_default_impl$/;"	s	namespace:Eigen::internal
atanh2_default_impl	src/Core/MathFunctions.h	/^struct atanh2_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
atanh2_impl	src/Core/MathFunctions.h	/^struct atanh2_impl : atanh2_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:atanh2_default_impl
atanh2_retval	src/Core/MathFunctions.h	/^struct atanh2_retval$/;"	s	namespace:Eigen::internal
axis	src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
axis	src/Eigen2Support/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
axis	src/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
axis	src/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
b	src/SVD/JacobiSVD.h	/^         b = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon417
base	src/Core/PlainObjectBase.h	/^    Base& base() { return *static_cast<Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
base	src/Core/PlainObjectBase.h	/^    const Base& base() const { return *static_cast<const Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
betas	src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType betas() const$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:() const
bicgstab	src/IterativeLinearSolvers/BiCGSTAB.h	/^bool bicgstab(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, const Rhs& rhs, Dest& x, const Preconditioner& precond, int& iters, typename Dest::RealScalar& tol_error)
bidiagonal	src/SVD/UpperBidiagonalization.h	/^    const BidiagonalType& bidiagonal() const { return m_bidiagonal; }$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
binaryExpr	src/plugins/CommonCwiseBinaryOps.h	/^binaryExpr(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const
binary_result_of_select	src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	s	namespace:Eigen::internal
binary_result_of_select	src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
binary_result_of_select	src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
blas_data_mapper	src/Core/util/BlasUtil.h	/^    blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::blas_data_mapper	access:public	signature:(Scalar* data, Index stride)
blas_data_mapper	src/Core/util/BlasUtil.h	/^class blas_data_mapper$/;"	c	namespace:Eigen::internal
blas_traits	src/Core/Transpose.h	/^struct blas_traits<SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<Transpose<NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	src/Core/util/BlasUtil.h	/^struct blas_traits<const T>$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	src/Core/util/BlasUtil.h	/^template<typename XprType> struct blas_traits$/;"	s	namespace:Eigen::internal
block	src/plugins/BlockMethods.h	/^inline Block<Derived, BlockRows, BlockCols> block(Index startRow, Index startCol)$/;"	f	signature:(Index startRow, Index startCol)
block	src/plugins/BlockMethods.h	/^inline Block<Derived, BlockRows, BlockCols> block(Index startRow, Index startCol, $/;"	f	signature:(Index startRow, Index startCol, Index blockRows, Index blockCols)
block	src/plugins/BlockMethods.h	/^inline Block<Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	signature:(Index startRow, Index startCol, Index blockRows, Index blockCols)
block	src/plugins/BlockMethods.h	/^inline const Block<const Derived, BlockRows, BlockCols> block(Index startRow, Index startCol) const$/;"	f	signature:(Index startRow, Index startCol) const
block	src/plugins/BlockMethods.h	/^inline const Block<const Derived, BlockRows, BlockCols> block(Index startRow, Index startCol,$/;"	f	signature:(Index startRow, Index startCol, Index blockRows, Index blockCols) const
block	src/plugins/BlockMethods.h	/^inline const Block<const Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols) const$/;"	f	signature:(Index startRow, Index startCol, Index blockRows, Index blockCols) const
blockA	src/Core/products/GeneralMatrixMatrix.h	/^    inline LhsScalar* blockA() { return m_blockA; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
blockB	src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockB() { return m_blockB; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
blockW	src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockW() { return m_blockW; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
blocked	src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index blocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
blocked	src/Cholesky/LLT.h	/^  static typename MatrixType::Index blocked(MatrixType& m)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& m)
blocked_lu	src/LU/PartialPivLU.h	/^  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)$/;"	f	struct:Eigen::internal::partial_lu_impl	access:public	signature:(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)
blueNorm	src/Core/MatrixBase.h	/^    RealScalar blueNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
blueNorm	src/Core/StableNorm.h	/^MatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
blueNorm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_blueNorm,RealScalar>::Type blueNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
blueNorm	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
blueNorm	src/SparseCore/SparseMatrixBase.h	/^    RealScalar blueNorm() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
blueNorm_impl	src/Core/StableNorm.h	/^blueNorm_impl(const EigenBase<Derived>& _vec)$/;"	f	namespace:Eigen::internal	signature:(const EigenBase<Derived>& _vec)
bottomLeftCorner	src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomLeftCorner()$/;"	f	signature:()
bottomLeftCorner	src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomLeftCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
bottomLeftCorner	src/plugins/BlockMethods.h	/^inline Block<Derived> bottomLeftCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
bottomLeftCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomLeftCorner() const$/;"	f	signature:() const
bottomLeftCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomLeftCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
bottomLeftCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived> bottomLeftCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
bottomRightCorner	src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomRightCorner()$/;"	f	signature:()
bottomRightCorner	src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomRightCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
bottomRightCorner	src/plugins/BlockMethods.h	/^inline Block<Derived> bottomRightCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
bottomRightCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomRightCorner() const$/;"	f	signature:() const
bottomRightCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomRightCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
bottomRightCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived> bottomRightCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
bottomRows	src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr bottomRows(Index n) const$/;"	f	signature:(Index n) const
bottomRows	src/plugins/BlockMethods.h	/^inline RowsBlockXpr bottomRows(Index n)$/;"	f	signature:(Index n)
bottomRows	src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type bottomRows(Index n = N) const$/;"	f	signature:(Index n = N) const
bottomRows	src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type bottomRows(Index n = N)$/;"	f	signature:(Index n = N)
bruteforce_det3_helper	src/LU/Determinant.h	/^inline const typename Derived::Scalar bruteforce_det3_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int a, int b, int c)
bruteforce_det4_helper	src/LU/Determinant.h	/^const typename Derived::Scalar bruteforce_det4_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int j, int k, int m, int n)
c	src/Jacobi/Jacobi.h	/^    Scalar c() const { return m_c; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
c	src/Jacobi/Jacobi.h	/^    Scalar& c() { return m_c; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
c_to_fortran_numbering	src/PaStiXSupport/PaStiXSupport.h	/^  void c_to_fortran_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
cast	src/Core/MathFunctions.h	/^inline NewType cast(const OldType& x)$/;"	f	namespace:Eigen::internal	signature:(const OldType& x)
cast	src/Eigen2Support/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
cast	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
cast	src/Eigen2Support/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
cast	src/Eigen2Support/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
cast	src/Eigen2Support/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Quaternion,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
cast	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
cast	src/Eigen2Support/Geometry/Scaling.h	/^  inline typename internal::cast_return_type<Scaling,Scaling<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Scaling	access:public	signature:() const
cast	src/Eigen2Support/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
cast	src/Eigen2Support/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation	access:public	signature:() const
cast	src/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
cast	src/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
cast	src/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
cast	src/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
cast	src/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
cast	src/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
cast	src/Geometry/Scaling.h	/^  inline UniformScaling<NewScalarType> cast() const$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
cast	src/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim,Mode,Options> >::type cast() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
cast	src/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation	access:public	signature:() const
cast	src/plugins/CommonCwiseUnaryOps.h	/^cast() const$/;"	f	signature:() const
cast_impl	src/Core/MathFunctions.h	/^struct cast_impl$/;"	s	namespace:Eigen::internal
cast_to_pointer_type	src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return const_cast<PointerType>(ptr); }$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType ptr)
cast_to_pointer_type	src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType ptr)
caxpy	src/misc/blas.h	/^int    BLASFUNC(caxpy) (int *, float  *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *, float *, int *)
caxpyc	src/misc/blas.h	/^int    BLASFUNC(caxpyc)(int *, float  *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *, float *, int *)
ccopy	src/misc/blas.h	/^int    BLASFUNC(ccopy) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
cdiv	src/Eigenvalues/EigenSolver.h	/^std::complex<Scalar> cdiv(const Scalar& xr, const Scalar& xi, const Scalar& yr, const Scalar& yi)$/;"	f	namespace:Eigen	signature:(const Scalar& xr, const Scalar& xi, const Scalar& yr, const Scalar& yi)
cdotcw	src/misc/blas.h	/^int  BLASFUNC(cdotcw)  (int *, float  *, int *, float  *, int *, float*);$/;"	p	signature:(int *, float *, int *, float *, int *, float*)
cdotuw	src/misc/blas.h	/^int  BLASFUNC(cdotuw)  (int *, float  *, int *, float  *, int *, float*);$/;"	p	signature:(int *, float *, int *, float *, int *, float*)
center	src/Geometry/AlignedBox.h	/^  center() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
cgbmv	src/misc/blas.h	/^int BLASFUNC(cgbmv)(char *, int *, int *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cge2mm	src/misc/blas.h	/^int BLASFUNC(cge2mm)(char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cgema	src/misc/blas.h	/^int BLASFUNC(cgema)(char *, char *, int *, int *, float  *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *, float *, int *)
cgemm	src/misc/blas.h	/^int BLASFUNC(cgemm)(char *, char *, int *, int *, int *, float *,$/;"	p	signature:(char *, char *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cgemm3m	src/misc/blas.h	/^int BLASFUNC(cgemm3m)(char *, char *, int *, int *, int *, float *,$/;"	p	signature:(char *, char *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cgems	src/misc/blas.h	/^int BLASFUNC(cgems)(char *, char *, int *, int *, float  *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *, float *, int *)
cgemt	src/misc/blas.h	/^int BLASFUNC(cgemt)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *)
cgemv	src/misc/blas.h	/^int BLASFUNC(cgemv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cgerc	src/misc/blas.h	/^int BLASFUNC(cgerc)(int *,    int *, float *,  float *, int *,$/;"	p	signature:(int *, int *, float *, float *, int *, float *, int *, float *, int *)
cgeru	src/misc/blas.h	/^int BLASFUNC(cgeru)(int *,    int *, float *,  float *, int *,$/;"	p	signature:(int *, int *, float *, float *, int *, float *, int *, float *, int *)
cgesv	src/misc/blas.h	/^int BLASFUNC(cgesv)(int *, int *, float  *, int *, int *, float *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, float *, int *, int *)
cgetf2	src/misc/blas.h	/^int BLASFUNC(cgetf2)(int *, int *, float  *, int *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, int *)
cgetrf	src/misc/blas.h	/^int BLASFUNC(cgetrf)(int *, int *, float  *, int *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, int *)
cgetrs	src/misc/blas.h	/^int BLASFUNC(cgetrs)(char *, int *, int *, float  *, int *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, int *, float *, int *, int *, float *, int *, int *)
chbmv	src/misc/blas.h	/^int BLASFUNC(chbmv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
checkSanity	src/Core/MapBase.h	/^    void checkSanity() const$/;"	f	class:Eigen::MapBase	access:protected	signature:() const
checkTransposeAliasing	src/Core/DenseBase.h	/^    void checkTransposeAliasing(const OtherDerived& other) const;$/;"	p	class:Eigen::DenseBase	access:protected	signature:(const OtherDerived& other) const
checkTransposeAliasing	src/Core/Transpose.h	/^void DenseBase<Derived>::checkTransposeAliasing(const OtherDerived& other) const$/;"	f	class:Eigen::DenseBase	signature:(const OtherDerived& other) const
checkTransposeAliasing_impl	src/Core/Transpose.h	/^struct checkTransposeAliasing_impl$/;"	s	namespace:Eigen::internal
checkTransposeAliasing_impl	src/Core/Transpose.h	/^struct checkTransposeAliasing_impl<Derived, OtherDerived, false>$/;"	s	namespace:Eigen::internal
check_DenseIndex_is_signed	src/Core/DenseBase.h	/^static inline void check_DenseIndex_is_signed() {$/;"	f	namespace:Eigen::internal	signature:()
check_coordinates	src/Core/TriangularMatrix.h	/^    void check_coordinates(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index row, Index col) const
check_coordinates_internal	src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index , Index ) const {}$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index , Index ) const
check_coordinates_internal	src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index row, Index col) const
check_rows_cols_for_overflow	src/Core/PlainObjectBase.h	/^template<> struct check_rows_cols_for_overflow<Dynamic> {$/;"	s	namespace:Eigen::internal
check_rows_cols_for_overflow	src/Core/PlainObjectBase.h	/^template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow {$/;"	s	namespace:Eigen::internal
check_size_for_overflow	src/Core/util/Memory.h	/^EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
check_static_allocation_size	src/Core/DenseStorage.h	/^template<typename T, int Size> void check_static_allocation_size()$/;"	f	namespace:Eigen::internal	signature:()
check_template_parameters	src/Cholesky/LDLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LDLT	access:protected	signature:()
check_template_parameters	src/Cholesky/LLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LLT	access:protected	signature:()
check_template_parameters	src/Eigenvalues/ComplexEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ComplexEigenSolver	access:protected	signature:()
check_template_parameters	src/Eigenvalues/EigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::EigenSolver	access:protected	signature:()
check_template_parameters	src/Eigenvalues/GeneralizedEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::GeneralizedEigenSolver	access:protected	signature:()
check_template_parameters	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:protected	signature:()
check_template_parameters	src/LU/FullPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivLU	access:protected	signature:()
check_template_parameters	src/LU/PartialPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::PartialPivLU	access:protected	signature:()
check_template_parameters	src/QR/ColPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ColPivHouseholderQR	access:protected	signature:()
check_template_parameters	src/QR/FullPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivHouseholderQR	access:protected	signature:()
check_template_parameters	src/QR/HouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::HouseholderQR	access:protected	signature:()
check_template_parameters	src/SVD/JacobiSVD.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::JacobiSVD	access:private	signature:()
check_template_parameters	src/SparseCore/SparseMatrix.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SparseMatrix	access:private	signature:()
check_template_parameters	src/SparseCore/SparseVector.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SparseVector	access:protected	signature:()
check_template_params	src/Geometry/Transform.h	/^    static EIGEN_STRONG_INLINE void check_template_params()$/;"	f	class:Eigen::Transform	access:protected	signature:()
check_that_malloc_is_allowed	src/Core/util/Memory.h	/^inline void check_that_malloc_is_allowed()$/;"	f	namespace:Eigen::internal	signature:()
check_transpose_aliasing_compile_time_selector	src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_compile_time_selector	src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
chemm	src/misc/blas.h	/^int BLASFUNC(chemm)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
chemm3m	src/misc/blas.h	/^int BLASFUNC(chemm3m)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
chemv	src/misc/blas.h	/^int BLASFUNC(chemv) (char *, int *, float  *, float *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cher	src/misc/blas.h	/^int BLASFUNC(cher) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *)
cher2	src/misc/blas.h	/^int BLASFUNC(cher2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, int *)
cher2k	src/misc/blas.h	/^int BLASFUNC(cher2k)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cher2m	src/misc/blas.h	/^int BLASFUNC(cher2m)(char *, char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cherk	src/misc/blas.h	/^int BLASFUNC(cherk)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *)
cholmod	src/CholmodSupport/CholmodSupport.h	/^    cholmod_common& cholmod() { return m_cholmod; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
cholmodCommon	src/SPQRSupport/SuiteSparseQRSupport.h	/^    cholmod_common *cholmodCommon() const { return &m_cc; }$/;"	f	class:Eigen::SPQR	access:public	signature:() const
cholmod_configure_matrix	src/CholmodSupport/CholmodSupport.h	/^void cholmod_configure_matrix(CholmodType& mat)$/;"	f	namespace:Eigen::internal	signature:(CholmodType& mat)
chpmv	src/misc/blas.h	/^int BLASFUNC(chpmv) (char *, int *, float  *, float *,$/;"	p	signature:(char *, int *, float *, float *, float *, int *, float *, float *, int *)
chpr	src/misc/blas.h	/^int BLASFUNC(chpr) (char *, int *, float   *, float  *, int *, float  *);$/;"	p	signature:(char *, int *, float *, float *, int *, float *)
chpr2	src/misc/blas.h	/^int BLASFUNC(chpr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *)
cj	src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
cj	src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,ConjLhs,false> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
cj	src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,false,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
clamp	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
clamp	src/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
claswp	src/misc/blas.h	/^int BLASFUNC(claswp)(int *, float  *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, float *, int *, int *, int *, int *, int *)
clauu2	src/misc/blas.h	/^int BLASFUNC(clauu2)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
clauum	src/misc/blas.h	/^int BLASFUNC(clauum)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
clean	src/PaStiXSupport/PaStiXSupport.h	/^    void clean()$/;"	f	class:Eigen::PastixBase	access:protected	signature:()
clear	src/SparseCore/CompressedStorage.h	/^    inline void clear() { m_size = 0; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
clearFactors	src/SuperLUSupport/SuperLUSupport.h	/^    void clearFactors()$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:()
clear_mark	src/OrderingMethods/Eigen_Colamd.h	/^static inline  Index clear_mark  \/* return the new value for tag_mark *\/$/;"	f	namespace:internal	signature:( Index n_row, Colamd_Row<Index> Row [] )
clear_mark	src/OrderingMethods/Eigen_Colamd.h	/^static inline  Index clear_mark (Index n_row, Colamd_Row<Index> Row [] ) ;$/;"	p	namespace:internal	signature:(Index n_row, Colamd_Row<Index> Row [] )
cmp_EQ	src/Core/util/Constants.h	/^    cmp_EQ = 0,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_LE	src/Core/util/Constants.h	/^    cmp_LE = 2,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_LT	src/Core/util/Constants.h	/^    cmp_LT = 1,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_NEQ	src/Core/util/Constants.h	/^    cmp_NEQ = 4$/;"	e	enum:Eigen::internal::ComparisonName
cmp_UNORD	src/Core/util/Constants.h	/^    cmp_UNORD = 3,$/;"	e	enum:Eigen::internal::ComparisonName
cnorm	src/misc/blas.h	/^int BLASFUNC(cnorm)(char *, int *, int *, float  *, int *);$/;"	p	signature:(char *, int *, int *, float *, int *)
coeff	src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
coeff	src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
coeff	src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/Block.h	/^    EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/Block.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index) const
coeff	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index index) const
coeff	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index index) const
coeff	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index index) const
coeff	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index index) const
coeff	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index row, Index col) const
coeff	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
coeff	src/Core/DenseCoeffsBase.h	/^    coeff(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
coeff	src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index idx) const$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index idx) const
coeff	src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index row, Index) const$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index row, Index) const
coeff	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index idx) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index idx) const
coeff	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index row, Index col) const
coeff	src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
coeff	src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
coeff	src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index) const
coeff	src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col) const
coeff	src/Core/MapBase.h	/^    inline const Scalar& coeff(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
coeff	src/Core/MapBase.h	/^    inline const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index) const
coeff	src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col) const
coeff	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
coeff	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/Replicate.h	/^    inline Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::Replicate	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index) const
coeff	src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index,Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index,Index) const
coeff	src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index) const
coeff	src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col) const
coeff	src/Core/Select.h	/^    const Scalar coeff(Index i) const$/;"	f	class:Eigen::Select	access:public	signature:(Index i) const
coeff	src/Core/Select.h	/^    const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::Select	access:public	signature:(Index i, Index j) const
coeff	src/Core/SelfAdjointView.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(Index row, Index col) const
coeff	src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
coeff	src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId) const
coeff	src/Core/Transpositions.h	/^    inline const Index& coeff(Index i) const { return indices().coeff(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
coeff	src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const  { return derived().coeff(row,col); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col) const
coeff	src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(Index row, Index col) const
coeff	src/Core/VectorwiseOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(Index i, Index j) const
coeff	src/Core/VectorwiseOp.h	/^    const Scalar coeff(Index index) const$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(Index index) const
coeff	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index index) const
coeff	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index row, Index col) const
coeff	src/Eigen2Support/Minor.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Minor	access:public	signature:(Index row, Index col) const
coeff	src/Geometry/Homogeneous.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Homogeneous	access:public	signature:(Index row, Index col) const
coeff	src/SparseCore/AmbiVector.h	/^    Scalar& coeff(Index i);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(Index i)
coeff	src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeff(_Index i)$/;"	f	class:Eigen::internal::AmbiVector	signature:(_Index i)
coeff	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index row, Index col) const
coeff	src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(int index) const$/;"	f	class:Eigen::BlockImpl	access:public	signature:(int index) const
coeff	src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(int row, int col) const$/;"	f	class:Eigen::BlockImpl	access:public	signature:(int row, int col) const
coeff	src/SparseCore/SparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col) const
coeff	src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index i) const$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i) const
coeff	src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col) const
coeffByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
coeffRef	src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index)
coeffRef	src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index)
coeffRef	src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId)
coeffRef	src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId)
coeffRef	src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
coeffRef	src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
coeffRef	src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId) const
coeffRef	src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId) const
coeffRef	src/Core/Block.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index)
coeffRef	src/Core/Block.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId)
coeffRef	src/Core/Block.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index) const
coeffRef	src/Core/Block.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId) const
coeffRef	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index index)
coeffRef	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index row, Index col)
coeffRef	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col)
coeffRef	src/Core/DenseCoeffsBase.h	/^    coeffRef(Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
coeffRef	src/Core/DenseCoeffsBase.h	/^    void coeffRef();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
coeffRef	src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index idx)$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index idx)
coeffRef	src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index row, Index)$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index row, Index)
coeffRef	src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index idx) const$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index idx) const
coeffRef	src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index row, Index) const$/;"	f	class:Eigen::Diagonal	access:public	signature:(Index row, Index) const
coeffRef	src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index)
coeffRef	src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col)
coeffRef	src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
coeffRef	src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
coeffRef	src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index)
coeffRef	src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col)
coeffRef	src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index)
coeffRef	src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col)
coeffRef	src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
coeffRef	src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index rowId, Index colId) const
coeffRef	src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index)
coeffRef	src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col)
coeffRef	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index)
coeffRef	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId)
coeffRef	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
coeffRef	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId) const
coeffRef	src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index i) const$/;"	f	namespace:Eigen	signature:(Index i) const
coeffRef	src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index row, Index col) const$/;"	f	namespace:Eigen	signature:(Index row, Index col) const
coeffRef	src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index)
coeffRef	src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index,Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index,Index)
coeffRef	src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index)
coeffRef	src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col)
coeffRef	src/Core/SelfAdjointView.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(Index row, Index col)
coeffRef	src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index)
coeffRef	src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col)
coeffRef	src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index) const
coeffRef	src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col) const
coeffRef	src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index) const
coeffRef	src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index)
coeffRef	src/Core/Swap.h	/^    inline Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index rowId, Index colId) const
coeffRef	src/Core/Swap.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index rowId, Index colId)
coeffRef	src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index)
coeffRef	src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId)
coeffRef	src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
coeffRef	src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId) const
coeffRef	src/Core/Transpositions.h	/^    inline Index& coeffRef(Index i) { return indices().coeffRef(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
coeffRef	src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col)
coeffRef	src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TriangularView	access:public	signature:(Index row, Index col)
coeffRef	src/Eigen2Support/Minor.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Minor	access:public	signature:(Index row, Index col)
coeffRef	src/SparseCore/AmbiVector.h	/^    Scalar& coeffRef(Index i);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(Index i)
coeffRef	src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeffRef(_Index i)$/;"	f	class:Eigen::internal::AmbiVector	signature:(_Index i)
coeffRef	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index row, Index col)
coeffRef	src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(int index)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(int index)
coeffRef	src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(int row, int col)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(int row, int col)
coeffRef	src/SparseCore/SparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
coeffRef	src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
coeffRef	src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col)
coeffRefByOuterInner	src/Core/DenseCoeffsBase.h	/^    coeffRefByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner)
coeffRefByOuterInner	src/Core/DenseCoeffsBase.h	/^    void coeffRefByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
coeffSeparator	src/Core/IO.h	/^  std::string coeffSeparator;$/;"	m	struct:Eigen::IOFormat	access:public
coeff_visitor	src/Core/Visitor.h	/^struct coeff_visitor$/;"	s	namespace:Eigen::internal
coeffs	src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
coeffs	src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:()
coeffs	src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
coeffs	src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
coeffs	src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
coeffs	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
coeffs	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
coeffs	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
coeffs	src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
coeffs	src/Eigen2Support/Geometry/Scaling.h	/^  VectorType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Scaling	access:public	signature:()
coeffs	src/Eigen2Support/Geometry/Scaling.h	/^  const VectorType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Scaling	access:public	signature:() const
coeffs	src/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
coeffs	src/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
coeffs	src/Geometry/Quaternion.h	/^    inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Map	access:public	signature:()
coeffs	src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Map	access:public	signature:() const
coeffs	src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Map	access:public	signature:() const
coeffs	src/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs;}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
coeffs	src/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
coeffs	src/Geometry/Quaternion.h	/^  inline const typename internal::traits<Derived>::Coefficients& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
coeffs	src/Geometry/Quaternion.h	/^  inline typename internal::traits<Derived>::Coefficients& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
cofactor_3x3	src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_3x3(const MatrixType& m)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& m)
cofactor_4x4	src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_4x4(const MatrixType& matrix)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& matrix)
col	src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,Dynamic,1> col(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i)
col	src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::all_unroller::__anon147
col	src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::any_unroller::__anon148
col	src/Core/CoreIterators.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
col	src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon316
col	src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon317
col	src/Core/TriangularMatrix.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon329
col	src/Core/Visitor.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_impl::__anon336
col	src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
col	src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
col	src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
col	src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
col	src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
col	src/SparseCore/SparseBlock.h	/^      inline Index col()    const { return Base::col()   - m_block.m_startCol.value(); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
col	src/SparseCore/SparseBlock.h	/^      inline Index col()    const { return Base::col()   - m_block.m_startCol.value(); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
col	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return Lhs::IsRowMajor ? index() : m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
col	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
col	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_rhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
col	src/SparseCore/SparseDenseProduct.h	/^    inline Index col() const { return Transpose ? Base::index() : m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
col	src/SparseCore/SparseDiagonalProduct.h	/^    inline Index col() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:() const
col	src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
col	src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
col	src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:() const
col	src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:() const
col	src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return (MatrixType::Flags&RowMajorBit ? this->index() : Base::outer()); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
col	src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return Base::col(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
col	src/SparseCore/SparseUtil.h	/^  const Index& col() const { return m_col; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
col	src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
col	src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
col	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index col() const { return m_outer; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
col	src/plugins/BlockMethods.h	/^inline ColXpr col(Index i)$/;"	f	signature:(Index i)
col	src/plugins/BlockMethods.h	/^inline ConstColXpr col(Index i) const$/;"	f	signature:(Index i) const
colIndexByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
colIndexPtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* colIndexPtr()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
colIndexPtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* colIndexPtr() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
colOffset	src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }$/;"	f	class:Eigen::Diagonal	access:private	signature:() const
colPivHouseholderQr	src/Core/MatrixBase.h	/^    const ColPivHouseholderQR<PlainObject> colPivHouseholderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
colPivHouseholderQr	src/QR/ColPivHouseholderQR.h	/^MatrixBase<Derived>::colPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
colStride	src/Core/DenseCoeffsBase.h	/^    inline Index colStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
colStride	src/Core/DenseCoeffsBase.h	/^    void colStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
colToSup	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* colToSup()  { return m_col_to_sup; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
colToSup	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* colToSup() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
colamd	src/OrderingMethods/Eigen_Colamd.h	/^static bool colamd(Index n_row, Index n_col, Index Alen, Index *A, Index *p, double knobs[COLAMD_KNOBS], Index stats[COLAMD_STATS])$/;"	f	namespace:internal	signature:(Index n_row, Index n_col, Index Alen, Index *A, Index *p, double knobs[COLAMD_KNOBS], Index stats[COLAMD_STATS])
colamd_c	src/OrderingMethods/Eigen_Colamd.h	/^inline Index colamd_c(Index n_col) $/;"	f	namespace:internal	signature:(Index n_col)
colamd_col	src/OrderingMethods/Eigen_Colamd.h	/^struct colamd_col$/;"	s	namespace:internal
colamd_r	src/OrderingMethods/Eigen_Colamd.h	/^inline Index  colamd_r(Index n_row)$/;"	f	namespace:internal	signature:(Index n_row)
colamd_recommended	src/OrderingMethods/Eigen_Colamd.h	/^inline Index colamd_recommended ( Index nnz, Index n_row, Index n_col)$/;"	f	namespace:internal	signature:( Index nnz, Index n_row, Index n_col)
colamd_set_defaults	src/OrderingMethods/Eigen_Colamd.h	/^static inline void colamd_set_defaults(double knobs[COLAMD_KNOBS])$/;"	f	namespace:internal	signature:(double knobs[COLAMD_KNOBS])
colblk	src/SparseLU/SparseLU_Structs.h	/^  Index colblk; \/\/ The minimum column dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues	access:public
coletree	src/SparseCore/SparseColEtree.h	/^int coletree(const MatrixType& mat, IndexVector& parent, IndexVector& firstRowElt, typename MatrixType::Index *perm=0)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, IndexVector& parent, IndexVector& firstRowElt, typename MatrixType::Index *perm=0)
cols	src/Cholesky/LDLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LDLT	access:public	signature:() const
cols	src/Cholesky/LLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LLT	access:public	signature:() const
cols	src/CholmodSupport/CholmodSupport.h	/^    inline Index cols() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
cols	src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
cols	src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
cols	src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
cols	src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
cols	src/Core/Block.h	/^    inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
cols	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
cols	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
cols	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
cols	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
cols	src/Core/DenseStorage.h	/^    DenseIndex cols() const {return m_cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
cols	src/Core/DenseStorage.h	/^    DenseIndex cols(void) const {return _Cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
cols	src/Core/DenseStorage.h	/^    DenseIndex cols(void) const {return m_cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
cols	src/Core/DenseStorage.h	/^    static DenseIndex cols(void) {return _Cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void)
cols	src/Core/Diagonal.h	/^    inline Index cols() const { return 1; }$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
cols	src/Core/DiagonalMatrix.h	/^    inline Index cols() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
cols	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:() const
cols	src/Core/EigenBase.h	/^  inline Index cols() const { return derived().cols(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
cols	src/Core/Flagged.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
cols	src/Core/ForceAlignedAccess.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
cols	src/Core/MapBase.h	/^    inline Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
cols	src/Core/NestByValue.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
cols	src/Core/PermutationMatrix.h	/^    inline Index cols() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
cols	src/Core/PermutationMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:() const
cols	src/Core/PermutationMatrix.h	/^    inline int cols() const { return m_permutation.cols(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
cols	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
cols	src/Core/ProductBase.h	/^      eigen_assert(this->rows() == 1 && this->cols() == 1);$/;"	t	class:Eigen::ProductBase	access:public
cols	src/Core/Replicate.h	/^    inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }$/;"	f	class:Eigen::Replicate	access:public	signature:() const
cols	src/Core/ReturnByValue.h	/^    inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:() const
cols	src/Core/Reverse.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Reverse	access:public	signature:() const
cols	src/Core/Select.h	/^    Index cols() const { return m_condition.cols(); }$/;"	f	class:Eigen::Select	access:public	signature:() const
cols	src/Core/SelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
cols	src/Core/SelfCwiseBinaryOp.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
cols	src/Core/SolveTriangular.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:() const
cols	src/Core/Swap.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
cols	src/Core/Transpose.h	/^    inline Index cols() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
cols	src/Core/Transpositions.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:() const
cols	src/Core/TriangularMatrix.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
cols	src/Core/TriangularMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
cols	src/Core/VectorwiseOp.h	/^    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:() const
cols	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
cols	src/Eigen2Support/Minor.h	/^    inline Index cols() const { return m_matrix.cols() - 1; }$/;"	f	class:Eigen::Minor	access:public	signature:() const
cols	src/Eigenvalues/HessenbergDecomposition.h	/^    Index cols() const { return m_hess.packedMatrix().cols(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:() const
cols	src/Eigenvalues/Tridiagonalization.h	/^    Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:() const
cols	src/Geometry/Homogeneous.h	/^    inline Index cols() const { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous	access:public	signature:() const
cols	src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:() const
cols	src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:() const
cols	src/Householder/HouseholderSequence.h	/^    Index cols() const { return rows(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
cols	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index cols() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:() const
cols	src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
cols	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index cols() const { return mp_matrix ? mp_matrix->cols() : 0; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
cols	src/LU/FullPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
cols	src/LU/Inverse.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:() const
cols	src/LU/PartialPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
cols	src/PaStiXSupport/PaStiXSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
cols	src/PardisoSupport/PardisoSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
cols	src/QR/ColPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
cols	src/QR/FullPivHouseholderQR.h	/^    Index cols() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:() const
cols	src/QR/FullPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
cols	src/QR/HouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
cols	src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index cols() const { return m_cR->ncol; }$/;"	f	class:Eigen::SPQR	access:public	signature:() const
cols	src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct	access:public	signature:() const
cols	src/SVD/JacobiSVD.h	/^    inline Index cols() const { return m_cols; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
cols	src/SparseCholesky/SimplicialCholesky.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
cols	src/SparseCore/MappedSparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
cols	src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
cols	src/SparseCore/SparseBlock.h	/^    inline int cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
cols	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return Tr ? m_lhs.cols() : m_rhs.cols(); }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
cols	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
cols	src/SparseCore/SparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
cols	src/SparseCore/SparseMatrixBase.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
cols	src/SparseCore/SparsePermutation.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:() const
cols	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
cols	src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
cols	src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:() const
cols	src/SparseCore/SparseTriangularView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
cols	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsColVector ? 1 : m_size; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
cols	src/SparseCore/SparseView.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
cols	src/SparseLU/SparseLU.h	/^    inline Index cols() const { return m_mat.cols(); }$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
cols	src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType	access:public	signature:()
cols	src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType	access:public	signature:()
cols	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index cols() { return m_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
cols	src/SparseQR/SparseQR.h	/^    inline Index cols() const { return m_pmat.cols();}$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
cols	src/SparseQR/SparseQR.h	/^  inline Index cols() const { return (std::min)(m_qr.rows(),m_qr.cols()); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:() const
cols	src/SparseQR/SparseQR.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SparseQR_QProduct	access:public	signature:() const
cols	src/SuperLUSupport/SuperLUSupport.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
cols	src/UmfPackSupport/UmfPackSupport.h	/^    inline Index cols() const { return m_copyMatrix.cols(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
cols	src/misc/Image.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
cols	src/misc/Kernel.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
cols	src/misc/Solve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
cols	src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:() const
cols	src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
colsPermutation	src/QR/ColPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
colsPermutation	src/QR/FullPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
colsPermutation	src/SPQRSupport/SuiteSparseQRSupport.h	/^    PermutationType colsPermutation() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
colsPermutation	src/SparseLU/SparseLU.h	/^    inline const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
colsPermutation	src/SparseQR/SparseQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
cols_select	src/Core/GeneralProduct.h	/^    cols_select = product_size_category<Cols,MaxCols>::value,$/;"	e	enum:Eigen::internal::product_type::__anon244
column_bmod	src/SparseLU/SparseLUImpl.h	/^     Index column_bmod(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t& glu)
column_bmod	src/SparseLU/SparseLU_column_bmod.h	/^Index SparseLUImpl<Scalar,Index>::column_bmod(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t& glu)
column_dfs	src/SparseLU/SparseLUImpl.h	/^     Index column_dfs(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg,  BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg, BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)
column_dfs	src/SparseLU/SparseLU_column_dfs.h	/^Index SparseLUImpl<Scalar,Index>::column_dfs(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg,  BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg, BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)
column_dfs_traits	src/SparseLU/SparseLU_column_dfs.h	/^  column_dfs_traits(Index jcol, Index& jsuper, typename SparseLUImpl<Scalar, Index>::GlobalLU_t& glu, SparseLUImpl<Scalar, Index>& luImpl)$/;"	f	struct:Eigen::internal::column_dfs_traits	access:public	signature:(Index jcol, Index& jsuper, typename SparseLUImpl<Scalar, Index>::GlobalLU_t& glu, SparseLUImpl<Scalar, Index>& luImpl)
column_dfs_traits	src/SparseLU/SparseLU_column_dfs.h	/^struct column_dfs_traits : no_assignment_operator$/;"	s	namespace:Eigen::internal	inherits:no_assignment_operator
colwise	src/Core/DenseBase.h	/^    ColwiseReturnType colwise();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
colwise	src/Core/DenseBase.h	/^    ConstColwiseReturnType colwise() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
colwise	src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise() const$/;"	f	class:Eigen::DenseBase	signature:() const
colwise	src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise()$/;"	f	class:Eigen::DenseBase	signature:()
complex_schur_reduce_to_hessenberg	src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg$/;"	s	namespace:Eigen::internal
complex_schur_reduce_to_hessenberg	src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg<MatrixType, false>$/;"	s	namespace:Eigen::internal
compute	src/Cholesky/LDLT.h	/^    LDLT& compute(const MatrixType& matrix);$/;"	p	class:Eigen::LDLT	access:public	signature:(const MatrixType& matrix)
compute	src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LDLT	signature:(const MatrixType& a)
compute	src/Cholesky/LLT.h	/^    LLT& compute(const MatrixType& matrix);$/;"	p	class:Eigen::LLT	access:public	signature:(const MatrixType& matrix)
compute	src/Cholesky/LLT.h	/^LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LLT	signature:(const MatrixType& a)
compute	src/CholmodSupport/CholmodSupport.h	/^    Derived& compute(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
compute	src/Eigen2Support/SVD.h	/^    void compute(const MatrixType& matrix);$/;"	p	class:Eigen::SVD	access:public	signature:(const MatrixType& matrix)
compute	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::SVD	signature:(const MatrixType& matrix)
compute	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);$/;"	p	class:Eigen::ComplexEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
compute	src/Eigenvalues/ComplexEigenSolver.h	/^ComplexEigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(const MatrixType& matrix, bool computeEigenvectors)
compute	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& compute(const MatrixType& matrix, bool computeU = true);$/;"	p	class:Eigen::ComplexSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
compute	src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(const MatrixType& matrix, bool computeU)
compute	src/Eigenvalues/EigenSolver.h	/^    EigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);$/;"	p	class:Eigen::EigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
compute	src/Eigenvalues/EigenSolver.h	/^EigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::EigenSolver	signature:(const MatrixType& matrix, bool computeEigenvectors)
compute	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver& compute(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true);$/;"	p	class:Eigen::GeneralizedEigenSolver	access:public	signature:(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true)
compute	src/Eigenvalues/GeneralizedEigenSolver.h	/^GeneralizedEigenSolver<MatrixType>::compute(const MatrixType& A, const MatrixType& B, bool computeEigenvectors)$/;"	f	class:Eigen::GeneralizedEigenSolver	signature:(const MatrixType& A, const MatrixType& B, bool computeEigenvectors)
compute	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver& compute(const MatrixType& matA, const MatrixType& matB,$/;"	p	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, int options = ComputeEigenvectors|Ax_lBx)
compute	src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^compute(const MatrixType& matA, const MatrixType& matB, int options)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	signature:(const MatrixType& matA, const MatrixType& matB, int options)
compute	src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition& compute(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(const MatrixType& matrix)
compute	src/Eigenvalues/RealQZ.h	/^      RealQZ& compute(const MatrixType& A, const MatrixType& B, bool computeQZ = true);$/;"	p	class:Eigen::RealQZ	access:public	signature:(const MatrixType& A, const MatrixType& B, bool computeQZ = true)
compute	src/Eigenvalues/RealQZ.h	/^    RealQZ<MatrixType>& RealQZ<MatrixType>::compute(const MatrixType& A_in, const MatrixType& B_in, bool computeQZ)$/;"	f	class:Eigen::RealQZ	signature:(const MatrixType& A_in, const MatrixType& B_in, bool computeQZ)
compute	src/Eigenvalues/RealSchur.h	/^    RealSchur& compute(const MatrixType& matrix, bool computeU = true);$/;"	p	class:Eigen::RealSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
compute	src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::RealSchur	signature:(const MatrixType& matrix, bool computeU)
compute	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver& compute(const MatrixType& matrix, int options = ComputeEigenvectors);$/;"	p	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
compute	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)
compute	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors)
compute	src/Eigenvalues/SelfAdjointEigenSolver.h	/^::compute(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver	signature:(const MatrixType& matrix, int options)
compute	src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization& compute(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(const MatrixType& matrix)
compute	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& compute(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatType& mat)
compute	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& compute(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
compute	src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT<Scalar>& compute(const MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
compute	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& compute(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const EigenBase<InputDerived>& A)
compute	src/LU/FullPivLU.h	/^    FullPivLU& compute(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& matrix)
compute	src/LU/FullPivLU.h	/^FullPivLU<MatrixType>& FullPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU	signature:(const MatrixType& matrix)
compute	src/LU/PartialPivLU.h	/^    PartialPivLU& compute(const MatrixType& matrix);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(const MatrixType& matrix)
compute	src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>& PartialPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU	signature:(const MatrixType& matrix)
compute	src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
compute	src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
compute	src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
compute	src/PaStiXSupport/PaStiXSupport.h	/^    void compute(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
compute	src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::compute(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
compute	src/PardisoSupport/PardisoSupport.h	/^    Derived& compute(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
compute	src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::compute(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
compute	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
compute	src/QR/ColPivHouseholderQR.h	/^ColPivHouseholderQR<MatrixType>& ColPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR	signature:(const MatrixType& matrix)
compute	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
compute	src/QR/FullPivHouseholderQR.h	/^FullPivHouseholderQR<MatrixType>& FullPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR	signature:(const MatrixType& matrix)
compute	src/QR/HouseholderQR.h	/^    HouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::HouseholderQR	access:public	signature:(const MatrixType& matrix)
compute	src/QR/HouseholderQR.h	/^HouseholderQR<MatrixType>& HouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR	signature:(const MatrixType& matrix)
compute	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void compute(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR	access:public	signature:(const _MatrixType& matrix)
compute	src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix)
compute	src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix, unsigned int computationOptions);$/;"	p	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix, unsigned int computationOptions)
compute	src/SVD/JacobiSVD.h	/^JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType& matrix, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD	signature:(const MatrixType& matrix, unsigned int computationOptions)
compute	src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization& compute(const MatrixType& matrix);$/;"	p	class:Eigen::internal::UpperBidiagonalization	access:public	signature:(const MatrixType& matrix)
compute	src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::compute(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization	signature:(const _MatrixType& matrix)
compute	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& matrix)
compute	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& matrix)
compute	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& matrix)
compute	src/SparseCholesky/SimplicialCholesky.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& matrix)
compute	src/SparseLU/SparseLU.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
compute	src/SparseQR/SparseQR.h	/^    void compute(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR	access:public	signature:(const MatrixType& mat)
compute	src/SuperLUSupport/SuperLUSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixType& matrix)
compute	src/UmfPackSupport/UmfPackSupport.h	/^    void compute(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const InputMatrixType& matrix)
computeDirect	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver& computeDirect(const MatrixType& matrix, int options = ComputeEigenvectors);$/;"	p	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
computeDirect	src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeDirect(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver	signature:(const MatrixType& matrix, int options)
computeFromHessenberg	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU=true);$/;"	p	class:Eigen::ComplexSchur	access:public	signature:(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU=true)
computeFromHessenberg	src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)
computeFromHessenberg	src/Eigenvalues/RealSchur.h	/^    RealSchur& computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU);$/;"	p	class:Eigen::RealSchur	access:public	signature:(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)
computeFromHessenberg	src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU)$/;"	f	class:Eigen::RealSchur	signature:(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)
computeImage	src/Eigen2Support/LU.h	/^    void computeImage(ImageMatrixType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(ImageMatrixType *result) const
computeInverse	src/Core/MatrixBase.h	/^    void computeInverse(MatrixBase<ResultType> *result) const {$/;"	f	class:Eigen::MatrixBase	access:public	signature:(MatrixBase<ResultType> *result) const
computeInverse	src/Eigen2Support/LU.h	/^    inline void computeInverse(ResultType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(ResultType *result) const
computeInverseAndDetWithCheck	src/Core/MatrixBase.h	/^    void computeInverseAndDetWithCheck($/;"	p	class:Eigen::MatrixBase	access:public	signature:( ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible, const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision() ) const
computeInverseAndDetWithCheck	src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseAndDetWithCheck($/;"	f	class:Eigen::MatrixBase	signature:( ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible, const RealScalar& absDeterminantThreshold ) const
computeInverseWithCheck	src/Core/MatrixBase.h	/^    void computeInverseWithCheck($/;"	p	class:Eigen::MatrixBase	access:public	signature:( ResultType& inverse, bool& invertible, const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision() ) const
computeInverseWithCheck	src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseWithCheck($/;"	f	class:Eigen::MatrixBase	signature:( ResultType& inverse, bool& invertible, const RealScalar& absDeterminantThreshold ) const
computeKernel	src/Eigen2Support/LU.h	/^    void computeKernel(KernelMatrixType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(KernelMatrixType *result) const
computeNormOfT	src/Eigenvalues/RealSchur.h	/^    Scalar computeNormOfT();$/;"	p	class:Eigen::RealSchur	access:private	signature:()
computeNormOfT	src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()$/;"	f	class:Eigen::RealSchur	signature:()
computeNorms	src/Eigenvalues/RealQZ.h	/^      void computeNorms();$/;"	p	class:Eigen::RealQZ	access:private	signature:()
computeNorms	src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::computeNorms()$/;"	f	class:Eigen::RealQZ	signature:()
computePositiveUnitary	src/Eigen2Support/SVD.h	/^    void computePositiveUnitary(PositiveType *positive, UnitaryType *unitary) const;$/;"	p	class:Eigen::SVD	access:public	signature:(PositiveType *positive, UnitaryType *unitary) const
computePositiveUnitary	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computePositiveUnitary(UnitaryType *positive,$/;"	f	class:Eigen::SVD	signature:(UnitaryType *positive, PositiveType *unitary) const
computeProductBlockingSizes	src/Core/products/GeneralBlockPanelKernel.h	/^inline void computeProductBlockingSizes(SizeType& k, SizeType& m, SizeType& n)$/;"	f	namespace:Eigen::internal	signature:(SizeType& k, SizeType& m, SizeType& n)
computeProductBlockingSizes	src/Core/products/GeneralBlockPanelKernel.h	/^void computeProductBlockingSizes(SizeType& k, SizeType& m, SizeType& n)$/;"	f	namespace:Eigen::internal	signature:(SizeType& k, SizeType& m, SizeType& n)
computeRoots	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void computeRoots(const MatrixType& m, VectorType& roots)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(const MatrixType& m, VectorType& roots)
computeRotationScaling	src/Eigen2Support/Geometry/Transform.h	/^  void computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const;$/;"	p	class:Eigen::Transform	access:public	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
computeRotationScaling	src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
computeRotationScaling	src/Eigen2Support/SVD.h	/^    void computeRotationScaling(RotationType *unitary, ScalingType *positive) const;$/;"	p	class:Eigen::SVD	access:public	signature:(RotationType *unitary, ScalingType *positive) const
computeRotationScaling	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeRotationScaling(RotationType *rotation, ScalingType *scaling) const$/;"	f	class:Eigen::SVD	signature:(RotationType *rotation, ScalingType *scaling) const
computeRotationScaling	src/Geometry/Transform.h	/^  void computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const;$/;"	p	class:Eigen::Transform	access:public	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
computeRotationScaling	src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
computeScalingRotation	src/Eigen2Support/Geometry/Transform.h	/^  void computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const;$/;"	p	class:Eigen::Transform	access:public	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
computeScalingRotation	src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
computeScalingRotation	src/Eigen2Support/SVD.h	/^    void computeScalingRotation(ScalingType *positive, RotationType *unitary) const;$/;"	p	class:Eigen::SVD	access:public	signature:(ScalingType *positive, RotationType *unitary) const
computeScalingRotation	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeScalingRotation(ScalingType *scaling, RotationType *rotation) const$/;"	f	class:Eigen::SVD	signature:(ScalingType *scaling, RotationType *rotation) const
computeScalingRotation	src/Geometry/Transform.h	/^  void computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const;$/;"	p	class:Eigen::Transform	access:public	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
computeScalingRotation	src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
computeShift	src/Eigenvalues/ComplexSchur.h	/^    ComplexScalar computeShift(Index iu, Index iter);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(Index iu, Index iter)
computeShift	src/Eigenvalues/ComplexSchur.h	/^typename ComplexSchur<MatrixType>::ComplexScalar ComplexSchur<MatrixType>::computeShift(Index iu, Index iter)$/;"	f	class:Eigen::ComplexSchur	signature:(Index iu, Index iter)
computeShift	src/Eigenvalues/RealSchur.h	/^    void computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)
computeShift	src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)
computeU	src/SVD/JacobiSVD.h	/^    inline bool computeU() const { return m_computeFullU || m_computeThinU; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
computeUnitaryPositive	src/Eigen2Support/SVD.h	/^    void computeUnitaryPositive(UnitaryType *unitary, PositiveType *positive) const;$/;"	p	class:Eigen::SVD	access:public	signature:(UnitaryType *unitary, PositiveType *positive) const
computeUnitaryPositive	src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeUnitaryPositive(UnitaryType *unitary,$/;"	f	class:Eigen::SVD	signature:(UnitaryType *unitary, PositiveType *positive) const
computeV	src/SVD/JacobiSVD.h	/^    inline bool computeV() const { return m_computeFullV || m_computeThinV; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
compute_inverse	src/LU/Inverse.h	/^struct compute_inverse$/;"	s	namespace:Eigen::internal
compute_inverse	src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse	src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse	src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse	src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal	inherits:compute_inverse_size4
compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check { \/* nothing! general case not supported. *\/ };$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_size2_helper	src/LU/Inverse.h	/^inline void compute_inverse_size2_helper($/;"	f	namespace:Eigen::internal	signature:( const MatrixType& matrix, const typename ResultType::Scalar& invdet, ResultType& result)
compute_inverse_size3_helper	src/LU/Inverse.h	/^inline void compute_inverse_size3_helper($/;"	f	namespace:Eigen::internal	signature:( const MatrixType& matrix, const typename ResultType::Scalar& invdet, const Matrix<typename ResultType::Scalar,3,1>& cofactors_col0, ResultType& result)
compute_inverse_size4	src/LU/Inverse.h	/^struct compute_inverse_size4$/;"	s	namespace:Eigen::internal
compute_inverse_size4	src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, double, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
compute_inverse_size4	src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, float, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
conditionMatrix	src/Core/Select.h	/^    const ConditionMatrixType& conditionMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
conditional	src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	s	namespace:Eigen::internal
conditional	src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	s	namespace:Eigen::internal
conditional_aligned_delete	src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
conditional_aligned_delete_auto	src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete_auto(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
conditional_aligned_free	src/Core/util/Memory.h	/^template<> inline void conditional_aligned_free<false>(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
conditional_aligned_free	src/Core/util/Memory.h	/^template<bool Align> inline void conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
conditional_aligned_malloc	src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_malloc<false>(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
conditional_aligned_malloc	src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
conditional_aligned_new	src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
conditional_aligned_new_auto	src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new_auto(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
conditional_aligned_realloc	src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t new_size, size_t)
conditional_aligned_realloc	src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t new_size, size_t old_size)
conditional_aligned_realloc_new	src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(T* pts, size_t new_size, size_t old_size)
conditional_aligned_realloc_new_auto	src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(T* pts, size_t new_size, size_t old_size)
conj	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(conj, Scalar) conj(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
conj_expr_if	src/Core/products/SelfadjointRank2Update.h	/^template<bool Cond, typename T> struct conj_expr_if$/;"	s	namespace:Eigen::internal	inherits:conditional
conj_helper	src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet2d, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet4f, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2d, Packet1cd, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet4f, Packet2cf, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	src/Core/util/BlasUtil.h	/^template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>$/;"	s	namespace:Eigen::internal
conj_if	src/Core/util/BlasUtil.h	/^template<> struct conj_if<false> {$/;"	s	namespace:Eigen::internal
conj_if	src/Core/util/BlasUtil.h	/^template<> struct conj_if<true> {$/;"	s	namespace:Eigen::internal
conj_impl	src/Core/MathFunctions.h	/^struct conj_impl$/;"	s	namespace:Eigen::internal
conj_impl	src/Core/MathFunctions.h	/^struct conj_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
conj_retval	src/Core/MathFunctions.h	/^struct conj_retval$/;"	s	namespace:Eigen::internal
conjugate	src/Core/TriangularMatrix.h	/^    inline TriangularView<MatrixConjugateReturnType,Mode> conjugate()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
conjugate	src/Core/TriangularMatrix.h	/^    inline const TriangularView<MatrixConjugateReturnType,Mode> conjugate() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
conjugate	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion conjugate(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
conjugate	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::conjugate() const$/;"	f	class:Eigen::Quaternion	signature:() const
conjugate	src/Geometry/Quaternion.h	/^  Quaternion<Scalar> conjugate() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
conjugate	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::conjugate() const$/;"	f	class:Eigen::QuaternionBase	signature:() const
conjugate	src/Householder/HouseholderSequence.h	/^    ConjugateReturnType conjugate() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
conjugate	src/plugins/CommonCwiseUnaryOps.h	/^conjugate() const$/;"	f	signature:() const
conjugate_gradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^void conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, const Rhs& rhs, Dest& x, const Preconditioner& precond, int& iters, typename Dest::RealScalar& tol_error)
conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)
conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex size, DenseIndex nbRows, DenseIndex)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex)
conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex size, DenseIndex, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex nbCols)
conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex, DenseIndex nbRows, DenseIndex nbCols) { m_rows = nbRows; m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex nbCols)
conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex, DenseIndex nbRows, DenseIndex) { m_rows = nbRows; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex)
conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex, DenseIndex, DenseIndex nbCols) { m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex nbCols)
conservativeResize	src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
conservativeResize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index nbRows, Index nbCols)
conservativeResize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index nbRows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index nbRows, NoChange_t)
conservativeResize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size)
conservativeResize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(NoChange_t, Index nbCols)
conservativeResize	src/SparseCore/SparseMatrix.h	/^    void conservativeResize(Index rows, Index cols) $/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
conservativeResizeLike	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived>& other)
conservative_resize_like_impl	src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl$/;"	s	namespace:Eigen::internal
conservative_resize_like_impl	src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl<Derived,OtherDerived,true>$/;"	s	namespace:Eigen::internal	inherits:conservative_resize_like_impl
conservative_sparse_sparse_product_impl	src/SparseCore/ConservativeSparseSparseProduct.h	/^static void conservative_sparse_sparse_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	namespace:Eigen::internal	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res)
conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
const_blas_data_mapper	src/Core/util/BlasUtil.h	/^    const_blas_data_mapper(const Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::const_blas_data_mapper	access:public	signature:(const Scalar* data, Index stride)
const_blas_data_mapper	src/Core/util/BlasUtil.h	/^class const_blas_data_mapper$/;"	c	namespace:Eigen::internal
const_cast_derived	src/Core/EigenBase.h	/^  inline Derived& const_cast_derived() const$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
const_cast_derived	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& const_cast_derived() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
const_derived	src/Core/EigenBase.h	/^  inline const Derived& const_derived() const$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
const_pointer	src/Core/util/Memory.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator	access:public
const_pointer	src/StlSupport/details.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
const_reference	src/Core/util/Memory.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator	access:public
const_reference	src/StlSupport/details.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
construct	src/Core/Ref.h	/^    void construct(const Expression& expr, internal::false_type)$/;"	f	class:Eigen::Ref	access:protected	signature:(const Expression& expr, internal::false_type)
construct	src/Core/Ref.h	/^    void construct(const Expression& expr,internal::true_type)$/;"	f	class:Eigen::Ref	access:protected	signature:(const Expression& expr,internal::true_type)
construct	src/Core/Ref.h	/^  void construct(Expression& expr)$/;"	f	class:Eigen::RefBase	access:protected	signature:(Expression& expr)
construct	src/Core/util/Memory.h	/^    void construct( pointer p, const T& value )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p, const T& value )
construct_elements_of_array	src/Core/util/Memory.h	/^template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
construct_from_matrix	src/Eigen2Support/Geometry/Transform.h	/^  struct construct_from_matrix$/;"	s	class:Eigen::Transform	access:public
construct_from_matrix	src/Eigen2Support/Geometry/Transform.h	/^  template<typename OtherDerived> struct construct_from_matrix<OtherDerived, true>$/;"	s	class:Eigen::Transform	access:public
constructor_without_unaligned_array_assert	src/Core/DenseStorage.h	/^struct constructor_without_unaligned_array_assert {};$/;"	s	namespace:Eigen::internal
contains	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
contains	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
contains	src/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
contains	src/Geometry/AlignedBox.h	/^  inline bool contains(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p) const
copyCoeff	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyCoeff	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
copyCoeff	src/Core/DenseCoeffsBase.h	/^    void copyCoeff();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
copyCoeff	src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyCoeff	src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
copyCoeff	src/Core/Swap.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyCoeff	src/Core/Swap.h	/^    void copyCoeff(Index rowId, Index colId, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index rowId, Index colId, const DenseBase<OtherDerived>& other)
copyCoeff	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, Other& other)$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col, Other& other)
copyCoeffByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeffByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const DenseBase<OtherDerived>& other)
copyCoeffByOuterInner	src/Core/DenseCoeffsBase.h	/^    void copyCoeffByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
copyPacket	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyPacket	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
copyPacket	src/Core/DenseCoeffsBase.h	/^    void copyPacket();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
copyPacket	src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyPacket	src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
copyPacket	src/Core/Swap.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyPacket	src/Core/Swap.h	/^    void copyPacket(Index rowId, Index colId, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index rowId, Index colId, const DenseBase<OtherDerived>& other)
copyPacketByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacketByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const DenseBase<OtherDerived>& other)
copyPacketByOuterInner	src/Core/DenseCoeffsBase.h	/^    void copyPacketByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
copy_bool	src/Core/util/Macros.h	/^    inline bool copy_bool(bool b) { return b; }$/;"	f	namespace:Eigen::internal	signature:(bool b)
copy_to_ucol	src/SparseLU/SparseLUImpl.h	/^     Index copy_to_ucol(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu)
copy_to_ucol	src/SparseLU/SparseLU_copy_to_ucol.h	/^Index SparseLUImpl<Scalar,Index>::copy_to_ucol(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu)
corner	src/Core/DenseBase.h	/^    Block<Derived, CRows, CCols> corner(CornerType type);$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type)
corner	src/Core/DenseBase.h	/^    Block<Derived> corner(CornerType type, Index cRows, Index cCols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type, Index cRows, Index cCols)
corner	src/Core/DenseBase.h	/^    const Block<Derived, CRows, CCols> corner(CornerType type) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type) const
corner	src/Core/DenseBase.h	/^    const Block<Derived> corner(CornerType type, Index cRows, Index cCols) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type, Index cRows, Index cCols) const
corner	src/Eigen2Support/Block.h	/^  ::corner(CornerType type, Index cRows, Index cCols)$/;"	f	class:Eigen::DenseBase	signature:(CornerType type, Index cRows, Index cCols)
corner	src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type) const$/;"	f	class:Eigen::DenseBase	signature:(CornerType type) const
corner	src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type)$/;"	f	class:Eigen::DenseBase	signature:(CornerType type)
corner	src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type, Index cRows, Index cCols) const$/;"	f	class:Eigen::DenseBase	signature:(CornerType type, Index cRows, Index cCols) const
corner	src/Geometry/AlignedBox.h	/^  inline VectorType corner(CornerType corner) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(CornerType corner) const
cos	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> cos() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
cos	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_cos_op)      cos() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
cos	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cos() const$/;"	f	class:Eigen::Cwise	signature:() const
cos	src/plugins/ArrayCwiseUnaryOps.h	/^cos() const$/;"	f	signature:() const
cosh	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> cosh() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
count	src/Core/BooleanRedux.h	/^inline typename DenseBase<Derived>::Index DenseBase<Derived>::count() const$/;"	f	class:Eigen::DenseBase	signature:() const
count	src/Core/DenseBase.h	/^    Index count() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
count	src/Core/VectorwiseOp.h	/^    const PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> count() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
countnz	src/SparseLU/SparseLUImpl.h	/^     void countnz(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)
countnz	src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,Index>::countnz(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)
cpotf2	src/misc/blas.h	/^int BLASFUNC(cpotf2)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
cpotrf	src/misc/blas.h	/^int BLASFUNC(cpotrf)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
cpotri	src/misc/blas.h	/^int BLASFUNC(cpotri)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
cpuid_is_vendor	src/Core/util/Memory.h	/^inline bool cpuid_is_vendor(int abcd[4], const int vendor[3])$/;"	f	namespace:Eigen::internal	signature:(int abcd[4], const int vendor[3])
cross	src/Core/MatrixBase.h	/^    cross(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
cross	src/Core/VectorwiseOp.h	/^    const CrossReturnType cross(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:(const MatrixBase<OtherDerived>& other) const
cross	src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
cross	src/Geometry/OrthoMethods.h	/^VectorwiseOp<ExpressionType,Direction>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	signature:(const MatrixBase<OtherDerived>& other) const
cross3	src/Core/MatrixBase.h	/^    PlainObject cross3(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
cross3	src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross3(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
cross3_impl	src/Geometry/OrthoMethods.h	/^struct cross3_impl {$/;"	s	namespace:Eigen::internal
cross3_impl	src/Geometry/arch/Geometry_SSE.h	/^struct cross3_impl<Architecture::SSE,VectorLhs,VectorRhs,float,true>$/;"	s	namespace:Eigen::internal
cross_product_return_type	src/Core/MatrixBase.h	/^    template<typename OtherDerived> struct cross_product_return_type {$/;"	s	class:Eigen::MatrixBase	access:public
crotg	src/misc/blas.h	/^int    BLASFUNC(crotg) (float  *, float  *, float  *, float  *);$/;"	p	signature:(float *, float *, float *, float *)
cs_tdfs	src/OrderingMethods/Amd.h	/^Index cs_tdfs(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)$/;"	f	namespace:Eigen::internal	signature:(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)
cs_wclear	src/OrderingMethods/Amd.h	/^static int cs_wclear (Index mark, Index lemax, Index *w, Index n)$/;"	f	namespace:Eigen::internal	signature:(Index mark, Index lemax, Index *w, Index n)
csbmv	src/misc/blas.h	/^int BLASFUNC(csbmv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cscal	src/misc/blas.h	/^int    BLASFUNC(cscal) (int *,  float  *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *)
cspmv	src/misc/blas.h	/^int BLASFUNC(cspmv) (char *, int *, float  *, float *,$/;"	p	signature:(char *, int *, float *, float *, float *, int *, float *, float *, int *)
cspr	src/misc/blas.h	/^int BLASFUNC(cspr) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *)
cspr2	src/misc/blas.h	/^int BLASFUNC(cspr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *)
csrot	src/misc/blas.h	/^int    BLASFUNC(csrot) (int *, float  *, int *, float  *, int *, float  *, float  *);$/;"	p	signature:(int *, float *, int *, float *, int *, float *, float *)
csscal	src/misc/blas.h	/^int    BLASFUNC(csscal)(int *,  float  *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *)
cswap	src/misc/blas.h	/^int    BLASFUNC(cswap) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
csymm	src/misc/blas.h	/^int BLASFUNC(csymm)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
csymm3m	src/misc/blas.h	/^int BLASFUNC(csymm3m)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
csymv	src/misc/blas.h	/^int BLASFUNC(csymv) (char *, int *, float  *, float *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
csyr	src/misc/blas.h	/^int BLASFUNC(csyr) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *)
csyr2	src/misc/blas.h	/^int BLASFUNC(csyr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, int *)
csyr2k	src/misc/blas.h	/^int BLASFUNC(csyr2k)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
csyrk	src/misc/blas.h	/^int BLASFUNC(csyrk)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *)
ctbmv	src/misc/blas.h	/^int BLASFUNC(ctbmv) (char *, char *, char *, int *, int *, float  *, int *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, float *, int *, float *, int *)
ctbsv	src/misc/blas.h	/^int BLASFUNC(ctbsv) (char *, char *, char *, int *, int *, float  *, int *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, float *, int *, float *, int *)
ctpmv	src/misc/blas.h	/^int BLASFUNC(ctpmv) (char *, char *, char *, int *, float  *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, float *, float *, int *)
ctpsv	src/misc/blas.h	/^int BLASFUNC(ctpsv) (char *, char *, char *, int *, float  *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, float *, float *, int *)
ctrmm	src/misc/blas.h	/^int BLASFUNC(ctrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, float *, float *, int *, float *, int *)
ctrmv	src/misc/blas.h	/^int BLASFUNC(ctrmv) (char *, char *, char *, int *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, float *, int *, float *, int *)
ctrsm	src/misc/blas.h	/^int BLASFUNC(ctrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, float *, float *, int *, float *, int *)
ctrsv	src/misc/blas.h	/^int BLASFUNC(ctrsv) (char *, char *, char *, int *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, float *, int *, float *, int *)
ctrti2	src/misc/blas.h	/^int BLASFUNC(ctrti2)(char *, char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, char *, int *, float *, int *, int *)
ctrtri	src/misc/blas.h	/^int BLASFUNC(ctrtri)(char *, char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, char *, int *, float *, int *, int *)
cube	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_cube_op)     cube() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
cube	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cube() const$/;"	f	class:Eigen::Cwise	signature:() const
cube	src/plugins/ArrayCwiseUnaryOps.h	/^cube() const$/;"	f	signature:() const
cwise	src/Core/MatrixBase.h	/^    inline Cwise<Derived> cwise();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
cwise	src/Core/MatrixBase.h	/^    inline const Cwise<Derived> cwise() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
cwise	src/Eigen2Support/Cwise.h	/^inline Cwise<Derived> MatrixBase<Derived>::cwise()$/;"	f	class:Eigen::MatrixBase	signature:()
cwise	src/Eigen2Support/Cwise.h	/^inline const Cwise<Derived> MatrixBase<Derived>::cwise() const$/;"	f	class:Eigen::MatrixBase	signature:() const
cwiseAbs	src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs() const { return derived(); }$/;"	f	signature:() const
cwiseAbs2	src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs2() const { return derived(); }$/;"	f	signature:() const
cwiseEqual	src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseEqual	src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const Scalar& s) const$/;"	f	signature:(const Scalar& s) const
cwiseInverse	src/plugins/MatrixCwiseUnaryOps.h	/^cwiseInverse() const { return derived(); }$/;"	f	signature:() const
cwiseMax	src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseMax	src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const Scalar &other) const$/;"	f	signature:(const Scalar &other) const
cwiseMin	src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseMin	src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const Scalar &other) const$/;"	f	signature:(const Scalar &other) const
cwiseNotEqual	src/plugins/MatrixCwiseBinaryOps.h	/^cwiseNotEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseProduct	src/Core/MatrixBase.h	/^    cwiseProduct(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived> &other) const
cwiseProduct	src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::cwiseProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
cwiseProduct	src/SparseCore/SparseMatrixBase.h	/^    cwiseProduct(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
cwiseProduct	src/plugins/MatrixCwiseBinaryOps.h	/^cwiseProduct(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseQuotient	src/plugins/MatrixCwiseBinaryOps.h	/^cwiseQuotient(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseSqrt	src/plugins/MatrixCwiseUnaryOps.h	/^cwiseSqrt() const { return derived(); }$/;"	f	signature:() const
damax	src/misc/blas.h	/^double BLASFUNC(damax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
damin	src/misc/blas.h	/^double BLASFUNC(damin) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dasum	src/misc/blas.h	/^double BLASFUNC(dasum) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
data	src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.const_cast_derived().data(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:()
data	src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.const_cast_derived().data(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:()
data	src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
data	src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
data	src/Core/Block.h	/^    inline const Scalar* data() const;$/;"	p	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
data	src/Core/CwiseUnaryView.h	/^    inline Scalar* data() { return &coeffRef(0); }$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:()
data	src/Core/CwiseUnaryView.h	/^    inline const Scalar* data() const { return &coeff(0); }$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
data	src/Core/DenseStorage.h	/^    T *data() { return 0; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
data	src/Core/DenseStorage.h	/^    T *data() { return m_data.array; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
data	src/Core/DenseStorage.h	/^    T *data() { return m_data; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
data	src/Core/DenseStorage.h	/^    const T *data() const { return 0; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
data	src/Core/DenseStorage.h	/^    const T *data() const { return m_data.array; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
data	src/Core/DenseStorage.h	/^    const T *data() const { return m_data; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
data	src/Core/Diagonal.h	/^    inline ScalarWithConstIfNotLvalue* data() { return &(m_matrix.const_cast_derived().coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal	access:public	signature:()
data	src/Core/Diagonal.h	/^    inline const Scalar* data() const { return &(m_matrix.const_cast_derived().coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
data	src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE  Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
data	src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
data	src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return m_data.array; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
data	src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; } \/\/ no const-cast here so non-const-correct code will give a compile error$/;"	f	class:Eigen::MapBase	access:public	signature:()
data	src/Core/MapBase.h	/^    inline const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
data	src/Core/MapBase.h	/^    inline const Scalar* data() const { return this->m_data; }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
data	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar *data()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
data	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar *data() const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
data	src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
data	src/Core/Swap.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:()
data	src/Core/Swap.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
data	src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:()
data	src/Core/Transpose.h	/^    inline const Scalar* data() const { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
data	src/Eigen2Support/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
data	src/Eigen2Support/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
data	src/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
data	src/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
data	src/SparseCore/SparseMatrix.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
data	src/SparseCore/SparseMatrix.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
data	src/SparseCore/SparseVector.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
data	src/SparseCore/SparseVector.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
daxpy	src/misc/blas.h	/^int    BLASFUNC(daxpy) (int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
dcomplex	src/Core/util/MKL_support.h	/^typedef std::complex<double> dcomplex;$/;"	t	namespace:Eigen
dcopy	src/misc/blas.h	/^int    BLASFUNC(dcopy) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
ddot	src/misc/blas.h	/^double BLASFUNC(ddot)  (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
deallocate	src/Core/util/Memory.h	/^    void deallocate( pointer p, size_type \/*num*\/ )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p, size_type )
debug	src/Core/Assign.h	/^  static void debug()$/;"	f	struct:Eigen::internal::assign_traits	access:public	signature:()
debug	src/Core/GeneralProduct.h	/^  static void debug()$/;"	f	struct:Eigen::internal::product_type	access:public	signature:()
dec	src/misc/Image.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
dec	src/misc/Kernel.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
dec	src/misc/Solve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
dec	src/misc/SparseSolve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
decrement_size	src/Householder/Householder.h	/^template<int n> struct decrement_size$/;"	s	namespace:Eigen::internal
defaultEvalTo	src/misc/SparseSolve.h	/^    inline void defaultEvalTo(SparseMatrix<DestScalar,DestOptions,DestIndex>& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:protected	signature:(SparseMatrix<DestScalar,DestOptions,DestIndex>& dst) const
default_packet_traits	src/Core/GenericPacketMath.h	/^struct default_packet_traits$/;"	s	namespace:Eigen::internal
default_prunning_func	src/SparseCore/SparseMatrix.h	/^    default_prunning_func(const Scalar& ref, const RealScalar& eps) : reference(ref), epsilon(eps) {}$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func	access:public	signature:(const Scalar& ref, const RealScalar& eps)
default_prunning_func	src/SparseCore/SparseMatrix.h	/^  struct default_prunning_func {$/;"	s	class:Eigen::SparseMatrix	access:private
degree	src/OrderingMethods/Eigen_Colamd.h	/^    Index degree ;  \/* number of principal & non-principal columns in row *\/$/;"	m	union:internal::Colamd_Row::__anon406	access:public
degree_next	src/OrderingMethods/Eigen_Colamd.h	/^    Index degree_next ; \/* next column, if col is in a degree list *\/$/;"	m	union:internal::colamd_col::__anon405	access:public
dense_xpr_base_dispatcher_for_doxygen	src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:ArrayBase
dense_xpr_base_dispatcher_for_doxygen	src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:MatrixBase
depth_select	src/Core/GeneralProduct.h	/^    depth_select = product_size_category<Depth,MaxDepth>::value$/;"	e	enum:Eigen::internal::product_type::__anon244
deque	src/StlSupport/StdDeque.h	/^  class deque<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:deque
deque_base	src/StlSupport/StdDeque.h	/^                Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > deque_base;$/;"	t	class:std::deque	access:private
derived	src/CholmodSupport/CholmodSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
derived	src/CholmodSupport/CholmodSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
derived	src/Core/DiagonalMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:()
derived	src/Core/DiagonalMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
derived	src/Core/EigenBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:()
derived	src/Core/EigenBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
derived	src/Core/Transpositions.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
derived	src/Core/Transpositions.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
derived	src/Core/TriangularMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:()
derived	src/Core/TriangularMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
derived	src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:()
derived	src/Eigen2Support/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
derived	src/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:()
derived	src/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
derived	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
derived	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
derived	src/PaStiXSupport/PaStiXSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
derived	src/PaStiXSupport/PaStiXSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
derived	src/PardisoSupport/PardisoSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
derived	src/PardisoSupport/PardisoSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
derived	src/SparseCholesky/SimplicialCholesky.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
derived	src/SparseCholesky/SimplicialCholesky.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
derived	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
derived	src/SparseCore/SparseMatrixBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
derived	src/SuperLUSupport/SuperLUSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
derived	src/SuperLUSupport/SuperLUSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
destroy	src/Core/util/Memory.h	/^    void destroy( pointer p )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p )
destruct_elements_of_array	src/Core/util/Memory.h	/^template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
detect_super_cols	src/OrderingMethods/Eigen_Colamd.h	/^static void detect_super_cols (colamd_col<Index> Col [], Index A [], Index head [], Index row_start, Index row_length ) ;$/;"	p	namespace:internal	signature:(colamd_col<Index> Col [], Index A [], Index head [], Index row_start, Index row_length )
detect_super_cols	src/OrderingMethods/Eigen_Colamd.h	/^static void detect_super_cols$/;"	f	namespace:internal	signature:( colamd_col<Index> Col [], Index A [], Index head [], Index row_start, Index row_length )
determinant	src/Core/MatrixBase.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
determinant	src/Core/PermutationMatrix.h	/^    Index determinant() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
determinant	src/Core/TriangularMatrix.h	/^    Scalar determinant() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
determinant	src/LU/Determinant.h	/^inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const$/;"	f	class:Eigen::MatrixBase	signature:() const
determinant	src/LU/FullPivLU.h	/^    typename internal::traits<MatrixType>::Scalar determinant() const;$/;"	p	class:Eigen::FullPivLU	access:public	signature:() const
determinant	src/LU/FullPivLU.h	/^typename internal::traits<MatrixType>::Scalar FullPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::FullPivLU	signature:() const
determinant	src/LU/PartialPivLU.h	/^    typename internal::traits<MatrixType>::Scalar determinant() const;$/;"	p	class:Eigen::PartialPivLU	access:public	signature:() const
determinant	src/LU/PartialPivLU.h	/^typename internal::traits<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::PartialPivLU	signature:() const
determinant	src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
determinant	src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
determinant	src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
determinant	src/SparseLU/SparseLU.h	/^    Scalar determinant()$/;"	f	class:Eigen::SparseLU	access:public	signature:()
determinant	src/SuperLUSupport/SuperLUSupport.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::SuperLU	access:public	signature:() const
determinant	src/SuperLUSupport/SuperLUSupport.h	/^typename SuperLU<MatrixType>::Scalar SuperLU<MatrixType>::determinant() const$/;"	f	class:Eigen::SuperLU	signature:() const
determinant	src/UmfPackSupport/UmfPackSupport.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:() const
determinant	src/UmfPackSupport/UmfPackSupport.h	/^typename UmfPackLU<MatrixType>::Scalar UmfPackLU<MatrixType>::determinant() const$/;"	f	class:Eigen::UmfPackLU	signature:() const
determinant_impl	src/LU/Determinant.h	/^> struct determinant_impl$/;"	s	namespace:Eigen::internal
determinant_impl	src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 1>$/;"	s	namespace:Eigen::internal
determinant_impl	src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 2>$/;"	s	namespace:Eigen::internal
determinant_impl	src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 3>$/;"	s	namespace:Eigen::internal
determinant_impl	src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 4>$/;"	s	namespace:Eigen::internal
dfs_kernel	src/SparseLU/SparseLUImpl.h	/^     void dfs_kernel(const Index jj, IndexVector& perm_r,$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jj, IndexVector& perm_r, Index& nseg, IndexVector& panel_lsub, IndexVector& segrep, Ref<IndexVector> repfnz_col, IndexVector& xprune, Ref<IndexVector> marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu, Index& nextl_col, Index krow, Traits& traits)
dfs_kernel	src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,Index>::dfs_kernel(const Index jj, IndexVector& perm_r,$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jj, IndexVector& perm_r, Index& nseg, IndexVector& panel_lsub, IndexVector& segrep, Ref<IndexVector> repfnz_col, IndexVector& xprune, Ref<IndexVector> marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu, Index& nextl_col, Index krow, Traits& traits )
dgbmv	src/misc/blas.h	/^int BLASFUNC(dgbmv)(char *, int *, int *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dge2mm	src/misc/blas.h	/^int BLASFUNC(dge2mm)(char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dgema	src/misc/blas.h	/^int BLASFUNC(dgema)(char *, char *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, double *, int *, double*, int *)
dgemm	src/misc/blas.h	/^int BLASFUNC(dgemm)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dgems	src/misc/blas.h	/^int BLASFUNC(dgems)(char *, char *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, double *, int *, double*, int *)
dgemt	src/misc/blas.h	/^int BLASFUNC(dgemt)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *)
dgemv	src/misc/blas.h	/^int BLASFUNC(dgemv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dger	src/misc/blas.h	/^int BLASFUNC(dger)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
dgesv	src/misc/blas.h	/^int BLASFUNC(dgesv)(int *, int *, double *, int *, int *, double*, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, double*, int *, int *)
dgetf2	src/misc/blas.h	/^int BLASFUNC(dgetf2)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
dgetrf	src/misc/blas.h	/^int BLASFUNC(dgetrf)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
dgetrs	src/misc/blas.h	/^int BLASFUNC(dgetrs)(char *, int *, int *, double *, int *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *, int *, double *, int *, int *)
diagonal	src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,Dynamic> diagonal(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i)
diagonal	src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,SizeAtCompileTime> diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
diagonal	src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i) const
diagonal	src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
diagonal	src/Core/BandMatrix.h	/^    template<int N> inline const typename DiagonalIntReturnType<N>::Type diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
diagonal	src/Core/BandMatrix.h	/^    template<int N> inline typename DiagonalIntReturnType<N>::Type diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
diagonal	src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
diagonal	src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal()$/;"	f	class:Eigen::MatrixBase	signature:()
diagonal	src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index) const$/;"	f	class:Eigen::MatrixBase	signature:(Index index) const
diagonal	src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index)$/;"	f	class:Eigen::MatrixBase	signature:(Index index)
diagonal	src/Core/DiagonalMatrix.h	/^    const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalWrapper	access:public	signature:() const
diagonal	src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:()
diagonal	src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
diagonal	src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
diagonal	src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:() const
diagonal	src/Core/MatrixBase.h	/^    ConstDiagonalDynamicIndexReturnType diagonal(Index index) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index) const
diagonal	src/Core/MatrixBase.h	/^    ConstDiagonalReturnType diagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
diagonal	src/Core/MatrixBase.h	/^    DiagonalDynamicIndexReturnType diagonal(Index index);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index)
diagonal	src/Core/MatrixBase.h	/^    DiagonalReturnType diagonal();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
diagonal	src/Core/MatrixBase.h	/^    template<int Index> typename ConstDiagonalIndexReturnType<Index>::Type diagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
diagonal	src/Core/MatrixBase.h	/^    template<int Index> typename DiagonalIndexReturnType<Index>::Type diagonal();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
diagonal	src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,0> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
diagonal	src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,DiagonalIndex> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
diagonal	src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,Dynamic> diagonal(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index index) const
diagonal	src/Eigenvalues/Tridiagonalization.h	/^    DiagonalReturnType diagonal() const;$/;"	p	class:Eigen::Tridiagonalization	access:public	signature:() const
diagonal	src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::diagonal() const$/;"	f	class:Eigen::Tridiagonalization	signature:() const
diagonal	src/Geometry/AlignedBox.h	/^  inline CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> diagonal() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
diagonal	src/SparseCore/SparseMatrix.h	/^    const Diagonal<const SparseMatrix> diagonal() const { return *this; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
diagonalLength	src/Core/BandMatrix.h	/^    inline Index diagonalLength(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:protected	signature:(Index i) const
diagonalSize	src/Core/MatrixBase.h	/^    inline Index diagonalSize() const { return (std::min)(rows(),cols()); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
difference_type	src/Core/util/Memory.h	/^    typedef std::ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator	access:public
difference_type	src/StlSupport/details.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
dim	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline int dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size()-1 : AmbientDimAtCompileTime; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
dim	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline int dim() const { return int(AmbientDimAtCompileTime)==Dynamic ? m_coeffs.size()-1 : int(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
dim	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline int dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
dim	src/Geometry/AlignedBox.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size() : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
dim	src/Geometry/Hyperplane.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_coeffs.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
dim	src/Geometry/ParametrizedLine.h	/^  inline Index dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
dimensionOfKernel	src/LU/FullPivLU.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
dimensionOfKernel	src/QR/ColPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
dimensionOfKernel	src/QR/FullPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
direct_selfadjoint_eigenvalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,2,false>$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,3,false>$/;"	s	namespace:Eigen::internal
direction	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
direction	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
direction	src/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
direction	src/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
distance	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { return ei_sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
distance	src/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { using std::sqrt; return sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
dlaswp	src/misc/blas.h	/^int BLASFUNC(dlaswp)(int *, double *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, double *, int *, int *, int *, int *, int *)
dlauu2	src/misc/blas.h	/^int BLASFUNC(dlauu2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
dlauum	src/misc/blas.h	/^int BLASFUNC(dlauum)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
dmax	src/misc/blas.h	/^double BLASFUNC(dmax)  (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dmin	src/misc/blas.h	/^double BLASFUNC(dmin)  (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dnorm	src/misc/blas.h	/^int BLASFUNC(dnorm)(char *, int *, int *, double *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *)
dnrm2	src/misc/blas.h	/^double BLASFUNC(dnrm2) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
doComputeEigenvectors	src/Eigenvalues/ComplexEigenSolver.h	/^    void doComputeEigenvectors(const RealScalar& matrixnorm);$/;"	p	class:Eigen::ComplexEigenSolver	access:private	signature:(const RealScalar& matrixnorm)
doComputeEigenvectors	src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::doComputeEigenvectors(const RealScalar& matrixnorm)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(const RealScalar& matrixnorm)
doComputeEigenvectors	src/Eigenvalues/EigenSolver.h	/^    void doComputeEigenvectors();$/;"	p	class:Eigen::EigenSolver	access:private	signature:()
doComputeEigenvectors	src/Eigenvalues/EigenSolver.h	/^void EigenSolver<MatrixType>::doComputeEigenvectors()$/;"	f	class:Eigen::EigenSolver	signature:()
dot	src/Core/Dot.h	/^MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
dot	src/Core/MatrixBase.h	/^    dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
dot	src/Geometry/Quaternion.h	/^  template<class OtherDerived> inline Scalar dot(const QuaternionBase<OtherDerived>& other) const { return coeffs().dot(other.coeffs()); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other) const
dot	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
dot	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived>& other) const
dot	src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> Scalar dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
dot	src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> Scalar dot(const SparseMatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other) const
dot_nocheck	src/Core/Dot.h	/^struct dot_nocheck$/;"	s	namespace:Eigen::internal
dot_nocheck	src/Core/Dot.h	/^struct dot_nocheck<T, U, true>$/;"	s	namespace:Eigen::internal
dparm	src/PaStiXSupport/PaStiXSupport.h	/^    Array<RealScalar,IPARM_SIZE,1>& dparm()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
dparm	src/PaStiXSupport/PaStiXSupport.h	/^    double& dparm(int idxparam)$/;"	f	class:Eigen::PastixBase	access:public	signature:(int idxparam)
dpotf2	src/misc/blas.h	/^int BLASFUNC(dpotf2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
dpotrf	src/misc/blas.h	/^int BLASFUNC(dpotrf)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
dpotri	src/misc/blas.h	/^int BLASFUNC(dpotri)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
drot	src/misc/blas.h	/^int    BLASFUNC(drot)  (int *, double *, int *, double *, int *, double *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *, double *)
drotg	src/misc/blas.h	/^int    BLASFUNC(drotg) (double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *)
drotm	src/misc/blas.h	/^int    BLASFUNC(drotm) (int *, double *, int *, double *, int *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *)
drotmg	src/misc/blas.h	/^int    BLASFUNC(drotmg)(double *, double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *, double *)
dsbmv	src/misc/blas.h	/^int BLASFUNC(dsbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dscal	src/misc/blas.h	/^int    BLASFUNC(dscal) (int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
dsdot	src/misc/blas.h	/^double BLASFUNC(dsdot) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
dspmv	src/misc/blas.h	/^int BLASFUNC(dspmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
dspr	src/misc/blas.h	/^int BLASFUNC(dspr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
dspr2	src/misc/blas.h	/^int BLASFUNC(dspr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
dswap	src/misc/blas.h	/^int    BLASFUNC(dswap) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
dsymm	src/misc/blas.h	/^int BLASFUNC(dsymm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dsymv	src/misc/blas.h	/^int BLASFUNC(dsymv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dsyr	src/misc/blas.h	/^int BLASFUNC(dsyr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
dsyr2	src/misc/blas.h	/^int BLASFUNC(dsyr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
dsyr2k	src/misc/blas.h	/^int BLASFUNC(dsyr2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
dsyrk	src/misc/blas.h	/^int BLASFUNC(dsyrk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
dtbmv	src/misc/blas.h	/^int BLASFUNC(dtbmv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
dtbsv	src/misc/blas.h	/^int BLASFUNC(dtbsv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
dtpmv	src/misc/blas.h	/^int BLASFUNC(dtpmv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
dtpsv	src/misc/blas.h	/^int BLASFUNC(dtpsv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
dtrmm	src/misc/blas.h	/^int BLASFUNC(dtrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
dtrmv	src/misc/blas.h	/^int BLASFUNC(dtrmv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
dtrsm	src/misc/blas.h	/^int BLASFUNC(dtrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
dtrsv	src/misc/blas.h	/^int BLASFUNC(dtrsv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
dtrti2	src/misc/blas.h	/^int BLASFUNC(dtrti2)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
dtrtri	src/misc/blas.h	/^int BLASFUNC(dtrtri)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
dumpMemory	src/CholmodSupport/CholmodSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(Stream& )
dumpMemory	src/SparseCholesky/SimplicialCholesky.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(Stream& s)
dumpMemory	src/SuperLUSupport/SuperLUSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(Stream& )
dzamax	src/misc/blas.h	/^double BLASFUNC(dzamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dzamin	src/misc/blas.h	/^double BLASFUNC(dzamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dzasum	src/misc/blas.h	/^double BLASFUNC(dzasum)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dzmax	src/misc/blas.h	/^double BLASFUNC(dzmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dzmin	src/misc/blas.h	/^double BLASFUNC(dzmin) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dznrm2	src/misc/blas.h	/^double BLASFUNC(dznrm2)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
ei_abs	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs (const T& x) { using std::abs; return abs(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_abs2	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs2(const T& x) { return numext::abs2(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_aligned_delete	src/Eigen2Support/Memory.h	/^template<typename T> inline void ei_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen	signature:(T *ptr, size_t size)
ei_aligned_free	src/Eigen2Support/Memory.h	/^inline void  ei_aligned_free(void *ptr) { internal::aligned_free(ptr); }$/;"	f	namespace:Eigen	signature:(void *ptr)
ei_aligned_malloc	src/Eigen2Support/Memory.h	/^inline void* ei_aligned_malloc(size_t size) { return internal::aligned_malloc(size); }$/;"	f	namespace:Eigen	signature:(size_t size)
ei_aligned_new	src/Eigen2Support/Memory.h	/^template<typename T> inline T* ei_aligned_new(size_t size)$/;"	f	namespace:Eigen	signature:(size_t size)
ei_aligned_realloc	src/Eigen2Support/Memory.h	/^inline void* ei_aligned_realloc(void *ptr, size_t new_size, size_t old_size) { return internal::aligned_realloc(ptr, new_size, old_size); }$/;"	f	namespace:Eigen	signature:(void *ptr, size_t new_size, size_t old_size)
ei_assert	src/Eigen2Support/Macros.h	13;"	d
ei_atan2	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_atan2(const T& x,const T& y) { using std::atan2; return atan2(x,y); }$/;"	f	namespace:Eigen	signature:(const T& x,const T& y)
ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	s	namespace:Eigen
ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_conditional_aligned_free	src/Eigen2Support/Memory.h	/^template<bool Align> inline void ei_conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen	signature:(void *ptr)
ei_conditional_aligned_malloc	src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen	signature:(size_t size)
ei_conditional_aligned_realloc	src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen	signature:(void* ptr, size_t new_size, size_t old_size)
ei_conj	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_conj(const T& x) { return numext::conj(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_cos	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_cos (const T& x) { using std::cos;  return cos(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_declare_aligned_stack_constructed_variable	src/Core/util/Memory.h	588;"	d
ei_exp	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_exp (const T& x) { using std::exp;  return exp(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_handmade_aligned_free	src/Eigen2Support/Memory.h	/^inline void  ei_handmade_aligned_free(void *ptr) { internal::handmade_aligned_free(ptr); }$/;"	f	namespace:Eigen	signature:(void *ptr)
ei_handmade_aligned_malloc	src/Eigen2Support/Memory.h	/^inline void* ei_handmade_aligned_malloc(size_t size) { return internal::handmade_aligned_malloc(size); }$/;"	f	namespace:Eigen	signature:(size_t size)
ei_imag	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_imag(const T& x) { return numext::imag(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_internal_assert	src/Eigen2Support/Macros.h	14;"	d
ei_isApprox	src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
ei_isApproxOrLessThan	src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
ei_isMuchSmallerThan	src/Eigen2Support/MathFunctions.h	/^inline bool ei_isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const OtherScalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
ei_is_same_type	src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	s	namespace:Eigen
ei_is_same_type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	s	namespace:Eigen
ei_log	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_log (const T& x) { using std::log;  return log(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_meta_false	src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	s	namespace:Eigen
ei_meta_if	src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	s	namespace:Eigen
ei_meta_if	src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	s	namespace:Eigen
ei_meta_sqrt	src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c
ei_meta_sqrt::ret	src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:ei_meta_sqrt::__anon357
ei_meta_true	src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	s	namespace:Eigen
ei_pow	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_pow (const T& x,const T& y) { return numext::pow(x,y); }$/;"	f	namespace:Eigen	signature:(const T& x,const T& y)
ei_quaternion_assign_impl	src/Eigen2Support/Geometry/All.h	61;"	d
ei_quaternion_assign_impl	src/Eigen2Support/Geometry/All.h	76;"	d
ei_quaternion_assign_impl	src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,3,3>$/;"	s	namespace:Eigen
ei_quaternion_assign_impl	src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,4,1>$/;"	s	namespace:Eigen
ei_quaternion_product	src/Eigen2Support/Geometry/Quaternion.h	/^ei_quaternion_product(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)$/;"	f	namespace:Eigen	signature:(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)
ei_random	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random () { return internal::random<T>(); }$/;"	f	namespace:Eigen	signature:()
ei_random	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random (const T& x, const T& y) { return internal::random(x, y); }$/;"	f	namespace:Eigen	signature:(const T& x, const T& y)
ei_real	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_real(const T& x) { return numext::real(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_sin	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sin (const T& x) { using std::sin;  return sin(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_sqrt	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sqrt(const T& x) { using std::sqrt; return sqrt(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_toRotationMatrix	src/Eigen2Support/Geometry/All.h	60;"	d
ei_toRotationMatrix	src/Eigen2Support/Geometry/All.h	75;"	d
ei_toRotationMatrix	src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> ei_toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen	signature:(const Scalar& s)
ei_toRotationMatrix	src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> ei_toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen	signature:(const RotationBase<OtherDerived,Dim>& r)
ei_toRotationMatrix	src/Eigen2Support/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& ei_toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen	signature:(const MatrixBase<OtherDerived>& mat)
ei_traits	src/Eigen2Support/Geometry/AngleAxis.h	/^template<typename _Scalar> struct ei_traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	src/Eigen2Support/Geometry/Quaternion.h	/^template<typename _Scalar> struct ei_traits<Quaternion<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	src/Eigen2Support/Geometry/Rotation2D.h	/^template<typename _Scalar> struct ei_traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	src/Eigen2Support/Meta.h	/^struct ei_traits : internal::traits<T>$/;"	s	namespace:Eigen	inherits:internal::traits
ei_transform_product_impl	src/Eigen2Support/Geometry/All.h	62;"	d
ei_transform_product_impl	src/Eigen2Support/Geometry/All.h	77;"	d
ei_transform_product_impl	src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,1>$/;"	s	namespace:Eigen
ei_transform_product_impl	src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen
ei_transform_product_impl	src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,1>$/;"	s	namespace:Eigen
ei_transform_product_impl	src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen
ei_unconst	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	s	namespace:Eigen
ei_unconst	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	s	namespace:Eigen
ei_unconst	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	s	namespace:Eigen
ei_unconst	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen
ei_unref	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	s	namespace:Eigen
ei_unref	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	s	namespace:Eigen
eigen2_dot	src/Core/Dot.h	/^MatrixBase<Derived>::eigen2_dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
eigen2_dot	src/Core/MatrixBase.h	/^      Scalar eigen2_dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
eigen2_dot	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar eigen2_dot(const Quaternion& other) const { return m_coeffs.eigen2_dot(other.m_coeffs); }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other) const
eigen2_lu	src/Core/MatrixBase.h	/^    const LU<PlainObject> eigen2_lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
eigen2_lu	src/Eigen2Support/LU.h	/^MatrixBase<Derived>::eigen2_lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
eigen2_part_return_type	src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type$/;"	s	namespace:Eigen::internal
eigen2_part_return_type	src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type<MatrixType, SelfAdjoint>$/;"	s	namespace:Eigen::internal
eigen2_product_return_type	src/Core/TriangularMatrix.h	/^    struct eigen2_product_return_type$/;"	s	class:Eigen::TriangularView	access:public
eigen_assert	src/Core/util/Macros.h	228;"	d
eigen_internal_assert	src/Core/util/Macros.h	232;"	d
eigen_pastix	src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)
eigen_pastix	src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)
eigen_pastix	src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)
eigen_pastix	src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)
eigen_plain_assert	src/Core/util/Macros.h	190;"	d
eigen_plain_assert	src/Core/util/Macros.h	198;"	d
eigen_unaligned_array_assert_workaround_gcc47	src/Core/DenseStorage.h	/^  EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }$/;"	f	namespace:Eigen::internal	signature:(PtrType array)
eigenvalues	src/Core/MatrixBase.h	/^    EigenvaluesReturnType eigenvalues() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
eigenvalues	src/Core/SelfAdjointView.h	/^    EigenvaluesReturnType eigenvalues() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
eigenvalues	src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
eigenvalues	src/Eigenvalues/EigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
eigenvalues	src/Eigenvalues/GeneralizedEigenSolver.h	/^    EigenvalueType eigenvalues() const$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:() const
eigenvalues	src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::eigenvalues() const$/;"	f	class:Eigen::MatrixBase	signature:() const
eigenvalues	src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::eigenvalues() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
eigenvalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const RealVectorType& eigenvalues() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
eigenvalues_selector	src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector$/;"	s	namespace:Eigen::internal
eigenvalues_selector	src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector<Derived, false>$/;"	s	namespace:Eigen::internal
eigenvectors	src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvectorType& eigenvectors() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
eigenvectors	src/Eigenvalues/EigenSolver.h	/^    EigenvectorsType eigenvectors() const;$/;"	p	class:Eigen::EigenSolver	access:public	signature:() const
eigenvectors	src/Eigenvalues/EigenSolver.h	/^typename EigenSolver<MatrixType>::EigenvectorsType EigenSolver<MatrixType>::eigenvectors() const$/;"	f	class:Eigen::EigenSolver	signature:() const
eigenvectors	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const EigenvectorsType& eigenvectors() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
elseMatrix	src/Core/Select.h	/^    const ElseMatrixType& elseMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
emptyIdxLU	src/SparseLU/SparseLU_Memory.h	/^enum {emptyIdxLU = -1};$/;"	e	enum:Eigen::internal::__anon462
enable_if	src/Core/util/Meta.h	/^template<typename T> struct enable_if<true,T>$/;"	s	namespace:Eigen::internal
end	src/Core/MatrixBase.h	/^    VectorBlock<Derived> end(Index size);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size)
end	src/Core/MatrixBase.h	/^    const VectorBlock<const Derived> end(Index size) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size) const
end	src/Core/MatrixBase.h	/^    template<int Size> VectorBlock<Derived,Size> end();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
end	src/Core/MatrixBase.h	/^    template<int Size> const VectorBlock<const Derived,Size> end() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
end	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end() const$/;"	f	class:Eigen::MatrixBase	signature:() const
end	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end()$/;"	f	class:Eigen::MatrixBase	signature:()
end	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size) const$/;"	f	class:Eigen::MatrixBase	signature:(Index size) const
end	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size)$/;"	f	class:Eigen::MatrixBase	signature:(Index size)
endFill	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
epsilon	src/SparseCore/SparseMatrix.h	/^    RealScalar epsilon;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func	access:public
error	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar error() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
essentialVector	src/Householder/HouseholderSequence.h	/^    const EssentialVectorType essentialVector(Index k) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index k) const
essentialVector	src/Householder/HouseholderSequence.h	/^  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)$/;"	f	struct:Eigen::internal::hseq_side_dependent_impl	access:public	signature:(const HouseholderSequenceType& h, Index k)
etree_find	src/SparseCore/SparseColEtree.h	/^Index etree_find (Index i, IndexVector& pp)$/;"	f	namespace:Eigen::internal	signature:(Index i, IndexVector& pp)
eulerAngles	src/Core/MatrixBase.h	/^    Matrix<Scalar,3,1> eulerAngles(Index a0, Index a1, Index a2) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index a0, Index a1, Index a2) const
eulerAngles	src/Geometry/EulerAngles.h	/^MatrixBase<Derived>::eulerAngles(Index a0, Index a1, Index a2) const$/;"	f	class:Eigen::MatrixBase	signature:(Index a0, Index a1, Index a2) const
eval	src/Core/DenseBase.h	/^    EIGEN_STRONG_INLINE EvalReturnType eval() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
eval	src/Core/PermutationMatrix.h	/^    PlainPermutationType eval() const { return *this; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
eval	src/SparseCore/SparseMatrixBase.h	/^    inline const typename internal::eval<Derived>::type eval() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
eval	src/SparseCore/SparseUtil.h	/^template<typename T> struct eval<T,Sparse>$/;"	s	namespace:Eigen::internal	inherits:sparse_eval
evalTo	src/Cholesky/LDLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/Cholesky/LLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/Core/ArrayWrapper.h	/^    inline void evalTo(Dest& dst) const { dst = m_expression; }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Dest& dst) const
evalTo	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& evalTo(ActualDerived& dst, const ActualOtherDerived& other) { Transpose<ActualDerived> dstTrans(dst); other.evalTo(dstTrans); return dst; }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(ActualDerived& dst, const ActualOtherDerived& other)
evalTo	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& evalTo(ActualDerived& dst, const ActualOtherDerived& other) { other.evalTo(dst); return dst; }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(ActualDerived& dst, const ActualOtherDerived& other)
evalTo	src/Core/BandMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Dest& dst) const
evalTo	src/Core/DenseBase.h	/^    template<typename Dest> inline void evalTo(Dest& ) const$/;"	f	class:Eigen::DenseBase	access:public	signature:(Dest& ) const
evalTo	src/Core/DiagonalMatrix.h	/^    void evalTo(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
evalTo	src/Core/DiagonalMatrix.h	/^void DiagonalBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	signature:(MatrixBase<DenseDerived> &other) const
evalTo	src/Core/EigenBase.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
evalTo	src/Core/GeneralProduct.h	/^    inline void evalTo(Dest& dest) const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest) const
evalTo	src/Core/PermutationMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:(Dest& dst) const
evalTo	src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(MatrixBase<DenseDerived>& other) const
evalTo	src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::Transpose	access:public	signature:(MatrixBase<DenseDerived>& other) const
evalTo	src/Core/ProductBase.h	/^    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:ScaledProduct	access:public	signature:(Dest& dst) const
evalTo	src/Core/ReturnByValue.h	/^    inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Dest& dst) const
evalTo	src/Core/SolveTriangular.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/Core/Transpositions.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:(Dest& dst) const
evalTo	src/Core/TriangularMatrix.h	/^    void evalTo(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::TriangularBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
evalTo	src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase	signature:(MatrixBase<DenseDerived> &other) const
evalTo	src/Eigenvalues/HessenbergDecomposition.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:(ResultType& result) const
evalTo	src/Eigenvalues/Tridiagonalization.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:(ResultType& result) const
evalTo	src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:(Dest& dst) const
evalTo	src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:(Dest& dst) const
evalTo	src/Householder/HouseholderSequence.h	/^    template<typename DestType> inline void evalTo(DestType& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(DestType& dst) const
evalTo	src/Householder/HouseholderSequence.h	/^    void evalTo(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
evalTo	src/IterativeLinearSolvers/BasicPreconditioners.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/IterativeLinearSolvers/BiCGSTAB.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/IterativeLinearSolvers/ConjugateGradient.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/IterativeLinearSolvers/IncompleteLUT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval	access:public	signature:(Dest& dst) const
evalTo	src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval	access:public	signature:(Dest& dst) const
evalTo	src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/LU/Inverse.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:(Dest& dst) const
evalTo	src/LU/PartialPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/QR/ColPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/QR/FullPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(ResultType& result) const
evalTo	src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result, WorkVectorType& workspace) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(ResultType& result, WorkVectorType& workspace) const
evalTo	src/QR/HouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SPQRSupport/SuiteSparseQRSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SPQRSupport/SuiteSparseQRSupport.h	/^  void evalTo(ResType& res) const$/;"	f	struct:Eigen::SPQR_QProduct	access:public	signature:(ResType& res) const
evalTo	src/SVD/JacobiSVD.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SparseCore/SparseMatrixBase.h	/^    void evalTo(MatrixBase<DenseDerived>& dst) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(MatrixBase<DenseDerived>& dst) const
evalTo	src/SparseCore/SparsePermutation.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:(Dest& dst) const
evalTo	src/SparseCore/SparseProduct.h	/^    void evalTo(Dest& result) const$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(Dest& result) const
evalTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar,int StorageOrder> void evalTo(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const
evalTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar> void evalTo(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const
evalTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestType,unsigned int DestUpLo> void evalTo(SparseSelfAdjointView<DestType,DestUpLo>& dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(SparseSelfAdjointView<DestType,DestUpLo>& dest) const
evalTo	src/SparseCore/SparseSelfAdjointView.h	/^    void evalTo(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const
evalTo	src/SparseLU/SparseLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SparseLU/SparseLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(MatrixBase<Dest>& dest) const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:(MatrixBase<Dest>& dest) const
evalTo	src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(SparseMatrixBase<Dest>& dest) const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:(SparseMatrixBase<Dest>& dest) const
evalTo	src/SparseQR/SparseQR.h	/^  void evalTo(DesType& res) const$/;"	f	struct:Eigen::SparseQR_QProduct	access:public	signature:(DesType& res) const
evalTo	src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	src/misc/Image.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:(Dest& dst) const
evalTo	src/misc/Kernel.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:(Dest& dst) const
evalTo	src/misc/Solve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:(Dest& dst) const
evalTo	src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:(Dest& dst) const
evalTo	src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:(Dest& dst) const
evalToLazy	src/Core/TriangularMatrix.h	/^    void evalToLazy(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::TriangularBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
evalToLazy	src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase	signature:(MatrixBase<DenseDerived> &other) const
exp	src/Core/MatrixBase.h	/^    const MatrixExponentialReturnValue<Derived> exp() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
exp	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_exp_op)      exp() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
exp	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::exp() const$/;"	f	class:Eigen::Cwise	signature:() const
exp	src/plugins/ArrayCwiseUnaryOps.h	/^exp() const$/;"	f	signature:() const
expand	src/SparseLU/SparseLUImpl.h	/^     Index expand(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions)
expand	src/SparseLU/SparseLU_Memory.h	/^Index  SparseLUImpl<Scalar,Index>::expand(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions) $/;"	f	class:Eigen::internal::SparseLUImpl	signature:(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions)
expression	src/Core/NoAlias.h	/^    ExpressionType& expression() const$/;"	f	class:Eigen::NoAlias	access:public	signature:() const
expression	src/Core/SelfCwiseBinaryOp.h	/^    Lhs& expression() const $/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
expression	src/Core/Swap.h	/^    ExpressionType& expression() const { return m_expression; }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
extend	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
extend	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const VectorType& p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p)
extend	src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
extend	src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const MatrixBase<Derived>& p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p)
extendedTo	src/Core/VectorwiseOp.h	/^    extendedTo(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(const DenseBase<OtherDerived>& other) const
extendedToOpposite	src/Core/VectorwiseOp.h	/^    extendedToOpposite(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(const DenseBase<OtherDerived>& other) const
exteriorDistance	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar exteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
exteriorDistance	src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
exteriorDistance	src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p) const
extract	src/Core/Transpose.h	/^  static inline const XprType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extract	src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extract	src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extractData	src/SuperLUSupport/SuperLUSupport.h	/^    void extractData() const;$/;"	p	class:Eigen::SuperLUBase	access:protected	signature:() const
extractData	src/SuperLUSupport/SuperLUSupport.h	/^void SuperLUBase<MatrixType,Derived>::extractData() const$/;"	f	class:Eigen::SuperLUBase	signature:() const
extractData	src/UmfPackSupport/UmfPackSupport.h	/^    void extractData() const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:() const
extractData	src/UmfPackSupport/UmfPackSupport.h	/^void UmfPackLU<MatrixType>::extractData() const$/;"	f	class:Eigen::UmfPackLU	signature:() const
extractScalarFactor	src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extractScalarFactor	src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extractScalarFactor	src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x)$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extractScalarFactor	src/Core/util/BlasUtil.h	/^  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType&)
extract_data	src/Core/util/BlasUtil.h	/^template<typename T> const typename T::Scalar* extract_data(const T& m)$/;"	f	namespace:Eigen::internal	signature:(const T& m)
extract_data_selector	src/Core/util/BlasUtil.h	/^struct extract_data_selector {$/;"	s	namespace:Eigen::internal
extract_data_selector	src/Core/util/BlasUtil.h	/^struct extract_data_selector<T,false> {$/;"	s	namespace:Eigen::internal
extract_kernel	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline bool extract_kernel(MatrixType& mat, Ref<VectorType> res, Ref<VectorType> representative)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(MatrixType& mat, Ref<VectorType> res, Ref<VectorType> representative)
factor	src/Geometry/Scaling.h	/^  inline Scalar& factor() { return m_factor; }$/;"	f	class:Eigen::UniformScaling	access:public	signature:()
factor	src/Geometry/Scaling.h	/^  inline const Scalar& factor() const { return m_factor; }$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
factorize	src/CholmodSupport/CholmodSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
factorize	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& factorize(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatType& mat)
factorize	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& factorize(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
factorize	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void factorize(const MatrixType& amat);$/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
factorize	src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::factorize(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	signature:(const _MatrixType& amat)
factorize	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& factorize(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const EigenBase<InputDerived>& A)
factorize	src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
factorize	src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
factorize	src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
factorize	src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
factorize	src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::factorize(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
factorize	src/PardisoSupport/PardisoSupport.h	/^    Derived& factorize(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
factorize	src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::factorize(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
factorize	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& a)
factorize	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a)
factorize	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& a)
factorize	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& a)
factorize	src/SparseLU/SparseLU.h	/^    void factorize (const MatrixType& matrix);$/;"	p	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
factorize	src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::factorize(const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU	signature:(const MatrixType& matrix)
factorize	src/SparseQR/SparseQR.h	/^    void factorize(const MatrixType& mat);$/;"	p	class:Eigen::SparseQR	access:public	signature:(const MatrixType& mat)
factorize	src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::factorize(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR	signature:(const MatrixType& mat)
factorize	src/SuperLUSupport/SuperLUSupport.h	/^    void factorize(const MatrixType& matrix);$/;"	p	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
factorize	src/SuperLUSupport/SuperLUSupport.h	/^    void factorize(const MatrixType& matrix);$/;"	p	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
factorize	src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperILU	signature:(const MatrixType& a)
factorize	src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperLU	signature:(const MatrixType& a)
factorize	src/UmfPackSupport/UmfPackSupport.h	/^    void factorize(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const InputMatrixType& matrix)
factorize_impl	src/UmfPackSupport/UmfPackSupport.h	/^    void factorize_impl()$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:()
factorize_preordered	src/SparseCholesky/SimplicialCholesky.h	/^    void factorize_preordered(const CholMatrixType& a);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const CholMatrixType& a)
factorize_preordered	src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::factorize_preordered(const CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const CholMatrixType& ap)
false_type	src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
fill	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE void DenseBase<Derived>::fill(const Scalar& val)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& val)
fill	src/Core/DenseBase.h	/^    void fill(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
fill	src/Core/TriangularMatrix.h	/^    void fill(const Scalar& value) { setConstant(value); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const Scalar& value)
fill	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
fill	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index r, Index c)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index r, Index c)
fillfactor	src/SparseLU/SparseLU_Structs.h	/^  Index fillfactor; \/\/ The estimated fills factors for L and U, compared with A$/;"	m	struct:Eigen::internal::perfvalues	access:public
fillrand	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
fillrand	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index r, Index c)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index r, Index c)
finalize	src/SparseCore/SparseMatrix.h	/^    inline void finalize()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
finalize	src/SparseCore/SparseVector.h	/^    inline void finalize() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
findSmallDiagEntry	src/Eigenvalues/RealQZ.h	/^      Index findSmallDiagEntry(Index f, Index l);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index f, Index l)
findSmallDiagEntry	src/Eigenvalues/RealQZ.h	/^    inline typename MatrixType::Index RealQZ<MatrixType>::findSmallDiagEntry(Index f, Index l)$/;"	f	class:Eigen::RealQZ	signature:(Index f, Index l)
findSmallSubdiagEntry	src/Eigenvalues/RealQZ.h	/^      Index findSmallSubdiagEntry(Index iu);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index iu)
findSmallSubdiagEntry	src/Eigenvalues/RealQZ.h	/^    inline typename MatrixType::Index RealQZ<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealQZ	signature:(Index iu)
findSmallSubdiagEntry	src/Eigenvalues/RealSchur.h	/^    Index findSmallSubdiagEntry(Index iu);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu)
findSmallSubdiagEntry	src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealSchur	signature:(Index iu)
find_ordering	src/OrderingMethods/Eigen_Colamd.h	/^static Index find_ordering (Index n_row, Index n_col, Index Alen, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], Index n_col2, Index max_deg, Index pfree);$/;"	p	namespace:internal	signature:(Index n_row, Index n_col, Index Alen, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], Index n_col2, Index max_deg, Index pfree)
find_ordering	src/OrderingMethods/Eigen_Colamd.h	/^static Index find_ordering \/* return the number of garbage collections *\/$/;"	f	namespace:internal	signature:( Index n_row, Index n_col, Index Alen, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], Index n_col2, Index max_deg, Index pfree )
finished	src/Core/CommaInitializer.h	/^  inline XprType& finished() { return m_xpr; }$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:()
first	src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket first;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket	access:public
first_aligned	src/Core/DenseCoeffsBase.h	/^static inline typename Derived::Index first_aligned(const Derived& m)$/;"	f	namespace:Eigen::internal	signature:(const Derived& m)
first_aligned	src/Core/util/Memory.h	/^static inline Index first_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal	signature:(const Scalar* array, Index size)
first_aligned_impl	src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl$/;"	s	namespace:Eigen::internal
first_aligned_impl	src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl<Derived, false>$/;"	s	namespace:Eigen::internal
first_column	src/OrderingMethods/Eigen_Colamd.h	/^    Index first_column ;\/* first column in row (used in garbage collection) *\/$/;"	m	union:internal::Colamd_Row::__anon407	access:public
first_multiple	src/Core/util/Memory.h	/^inline static Index first_multiple(Index size, Index base)$/;"	f	namespace:Eigen::internal	signature:(Index size, Index base)
fitHyperplane	src/Eigen2Support/LeastSquares.h	/^void fitHyperplane(int numPoints,$/;"	f	namespace:Eigen	signature:(int numPoints, VectorType **points, HyperplaneType *result, typename NumTraits<typename VectorType::Scalar>::Real* soundness = 0)
fixupL	src/SparseLU/SparseLUImpl.h	/^     void fixupL(const Index n, const IndexVector& perm_r, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)
fixupL	src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,Index>::fixupL(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)
flagged	src/Core/DenseBase.h	/^    const Flagged<Derived, Added, Removed> flagged() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
flagged	src/Core/Flagged.h	/^DenseBase<Derived>::flagged() const$/;"	f	class:Eigen::DenseBase	signature:() const
flags	src/Core/IO.h	/^  int flags;$/;"	m	struct:Eigen::IOFormat	access:public
floor_log2	src/Core/MathFunctions.h	/^struct floor_log2 {};$/;"	s	namespace:Eigen::internal
floor_log2	src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_bogus>$/;"	s	namespace:Eigen::internal
floor_log2	src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_down>$/;"	s	namespace:Eigen::internal
floor_log2	src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_up>$/;"	s	namespace:Eigen::internal
floor_log2	src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_terminate>$/;"	s	namespace:Eigen::internal
floor_log2_bogus	src/Core/MathFunctions.h	/^  floor_log2_bogus$/;"	e	enum:Eigen::internal::__anon277
floor_log2_move_down	src/Core/MathFunctions.h	/^  floor_log2_move_down,$/;"	e	enum:Eigen::internal::__anon277
floor_log2_move_up	src/Core/MathFunctions.h	/^  floor_log2_move_up,$/;"	e	enum:Eigen::internal::__anon277
floor_log2_selector	src/Core/MathFunctions.h	/^template<unsigned int n, int lower, int upper> struct floor_log2_selector$/;"	s	namespace:Eigen::internal
floor_log2_terminate	src/Core/MathFunctions.h	/^  floor_log2_terminate,$/;"	e	enum:Eigen::internal::__anon277
forceAlignedAccess	src/Core/DenseBase.h	/^    inline ForceAlignedAccess<Derived> forceAlignedAccess();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
forceAlignedAccess	src/Core/DenseBase.h	/^    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
forceAlignedAccess	src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess() const$/;"	f	class:Eigen::MatrixBase	signature:() const
forceAlignedAccess	src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess()$/;"	f	class:Eigen::MatrixBase	signature:()
forceAlignedAccess	src/Core/MatrixBase.h	/^    inline ForceAlignedAccess<Derived> forceAlignedAccess();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
forceAlignedAccess	src/Core/MatrixBase.h	/^    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
forceAlignedAccessIf	src/Core/DenseBase.h	/^    template<bool Enable> inline const typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
forceAlignedAccessIf	src/Core/DenseBase.h	/^    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
forceAlignedAccessIf	src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf() const$/;"	f	class:Eigen::MatrixBase	signature:() const
forceAlignedAccessIf	src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf()$/;"	f	class:Eigen::MatrixBase	signature:()
forceAlignedAccessIf	src/Core/MatrixBase.h	/^    template<bool Enable> inline typename internal::add_const_on_value_type<typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type>::type forceAlignedAccessIf() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
forceAlignedAccessIf	src/Core/MatrixBase.h	/^    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
format	src/Core/DenseBase.h	/^    inline const WithFormat<Derived> format(const IOFormat& fmt) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const IOFormat& fmt) const
format	src/Core/IO.h	/^DenseBase<Derived>::format(const IOFormat& fmt) const$/;"	f	class:Eigen::DenseBase	signature:(const IOFormat& fmt) const
fortran_to_c_numbering	src/PaStiXSupport/PaStiXSupport.h	/^  void fortran_to_c_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
fromPositionOrientationScale	src/Eigen2Support/Geometry/Transform.h	/^  Transform& fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
fromPositionOrientationScale	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
fromPositionOrientationScale	src/Geometry/Transform.h	/^  Transform& fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
fromPositionOrientationScale	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
fromRotationMatrix	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
fromRotationMatrix	src/Eigen2Support/Geometry/Rotation2D.h	/^  Rotation2D& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Rotation2D	access:public	signature:(const MatrixBase<Derived>& m)
fromRotationMatrix	src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D	signature:(const MatrixBase<Derived>& mat)
fromRotationMatrix	src/Geometry/AngleAxis.h	/^  AngleAxis& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
fromRotationMatrix	src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
fromRotationMatrix	src/Geometry/Rotation2D.h	/^  Rotation2D& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Rotation2D	access:public	signature:(const MatrixBase<Derived>& m)
fromRotationMatrix	src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D	signature:(const MatrixBase<Derived>& mat)
fullPivHouseholderQr	src/Core/MatrixBase.h	/^    const FullPivHouseholderQR<PlainObject> fullPivHouseholderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
fullPivHouseholderQr	src/QR/FullPivHouseholderQR.h	/^MatrixBase<Derived>::fullPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
fullPivLu	src/Core/MatrixBase.h	/^    const FullPivLU<PlainObject> fullPivLu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
fullPivLu	src/LU/FullPivLU.h	/^MatrixBase<Derived>::fullPivLu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
functor	src/Core/CwiseBinaryOp.h	/^    const BinaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
functor	src/Core/CwiseNullaryOp.h	/^    const NullaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
functor	src/Core/CwiseUnaryOp.h	/^    const UnaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
functor	src/Core/CwiseUnaryView.h	/^    const ViewOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
functor	src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& functor() const $/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
functor_has_linear_access	src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_has_linear_access	src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
functor_is_product_like	src/Core/Functors.h	/^template<typename Functor> struct functor_is_product_like { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
functor_is_product_like	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_is_product_like	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_is_product_like	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_quotient_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_abs2_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_abs_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_acos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_add_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_asin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_binary_pow_op<Scalar,OtherScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_cast_op<Scalar,NewType> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_cmp_op<Scalar, cmp> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_conjugate_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_constant_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_cos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_cube_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_difference_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_exp_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_hypot_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_identity_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_imag_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_imag_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_inverse_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_log_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_max_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_min_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_multiple2_op<Scalar1,Scalar2> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_multiple_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_opposite_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_pow_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_quotient_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_real_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_real_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_sin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_sqrt_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_square_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_sum_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<scalar_tan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::binary_compose<T0,T1,T2> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::binary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::binder1st<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::binder2nd<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::divides<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::greater<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::greater_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::less<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::less_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::logical_and<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::logical_not<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::logical_or<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::minus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::multiplies<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::not_equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::plus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::project1st<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::project2nd<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::select1st<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::select2nd<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::unary_compose<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^struct functor_traits<std::unary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct functor_traits< linspaced_op<Scalar,RandomAccess> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_and_op> {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_or_op> {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Random.h	/^struct functor_traits<scalar_random_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Visitor.h	/^struct functor_traits<max_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	src/Core/Visitor.h	/^struct functor_traits<min_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
garbage_collection	src/OrderingMethods/Eigen_Colamd.h	/^static Index garbage_collection  \/* returns the new value of pfree *\/$/;"	f	namespace:internal	signature:( Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index *pfree )
garbage_collection	src/OrderingMethods/Eigen_Colamd.h	/^static Index garbage_collection (Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index *pfree) ;$/;"	p	namespace:internal	signature:(Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index *pfree)
gebp_kernel	src/Core/products/GeneralBlockPanelKernel.h	/^struct gebp_kernel$/;"	s	namespace:Eigen::internal
gebp_madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void gebp_madd(const CJ& cj, A& a, B& b, C& c, T& t)$/;"	f	namespace:Eigen::internal	signature:(const CJ& cj, A& a, B& b, C& c, T& t)
gebp_madd_selector	src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename A, typename B, typename C, typename T> struct gebp_madd_selector {$/;"	s	namespace:Eigen::internal
gebp_madd_selector	src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename T> struct gebp_madd_selector<CJ,T,T,T,T> {$/;"	s	namespace:Eigen::internal
gebp_traits	src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits$/;"	c	namespace:Eigen::internal
gebp_traits	src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<RealScalar, std::complex<RealScalar>, false, _ConjRhs >$/;"	c	namespace:Eigen::internal
gebp_traits	src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, RealScalar, _ConjLhs, false>$/;"	c	namespace:Eigen::internal
gebp_traits	src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, std::complex<RealScalar>, _ConjLhs, _ConjRhs >$/;"	c	namespace:Eigen::internal
gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex \/*rows*\/, DenseIndex \/*cols*\/, DenseIndex \/*depth*\/)$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:(DenseIndex , DenseIndex , DenseIndex )
gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex rows, DenseIndex cols, DenseIndex depth)$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:(DenseIndex rows, DenseIndex cols, DenseIndex depth)
gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, false>$/;"	c	namespace:Eigen::internal	inherits:level3_blocking
gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, true>$/;"	c	namespace:Eigen::internal	inherits:level3_blocking
gemm_functor	src/Core/products/GeneralMatrixMatrix.h	/^  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, const Scalar& actualAlpha,$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:(const Lhs& lhs, const Rhs& rhs, Dest& dest, const Scalar& actualAlpha, BlockingType& blocking)
gemm_functor	src/Core/products/GeneralMatrixMatrix.h	/^struct gemm_functor$/;"	s	namespace:Eigen::internal
gemm_pack_lhs	src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemv_selector	src/Core/GeneralProduct.h	/^struct gemv_selector<OnTheLeft,StorageOrder,BlasCompatible>$/;"	s	namespace:Eigen::internal
gemv_selector	src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,false>$/;"	s	namespace:Eigen::internal
gemv_selector	src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,true>$/;"	s	namespace:Eigen::internal
gemv_selector	src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,false>$/;"	s	namespace:Eigen::internal
gemv_selector	src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,Dynamic,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,false>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,true>$/;"	s	namespace:Eigen::internal
general_det3_helper	src/LU/Inverse.h	/^inline const typename Derived::Scalar general_det3_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int i1, int i2, int i3, int j1, int j2, int j3)
general_matrix_matrix_product	src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_product	src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_rankupdate	src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^struct general_matrix_matrix_rankupdate :$/;"	s	namespace:Eigen::internal	inherits:general_matrix_matrix_triangular_product
general_matrix_matrix_triangular_product	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product_gemv	src/Core/products/GeneralMatrixVector_MKL.h	/^struct general_matrix_vector_product_gemv :$/;"	s	namespace:Eigen::internal	inherits:general_matrix_vector_product
general_product_to_triangular_selector	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,false>$/;"	s	namespace:Eigen
general_product_to_triangular_selector	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,true>$/;"	s	namespace:Eigen
generic_aligned_realloc	src/Core/util/Memory.h	/^inline void* generic_aligned_realloc(void* ptr, size_t size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t size, size_t old_size)
get	src/SparseCore/SparseDenseProduct.h	/^    static Scalar get(const _RhsNested &rhs, Index outer, Dense = Dense())$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected	signature:(const _RhsNested &rhs, Index outer, Dense = Dense())
get	src/SparseCore/SparseDenseProduct.h	/^    static Scalar get(const _RhsNested &rhs, Index outer, Sparse = Sparse())$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected	signature:(const _RhsNested &rhs, Index outer, Sparse = Sparse())
getL	src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
getL	src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
getL	src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
getL	src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
getL	src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::traits	access:public	signature:(const MatrixType& m)
getMatrix	src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:(const MatrixType& matrix)
getMatrix	src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT	access:protected	signature:(const MatrixType& matrix)
getMatrix	src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU	access:protected	signature:(const MatrixType& matrix)
getMaxIterations	src/Eigenvalues/ComplexEigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:()
getMaxIterations	src/Eigenvalues/ComplexSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexSchur	access:public	signature:()
getMaxIterations	src/Eigenvalues/EigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::EigenSolver	access:public	signature:()
getMaxIterations	src/Eigenvalues/RealSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::RealSchur	access:public	signature:()
getU	src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
getU	src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
getU	src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
getU	src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
getU	src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::traits	access:public	signature:(const MatrixType& m)
get_factor	src/Core/util/BlasUtil.h	/^template<typename From,typename To> struct get_factor {$/;"	s	namespace:Eigen::internal
get_factor	src/Core/util/BlasUtil.h	/^template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {$/;"	s	namespace:Eigen::internal
get_symmetrized_graph	src/MetisSupport/MetisSupport.h	/^  void get_symmetrized_graph(const MatrixType& A)$/;"	f	class:Eigen::MetisOrdering	access:public	signature:(const MatrixType& A)
global_math_functions_filtering_base	src/Core/MathFunctions.h	/^struct global_math_functions_filtering_base$/;"	s	namespace:Eigen::internal
grabInput	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grabInput(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:(const EigenBase<InputDerived>& A)
grabInput_impl	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grabInput_impl(MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:(MatrixType& A)
grabInput_impl	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grabInput_impl(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:(const EigenBase<InputDerived>& A)
grabMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLDLT	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
grabMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLLT	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
grabMatrix	src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLU	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
grapInput	src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput(const InputMatrixType& mat)$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:(const InputMatrixType& mat)
grapInput_impl	src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput_impl(const InputMatrixType& mat, internal::false_type)$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:(const InputMatrixType& mat, internal::false_type)
grapInput_impl	src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput_impl(const InputMatrixType& mat, internal::true_type)$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:(const InputMatrixType& mat, internal::true_type)
hCoeffs	src/QR/ColPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
hCoeffs	src/QR/FullPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
hCoeffs	src/QR/HouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
handmade_aligned_free	src/Core/util/Memory.h	/^inline void handmade_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
handmade_aligned_malloc	src/Core/util/Memory.h	/^inline void* handmade_aligned_malloc(std::size_t size)$/;"	f	namespace:Eigen::internal	signature:(std::size_t size)
handmade_aligned_realloc	src/Core/util/Memory.h	/^inline void* handmade_aligned_realloc(void* ptr, std::size_t size, std::size_t = 0)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, std::size_t size, std::size_t = 0)
hasNaN	src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::hasNaN() const$/;"	f	class:Eigen::DenseBase	signature:() const
hasNaN	src/Core/DenseBase.h	/^    inline bool hasNaN() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
has_direct_access	src/Core/util/ForwardDeclarations.h	/^  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon71
has_direct_access	src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct has_direct_access$/;"	s	namespace:Eigen::internal
has_none	src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	s	namespace:Eigen::internal
has_std_result_type	src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	s	namespace:Eigen::internal
has_tr1_result	src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	s	namespace:Eigen::internal
has_write_access	src/Core/util/ForwardDeclarations.h	/^         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon71
hash	src/OrderingMethods/Eigen_Colamd.h	/^    Index hash ;  \/* hash value, if col is not in a degree list *\/$/;"	m	union:internal::colamd_col::__anon404	access:public
hash_next	src/OrderingMethods/Eigen_Colamd.h	/^    Index hash_next ;   \/* next column, if col is in a hash list *\/$/;"	m	union:internal::colamd_col::__anon405	access:public
head	src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType head(Index n) const$/;"	f	signature:(Index n) const
head	src/plugins/BlockMethods.h	/^inline SegmentReturnType head(Index n)$/;"	f	signature:(Index n)
head	src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type head(Index n = N) const$/;"	f	signature:(Index n = N) const
head	src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type head(Index n = N)$/;"	f	signature:(Index n = N)
headhash	src/OrderingMethods/Eigen_Colamd.h	/^    Index headhash ;  \/* head of a hash bucket, if col is at the head of *\/$/;"	m	union:internal::colamd_col::__anon404	access:public
heap_relax_snode	src/SparseLU/SparseLUImpl.h	/^     void heap_relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)
heap_relax_snode	src/SparseLU/SparseLU_heap_relax_snode.h	/^void SparseLUImpl<Scalar,Index>::heap_relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)
hessenbergTriangular	src/Eigenvalues/RealQZ.h	/^      void hessenbergTriangular();$/;"	p	class:Eigen::RealQZ	access:private	signature:()
hessenbergTriangular	src/Eigenvalues/RealQZ.h	/^    void RealQZ<MatrixType>::hessenbergTriangular()$/;"	f	class:Eigen::RealQZ	signature:()
hnormalized	src/Core/MatrixBase.h	/^    const HNormalizedReturnType hnormalized() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
hnormalized	src/Core/VectorwiseOp.h	/^    const HNormalizedReturnType hnormalized() const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:() const
hnormalized	src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::hnormalized() const$/;"	f	class:Eigen::MatrixBase	signature:() const
hnormalized	src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::hnormalized() const$/;"	f	class:Eigen::VectorwiseOp	signature:() const
homogeneous	src/Core/MatrixBase.h	/^    HomogeneousReturnType homogeneous() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
homogeneous	src/Core/VectorwiseOp.h	/^    Homogeneous<ExpressionType,Direction> homogeneous() const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:() const
homogeneous	src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::homogeneous() const$/;"	f	class:Eigen::MatrixBase	signature:() const
homogeneous	src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::homogeneous() const$/;"	f	class:Eigen::VectorwiseOp	signature:() const
homogeneous_left_product_impl	src/Geometry/Homogeneous.h	/^  homogeneous_left_product_impl(const Lhs& lhs, const MatrixType& rhs)$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:(const Lhs& lhs, const MatrixType& rhs)
homogeneous_left_product_impl	src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs>$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
homogeneous_right_product_impl	src/Geometry/Homogeneous.h	/^  homogeneous_right_product_impl(const MatrixType& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:(const MatrixType& lhs, const Rhs& rhs)
homogeneous_right_product_impl	src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs>$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
householder	src/SVD/UpperBidiagonalization.h	/^    const MatrixType& householder() const { return m_householder; }$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
householderCoefficients	src/Eigenvalues/HessenbergDecomposition.h	/^    const CoeffVectorType& householderCoefficients() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
householderCoefficients	src/Eigenvalues/Tridiagonalization.h	/^    inline CoeffVectorType householderCoefficients() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
householderQ	src/QR/ColPivHouseholderQR.h	/^    HouseholderSequenceType householderQ(void) const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:(void) const
householderQ	src/QR/ColPivHouseholderQR.h	/^  ::householderQ() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
householderQ	src/QR/HouseholderQR.h	/^    HouseholderSequenceType householderQ() const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
householderQr	src/Core/MatrixBase.h	/^    const HouseholderQR<PlainObject> householderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
householderQr	src/QR/HouseholderQR.h	/^MatrixBase<Derived>::householderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
householderSequence	src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen	signature:(const VectorsType& v, const CoeffsType& h)
householderU	src/SVD/UpperBidiagonalization.h	/^    const HouseholderUSequenceType householderU() const$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
householderV	src/SVD/UpperBidiagonalization.h	/^    const HouseholderVSequenceType householderV() \/\/ const here gives nasty errors and i'm lazy$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:()
householder_qr_inplace_blocked	src/QR/HouseholderQR.h	/^struct householder_qr_inplace_blocked$/;"	s	namespace:Eigen::internal
householder_qr_inplace_unblocked	src/QR/HouseholderQR.h	/^void householder_qr_inplace_unblocked(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)$/;"	f	namespace:Eigen::internal	signature:(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)
hseq_side_dependent_impl	src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl$/;"	s	namespace:Eigen::internal
hseq_side_dependent_impl	src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl<VectorsType, CoeffsType, OnTheRight>$/;"	s	namespace:Eigen::internal
hypot	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x, const Scalar& y)
hypotNorm	src/Core/MatrixBase.h	/^    RealScalar hypotNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
hypotNorm	src/Core/StableNorm.h	/^MatrixBase<Derived>::hypotNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
hypotNorm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_hypotNorm,RealScalar>::Type hypotNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
hypot_impl	src/Core/MathFunctions.h	/^struct hypot_impl$/;"	s	namespace:Eigen::internal
hypot_retval	src/Core/MathFunctions.h	/^struct hypot_retval$/;"	s	namespace:Eigen::internal
icamax	src/misc/blas.h	/^int    BLASFUNC(icamax)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
icamin	src/misc/blas.h	/^int    BLASFUNC(icamin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
icc_11_workaround	src/Geometry/Transform.h	/^  template<int OtherMode,int OtherOptions> struct icc_11_workaround$/;"	s	class:Eigen::Transform	access:private
icmax	src/misc/blas.h	/^int    BLASFUNC(icmax) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
icmin	src/misc/blas.h	/^int    BLASFUNC(icmin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
idamax	src/misc/blas.h	/^int    BLASFUNC(idamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
idamin	src/misc/blas.h	/^int    BLASFUNC(idamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
idmax	src/misc/blas.h	/^int    BLASFUNC(idmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
idmin	src/misc/blas.h	/^int    BLASFUNC(idmin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
ignore_unused_variable	src/Core/util/Macros.h	/^    template<typename T> void ignore_unused_variable(const T&) {}$/;"	f	namespace:Eigen::internal	signature:(const T&)
imag	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag, Scalar) imag(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
imag	src/plugins/CommonCwiseUnaryOps.h	/^imag() const { return derived(); }$/;"	f	signature:() const
imag	src/plugins/CommonCwiseUnaryOps.h	/^imag() { return derived(); }$/;"	f	signature:()
imag_default_impl	src/Core/MathFunctions.h	/^struct imag_default_impl$/;"	s	namespace:Eigen::internal
imag_default_impl	src/Core/MathFunctions.h	/^struct imag_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
imag_impl	src/Core/MathFunctions.h	/^template<typename Scalar> struct imag_impl : imag_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal	inherits:imag_default_impl
imag_ref	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) imag_ref(Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(Scalar& x)
imag_ref	src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) >::type imag_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
imag_ref_default_impl	src/Core/MathFunctions.h	/^struct imag_ref_default_impl$/;"	s	namespace:Eigen::internal
imag_ref_default_impl	src/Core/MathFunctions.h	/^struct imag_ref_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
imag_ref_impl	src/Core/MathFunctions.h	/^struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal	inherits:imag_ref_default_impl
imag_ref_retval	src/Core/MathFunctions.h	/^struct imag_ref_retval$/;"	s	namespace:Eigen::internal
imag_retval	src/Core/MathFunctions.h	/^struct imag_retval$/;"	s	namespace:Eigen::internal
image	src/Eigen2Support/LU.h	/^    const ImageResultType image() const$/;"	f	class:Eigen::LU	access:public	signature:() const
image	src/LU/FullPivLU.h	/^      image(const MatrixType& originalMatrix) const$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& originalMatrix) const
image_retval	src/LU/FullPivLU.h	/^struct image_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:image_retval_base
image_retval_base	src/misc/Image.h	/^  image_retval_base(const DecompositionType& dec, const MatrixType& originalMatrix)$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:(const DecompositionType& dec, const MatrixType& originalMatrix)
image_retval_base	src/misc/Image.h	/^template<typename _DecompositionType> struct image_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
impl	src/Core/Functors.h	/^  const linspaced_op_impl<Scalar,RandomAccess> impl;$/;"	m	struct:Eigen::internal::linspaced_op	access:public
incrementToNonZero	src/SparseCore/SparseView.h	/^  void incrementToNonZero()$/;"	f	class:Eigen::SparseView::InnerIterator	access:private	signature:()
index	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_inner; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
index	src/Core/Diagonal.h	/^    int index() const$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
index	src/Core/Redux.h	/^    index = Start * packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon304
index	src/SparseCore/AmbiVector.h	/^      Index index;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
index	src/SparseCore/AmbiVector.h	/^    Index index() const { return m_cachedIndex; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
index	src/SparseCore/CompressedStorage.h	/^    inline Index& index(size_t i) { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i)
index	src/SparseCore/CompressedStorage.h	/^    inline const Index& index(size_t i) const { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i) const
index	src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
index	src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
index	src/SparseCore/SparseBlock.h	/^      inline Index index()  const { return Base::index() - (IsRowMajor ? m_block.m_startCol.value() : m_block.m_startRow.value()); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
index	src/SparseCore/SparseBlock.h	/^      inline Index index()  const { return Base::index() - (IsRowMajor ? m_block.m_startCol.value() : m_block.m_startRow.value()); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
index	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_id; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
index	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_lhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
index	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_rhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
index	src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
index	src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
index	src/SparseCore/SparseTriangularView.h	/^    inline Index index() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
index	src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
index	src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
index	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index index() const { return m_matrix.rowIndex()[m_idrow]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
indices	src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:()
indices	src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:()
indices	src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:()
indices	src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
indices	src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:() const
indices	src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:() const
indices	src/Core/PermutationMatrix.h	/^    indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationWrapper	access:public	signature:() const
indices	src/Core/Transpositions.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
indices	src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:()
indices	src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Transpositions	access:public	signature:()
indices	src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:()
indices	src/Core/Transpositions.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
indices	src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:() const
indices	src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Transpositions	access:public	signature:() const
indices	src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:() const
info	src/Cholesky/LDLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
info	src/Cholesky/LLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
info	src/CholmodSupport/CholmodSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
info	src/Eigenvalues/ComplexEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
info	src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
info	src/Eigenvalues/EigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
info	src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:() const
info	src/Eigenvalues/RealQZ.h	/^      ComputationInfo info() const$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
info	src/Eigenvalues/RealSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
info	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
info	src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
info	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ComputationInfo info() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
info	src/PaStiXSupport/PaStiXSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
info	src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
info	src/QR/ColPivHouseholderQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
info	src/SPQRSupport/SuiteSparseQRSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
info	src/SparseCholesky/SimplicialCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
info	src/SparseLU/SparseLU.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
info	src/SparseQR/SparseQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
info	src/SuperLUSupport/SuperLUSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
info	src/UmfPackSupport/UmfPackSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
init	src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodDecomposition	access:protected	signature:()
init	src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:protected	signature:()
init	src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLLT	access:protected	signature:()
init	src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSupernodalLLT	access:protected	signature:()
init	src/Core/Block.h	/^    void init()$/;"	f	class:Eigen::internal::BlockImpl_dense	access:protected	signature:()
init	src/Core/Visitor.h	/^  inline void init(const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
init	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void init()$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:()
init	src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLDLT	access:protected	signature:()
init	src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLLT	access:protected	signature:()
init	src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLU	access:protected	signature:()
init	src/PaStiXSupport/PaStiXSupport.h	/^    void init(); $/;"	p	class:Eigen::PastixBase	access:protected	signature:()
init	src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::init()$/;"	f	class:Eigen::PastixBase	signature:()
init	src/SparseCore/AmbiVector.h	/^    void init(double estimatedDensity);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(double estimatedDensity)
init	src/SparseCore/AmbiVector.h	/^    void init(int mode);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(int mode)
init	src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(double estimatedDensity)$/;"	f	class:Eigen::internal::AmbiVector	signature:(double estimatedDensity)
init	src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(int mode)$/;"	f	class:Eigen::internal::AmbiVector	signature:(int mode)
init	src/SparseCore/SparseProduct.h	/^    void init()$/;"	f	class:Eigen::SparseSparseProduct	access:protected	signature:()
init	src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperILU	access:protected	signature:()
init	src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLU	access:protected	signature:()
init	src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:()
init	src/UmfPackSupport/UmfPackSupport.h	/^    void init()$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:()
initAcc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(AccPacket& p)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(AccPacket& p)
initAcc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(DoublePacket& p)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DoublePacket& p)
initAcc	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(Scalar& p) { p = Scalar(0); }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(Scalar& p)
initAssignment	src/SparseCore/SparseMatrix.h	/^    void initAssignment(const Other& other)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(const Other& other)
initFactorization	src/SuperLUSupport/SuperLUSupport.h	/^    void initFactorization(const MatrixType& a)$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:(const MatrixType& a)
initFrancisQRStep	src/Eigenvalues/RealSchur.h	/^    void initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)
initFrancisQRStep	src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)$/;"	f	class:Eigen::RealSchur	signature:(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)
initParallel	src/Core/products/Parallelizer.h	/^inline void initParallel()$/;"	f	namespace:Eigen	signature:()
initParallelSession	src/Core/products/GeneralMatrixMatrix.h	/^  void initParallelSession() const$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:() const
init_rows_cols	src/OrderingMethods/Eigen_Colamd.h	/^static Index init_rows_cols  \/* returns true if OK, or false otherwise *\/$/;"	f	namespace:internal	signature:( Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index p [], Index stats [COLAMD_STATS] )
init_rows_cols	src/OrderingMethods/Eigen_Colamd.h	/^static Index init_rows_cols (Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> col [], Index A [], Index p [], Index stats[COLAMD_STATS] ); $/;"	p	namespace:internal	signature:(Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> col [], Index A [], Index p [], Index stats[COLAMD_STATS] )
init_scoring	src/OrderingMethods/Eigen_Colamd.h	/^static void init_scoring (Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], double knobs[COLAMD_KNOBS], Index *p_n_row2, Index *p_n_col2, Index *p_max_deg);$/;"	p	namespace:internal	signature:(Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], double knobs[COLAMD_KNOBS], Index *p_n_row2, Index *p_n_col2, Index *p_max_deg)
init_scoring	src/OrderingMethods/Eigen_Colamd.h	/^static void init_scoring$/;"	f	namespace:internal	signature:( Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], double knobs [COLAMD_KNOBS], Index *p_n_row2, Index *p_n_col2, Index *p_max_deg )
initperfvalues	src/SparseLU/SparseLU.h	/^    void initperfvalues()$/;"	f	class:Eigen::SparseLU	access:protected	signature:()
inner	src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon136
inner	src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon137
inner	src/Core/Redux.h	/^    inner = Start % Derived::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon302
inner	src/Core/Redux.h	/^    inner = index % int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon304
inner	src/Core/Stride.h	/^    inline Index inner() const { return m_inner.value(); }$/;"	f	class:Eigen::Stride	access:public	signature:() const
innerInd	src/SuperLUSupport/SuperLUSupport.h	/^    int *innerInd;$/;"	m	struct:Eigen::SluMatrix::__anon466	access:public
innerIndexPtr	src/SparseCore/MappedSparseMatrix.h	/^    inline Index* innerIndexPtr() { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
innerIndexPtr	src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
innerIndexPtr	src/SparseCore/SparseBlock.h	/^    inline Index* innerIndexPtr()$/;"	f	class:Eigen::BlockImpl	access:public	signature:()
innerIndexPtr	src/SparseCore/SparseBlock.h	/^    inline const Index* innerIndexPtr() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
innerIndexPtr	src/SparseCore/SparseMatrix.h	/^    inline Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
innerIndexPtr	src/SparseCore/SparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
innerIndexPtr	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
innerIndexPtr	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
innerNonZeroPtr	src/SparseCore/SparseMatrix.h	/^    inline Index* innerNonZeroPtr() { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
innerNonZeroPtr	src/SparseCore/SparseMatrix.h	/^    inline const Index* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
innerNonZeros	src/SparseCore/SparseMatrix.h	/^    Eigen::Map<Matrix<Index,Dynamic,1> > innerNonZeros() { return Eigen::Map<Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:()
innerNonZeros	src/SparseCore/SparseMatrix.h	/^    const  Eigen::Map<const Matrix<Index,Dynamic,1> > innerNonZeros() const { return Eigen::Map<const Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:() const
innerSize	src/Core/DenseBase.h	/^    Index innerSize() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
innerSize	src/SparseCore/MappedSparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
innerSize	src/SparseCore/SparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
innerSize	src/SparseCore/SparseMatrixBase.h	/^    Index innerSize() const { return (int(Flags)&RowMajorBit) ? this->cols() : this->rows(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
innerSize	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index innerSize() const { return m_size; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
innerSize	src/SparseCore/SparseView.h	/^  inline Index innerSize() const { return m_matrix.innerSize(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
innerStride	src/Core/Array.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Array	access:public	signature:() const
innerStride	src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
innerStride	src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
innerStride	src/Core/Block.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
innerStride	src/Core/Block.h	/^    inline Index innerStride() const;$/;"	p	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
innerStride	src/Core/CwiseUnaryView.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
innerStride	src/Core/DenseCoeffsBase.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
innerStride	src/Core/DenseCoeffsBase.h	/^    void innerStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
innerStride	src/Core/Diagonal.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
innerStride	src/Core/Flagged.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
innerStride	src/Core/ForceAlignedAccess.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
innerStride	src/Core/Map.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Map	access:public	signature:() const
innerStride	src/Core/Matrix.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Matrix	access:public	signature:() const
innerStride	src/Core/NestByValue.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
innerStride	src/Core/Ref.h	/^  inline Index innerStride() const$/;"	f	class:Eigen::RefBase	access:public	signature:() const
innerStride	src/Core/Reverse.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Reverse	access:public	signature:() const
innerStride	src/Core/SelfAdjointView.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
innerStride	src/Core/SelfCwiseBinaryOp.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
innerStride	src/Core/Swap.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
innerStride	src/Core/Transpose.h	/^    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
innerStride	src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().innerStride(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
innerStride	src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
innerVector	src/SparseCore/SparseBlock.h	/^const typename SparseMatrixBase<Derived>::ConstInnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outer) const
innerVector	src/SparseCore/SparseBlock.h	/^typename SparseMatrixBase<Derived>::InnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outer)
innerVector	src/SparseCore/SparseMatrixBase.h	/^    InnerVectorReturnType innerVector(Index outer);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outer)
innerVector	src/SparseCore/SparseMatrixBase.h	/^    const ConstInnerVectorReturnType innerVector(Index outer) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outer) const
innerVectors	src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outerStart, Index outerSize) const
innerVectors	src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outerStart, Index outerSize)
innerVectors	src/SparseCore/SparseMatrixBase.h	/^    InnerVectorsReturnType innerVectors(Index outerStart, Index outerSize);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outerStart, Index outerSize)
innerVectors	src/SparseCore/SparseMatrixBase.h	/^    const ConstInnerVectorsReturnType innerVectors(Index outerStart, Index outerSize) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outerStart, Index outerSize) const
inner_stride_at_compile_time	src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time$/;"	s	namespace:Eigen::internal
inner_stride_at_compile_time	src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
inplace_decomposition	src/Cholesky/LLT.h	/^  static bool inplace_decomposition(MatrixType& m)$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(MatrixType& m)
inplace_transpose_selector	src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,false> { \/\/ non square matrix$/;"	s	namespace:Eigen::internal
inplace_transpose_selector	src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true> { \/\/ square matrix$/;"	s	namespace:Eigen::internal
insert	src/SparseCore/SparseMatrix.h	/^    Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
insert	src/SparseCore/SparseVector.h	/^    Scalar& insert(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
insert	src/SparseCore/SparseVector.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col)
insert	src/StlSupport/StdDeque.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const_iterator position, const value_type& x)
insert	src/StlSupport/StdDeque.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
insert	src/StlSupport/StdList.h	/^    iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::list	access:private	signature:(const_iterator position, const value_type& x)
insert	src/StlSupport/StdList.h	/^    void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::list	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
insert	src/StlSupport/StdVector.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const_iterator position, const value_type& x)
insert	src/StlSupport/StdVector.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
insertBack	src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
insertBack	src/SparseCore/SparseVector.h	/^    inline Scalar& insertBack(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
insertBackByOuterInner	src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer, Index inner)
insertBackByOuterInner	src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index outer, Index inner)
insertBackByOuterInnerUnordered	src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer, Index inner)
insertBackUncompressed	src/SparseCore/SparseMatrix.h	/^    EIGEN_STRONG_INLINE Scalar& insertBackUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
insertByOuterInner	src/SparseCore/SparseMatrix.h	/^    Scalar& insertByOuterInner(Index j, Index i)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index j, Index i)
insertCompressed	src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertCompressed(Index row, Index col);$/;"	p	class:Eigen::SparseMatrix	access:protected	signature:(Index row, Index col)
insertCompressed	src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_Index>::Scalar& SparseMatrix<_Scalar,_Options,_Index>::insertCompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	signature:(Index row, Index col)
insertUncompressed	src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertUncompressed(Index row, Index col);$/;"	p	class:Eigen::SparseMatrix	access:protected	signature:(Index row, Index col)
insertUncompressed	src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_Index>::Scalar& SparseMatrix<_Scalar,_Options,_Index>::insertUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	signature:(Index row, Index col)
internal	src/Cholesky/LDLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Cholesky/LLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Cholesky/LLT.h	/^namespace internal{$/;"	n	namespace:Eigen
internal	src/Cholesky/LLT_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/CholmodSupport/CholmodSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Array.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/ArrayWrapper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Assign.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Assign_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/BandMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Block.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/BooleanRedux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/CwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/CwiseNullaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/CwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/CwiseUnaryView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/DenseBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/DenseCoeffsBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/DenseStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Diagonal.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/DiagonalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/DiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Dot.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Flagged.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/ForceAlignedAccess.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Functors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Fuzzy.h	/^namespace internal$/;"	n	namespace:Eigen
internal	src/Core/GeneralProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/GenericPacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/GlobalFunctions.h	/^  namespace internal$/;"	n	namespace:Eigen
internal	src/Core/IO.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Map.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Matrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/NestByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/PermutationMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/PlainObjectBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/ProductBase.h	/^namespace internal {$/;"	n
internal	src/Core/ProductBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Random.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Redux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Ref.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Replicate.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/ReturnByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Reverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Select.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/SelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/SelfCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/SolveTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/StableNorm.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Swap.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Transpose.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Transpositions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/TriangularMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/VectorBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/VectorwiseOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/Visitor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/arch/AltiVec/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/arch/AltiVec/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/arch/NEON/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/arch/NEON/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/arch/SSE/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/arch/SSE/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/arch/SSE/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/CoeffBasedProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/GeneralBlockPanelKernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/GeneralMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/GeneralMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/GeneralMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/Parallelizer.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/SelfadjointMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/SelfadjointMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/SelfadjointRank2Update.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/TriangularMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/TriangularMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/TriangularMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/TriangularSolverMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/products/TriangularSolverVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/BlasUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/Constants.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/ForwardDeclarations.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/MKL_support.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/Macros.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/Macros.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/StaticAssert.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	src/Core/util/XprHelper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Eigen2Support/Minor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Eigenvalues/ComplexSchur.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Eigenvalues/HessenbergDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Eigenvalues/Tridiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Geometry/AngleAxis.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Geometry/Homogeneous.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Geometry/OrthoMethods.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Geometry/Quaternion.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Geometry/Rotation2D.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Geometry/RotationBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Geometry/Transform.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Geometry/Umeyama.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Geometry/arch/Geometry_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Householder/BlockHouseholder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Householder/Householder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Householder/HouseholderSequence.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/Jacobi/Jacobi.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/LU/Determinant.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/LU/FullPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/LU/Inverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/LU/PartialPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/LU/PartialPivLU_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/LU/arch/Inverse_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/OrderingMethods/Amd.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/OrderingMethods/Eigen_Colamd.h	/^namespace internal {$/;"	n
internal	src/OrderingMethods/Ordering.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/PaStiXSupport/PaStiXSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/PaStiXSupport/PaStiXSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	src/PardisoSupport/PardisoSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/PardisoSupport/PardisoSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	src/QR/ColPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/QR/FullPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/QR/HouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/QR/HouseholderQR_MKL.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	src/SPQRSupport/SuiteSparseQRSupport.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	src/SPQRSupport/SuiteSparseQRSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SVD/JacobiSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SVD/UpperBidiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCholesky/SimplicialCholesky.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/AmbiVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/CompressedStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/MappedSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseColEtree.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseDenseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseDiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparsePermutation.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseSelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseSparseProductWithPruning.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseTriangularView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/SparseView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseCore/TriangularSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLUImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_Structs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_SupernodalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_Utils.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_column_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_column_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_copy_to_ucol.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_gemm_kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_heap_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_kernel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_panel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_panel_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_pivotL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_pruneL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseLU/SparseLU_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/SparseQR/SparseQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/StlSupport/details.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	src/SuperLUSupport/SuperLUSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/UmfPackSupport/UmfPackSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/misc/Image.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/misc/Kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/misc/Solve.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	src/misc/SparseSolve.h	/^namespace internal {$/;"	n	namespace:Eigen
internal::Colamd_Row	src/OrderingMethods/Eigen_Colamd.h	/^struct Colamd_Row$/;"	s	namespace:internal
internal::Colamd_Row::__anon406::degree	src/OrderingMethods/Eigen_Colamd.h	/^    Index degree ;  \/* number of principal & non-principal columns in row *\/$/;"	m	union:internal::Colamd_Row::__anon406	access:public
internal::Colamd_Row::__anon406::p	src/OrderingMethods/Eigen_Colamd.h	/^    Index p ;   \/* used as a row pointer in init_rows_cols () *\/$/;"	m	union:internal::Colamd_Row::__anon406	access:public
internal::Colamd_Row::__anon407::first_column	src/OrderingMethods/Eigen_Colamd.h	/^    Index first_column ;\/* first column in row (used in garbage collection) *\/$/;"	m	union:internal::Colamd_Row::__anon407	access:public
internal::Colamd_Row::__anon407::mark	src/OrderingMethods/Eigen_Colamd.h	/^    Index mark ;  \/* for computing set differences and marking dead rows*\/$/;"	m	union:internal::Colamd_Row::__anon407	access:public
internal::Colamd_Row::length	src/OrderingMethods/Eigen_Colamd.h	/^  Index length ;  \/* number of principal columns in this row *\/$/;"	m	struct:internal::Colamd_Row	access:public
internal::Colamd_Row::shared1	src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon406	access:public
internal::Colamd_Row::shared2	src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon407	access:public
internal::Colamd_Row::start	src/OrderingMethods/Eigen_Colamd.h	/^  Index start ;   \/* index for A of first col in this row *\/$/;"	m	struct:internal::Colamd_Row	access:public
internal::clear_mark	src/OrderingMethods/Eigen_Colamd.h	/^static inline  Index clear_mark  \/* return the new value for tag_mark *\/$/;"	f	namespace:internal	signature:( Index n_row, Colamd_Row<Index> Row [] )
internal::clear_mark	src/OrderingMethods/Eigen_Colamd.h	/^static inline  Index clear_mark (Index n_row, Colamd_Row<Index> Row [] ) ;$/;"	p	namespace:internal	signature:(Index n_row, Colamd_Row<Index> Row [] )
internal::colamd	src/OrderingMethods/Eigen_Colamd.h	/^static bool colamd(Index n_row, Index n_col, Index Alen, Index *A, Index *p, double knobs[COLAMD_KNOBS], Index stats[COLAMD_STATS])$/;"	f	namespace:internal	signature:(Index n_row, Index n_col, Index Alen, Index *A, Index *p, double knobs[COLAMD_KNOBS], Index stats[COLAMD_STATS])
internal::colamd_c	src/OrderingMethods/Eigen_Colamd.h	/^inline Index colamd_c(Index n_col) $/;"	f	namespace:internal	signature:(Index n_col)
internal::colamd_col	src/OrderingMethods/Eigen_Colamd.h	/^struct colamd_col$/;"	s	namespace:internal
internal::colamd_col::__anon402::parent	src/OrderingMethods/Eigen_Colamd.h	/^    Index parent ;  \/* parent in parent tree super-column structure, if *\/$/;"	m	union:internal::colamd_col::__anon402	access:public
internal::colamd_col::__anon402::thickness	src/OrderingMethods/Eigen_Colamd.h	/^    Index thickness ; \/* number of original columns represented by this *\/$/;"	m	union:internal::colamd_col::__anon402	access:public
internal::colamd_col::__anon403::order	src/OrderingMethods/Eigen_Colamd.h	/^    Index order ; \/* pivot ordering of this column, if col is dead *\/$/;"	m	union:internal::colamd_col::__anon403	access:public
internal::colamd_col::__anon403::score	src/OrderingMethods/Eigen_Colamd.h	/^    Index score ; \/* the score used to maintain heap, if col is alive *\/$/;"	m	union:internal::colamd_col::__anon403	access:public
internal::colamd_col::__anon404::hash	src/OrderingMethods/Eigen_Colamd.h	/^    Index hash ;  \/* hash value, if col is not in a degree list *\/$/;"	m	union:internal::colamd_col::__anon404	access:public
internal::colamd_col::__anon404::headhash	src/OrderingMethods/Eigen_Colamd.h	/^    Index headhash ;  \/* head of a hash bucket, if col is at the head of *\/$/;"	m	union:internal::colamd_col::__anon404	access:public
internal::colamd_col::__anon404::prev	src/OrderingMethods/Eigen_Colamd.h	/^    Index prev ;  \/* previous column in degree list, if col is in a *\/$/;"	m	union:internal::colamd_col::__anon404	access:public
internal::colamd_col::__anon405::degree_next	src/OrderingMethods/Eigen_Colamd.h	/^    Index degree_next ; \/* next column, if col is in a degree list *\/$/;"	m	union:internal::colamd_col::__anon405	access:public
internal::colamd_col::__anon405::hash_next	src/OrderingMethods/Eigen_Colamd.h	/^    Index hash_next ;   \/* next column, if col is in a hash list *\/$/;"	m	union:internal::colamd_col::__anon405	access:public
internal::colamd_col::length	src/OrderingMethods/Eigen_Colamd.h	/^  Index length ;  \/* number of rows in this column *\/$/;"	m	struct:internal::colamd_col	access:public
internal::colamd_col::shared1	src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon402	access:public
internal::colamd_col::shared2	src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon403	access:public
internal::colamd_col::shared3	src/OrderingMethods/Eigen_Colamd.h	/^  } shared3 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon404	access:public
internal::colamd_col::shared4	src/OrderingMethods/Eigen_Colamd.h	/^  } shared4 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon405	access:public
internal::colamd_col::start	src/OrderingMethods/Eigen_Colamd.h	/^  Index start ;   \/* index for A of first row in this column, or DEAD *\/$/;"	m	struct:internal::colamd_col	access:public
internal::colamd_r	src/OrderingMethods/Eigen_Colamd.h	/^inline Index  colamd_r(Index n_row)$/;"	f	namespace:internal	signature:(Index n_row)
internal::colamd_recommended	src/OrderingMethods/Eigen_Colamd.h	/^inline Index colamd_recommended ( Index nnz, Index n_row, Index n_col)$/;"	f	namespace:internal	signature:( Index nnz, Index n_row, Index n_col)
internal::colamd_set_defaults	src/OrderingMethods/Eigen_Colamd.h	/^static inline void colamd_set_defaults(double knobs[COLAMD_KNOBS])$/;"	f	namespace:internal	signature:(double knobs[COLAMD_KNOBS])
internal::detect_super_cols	src/OrderingMethods/Eigen_Colamd.h	/^static void detect_super_cols (colamd_col<Index> Col [], Index A [], Index head [], Index row_start, Index row_length ) ;$/;"	p	namespace:internal	signature:(colamd_col<Index> Col [], Index A [], Index head [], Index row_start, Index row_length )
internal::detect_super_cols	src/OrderingMethods/Eigen_Colamd.h	/^static void detect_super_cols$/;"	f	namespace:internal	signature:( colamd_col<Index> Col [], Index A [], Index head [], Index row_start, Index row_length )
internal::find_ordering	src/OrderingMethods/Eigen_Colamd.h	/^static Index find_ordering (Index n_row, Index n_col, Index Alen, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], Index n_col2, Index max_deg, Index pfree);$/;"	p	namespace:internal	signature:(Index n_row, Index n_col, Index Alen, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], Index n_col2, Index max_deg, Index pfree)
internal::find_ordering	src/OrderingMethods/Eigen_Colamd.h	/^static Index find_ordering \/* return the number of garbage collections *\/$/;"	f	namespace:internal	signature:( Index n_row, Index n_col, Index Alen, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], Index n_col2, Index max_deg, Index pfree )
internal::garbage_collection	src/OrderingMethods/Eigen_Colamd.h	/^static Index garbage_collection  \/* returns the new value of pfree *\/$/;"	f	namespace:internal	signature:( Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index *pfree )
internal::garbage_collection	src/OrderingMethods/Eigen_Colamd.h	/^static Index garbage_collection (Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index *pfree) ;$/;"	p	namespace:internal	signature:(Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index *pfree)
internal::init_rows_cols	src/OrderingMethods/Eigen_Colamd.h	/^static Index init_rows_cols  \/* returns true if OK, or false otherwise *\/$/;"	f	namespace:internal	signature:( Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index p [], Index stats [COLAMD_STATS] )
internal::init_rows_cols	src/OrderingMethods/Eigen_Colamd.h	/^static Index init_rows_cols (Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> col [], Index A [], Index p [], Index stats[COLAMD_STATS] ); $/;"	p	namespace:internal	signature:(Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> col [], Index A [], Index p [], Index stats[COLAMD_STATS] )
internal::init_scoring	src/OrderingMethods/Eigen_Colamd.h	/^static void init_scoring (Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], double knobs[COLAMD_KNOBS], Index *p_n_row2, Index *p_n_col2, Index *p_max_deg);$/;"	p	namespace:internal	signature:(Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], double knobs[COLAMD_KNOBS], Index *p_n_row2, Index *p_n_col2, Index *p_max_deg)
internal::init_scoring	src/OrderingMethods/Eigen_Colamd.h	/^static void init_scoring$/;"	f	namespace:internal	signature:( Index n_row, Index n_col, Colamd_Row<Index> Row [], colamd_col<Index> Col [], Index A [], Index head [], double knobs [COLAMD_KNOBS], Index *p_n_row2, Index *p_n_col2, Index *p_max_deg )
internal::nested	src/Core/ProductBase.h	/^struct nested<GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>$/;"	s	namespace:internal
internal::nested	src/Core/ProductBase.h	/^struct nested<const GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>$/;"	s	namespace:internal
internal::nested::GeneralProduct::type	src/Core/ProductBase.h	/^  typedef typename GeneralProduct<Lhs,Rhs,Mode>::PlainObject const& type;$/;"	t	class:internal::nested::GeneralProduct	access:public
internal::order_children	src/OrderingMethods/Eigen_Colamd.h	/^static inline  void order_children$/;"	f	namespace:internal	signature:( Index n_col, colamd_col<Index> Col [], Index p [] )
internal::order_children	src/OrderingMethods/Eigen_Colamd.h	/^static void order_children (Index n_col, colamd_col<Index> Col [], Index p []);$/;"	p	namespace:internal	signature:(Index n_col, colamd_col<Index> Col [], Index p [])
internal::traits	src/Core/ProductBase.h	/^struct traits<ScaledProduct<NestedProduct> >$/;"	s	namespace:internal	inherits:traits
internal::traits::StorageKind	src/Core/ProductBase.h	/^  typedef typename traits<NestedProduct>::StorageKind StorageKind;$/;"	t	struct:internal::traits	access:public
intersection	src/Eigen2Support/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other)
intersection	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  Scalar intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
intersection	src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim>::intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
intersection	src/Geometry/AlignedBox.h	/^  inline AlignedBox intersection(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
intersection	src/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other) const
intersection	src/Geometry/ParametrizedLine.h	/^  Scalar intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersection	src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersectionParameter	src/Geometry/ParametrizedLine.h	/^  Scalar intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersectionParameter	src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersectionPoint	src/Geometry/ParametrizedLine.h	/^  VectorType intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersectionPoint	src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersects	src/Geometry/AlignedBox.h	/^  inline bool intersects(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
inverse	src/Core/DiagonalMatrix.h	/^    inverse() const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
inverse	src/Core/MatrixBase.h	/^    const internal::inverse_impl<Derived> inverse() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
inverse	src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> inverse() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
inverse	src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> inverse() const$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
inverse	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_inverse_op)  inverse() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
inverse	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::inverse() const$/;"	f	class:Eigen::Cwise	signature:() const
inverse	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
inverse	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion inverse(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
inverse	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::inverse() const$/;"	f	class:Eigen::Quaternion	signature:() const
inverse	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
inverse	src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
inverse	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling inverse() const$/;"	f	class:Eigen::Scaling	access:public	signature:() const
inverse	src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType inverse(TransformTraits traits = Affine) const;$/;"	p	class:Eigen::Transform	access:public	signature:(TransformTraits traits = Affine) const
inverse	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::inverse(TransformTraits traits) const$/;"	f	class:Eigen::Transform	signature:(TransformTraits traits) const
inverse	src/Eigen2Support/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
inverse	src/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
inverse	src/Geometry/Quaternion.h	/^  Quaternion<Scalar> inverse() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
inverse	src/Geometry/Quaternion.h	/^inline Quaternion<typename internal::traits<Derived>::Scalar> QuaternionBase<Derived>::inverse() const$/;"	f	class:Eigen::QuaternionBase	signature:() const
inverse	src/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
inverse	src/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
inverse	src/Geometry/Scaling.h	/^  inline UniformScaling inverse() const$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
inverse	src/Geometry/Transform.h	/^  inline Transform inverse(TransformTraits traits = (TransformTraits)Mode) const;$/;"	p	class:Eigen::Transform	access:public	signature:(TransformTraits traits = (TransformTraits)Mode) const
inverse	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::inverse(TransformTraits hint) const$/;"	f	class:Eigen::Transform	signature:(TransformTraits hint) const
inverse	src/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
inverse	src/Householder/HouseholderSequence.h	/^    ConjugateReturnType inverse() const { return adjoint(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
inverse	src/LU/FullPivLU.h	/^    inline const internal::solve_retval<FullPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
inverse	src/LU/Inverse.h	/^inline const internal::inverse_impl<Derived> MatrixBase<Derived>::inverse() const$/;"	f	class:Eigen::MatrixBase	signature:() const
inverse	src/LU/PartialPivLU.h	/^    inline const internal::solve_retval<PartialPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
inverse	src/QR/ColPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
inverse	src/QR/FullPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
inverse	src/plugins/ArrayCwiseUnaryOps.h	/^inverse() const$/;"	f	signature:() const
inverse_impl	src/LU/Inverse.h	/^  inverse_impl(const MatrixType& matrix)$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:(const MatrixType& matrix)
inverse_impl	src/LU/Inverse.h	/^struct inverse_impl : public ReturnByValue<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
iparm	src/PaStiXSupport/PaStiXSupport.h	/^    Array<Index,IPARM_SIZE,1>& iparm()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
iparm	src/PaStiXSupport/PaStiXSupport.h	/^    int& iparm(int idxparam)$/;"	f	class:Eigen::PastixBase	access:public	signature:(int idxparam)
iqamax	src/misc/blas.h	/^int    BLASFUNC(iqamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
iqamin	src/misc/blas.h	/^int    BLASFUNC(iqamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
iqmax	src/misc/blas.h	/^int    BLASFUNC(iqmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
iqmin	src/misc/blas.h	/^int    BLASFUNC(iqmin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
isApprox	src/Core/DenseBase.h	/^    bool isApprox(const DenseBase<OtherDerived>& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Core/DiagonalMatrix.h	/^    bool isApprox(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Core/DiagonalMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isApprox($/;"	f	class:Eigen::DenseBase	signature:( const DenseBase<OtherDerived>& other, const RealScalar& prec ) const
isApprox	src/Core/MathFunctions.h	/^  static inline bool isApprox(bool x, bool y, bool)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(bool x, bool y, bool)
isApprox	src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar& prec)
isApprox	src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar&)
isApprox	src/Core/MathFunctions.h	/^inline bool isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
isApprox	src/Core/TriangularMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Core/TriangularMatrix.h	/^    bool isApprox(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Eigen2Support/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	src/Eigen2Support/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	src/Eigen2Support/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	src/Eigen2Support/Geometry/Quaternion.h	/^  bool isApprox(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	src/Eigen2Support/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	src/Eigen2Support/Geometry/Scaling.h	/^  bool isApprox(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	src/Eigen2Support/Geometry/Transform.h	/^  bool isApprox(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	src/Eigen2Support/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	src/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, const RealScalar& prec = ScalarTraits::dummy_precision()) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& other, const RealScalar& prec = ScalarTraits::dummy_precision()) const
isApprox	src/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Geometry/Quaternion.h	/^  bool isApprox(const QuaternionBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Geometry/Scaling.h	/^  bool isApprox(const UniformScaling& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Geometry/Transform.h	/^  bool isApprox(const Transform& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const SparseMatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isApproxOrLessThan	src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar& prec)
isApproxOrLessThan	src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar&)
isApproxOrLessThan	src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(const bool& x, const bool& y, const bool&)
isApproxOrLessThan	src/Core/MathFunctions.h	/^inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
isApproxToConstant	src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isApproxToConstant$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& val, const RealScalar& prec) const
isApproxToConstant	src/Core/DenseBase.h	/^    bool isApproxToConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isApprox_selector	src/Core/Fuzzy.h	/^struct isApprox_selector$/;"	s	namespace:Eigen::internal
isApprox_selector	src/Core/Fuzzy.h	/^struct isApprox_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isCompressed	src/SparseCore/MappedSparseMatrix.h	/^    bool isCompressed() const { return true; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
isCompressed	src/SparseCore/SparseMatrix.h	/^    inline bool isCompressed() const { return m_innerNonZeros==0; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
isConstant	src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isConstant$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& val, const RealScalar& prec) const
isConstant	src/Core/DenseBase.h	/^    bool isConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isDiagonal	src/Core/DiagonalMatrix.h	/^bool MatrixBase<Derived>::isDiagonal(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
isDiagonal	src/Core/MatrixBase.h	/^    bool isDiagonal(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isEmpty	src/Geometry/AlignedBox.h	/^  inline bool isEmpty() const { return (m_min.array() > m_max.array()).any(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
isFullRank	src/Eigen2Support/QR.h	/^    bool isFullRank() const {$/;"	f	class:Eigen::QR	access:public	signature:() const
isIdentity	src/Core/CwiseNullaryOp.h	/^bool MatrixBase<Derived>::isIdentity$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
isIdentity	src/Core/MatrixBase.h	/^    bool isIdentity(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isInjective	src/LU/FullPivLU.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
isInjective	src/QR/ColPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
isInjective	src/QR/FullPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
isInvertible	src/LU/FullPivLU.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
isInvertible	src/QR/ColPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
isInvertible	src/QR/FullPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
isLowerTriangular	src/Core/MatrixBase.h	/^    bool isLowerTriangular(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isLowerTriangular	src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isLowerTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
isMuchSmallerThan	src/Core/DenseBase.h	/^    bool isMuchSmallerThan(const DenseBase<OtherDerived>& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isMuchSmallerThan	src/Core/DenseBase.h	/^    bool isMuchSmallerThan(const RealScalar& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const RealScalar& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isMuchSmallerThan	src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase	signature:( const DenseBase<OtherDerived>& other, const RealScalar& prec ) const
isMuchSmallerThan	src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase	signature:( const typename NumTraits<Scalar>::Real& other, const RealScalar& prec ) const
isMuchSmallerThan	src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const OtherScalar& y, const RealScalar& prec)
isMuchSmallerThan	src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar&, const RealScalar&)
isMuchSmallerThan	src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(const bool& x, const bool&, const bool&)
isMuchSmallerThan	src/Core/MathFunctions.h	/^inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const OtherScalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
isMuchSmallerThan_object_selector	src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_object_selector	src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector<Derived, true>$/;"	s	namespace:Eigen::internal
isNegative	src/Cholesky/LDLT.h	/^    inline bool isNegative(void) const$/;"	f	class:Eigen::LDLT	access:public	signature:(void) const
isNull	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool isNull() const { return (m_min.cwise() > m_max).any(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
isNull	src/Geometry/AlignedBox.h	/^  inline bool isNull() const { return isEmpty(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
isOnes	src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isOnes$/;"	f	class:Eigen::DenseBase	signature:(const RealScalar& prec) const
isOnes	src/Core/DenseBase.h	/^    bool isOnes(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isOrthogonal	src/Core/Dot.h	/^bool MatrixBase<Derived>::isOrthogonal$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other, const RealScalar& prec) const
isOrthogonal	src/Core/MatrixBase.h	/^    bool isOrthogonal(const MatrixBase<OtherDerived>& other,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isPositive	src/Cholesky/LDLT.h	/^    inline bool isPositive() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
isPositiveDefinite	src/Cholesky/LDLT.h	/^    inline bool isPositiveDefinite() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
isPositiveDefinite	src/Cholesky/LLT.h	/^    bool isPositiveDefinite() const { return true; }$/;"	f	class:Eigen::LLT	access:public	signature:() const
isRValue	src/SparseCore/SparseMatrixBase.h	/^    bool isRValue() const { return m_isRValue; }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
isSurjective	src/LU/FullPivLU.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
isSurjective	src/QR/ColPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
isSurjective	src/QR/FullPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
isSymmetric	src/SparseLU/SparseLU.h	/^    void isSymmetric(bool sym)$/;"	f	class:Eigen::SparseLU	access:public	signature:(bool sym)
isUnitary	src/Core/Dot.h	/^bool MatrixBase<Derived>::isUnitary(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
isUnitary	src/Core/MatrixBase.h	/^    bool isUnitary(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isUpperTriangular	src/Core/MatrixBase.h	/^    bool isUpperTriangular(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
isUpperTriangular	src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isUpperTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase	signature:(const RealScalar& prec) const
isVector	src/SparseCore/SparseMatrixBase.h	/^    inline bool isVector() const { return rows()==1 || cols()==1; }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
isZero	src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isZero(const RealScalar& prec) const$/;"	f	class:Eigen::DenseBase	signature:(const RealScalar& prec) const
isZero	src/Core/DenseBase.h	/^    bool isZero(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
is_arithmetic	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	s	namespace:Eigen::internal
is_const	src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_const	src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
is_diagonal	src/Core/util/Meta.h	/^template<typename T, int S> struct is_diagonal<DiagonalMatrix<T,S> >$/;"	s	namespace:Eigen
is_diagonal	src/Core/util/Meta.h	/^template<typename T> struct is_diagonal$/;"	s	namespace:Eigen
is_diagonal	src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalBase<T> >$/;"	s	namespace:Eigen
is_diagonal	src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalWrapper<T> >$/;"	s	namespace:Eigen
is_large	src/Core/GeneralProduct.h	/^  enum { is_large = MaxSize == Dynamic ||$/;"	e	enum:Eigen::internal::product_size_category::__anon242
is_malloc_allowed	src/Core/util/Memory.h	/^inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }$/;"	f	namespace:Eigen::internal	signature:()
is_malloc_allowed_impl	src/Core/util/Memory.h	/^inline bool is_malloc_allowed_impl(bool update, bool new_value = false)$/;"	f	namespace:Eigen::internal	signature:(bool update, bool new_value = false)
is_row_major	src/Core/GeneralProduct.h	/^    template<typename T> struct is_row_major : internal::conditional<(int(T::Flags)&RowMajorBit), internal::true_type, internal::false_type>::type {};$/;"	s	class:Eigen::GeneralProduct	inherits:internal::conditional::type	access:private
is_same	src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_same	src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
isamax	src/misc/blas.h	/^int    BLASFUNC(isamax)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
isamin	src/misc/blas.h	/^int    BLASFUNC(isamin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
isfinite	src/Core/MathFunctions.h	/^template<typename T> bool (isfinite)(const T& x)$/;"	f	namespace:Eigen::numext	signature:(const T& x)
ismax	src/misc/blas.h	/^int    BLASFUNC(ismax) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
ismin	src/misc/blas.h	/^int    BLASFUNC(ismin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
iterations	src/Eigenvalues/RealQZ.h	/^      Index iterations() const$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
iterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int iterations() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
ixamax	src/misc/blas.h	/^int    BLASFUNC(ixamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
ixamin	src/misc/blas.h	/^int    BLASFUNC(ixamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
ixmax	src/misc/blas.h	/^int    BLASFUNC(ixmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
ixmin	src/misc/blas.h	/^int    BLASFUNC(ixmin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
izamax	src/misc/blas.h	/^int    BLASFUNC(izamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
izamin	src/misc/blas.h	/^int    BLASFUNC(izamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
izmax	src/misc/blas.h	/^int    BLASFUNC(izmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
izmin	src/misc/blas.h	/^int    BLASFUNC(izmin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
jacobiSvd	src/Core/MatrixBase.h	/^    JacobiSVD<PlainObject> jacobiSvd(unsigned int computationOptions = 0) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(unsigned int computationOptions = 0) const
jacobiSvd	src/SVD/JacobiSVD.h	/^MatrixBase<Derived>::jacobiSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase	signature:(unsigned int computationOptions) const
kc	src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex kc() const { return m_kc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
keep_diag	src/IterativeLinearSolvers/IncompleteLUT.h	/^    struct keep_diag {$/;"	s	class:Eigen::IncompleteLUT	access:protected
keep_diag	src/SparseCholesky/SimplicialCholesky.h	/^    struct keep_diag {$/;"	s	class:Eigen::SimplicialCholeskyBase	access:protected
kernel	src/LU/FullPivLU.h	/^    inline const internal::kernel_retval<FullPivLU> kernel() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
kernel_retval	src/LU/FullPivLU.h	/^struct kernel_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:kernel_retval_base
kernel_retval_base	src/misc/Kernel.h	/^  kernel_retval_base(const DecompositionType& dec)$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:(const DecompositionType& dec)
kernel_retval_base	src/misc/Kernel.h	/^template<typename _DecompositionType> struct kernel_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
l1CacheSize	src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l1CacheSize()$/;"	f	namespace:Eigen	signature:()
l2CacheSize	src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l2CacheSize()$/;"	f	namespace:Eigen	signature:()
lastCoeff	src/SparseCore/SparseBlock.h	/^    const Scalar& lastCoeff() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
lastErrorMessage	src/SparseLU/SparseLU.h	/^    std::string lastErrorMessage() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
lastErrorMessage	src/SparseQR/SparseQR.h	/^    std::string lastErrorMessage() const { return m_lastError; }$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
lazy	src/Core/MatrixBase.h	/^    const Flagged<Derived, 0, EvalBeforeAssigningBit> lazy() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
lazy	src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::lazy() const$/;"	f	class:Eigen::MatrixBase	signature:() const
lazyAssign	src/Core/Assign.h	/^  ::lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
lazyAssign	src/Core/DenseBase.h	/^    Derived& lazyAssign(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
lazyAssign	src/Core/DenseBase.h	/^    Derived& lazyAssign(const ReturnByValue<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
lazyAssign	src/Core/MatrixBase.h	/^    Derived& lazyAssign(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)
lazyAssign	src/Core/MatrixBase.h	/^    Derived& lazyAssign(const MatrixPowerProduct<MatrixPower, Lhs,Rhs>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixPowerProduct<MatrixPower, Lhs,Rhs>& other)
lazyAssign	src/Core/MatrixBase.h	/^    Derived& lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
lazyAssign	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived>& other)
lazyAssign	src/Core/ProductBase.h	/^Derived& MatrixBase<Derived>::lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:MatrixBase	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
lazyAssign	src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::lazyAssign(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const ReturnByValue<OtherDerived>& other)
lazyAssign	src/Core/SelfCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(const DenseBase<RhsDerived>& rhs)
lazyAssign	src/Core/TriangularMatrix.h	/^    void lazyAssign(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other)
lazyAssign	src/Core/TriangularMatrix.h	/^    void lazyAssign(const TriangularBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const TriangularBase<OtherDerived>& other)
lazyAssign	src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& other)
lazyAssign	src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const TriangularBase<OtherDerived>& other)
lazyProduct	src/Core/GeneralProduct.h	/^MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
lazyProduct	src/Core/MatrixBase.h	/^    lazyProduct(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
lda	src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon466::__anon467	access:public
ldlt	src/Cholesky/LDLT.h	/^MatrixBase<Derived>::ldlt() const$/;"	f	class:Eigen::MatrixBase	signature:() const
ldlt	src/Cholesky/LDLT.h	/^SelfAdjointView<MatrixType, UpLo>::ldlt() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
ldlt	src/Core/MatrixBase.h	/^    const LDLT<PlainObject> ldlt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
ldlt	src/Core/SelfAdjointView.h	/^    const LDLT<PlainObject, UpLo> ldlt() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
ldlt_inplace	src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Lower>$/;"	s	namespace:Eigen::internal
ldlt_inplace	src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Upper>$/;"	s	namespace:Eigen::internal
leftCols	src/plugins/BlockMethods.h	/^inline ColsBlockXpr leftCols(Index n)$/;"	f	signature:(Index n)
leftCols	src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr leftCols(Index n) const$/;"	f	signature:(Index n) const
leftCols	src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type leftCols(Index n = N) const$/;"	f	signature:(Index n = N) const
leftCols	src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type leftCols(Index n = N)$/;"	f	signature:(Index n = N)
length	src/Householder/HouseholderSequence.h	/^    Index length() const { return m_length; }  \/**< \\brief Returns the length of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
length	src/OrderingMethods/Eigen_Colamd.h	/^  Index length ;  \/* number of principal columns in this row *\/$/;"	m	struct:internal::Colamd_Row	access:public
length	src/OrderingMethods/Eigen_Colamd.h	/^  Index length ;  \/* number of rows in this column *\/$/;"	m	struct:internal::colamd_col	access:public
level3_blocking	src/Core/products/GeneralMatrixMatrix.h	/^    level3_blocking()$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
level3_blocking	src/Core/products/GeneralMatrixMatrix.h	/^class level3_blocking$/;"	c	namespace:Eigen::internal
lhs	src/Core/CwiseBinaryOp.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
lhs	src/Core/products/CoeffBasedProduct.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
lhs	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
lhs	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
lhs	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
linear	src/Eigen2Support/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
linear	src/Eigen2Support/Geometry/Transform.h	/^  inline LinearPart linear() { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:()
linear	src/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return ConstLinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
linear	src/Geometry/Transform.h	/^  inline LinearPart linear() { return LinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:()
linearExt	src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt()$/;"	f	class:Eigen::Transform	access:public	signature:()
linearExt	src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
linearRegression	src/Eigen2Support/LeastSquares.h	/^void linearRegression(int numPoints,$/;"	f	namespace:Eigen	signature:(int numPoints, VectorType **points, VectorType *result, int funcOfOthers )
linspaced_op	src/Core/Functors.h	/^  linspaced_op(const Scalar& low, const Scalar& high, DenseIndex num_steps) : impl((num_steps==1 ? high : low), (num_steps==1 ? Scalar() : (high-low)\/Scalar(num_steps-1))) {}$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(const Scalar& low, const Scalar& high, DenseIndex num_steps)
linspaced_op	src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct linspaced_op$/;"	s	namespace:Eigen::internal
linspaced_op_impl	src/Core/Functors.h	/^  linspaced_op_impl(const Scalar& low, const Scalar& step) :$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(const Scalar& low, const Scalar& step)
linspaced_op_impl	src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,false>$/;"	s	namespace:Eigen::internal
linspaced_op_impl	src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
list	src/StlSupport/StdList.h	/^  class list<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:list
list_base	src/StlSupport/StdList.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > list_base;$/;"	t	class:std::list	access:private
llt	src/Cholesky/LLT.h	/^MatrixBase<Derived>::llt() const$/;"	f	class:Eigen::MatrixBase	signature:() const
llt	src/Cholesky/LLT.h	/^SelfAdjointView<MatrixType, UpLo>::llt() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
llt	src/Core/MatrixBase.h	/^    const LLT<PlainObject>  llt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
llt	src/Core/SelfAdjointView.h	/^    const LLT<PlainObject, UpLo> llt() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
llt_inplace	src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Lower>$/;"	s	namespace:Eigen::internal
llt_inplace	src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Upper>$/;"	s	namespace:Eigen::internal
llt_rank_update_lower	src/Cholesky/LLT.h	/^static typename MatrixType::Index llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)
loadLhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsScalar* a, LhsPacket& dest) const
loadRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, DoublePacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, DoublePacket& dest) const
loadRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, ResPacket& dest) const { dest = *b; }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, ResPacket& dest) const
loadRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, RhsPacket& dest) const
log	src/Core/MatrixBase.h	/^    const MatrixLogarithmReturnValue<Derived> log() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
log	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_log_op)      log() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
log	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::log() const$/;"	f	class:Eigen::Cwise	signature:() const
log	src/plugins/ArrayCwiseUnaryOps.h	/^log() const$/;"	f	signature:() const
logAbsDeterminant	src/QR/ColPivHouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
logAbsDeterminant	src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
logAbsDeterminant	src/QR/FullPivHouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
logAbsDeterminant	src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
logAbsDeterminant	src/QR/HouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::HouseholderQR	access:public	signature:() const
logAbsDeterminant	src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::HouseholderQR	signature:() const
logAbsDeterminant	src/SparseLU/SparseLU.h	/^     Scalar logAbsDeterminant() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
lpNorm	src/Core/DenseBase.h	/^    template<int p> RealScalar lpNorm() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
lpNorm	src/Core/Dot.h	/^MatrixBase<Derived>::lpNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
lpNorm	src/Core/MatrixBase.h	/^    template<int p> RealScalar lpNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
lpNorm_selector	src/Core/Dot.h	/^struct lpNorm_selector$/;"	s	namespace:Eigen::internal
lpNorm_selector	src/Core/Dot.h	/^struct lpNorm_selector<Derived, 1>$/;"	s	namespace:Eigen::internal
lpNorm_selector	src/Core/Dot.h	/^struct lpNorm_selector<Derived, 2>$/;"	s	namespace:Eigen::internal
lpNorm_selector	src/Core/Dot.h	/^struct lpNorm_selector<Derived, Infinity>$/;"	s	namespace:Eigen::internal
lsub	src/SparseLU/SparseLU_Structs.h	/^  IndexVector lsub; \/\/ Compressed row indices of L rectangular supernodes. $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
lu	src/Core/MatrixBase.h	/^    const LU<PlainObject> lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
lu	src/Core/MatrixBase.h	/^    const PartialPivLU<PlainObject> lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
lu	src/Eigen2Support/LU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
lu	src/LU/PartialPivLU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
lusup	src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  lusup; \/\/ nonzero values of L ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
m_E	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index *m_E; \/\/ The permutation applied to columns$/;"	m	class:Eigen::SPQR	access:protected
m_H	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_H;  \/\/The householder vectors$/;"	m	class:Eigen::SPQR	access:protected
m_HPinv	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index *m_HPinv; \/\/ The row permutation of H$/;"	m	class:Eigen::SPQR	access:protected
m_HTau	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_dense *m_HTau; \/\/ The Householder coefficients$/;"	m	class:Eigen::SPQR	access:protected
m_LDLT	src/SparseCholesky/SimplicialCholesky.h	/^    bool m_LDLT;$/;"	m	class:Eigen::SimplicialCholesky	access:protected
m_Lstore	src/SparseLU/SparseLU.h	/^    SCMatrix m_Lstore; \/\/ The lower triangular matrix (supernodal)$/;"	m	class:Eigen::SparseLU	access:protected
m_P	src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ Fill-reducing permutation$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_P	src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ the permutation$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_Pinv	src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ Inverse permutation$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_Pinv	src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ the inverse permutation$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_Q	src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ	access:private
m_Q	src/SparseQR/SparseQR.h	/^    QRMatrixType m_Q;               \/\/ The orthogonal reflectors$/;"	m	class:Eigen::SparseQR	access:protected
m_R	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable MatrixType m_R; \/\/ The sparse matrix R in Eigen format$/;"	m	class:Eigen::SPQR	access:protected
m_R	src/SparseQR/SparseQR.h	/^    QRMatrixType m_R;               \/\/ The triangular factor matrix$/;"	m	class:Eigen::SparseQR	access:protected
m_S	src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ	access:private
m_T	src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ	access:private
m_Ustore	src/SparseLU/SparseLU.h	/^    MappedSparseMatrix<Scalar,ColMajor,Index> m_Ustore; \/\/ The upper triangular matrix$/;"	m	class:Eigen::SparseLU	access:protected
m_Z	src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ	access:private
m_actualAlpha	src/Core/products/GeneralMatrixMatrix.h	/^    Scalar m_actualAlpha;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
m_adjoint	src/SVD/JacobiSVD.h	/^  TransposeTypeWithSameStorageOrder m_adjoint;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_allocatedElements	src/SparseCore/AmbiVector.h	/^    Index m_allocatedElements;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_allocatedSize	src/SparseCore/AmbiVector.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_allocatedSize	src/SparseCore/CompressedStorage.h	/^    size_t m_allocatedSize;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
m_allow_tol	src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_allow_tol; \/\/ Allow to use some tolerance during numerical factorization.$/;"	m	class:Eigen::SPQR	access:protected
m_alpha	src/Core/ProductBase.h	/^    Scalar m_alpha;$/;"	m	class:ScaledProduct	access:protected
m_alphas	src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType m_alphas;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
m_analysisIsOk	src/CholmodSupport/CholmodSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::CholmodBase	access:protected
m_analysisIsOk	src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_analysisIsOk	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_analysisIsOk	src/PaStiXSupport/PaStiXSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::PastixBase	access:protected
m_analysisIsOk	src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_analysisIsOk	src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SPQR	access:protected
m_analysisIsOk	src/SparseCholesky/SimplicialCholesky.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_analysisIsOk	src/SparseLU/SparseLU.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SparseLU	access:protected
m_analysisIsOk	src/SuperLUSupport/SuperLUSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_analysisIsOk	src/UmfPackSupport/UmfPackSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_analysisIsok	src/SparseQR/SparseQR.h	/^    bool m_analysisIsok;$/;"	m	class:Eigen::SparseQR	access:protected
m_angle	src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis	access:protected
m_angle	src/Eigen2Support/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D	access:protected
m_angle	src/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis	access:protected
m_angle	src/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D	access:protected
m_axis	src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis	access:protected
m_axis	src/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis	access:protected
m_base	src/Core/Functors.h	/^  mutable Packet m_base;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_begin	src/SparseCore/SparseBlock.h	/^      Index m_begin;$/;"	m	class:Eigen::BlockImpl::ReverseInnerIterator	access:private
m_betas	src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType m_betas;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
m_bidiagonal	src/SVD/UpperBidiagonalization.h	/^    BidiagonalType m_bidiagonal;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
m_block	src/SparseCore/SparseBlock.h	/^      const BlockType& m_block;$/;"	m	class:Eigen::BlockImpl::InnerIterator	access:private
m_block	src/SparseCore/SparseBlock.h	/^      const BlockType& m_block;$/;"	m	class:Eigen::BlockImpl::ReverseInnerIterator	access:private
m_blockA	src/Core/products/GeneralMatrixMatrix.h	/^    LhsScalar* m_blockA;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_blockB	src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockB;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_blockCols	src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
m_blockCols	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::BlockImpl	access:protected
m_blockRows	src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
m_blockRows	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::BlockImpl	access:protected
m_blockW	src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockW;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_blocking	src/Core/products/GeneralMatrixMatrix.h	/^    BlockingType& m_blocking;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
m_buffer	src/SparseCore/AmbiVector.h	/^    Scalar* m_buffer;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_c	src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation	access:protected
m_cR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_cR; \/\/ The sparse R factor in cholmod format$/;"	m	class:Eigen::SPQR	access:protected
m_cachedIndex	src/SparseCore/AmbiVector.h	/^    Index m_cachedIndex;          \/\/ current coordinate$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_cachedValue	src/SparseCore/AmbiVector.h	/^    Scalar m_cachedValue;       \/\/ current value$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_cc	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_common m_cc; \/\/ Workspace and parameters$/;"	m	class:Eigen::SPQR	access:protected
m_cholmod	src/CholmodSupport/CholmodSupport.h	/^    mutable cholmod_common m_cholmod;$/;"	m	class:Eigen::CholmodBase	access:protected
m_cholmodFactor	src/CholmodSupport/CholmodSupport.h	/^    cholmod_factor* m_cholmodFactor;$/;"	m	class:Eigen::CholmodBase	access:protected
m_coeffs	src/Core/BandMatrix.h	/^    CoefficientsType m_coeffs;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
m_coeffs	src/Core/BandMatrix.h	/^    const CoefficientsType& m_coeffs;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
m_coeffs	src/Eigen2Support/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane	access:protected
m_coeffs	src/Eigen2Support/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion	access:protected
m_coeffs	src/Eigen2Support/Geometry/Scaling.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Scaling	access:protected
m_coeffs	src/Eigen2Support/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation	access:protected
m_coeffs	src/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane	access:protected
m_coeffs	src/Geometry/Quaternion.h	/^    Coefficients m_coeffs;$/;"	m	class:Eigen::Map	access:protected
m_coeffs	src/Geometry/Quaternion.h	/^    const Coefficients m_coeffs;$/;"	m	class:Eigen::Map	access:protected
m_coeffs	src/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion	access:protected
m_coeffs	src/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation	access:protected
m_coeffs	src/Householder/HouseholderSequence.h	/^    typename CoeffsType::Nested m_coeffs;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_col	src/Core/CommaInitializer.h	/^  Index m_col;              \/\/ current col id$/;"	m	struct:Eigen::CommaInitializer	access:public
m_col	src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor	access:protected
m_col	src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet	access:protected
m_col	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_col; \/\/ Number of columns $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
m_colFactor	src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;$/;"	m	class:Eigen::Replicate	access:protected
m_colSqNorms	src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colSqNorms;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_col_to_sup	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_col_to_sup; \/\/ col_to_sup[j] is the supernode number to which column j belongs$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
m_cols	src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
m_cols	src/Core/DenseStorage.h	/^    DenseIndex m_cols;$/;"	m	class:Eigen::DenseStorage	access:private
m_cols	src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::MapBase	access:protected
m_cols	src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_cols	src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
m_cols	src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
m_colsPermutation	src/QR/ColPivHouseholderQR.h	/^    PermutationType m_colsPermutation;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_colsTranspositions	src/LU/FullPivLU.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::FullPivLU	access:protected
m_colsTranspositions	src/QR/ColPivHouseholderQR.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_cols_permutation	src/QR/FullPivHouseholderQR.h	/^    PermutationType m_cols_permutation;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_cols_transpositions	src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_cols_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_comm	src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_comm; \/\/ The MPI communicator identifier$/;"	m	class:Eigen::PastixBase	access:protected
m_computationOptions	src/SVD/JacobiSVD.h	/^    unsigned int m_computationOptions;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_computeFullU	src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_computeFullV	src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_computeQZ	src/Eigenvalues/RealQZ.h	/^      bool m_computeQZ;$/;"	m	class:Eigen::RealQZ	access:private
m_computeThinU	src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_computeThinV	src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_condition	src/Core/Select.h	/^    typename ConditionMatrixType::Nested m_condition;$/;"	m	class:Eigen::Select	access:protected
m_conservative	src/SparseCore/SparseProduct.h	/^    bool m_conservative;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
m_copyMatrix	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  MatrixType m_copyMatrix;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_copyMatrix	src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixType m_copyMatrix;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_countPerCol	src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerCol;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
m_countPerRow	src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerRow;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
m_currentBlockRows	src/Core/CommaInitializer.h	/^  Index m_currentBlockRows; \/\/ current block height$/;"	m	struct:Eigen::CommaInitializer	access:public
m_currentEl	src/SparseCore/AmbiVector.h	/^    Index m_currentEl;            \/\/ the current element in sparse\/linked-list mode$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_data	src/Core/DenseStorage.h	/^    T *m_data;$/;"	m	class:Eigen::DenseStorage	access:private
m_data	src/Core/DenseStorage.h	/^    internal::plain_array<T,Size,_Options> m_data;$/;"	m	class:Eigen::DenseStorage	access:private
m_data	src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize),0> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if	access:public
m_data	src/Core/MapBase.h	/^    PointerType m_data;$/;"	m	class:Eigen::MapBase	access:protected
m_data	src/Core/util/BlasUtil.h	/^    Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::blas_data_mapper	access:protected
m_data	src/Core/util/BlasUtil.h	/^    const Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::const_blas_data_mapper	access:protected
m_data	src/SparseCore/SparseMatrix.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseMatrix	access:protected
m_data	src/SparseCore/SparseVector.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseVector	access:protected
m_data	src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
m_data	src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
m_deallocate	src/Core/util/Memory.h	/^    bool m_deallocate;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
m_dec	src/misc/Image.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
m_dec	src/misc/Kernel.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
m_dec	src/misc/Solve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_base	access:protected
m_dec	src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
m_dec	src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base	access:protected
m_dest	src/Core/products/GeneralMatrixMatrix.h	/^    Dest& m_dest;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
m_detPermC	src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU	access:protected
m_detPermR	src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU	access:protected
m_det_p	src/LU/PartialPivLU.h	/^    Index m_det_p;$/;"	m	class:Eigen::PartialPivLU	access:protected
m_det_pq	src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU	access:protected
m_det_pq	src/QR/ColPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_det_pq	src/QR/FullPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_diag	src/SparseCholesky/SimplicialCholesky.h	/^    VectorType m_diag;                                \/\/ the diagonal coefficients (LDLT mode)$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_diagSize	src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_diagonal	src/Core/DiagonalMatrix.h	/^    DiagonalVectorType m_diagonal;$/;"	m	class:Eigen::DiagonalMatrix	access:protected
m_diagonal	src/Core/DiagonalMatrix.h	/^    typename DiagonalVectorType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalWrapper	access:protected
m_diagonal	src/Core/DiagonalProduct.h	/^    typename DiagonalType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalProduct	access:protected
m_diagpivotthresh	src/SparseLU/SparseLU.h	/^    RealScalar m_diagpivotthresh; \/\/ Specifies the threshold used for a diagonal entry to be an acceptable pivot$/;"	m	class:Eigen::SparseLU	access:protected
m_direction	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
m_direction	src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
m_dparm	src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<double,DPARM_SIZE,1> m_dparm; \/\/ Scalar vector for the input parameters$/;"	m	class:Eigen::PastixBase	access:protected
m_droptol	src/IterativeLinearSolvers/IncompleteLUT.h	/^    RealScalar m_droptol;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_eigenvectorsOk	src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_eigenvectorsOk	src/Eigenvalues/EigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::EigenSolver	access:protected
m_eigenvectorsOk	src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
m_eigenvectorsOk	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_eivalues	src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_eivalues	src/Eigenvalues/EigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::EigenSolver	access:protected
m_eivalues	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    RealVectorType m_eivalues;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_eivec	src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_eivec;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_eivec	src/Eigenvalues/EigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::EigenSolver	access:protected
m_eivec	src/Eigenvalues/GeneralizedEigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
m_eivec	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    EigenvectorsType m_eivec;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_else	src/Core/Select.h	/^    typename ElseMatrixType::Nested m_else;$/;"	m	class:Eigen::Select	access:protected
m_end	src/Core/CoreIterators.h	/^    const Index m_end;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
m_end	src/SparseCore/AmbiVector.h	/^    Index m_end;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_end	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_end	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_end	src/SparseCore/SparseBlock.h	/^      Index m_end;$/;"	m	class:Eigen::BlockImpl::InnerIterator	access:private
m_end	src/SparseCore/SparseMatrix.h	/^    Index m_end;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_end	src/SparseCore/SparseVector.h	/^    const Index m_end;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
m_endidrow	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_endidrow;                       \/\/ End index of row indices of the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
m_endidval	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_endidval;                 \/\/ End of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
m_epsilon	src/SparseCore/AmbiVector.h	/^    RealScalar m_epsilon;       \/\/ epsilon used to prune zero coefficients$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_epsilon	src/SparseCore/SparseView.h	/^  typename NumTraits<Scalar>::Real m_epsilon;$/;"	m	class:Eigen::SparseView	access:protected
m_error	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable RealScalar m_error;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_etree	src/SparseLU/SparseLU.h	/^    IndexVector m_etree; \/\/ Column elimination tree $/;"	m	class:Eigen::SparseLU	access:protected
m_etree	src/SparseQR/SparseQR.h	/^    IndexVector m_etree;            \/\/ Column elimination tree$/;"	m	class:Eigen::SparseQR	access:protected
m_exponent	src/Core/Functors.h	/^  const Scalar m_exponent;$/;"	m	struct:Eigen::internal::scalar_pow_op	access:public
m_expression	src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::ArrayWrapper	access:protected
m_expression	src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::MatrixWrapper	access:protected
m_expression	src/Core/CoreIterators.h	/^    const Derived& m_expression;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
m_expression	src/Core/ForceAlignedAccess.h	/^    const ExpressionType& m_expression;$/;"	m	class:Eigen::ForceAlignedAccess	access:protected
m_expression	src/Core/NestByValue.h	/^    const ExpressionType m_expression;$/;"	m	class:Eigen::NestByValue	access:protected
m_expression	src/Core/NoAlias.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::NoAlias	access:protected
m_expression	src/Core/Swap.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::SwapWrapper	access:protected
m_extractedDataAreDirty	src/SuperLUSupport/SuperLUSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_extractedDataAreDirty	src/UmfPackSupport/UmfPackSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_factor	src/Geometry/Scaling.h	/^  Scalar m_factor;$/;"	m	class:Eigen::UniformScaling	access:protected
m_factor	src/SparseCore/SparseDenseProduct.h	/^    Scalar m_factor;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected
m_factorizationIsOk	src/CholmodSupport/CholmodSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::CholmodBase	access:protected
m_factorizationIsOk	src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_factorizationIsOk	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_factorizationIsOk	src/PaStiXSupport/PaStiXSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::PastixBase	access:protected
m_factorizationIsOk	src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_factorizationIsOk	src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SPQR	access:protected
m_factorizationIsOk	src/SparseCholesky/SimplicialCholesky.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_factorizationIsOk	src/SparseLU/SparseLU.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SparseLU	access:protected
m_factorizationIsOk	src/SuperLUSupport/SuperLUSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_factorizationIsOk	src/UmfPackSupport/UmfPackSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_factorizationIsok	src/SparseQR/SparseQR.h	/^    bool m_factorizationIsok;$/;"	m	class:Eigen::SparseQR	access:protected
m_fillfactor	src/IterativeLinearSolvers/IncompleteLUT.h	/^    int m_fillfactor;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_firstRowElt	src/SparseQR/SparseQR.h	/^    IndexVector m_firstRowElt;      \/\/ First element in each row$/;"	m	class:Eigen::SparseQR	access:protected
m_format	src/Core/IO.h	/^    IOFormat m_format;$/;"	m	class:Eigen::WithFormat	access:protected
m_functor	src/Core/CwiseBinaryOp.h	/^    const BinaryOp m_functor;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
m_functor	src/Core/CwiseNullaryOp.h	/^    const NullaryOp m_functor;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
m_functor	src/Core/CwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOp	access:protected
m_functor	src/Core/CwiseUnaryView.h	/^    ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryView	access:protected
m_functor	src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::SelfCwiseBinaryOp	access:protected
m_functor	src/Core/VectorwiseOp.h	/^    const MemberOp m_functor;$/;"	m	class:Eigen::PartialReduxExpr	access:protected
m_functor	src/Core/VectorwiseOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::member_redux	access:public
m_functor	src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_functor	src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_functor	src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_functor	src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:protected
m_functor	src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:protected
m_functor	src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:protected
m_functor	src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:protected
m_global_iter	src/Eigenvalues/RealQZ.h	/^      Index m_global_iter;$/;"	m	class:Eigen::RealQZ	access:private
m_glu	src/SparseLU/SparseLU.h	/^    typename Base::GlobalLU_t m_glu; $/;"	m	class:Eigen::SparseLU	access:protected
m_glu	src/SparseLU/SparseLU_column_dfs.h	/^  typename SparseLUImpl<Scalar, Index>::GlobalLU_t& m_glu;$/;"	m	struct:Eigen::internal::column_dfs_traits	access:public
m_guess	src/misc/SparseSolve.h	/^    const typename Guess::Nested m_guess;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
m_hCoeffs	src/Eigenvalues/HessenbergDecomposition.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
m_hCoeffs	src/Eigenvalues/Tridiagonalization.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::Tridiagonalization	access:protected
m_hCoeffs	src/QR/ColPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_hCoeffs	src/QR/FullPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_hCoeffs	src/QR/FullPivHouseholderQR.h	/^  typename HCoeffsType::Nested m_hCoeffs;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
m_hCoeffs	src/QR/HouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::HouseholderQR	access:protected
m_hcoeffs	src/SparseQR/SparseQR.h	/^    ScalarVector m_hcoeffs;         \/\/ The Householder coefficients$/;"	m	class:Eigen::SparseQR	access:protected
m_hess	src/Eigenvalues/ComplexSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_hess	src/Eigenvalues/HessenbergDecomposition.h	/^    const HessenbergDecomposition<MatrixType>& m_hess;$/;"	m	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:protected
m_hess	src/Eigenvalues/RealSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::RealSchur	access:private
m_householder	src/SVD/UpperBidiagonalization.h	/^    MatrixType m_householder;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
m_id	src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_id	src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_id	src/SparseCore/SparseCwiseBinaryOp.h	/^    Index m_id;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_id	src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_id	src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_id	src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
m_id	src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
m_idrow	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idrow;                          \/\/ Index to browse the row indices $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
m_idval	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idval;                          \/\/ Index to browse the values in the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
m_index	src/Core/Diagonal.h	/^    const internal::variable_if_dynamicindex<Index, DiagIndex> m_index;$/;"	m	class:Eigen::Diagonal	access:protected
m_index	src/SparseCore/SparseMatrix.h	/^        Index m_index;$/;"	m	class:Eigen::SparseMatrix::SingletonVector	access:private
m_indexPtr	src/MetisSupport/MetisSupport.h	/^    IndexVector m_indexPtr; \/\/ Pointer to the adjacenccy list of each row\/column$/;"	m	class:Eigen::MetisOrdering	access:protected
m_indices	src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map	access:protected
m_indices	src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::PermutationMatrix	access:protected
m_indices	src/Core/PermutationMatrix.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::PermutationWrapper	access:protected
m_indices	src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map	access:protected
m_indices	src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Transpositions	access:protected
m_indices	src/Core/Transpositions.h	/^    const typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::TranspositionsWrapper	access:protected
m_indices	src/SparseCore/CompressedStorage.h	/^    Index* m_indices;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
m_indices	src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_indices	src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_info	src/Cholesky/LLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LLT	access:protected
m_info	src/CholmodSupport/CholmodSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::CholmodBase	access:protected
m_info	src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_info	src/Eigenvalues/RealQZ.h	/^      ComputationInfo m_info;$/;"	m	class:Eigen::RealQZ	access:private
m_info	src/Eigenvalues/RealSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::RealSchur	access:private
m_info	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_info	src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_info	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable ComputationInfo m_info;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_info	src/PaStiXSupport/PaStiXSupport.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Eigen::PastixBase	access:protected
m_info	src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_info	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SPQR	access:protected
m_info	src/SparseCholesky/SimplicialCholesky.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_info	src/SparseLU/SparseLU.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseLU	access:protected
m_info	src/SparseQR/SparseQR.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseQR	access:protected
m_info	src/SuperLUSupport/SuperLUSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_info	src/UmfPackSupport/UmfPackSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_initialized	src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_initisOk	src/PaStiXSupport/PaStiXSupport.h	/^    int m_initisOk; $/;"	m	class:Eigen::PastixBase	access:protected
m_inner	src/Core/CoreIterators.h	/^    Index m_inner;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
m_inner	src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;$/;"	m	class:Eigen::Stride	access:protected
m_innerIndexPtr	src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_innerIndexPtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_innerIndices	src/MetisSupport/MetisSupport.h	/^    IndexVector m_innerIndices; \/\/ Adjacency list $/;"	m	class:Eigen::MetisOrdering	access:protected
m_innerIndices	src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_innerIndices;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_innerNonZeros	src/SparseCore/SparseMatrix.h	/^    Index* m_innerNonZeros;     \/\/ optional, if null then the data is compressed$/;"	m	class:Eigen::SparseMatrix	access:protected
m_innerSize	src/SparseCore/MappedSparseMatrix.h	/^    Index   m_innerSize;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_innerSize	src/SparseCore/SparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SparseMatrix	access:protected
m_interPacket	src/Core/Functors.h	/^  const Packet m_interPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_invdiag	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Vector m_invdiag;$/;"	m	class:Eigen::DiagonalPreconditioner	access:protected
m_invp	src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_invp;  \/\/ Inverse permutation vector$/;"	m	class:Eigen::PastixBase	access:protected
m_iparm	src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<int,IPARM_SIZE,1> m_iparm; \/\/ integer vector for the input parameters$/;"	m	class:Eigen::PastixBase	access:protected
m_iparm	src/PardisoSupport/PardisoSupport.h	/^    mutable ParameterType m_iparm;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_isAllocated	src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_isDense	src/SparseCore/AmbiVector.h	/^    bool m_isDense;             \/\/ mode of the vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_isEtreeOk	src/SparseQR/SparseQR.h	/^    bool m_isEtreeOk;               \/\/ whether the elimination tree match the initial input matrix$/;"	m	class:Eigen::SparseQR	access:protected
m_isInitialized	src/Cholesky/LDLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LDLT	access:protected
m_isInitialized	src/Cholesky/LLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LLT	access:protected
m_isInitialized	src/CholmodSupport/CholmodSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::CholmodBase	access:protected
m_isInitialized	src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_isInitialized	src/Eigenvalues/ComplexSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_isInitialized	src/Eigenvalues/EigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::EigenSolver	access:protected
m_isInitialized	src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
m_isInitialized	src/Eigenvalues/HessenbergDecomposition.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
m_isInitialized	src/Eigenvalues/RealQZ.h	/^      bool m_isInitialized;$/;"	m	class:Eigen::RealQZ	access:private
m_isInitialized	src/Eigenvalues/RealSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::RealSchur	access:private
m_isInitialized	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_isInitialized	src/Eigenvalues/Tridiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::Tridiagonalization	access:protected
m_isInitialized	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::DiagonalPreconditioner	access:protected
m_isInitialized	src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_isInitialized	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_isInitialized	src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
m_isInitialized	src/LU/PartialPivLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PartialPivLU	access:protected
m_isInitialized	src/PaStiXSupport/PaStiXSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PastixBase	access:protected
m_isInitialized	src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_isInitialized	src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_isInitialized	src/QR/HouseholderQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HouseholderQR	access:protected
m_isInitialized	src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SPQR	access:protected
m_isInitialized	src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_isInitialized	src/SVD/UpperBidiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
m_isInitialized	src/SparseCholesky/SimplicialCholesky.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_isInitialized	src/SparseLU/SparseLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SparseLU	access:protected
m_isInitialized	src/SparseQR/SparseQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SparseQR	access:protected
m_isInitialized	src/SuperLUSupport/SuperLUSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_isInitialized	src/UmfPackSupport/UmfPackSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_isQSorted	src/SparseQR/SparseQR.h	/^    bool m_isQSorted;               \/\/ whether Q is sorted or not$/;"	m	class:Eigen::SparseQR	access:protected
m_isRUpToDate	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable bool m_isRUpToDate;$/;"	m	class:Eigen::SPQR	access:protected
m_isRValue	src/SparseCore/SparseMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SparseMatrixBase	access:protected
m_iterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable int m_iterations;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_jcol	src/SparseLU/SparseLU_column_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::column_dfs_traits	access:public
m_jcol	src/SparseLU/SparseLU_panel_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::panel_dfs_traits	access:public
m_jsuper_ref	src/SparseLU/SparseLU_column_dfs.h	/^  Index& m_jsuper_ref;$/;"	m	struct:Eigen::internal::column_dfs_traits	access:public
m_kc	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_kc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_l	src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_l	src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_lastError	src/SparseLU/SparseLU.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseLU	access:protected
m_lastError	src/SparseQR/SparseQR.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseQR	access:protected
m_length	src/Householder/HouseholderSequence.h	/^    Index m_length;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_lhs	src/Core/CwiseBinaryOp.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
m_lhs	src/Core/ProductBase.h	/^    LhsNested m_lhs;$/;"	m	namespace:Eigen	access:protected
m_lhs	src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<LhsNested>::type m_lhs;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
m_lhs	src/Core/products/GeneralMatrixMatrix.h	/^    const Lhs& m_lhs;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
m_lhs	src/Geometry/Homogeneous.h	/^  typename LhsMatrixTypeCleaned::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl	access:public
m_lhs	src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl	access:public
m_lhs	src/SparseCore/SparseDenseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDenseOuterProduct	access:protected
m_lhs	src/SparseCore/SparseDiagonalProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDiagonalProduct	access:protected
m_lhs	src/SparseCore/SparseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
m_lhsIter	src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_llCurrent	src/SparseCore/AmbiVector.h	/^    Index m_llCurrent;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_llSize	src/SparseCore/AmbiVector.h	/^    Index m_llSize;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_llStart	src/SparseCore/AmbiVector.h	/^    Index m_llStart;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_low	src/Core/Functors.h	/^  const Scalar m_low;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_lowPacket	src/Core/Functors.h	/^  const Packet m_lowPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_lu	src/IterativeLinearSolvers/IncompleteLUT.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_lu	src/LU/FullPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::FullPivLU	access:protected
m_lu	src/LU/PartialPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::PartialPivLU	access:protected
m_luImpl	src/SparseLU/SparseLU_column_dfs.h	/^  SparseLUImpl<Scalar, Index>& m_luImpl;$/;"	m	struct:Eigen::internal::column_dfs_traits	access:public
m_mapL	src/SparseLU/SparseLU.h	/^  const MappedSupernodalType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixLReturnType	access:public
m_mapL	src/SparseLU/SparseLU.h	/^  const MatrixLType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType	access:public
m_mapU	src/SparseLU/SparseLU.h	/^  const MatrixUType& m_mapU;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType	access:public
m_marker	src/SparseLU/SparseLU_panel_dfs.h	/^  Index* m_marker;$/;"	m	struct:Eigen::internal::panel_dfs_traits	access:public
m_mat	src/SparseLU/SparseLU.h	/^    NCMatrix m_mat; \/\/ The input (permuted ) matrix $/;"	m	class:Eigen::SparseLU	access:protected
m_matS	src/Eigenvalues/GeneralizedEigenSolver.h	/^    MatrixType m_matS;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
m_matT	src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_matT	src/Eigenvalues/EigenSolver.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::EigenSolver	access:protected
m_matT	src/Eigenvalues/RealSchur.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::RealSchur	access:private
m_matU	src/Eigen2Support/SVD.h	/^    MatrixUType m_matU;$/;"	m	class:Eigen::SVD	access:protected
m_matU	src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_matU	src/Eigenvalues/RealSchur.h	/^    MatrixType m_matU;$/;"	m	class:Eigen::RealSchur	access:private
m_matUisUptodate	src/Eigenvalues/ComplexSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_matUisUptodate	src/Eigenvalues/RealSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::RealSchur	access:private
m_matV	src/Eigen2Support/SVD.h	/^    MatrixVType m_matV;$/;"	m	class:Eigen::SVD	access:protected
m_matX	src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_matX;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_matrix	src/Cholesky/LDLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LDLT	access:protected
m_matrix	src/Cholesky/LLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LLT	access:protected
m_matrix	src/Core/CwiseUnaryView.h	/^    typename internal::nested<MatrixType>::type m_matrix;$/;"	m	class:Eigen::CwiseUnaryView	access:protected
m_matrix	src/Core/Diagonal.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Diagonal	access:protected
m_matrix	src/Core/DiagonalProduct.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::DiagonalProduct	access:protected
m_matrix	src/Core/Flagged.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Flagged	access:protected
m_matrix	src/Core/IO.h	/^    const typename ExpressionType::Nested m_matrix;$/;"	m	class:Eigen::WithFormat	access:protected
m_matrix	src/Core/PermutationMatrix.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval	access:protected
m_matrix	src/Core/Replicate.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::Replicate	access:protected
m_matrix	src/Core/Reverse.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Reverse	access:protected
m_matrix	src/Core/SelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SelfAdjointView	access:protected
m_matrix	src/Core/SelfCwiseBinaryOp.h	/^    Lhs& m_matrix;$/;"	m	class:Eigen::SelfCwiseBinaryOp	access:protected
m_matrix	src/Core/Transpose.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Transpose	access:protected
m_matrix	src/Core/Transpositions.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval	access:protected
m_matrix	src/Core/TriangularMatrix.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::TriangularView	access:protected
m_matrix	src/Core/VectorwiseOp.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::VectorwiseOp	access:protected
m_matrix	src/Core/VectorwiseOp.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::PartialReduxExpr	access:protected
m_matrix	src/Eigen2Support/Cwise.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Cwise	access:protected
m_matrix	src/Eigen2Support/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform	access:protected
m_matrix	src/Eigen2Support/Minor.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Minor	access:protected
m_matrix	src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
m_matrix	src/Eigenvalues/Tridiagonalization.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::Tridiagonalization	access:protected
m_matrix	src/Eigenvalues/Tridiagonalization.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:protected
m_matrix	src/Geometry/Homogeneous.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Homogeneous	access:protected
m_matrix	src/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform	access:protected
m_matrix	src/LU/Inverse.h	/^  MatrixTypeNested m_matrix;$/;"	m	struct:Eigen::internal::inverse_impl	access:public
m_matrix	src/PardisoSupport/PardisoSupport.h	/^    mutable SparseMatrixType m_matrix;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_matrix	src/SparseCholesky/SimplicialCholesky.h	/^    CholMatrixType m_matrix;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_matrix	src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_matrix	src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_matrix	src/SparseCore/SparseBlock.h	/^    typename SparseMatrixType::Nested m_matrix;$/;"	m	class:Eigen::BlockImpl	access:protected
m_matrix	src/SparseCore/SparseBlock.h	/^    typename XprType::Nested m_matrix;$/;"	m	class:Eigen::BlockImpl	access:protected
m_matrix	src/SparseCore/SparsePermutation.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval	access:protected
m_matrix	src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct	access:protected
m_matrix	src/SparseCore/SparseSelfAdjointView.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
m_matrix	src/SparseCore/SparseTriangularView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseTriangularView	access:protected
m_matrix	src/SparseCore/SparseView.h	/^  MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseView	access:protected
m_matrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const MappedSuperNodalMatrix& m_matrix; \/\/ Supernodal lower triangular matrix $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
m_matrix	src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_matrix;  \/\/ copy of the factorized matrix$/;"	m	class:Eigen::SuperLUBase	access:protected
m_matrixU	src/SVD/JacobiSVD.h	/^    MatrixUType m_matrixU;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_matrixV	src/SVD/JacobiSVD.h	/^    MatrixVType m_matrixV;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_max	src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
m_max	src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
m_maxIterations	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:public
m_maxIterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int m_maxIterations;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_maxIterationsPerRow	src/Eigenvalues/ComplexSchur.h	/^    static const int m_maxIterationsPerRow = 30;$/;"	m	class:Eigen::ComplexSchur	access:public
m_maxIterationsPerRow	src/Eigenvalues/RealSchur.h	/^    static const int m_maxIterationsPerRow = 40;$/;"	m	class:Eigen::RealSchur	access:public
m_maxIters	src/Eigenvalues/ComplexSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_maxIters	src/Eigenvalues/RealQZ.h	/^      Index m_maxIters;$/;"	m	class:Eigen::RealQZ	access:private
m_maxIters	src/Eigenvalues/RealSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::RealSchur	access:private
m_maxpivot	src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
m_maxpivot	src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_maxpivot	src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_mc	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_mc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_min	src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
m_min	src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
m_mode	src/SparseCore/AmbiVector.h	/^    Index m_mode;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_msglvl	src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_nc	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_nc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_nnz	src/SparseCore/MappedSparseMatrix.h	/^    Index   m_nnz;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_nnzL	src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU	access:protected
m_nnzU	src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU	access:protected
m_nonZerosPerCol	src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_nonZerosPerCol;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_nonzeroSingularValues	src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_nonzero_pivots	src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU	access:protected
m_nonzero_pivots	src/QR/ColPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_nonzero_pivots	src/QR/FullPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_nonzeropivots	src/SparseQR/SparseQR.h	/^    Index m_nonzeropivots;          \/\/ Number of non zero pivots found $/;"	m	class:Eigen::SparseQR	access:protected
m_normOfS	src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ	access:private
m_normOfT	src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ	access:private
m_nsuper	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_nsuper; \/\/ Number of supernodes $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
m_numeric	src/UmfPackSupport/UmfPackSupport.h	/^    void* m_numeric;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_nzval	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* m_nzval; \/\/array of nonzero values packed by column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
m_nzval_colptr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_nzval_colptr; \/\/nzval_colptr[j] Stores the location in nzval[] which starts column j $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
m_object	src/Core/Ref.h	/^    TPlainObjectType m_object;$/;"	m	class:Eigen::Ref	access:protected
m_ordering	src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_ordering; \/\/ Ordering method to use, see SPQR's manual$/;"	m	class:Eigen::SPQR	access:protected
m_origin	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
m_origin	src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
m_originalMatrix	src/Eigen2Support/LU.h	/^    const MatrixType& m_originalMatrix;$/;"	m	class:Eigen::LU	access:public
m_originalMatrix	src/misc/Image.h	/^    const MatrixType& m_originalMatrix;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
m_other	src/Core/Functors.h	/^  Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_inverse_mult_op	access:public
m_other	src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_add_op	access:public
m_other	src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_constant_op	access:public
m_other	src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar2>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple2_op	access:public
m_other	src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple_op	access:public
m_other	src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_quotient1_op	access:public
m_other	src/SPQRSupport/SuiteSparseQRSupport.h	/^  const Derived& m_other; $/;"	m	struct:Eigen::SPQR_QProduct	access:public
m_other	src/SparseQR/SparseQR.h	/^  const Derived& m_other;$/;"	m	struct:Eigen::SparseQR_QProduct	access:public
m_outer	src/Core/CoreIterators.h	/^    const Index m_outer;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
m_outer	src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;$/;"	m	class:Eigen::Stride	access:protected
m_outer	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_outer	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_outer	src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::BlockImpl::InnerIterator	access:protected
m_outer	src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::BlockImpl::ReverseInnerIterator	access:protected
m_outer	src/SparseCore/SparseCwiseBinaryOp.h	/^    const Index m_outer;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_outer	src/SparseCore/SparseDenseProduct.h	/^    Index m_outer;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected
m_outer	src/SparseCore/SparseDiagonalProduct.h	/^    Index m_outer;$/;"	m	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
m_outer	src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_outer	src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_outer	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_outer;                    \/\/ Current column $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
m_outerIndex	src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_outerIndex;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_outerIndex	src/SparseCore/SparseMatrix.h	/^    Index* m_outerIndex;$/;"	m	class:Eigen::SparseMatrix	access:protected
m_outerIndexPtr	src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_outerIndexPtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_outerSize	src/SparseCore/MappedSparseMatrix.h	/^    Index   m_outerSize;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_outerSize	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, OuterSize> m_outerSize;$/;"	m	class:Eigen::BlockImpl	access:protected
m_outerSize	src/SparseCore/SparseMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SparseMatrix	access:protected
m_outerStart	src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::BlockImpl	access:protected
m_outerStride	src/Core/Block.h	/^    Index m_outerStride;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
m_outputPerm_c	src/SparseQR/SparseQR.h	/^    PermutationType m_outputPerm_c; \/\/ The final column permutation$/;"	m	class:Eigen::SparseQR	access:protected
m_p	src/LU/FullPivLU.h	/^    PermutationPType m_p;$/;"	m	class:Eigen::FullPivLU	access:protected
m_p	src/LU/PartialPivLU.h	/^    PermutationType m_p;$/;"	m	class:Eigen::PartialPivLU	access:protected
m_p	src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_p	src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_packetStep	src/Core/Functors.h	/^  const Packet m_packetStep;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_parent	src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_parent;                                \/\/ elimination tree$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_pastixdata	src/PaStiXSupport/PaStiXSupport.h	/^    mutable pastix_data_t *m_pastixdata; \/\/ Data structure for pastix$/;"	m	class:Eigen::PastixBase	access:protected
m_perfv	src/SparseLU/SparseLU.h	/^    internal::perfvalues<Index> m_perfv; $/;"	m	class:Eigen::SparseLU	access:protected
m_perm	src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_perm;  \/\/ Permutation vector$/;"	m	class:Eigen::PastixBase	access:protected
m_perm	src/PardisoSupport/PardisoSupport.h	/^    mutable IntColVectorType m_perm;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_perm	src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& m_perm;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct	access:protected
m_perm_c	src/SparseLU/SparseLU.h	/^    PermutationType m_perm_c; \/\/ Column permutation $/;"	m	class:Eigen::SparseLU	access:protected
m_perm_c	src/SparseQR/SparseQR.h	/^    PermutationType m_perm_c;       \/\/ Fill-reducing  Column  permutation$/;"	m	class:Eigen::SparseQR	access:protected
m_perm_r	src/SparseLU/SparseLU.h	/^    PermutationType m_perm_r ; \/\/ Row permutation$/;"	m	class:Eigen::SparseLU	access:protected
m_permutation	src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	class:Eigen::Transpose	access:protected
m_permutation	src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval	access:protected
m_permutation	src/SparseCore/SparsePermutation.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval	access:protected
m_pivotperm	src/SparseQR/SparseQR.h	/^    PermutationType m_pivotperm;    \/\/ The permutation for rank revealing$/;"	m	class:Eigen::SparseQR	access:protected
m_pmat	src/SparseQR/SparseQR.h	/^    QRMatrixType m_pmat;            \/\/ Temporary matrix$/;"	m	class:Eigen::SparseQR	access:protected
m_precision	src/QR/FullPivHouseholderQR.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_preconditioner	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner m_preconditioner;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_prescribedThreshold	src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
m_prescribedThreshold	src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_prescribedThreshold	src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_prescribedThreshold	src/SVD/JacobiSVD.h	/^    RealScalar m_prescribedThreshold;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_prod	src/Core/ProductBase.h	/^    const NestedProduct& m_prod;$/;"	m	class:ScaledProduct	access:protected
m_pt	src/PardisoSupport/PardisoSupport.h	/^    mutable void *m_pt[64];$/;"	m	class:Eigen::PardisoImpl	access:protected
m_ptr	src/Core/util/Memory.h	/^    T* m_ptr;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
m_q	src/LU/FullPivLU.h	/^    PermutationQType m_q;$/;"	m	class:Eigen::FullPivLU	access:protected
m_q	src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_q	src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_qr	src/QR/ColPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_qr	src/QR/FullPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_qr	src/QR/FullPivHouseholderQR.h	/^  typename MatrixType::Nested m_qr;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
m_qr	src/QR/HouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::HouseholderQR	access:protected
m_qr	src/SVD/JacobiSVD.h	/^  QRType m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_qr	src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQReturnType	access:public
m_qr	src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQTransposeReturnType	access:public
m_qr	src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQR_QProduct	access:public
m_qr_precond_morecols	src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows> m_qr_precond_morecols;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_qr_precond_morerows	src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols> m_qr_precond_morerows;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_rank	src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index m_rank; \/\/ The rank of the matrix$/;"	m	class:Eigen::SPQR	access:protected
m_rank	src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
m_rank	src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
m_realQZ	src/Eigenvalues/GeneralizedEigenSolver.h	/^    RealQZ<MatrixType> m_realQZ;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
m_realSchur	src/Eigenvalues/EigenSolver.h	/^    RealSchur<MatrixType> m_realSchur;$/;"	m	class:Eigen::EigenSolver	access:protected
m_reference	src/SparseCore/SparseView.h	/^  Scalar m_reference;$/;"	m	class:Eigen::SparseView	access:protected
m_result	src/Core/ProductBase.h	/^    mutable PlainObject m_result;$/;"	m	namespace:Eigen	access:protected
m_result	src/Core/products/CoeffBasedProduct.h	/^    mutable PlainObject m_result;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
m_returnOne	src/SparseCore/SparseTriangularView.h	/^    bool m_returnOne;$/;"	m	class:Eigen::SparseTriangularView::InnerIterator	access:protected
m_rhs	src/Core/CwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
m_rhs	src/Core/ProductBase.h	/^    RhsNested m_rhs;$/;"	m	namespace:Eigen	access:protected
m_rhs	src/Core/SolveTriangular.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::triangular_solve_retval	access:protected
m_rhs	src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<RhsNested>::type m_rhs;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
m_rhs	src/Core/products/GeneralMatrixMatrix.h	/^    const Rhs& m_rhs;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
m_rhs	src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl	access:public
m_rhs	src/Geometry/Homogeneous.h	/^  typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl	access:public
m_rhs	src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_rhs	src/SparseCore/SparseDenseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDenseOuterProduct	access:protected
m_rhs	src/SparseCore/SparseDiagonalProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDiagonalProduct	access:protected
m_rhs	src/SparseCore/SparseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
m_rhs	src/misc/Solve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_base	access:protected
m_rhs	src/misc/SparseSolve.h	/^    const typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
m_rhs	src/misc/SparseSolve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base	access:protected
m_rhsIter	src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_row	src/Core/CommaInitializer.h	/^  Index m_row;              \/\/ current row id$/;"	m	struct:Eigen::CommaInitializer	access:public
m_row	src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor	access:protected
m_row	src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet	access:protected
m_row	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_row; \/\/ Number of rows$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
m_rowFactor	src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;$/;"	m	class:Eigen::Replicate	access:protected
m_rowind	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_rowind; \/\/ Array of compressed row indices of rectangular supernodes$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
m_rowind_colptr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_rowind_colptr; \/\/rowind_colptr[j] stores the location in rowind[] which starts column j$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
m_rows	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
m_rows	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
m_rows	src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
m_rows	src/Core/DenseStorage.h	/^    DenseIndex m_rows;$/;"	m	class:Eigen::DenseStorage	access:private
m_rows	src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::MapBase	access:protected
m_rows	src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_rowsTranspositions	src/LU/FullPivLU.h	/^    IntColVectorType m_rowsTranspositions;$/;"	m	class:Eigen::FullPivLU	access:protected
m_rowsTranspositions	src/LU/PartialPivLU.h	/^    TranspositionType m_rowsTranspositions;$/;"	m	class:Eigen::PartialPivLU	access:protected
m_rowsTranspositions	src/QR/FullPivHouseholderQR.h	/^  typename IntDiagSizeVectorType::Nested m_rowsTranspositions;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
m_rows_transpositions	src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_rows_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_s	src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation	access:protected
m_scale	src/Core/GeneralProduct.h	/^      Scalar m_scale;$/;"	m	struct:Eigen::GeneralProduct::adds	access:public
m_scaledMatrix	src/SVD/JacobiSVD.h	/^    MatrixType m_scaledMatrix;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_schur	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexSchur<MatrixType> m_schur;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_shift	src/Householder/HouseholderSequence.h	/^    Index m_shift;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_shiftOffset	src/CholmodSupport/CholmodSupport.h	/^    RealScalar m_shiftOffset[2];$/;"	m	class:Eigen::CholmodBase	access:protected
m_shiftOffset	src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftOffset;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_shiftScale	src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftScale;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_sigma	src/Eigen2Support/SVD.h	/^    SingularValuesType m_sigma;$/;"	m	class:Eigen::SVD	access:protected
m_sign	src/Cholesky/LDLT.h	/^    internal::SignMatrix m_sign;$/;"	m	class:Eigen::LDLT	access:protected
m_singularValues	src/SVD/JacobiSVD.h	/^    SingularValuesType m_singularValues;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_size	src/Core/util/Memory.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
m_size	src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_size; \/\/ Size of the matrix $/;"	m	class:Eigen::PastixBase	access:protected
m_size	src/PardisoSupport/PardisoSupport.h	/^    Index m_size;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_size	src/SparseCore/AmbiVector.h	/^    Index m_size;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_size	src/SparseCore/CompressedStorage.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
m_size	src/SparseCore/SparseVector.h	/^    Index m_size;$/;"	m	class:Eigen::SparseVector	access:protected
m_sizeA	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeA;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_sizeB	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeB;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_sizeW	src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeW;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_sluA	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluA;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluB	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluBerr	src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluCscale	src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluEqued	src/SuperLUSupport/SuperLUSupport.h	/^    mutable char m_sluEqued;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluEtree	src/SuperLUSupport/SuperLUSupport.h	/^    mutable std::vector<int> m_sluEtree;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluFerr	src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluL	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluOptions	src/SuperLUSupport/SuperLUSupport.h	/^    mutable superlu_options_t m_sluOptions;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluRscale	src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluStat	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperLUStat_t m_sluStat;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluU	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluX	src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_spqr	src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr; $/;"	m	struct:Eigen::SPQR_QProduct	access:public
m_spqr	src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQReturnType	access:public
m_spqr	src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQTransposeReturnType	access:public
m_start	src/SparseCore/AmbiVector.h	/^    Index m_start;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_start	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_start	src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_start	src/SparseCore/SparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_start	src/SparseCore/SparseVector.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
m_startCol	src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
m_startCol	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::BlockImpl	access:protected
m_startRow	src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
m_startRow	src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::BlockImpl	access:protected
m_startidval	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_startidval;               \/\/ Start of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
m_staticA	src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 LhsScalar m_staticA[SizeA];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_staticB	src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticB[SizeB];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_staticW	src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticW[SizeW];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_step	src/Core/Functors.h	/^  const Scalar m_step;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_stepPacket	src/Core/Functors.h	/^  const Packet m_stepPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_storage	src/Core/PlainObjectBase.h	/^    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;$/;"	m	class:Eigen::PlainObjectBase	access:protected
m_stride	src/Core/Map.h	/^    StrideType m_stride;$/;"	m	class:Eigen::Map	access:protected
m_stride	src/Core/Ref.h	/^  StrideBase m_stride;$/;"	m	class:Eigen::RefBase	access:protected
m_stride	src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::blas_data_mapper	access:protected
m_stride	src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::const_blas_data_mapper	access:protected
m_structureIsUptodate	src/PaStiXSupport/PaStiXSupport.h	/^    bool m_structureIsUptodate;$/;"	m	class:Eigen::PastixLU	access:protected
m_subdiag	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typename TridiagonalizationType::SubDiagonalType m_subdiag;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_subs	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
m_subs	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
m_sup_to_col	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_sup_to_col; \/\/sup_to_col[s] points to the starting column of the s-th supernode$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix	access:protected
m_supers	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
m_supers	src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
m_supno	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_supno;                    \/\/ Current SuperNode number$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:protected
m_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^    void* m_symbolic;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_symmetricmode	src/SparseLU/SparseLU.h	/^    bool m_symmetricmode;$/;"	m	class:Eigen::SparseLU	access:protected
m_temp	src/Eigenvalues/HessenbergDecomposition.h	/^    VectorType m_temp;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
m_temp	src/QR/ColPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_temp	src/QR/FullPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_temp	src/QR/HouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::HouseholderQR	access:protected
m_temporary	src/Cholesky/LDLT.h	/^    TmpMatrixType m_temporary;$/;"	m	class:Eigen::LDLT	access:protected
m_then	src/Core/Select.h	/^    typename ThenMatrixType::Nested m_then;$/;"	m	class:Eigen::Select	access:protected
m_threshold	src/SparseQR/SparseQR.h	/^    RealScalar m_threshold;         \/\/ Threshold to determine null Householder reflections$/;"	m	class:Eigen::SparseQR	access:protected
m_tmp	src/Eigenvalues/EigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::EigenSolver	access:protected
m_tmp	src/Eigenvalues/GeneralizedEigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::GeneralizedEigenSolver	access:protected
m_tolerance	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar m_tolerance;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_tolerance	src/SPQRSupport/SuiteSparseQRSupport.h	/^    RealScalar m_tolerance; \/\/ treat columns with 2-norm below this tolerance as zero$/;"	m	class:Eigen::SPQR	access:protected
m_tolerance	src/SparseCore/SparseProduct.h	/^    RealScalar m_tolerance;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
m_trans	src/Householder/HouseholderSequence.h	/^    bool m_trans;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_transpose	src/SPQRSupport/SuiteSparseQRSupport.h	/^  bool m_transpose; $/;"	m	struct:Eigen::SPQR_QProduct	access:public
m_transpose	src/SparseQR/SparseQR.h	/^  bool m_transpose;$/;"	m	struct:Eigen::SparseQR_QProduct	access:public
m_transpositions	src/Cholesky/LDLT.h	/^    TranspositionType m_transpositions;$/;"	m	class:Eigen::LDLT	access:protected
m_transpositions	src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	class:Eigen::Transpose	access:protected
m_transpositions	src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval	access:protected
m_triangularMatrix	src/Core/SolveTriangular.h	/^    const TriangularType& m_triangularMatrix;$/;"	m	struct:Eigen::internal::triangular_solve_retval	access:protected
m_type	src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_u	src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_u	src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_useDefaultThreshold	src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SPQR	access:protected
m_useDefaultThreshold	src/SparseQR/SparseQR.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SparseQR	access:protected
m_usePrescribedThreshold	src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
m_usePrescribedThreshold	src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_usePrescribedThreshold	src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_usePrescribedThreshold	src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_value	src/SparseCore/SparseCwiseBinaryOp.h	/^    Scalar m_value;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_value	src/SparseCore/SparseMatrix.h	/^        Index m_value;$/;"	m	class:Eigen::SparseMatrix::SingletonVector	access:private
m_value	src/SparseCore/SparseUtil.h	/^  Scalar m_value;$/;"	m	class:Eigen::Triplet	access:protected
m_valuePtr	src/UmfPackSupport/UmfPackSupport.h	/^    const Scalar* m_valuePtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_values	src/SparseCore/CompressedStorage.h	/^    Scalar* m_values;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
m_values	src/SparseCore/MappedSparseMatrix.h	/^    Scalar* m_values;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_values	src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_values	src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_vector	src/SparseCore/AmbiVector.h	/^    const AmbiVector& m_vector; \/\/ the target vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_vectors	src/Householder/HouseholderSequence.h	/^    typename VectorsType::Nested m_vectors;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_view	src/SparseCore/SparseView.h	/^  const SparseView& m_view;$/;"	m	class:Eigen::SparseView::InnerIterator	access:protected
m_workMatrix	src/SVD/JacobiSVD.h	/^    WorkMatrixType m_workMatrix;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_workspace	src/Eigenvalues/RealQZ.h	/^      Matrix<Scalar,Dynamic,1> m_workspace;$/;"	m	class:Eigen::RealQZ	access:private
m_workspace	src/SVD/JacobiSVD.h	/^  WorkspaceType m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_workspace	src/SVD/JacobiSVD.h	/^  typename internal::plain_col_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_workspace	src/SVD/JacobiSVD.h	/^  typename internal::plain_row_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_workspaceVector	src/Eigenvalues/RealSchur.h	/^    ColumnVectorType m_workspaceVector;$/;"	m	class:Eigen::RealSchur	access:private
m_xpr	src/Core/Block.h	/^    const typename XprType::Nested m_xpr;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
m_xpr	src/Core/Block.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::internal::BlockImpl_dense	access:protected
m_xpr	src/Core/CommaInitializer.h	/^  XprType& m_xpr;   \/\/ target expression$/;"	m	struct:Eigen::CommaInitializer	access:public
m_xpr	src/Core/CwiseUnaryOp.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::CwiseUnaryOp	access:protected
m_xpr	src/SparseCore/SparseCwiseBinaryOp.h	/^    const CwiseBinaryXpr& m_xpr;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_zero	src/SparseCore/AmbiVector.h	/^    Scalar m_zero;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
machine_epsilon	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T machine_epsilon () { return NumTraits<T>::epsilon(); }$/;"	f	namespace:Eigen	signature:()
madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const
madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const
madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& ) const
madd	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& ) const
madd_impl	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const
madd_impl	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& \/*tmp*\/, const false_type&) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& , const false_type&) const
makeAffine	src/Geometry/Transform.h	/^  void makeAffine()$/;"	f	class:Eigen::Transform	access:public	signature:()
makeCompressed	src/SparseCore/SparseMatrix.h	/^    void makeCompressed()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
makeGivens	src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::false_type);$/;"	p	class:Eigen::JacobiRotation	access:protected	signature:(const Scalar& p, const Scalar& q, Scalar* z, internal::false_type)
makeGivens	src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::true_type);$/;"	p	class:Eigen::JacobiRotation	access:protected	signature:(const Scalar& p, const Scalar& q, Scalar* z, internal::true_type)
makeGivens	src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z=0);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const Scalar& p, const Scalar& q, Scalar* z=0)
makeGivens	src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)
makeGivens	src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)
makeGivens	src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* z)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* z)
makeHouseholder	src/Core/MatrixBase.h	/^    void makeHouseholder(EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(EssentialPart& essential, Scalar& tau, RealScalar& beta) const
makeHouseholder	src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholder($/;"	f	class:Eigen::MatrixBase	signature:( EssentialPart& essential, Scalar& tau, RealScalar& beta) const
makeHouseholderInPlace	src/Core/MatrixBase.h	/^    void makeHouseholderInPlace(Scalar& tau, RealScalar& beta);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Scalar& tau, RealScalar& beta)
makeHouseholderInPlace	src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)$/;"	f	class:Eigen::MatrixBase	signature:(Scalar& tau, RealScalar& beta)
makeJacobi	src/Jacobi/Jacobi.h	/^    bool makeJacobi(const MatrixBase<Derived>&, typename Derived::Index p, typename Derived::Index q);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const MatrixBase<Derived>&, typename Derived::Index p, typename Derived::Index q)
makeJacobi	src/Jacobi/Jacobi.h	/^    bool makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const RealScalar& x, const Scalar& y, const RealScalar& z)
makeJacobi	src/Jacobi/Jacobi.h	/^bool JacobiRotation<Scalar>::makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z)$/;"	f	class:Eigen::JacobiRotation	signature:(const RealScalar& x, const Scalar& y, const RealScalar& z)
makeJacobi	src/Jacobi/Jacobi.h	/^inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)$/;"	f	class:Eigen::JacobiRotation	signature:(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)
make_block_householder_triangular_factor	src/Householder/BlockHouseholder.h	/^void make_block_householder_triangular_factor(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)
manageErrorCode	src/PardisoSupport/PardisoSupport.h	/^    void manageErrorCode(Index error)$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:(Index error)
manage_caching_sizes	src/Core/products/GeneralBlockPanelKernel.h	/^inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)$/;"	f	namespace:Eigen::internal	signature:(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)
manage_caching_sizes_helper	src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)$/;"	f	namespace:Eigen::internal	signature:(std::ptrdiff_t a, std::ptrdiff_t b)
manage_multi_threading	src/Core/products/Parallelizer.h	/^inline void manage_multi_threading(Action action, int* v)$/;"	f	namespace:Eigen::internal	signature:(Action action, int* v)
map_superlu	src/SuperLUSupport/SuperLUSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> map_superlu(SluMatrix& sluMat)$/;"	f	namespace:Eigen::internal	signature:(SluMatrix& sluMat)
mark	src/OrderingMethods/Eigen_Colamd.h	/^    Index mark ;  \/* for computing set differences and marking dead rows*\/$/;"	m	union:internal::Colamd_Row::__anon407	access:public
markAsRValue	src/SparseCore/SparseMatrixBase.h	/^    Derived& markAsRValue() { m_isRValue = true; return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
marked	src/Core/MatrixBase.h	/^    const Flagged<Derived, Added, 0> marked() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
marked	src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::marked() const$/;"	f	class:Eigen::MatrixBase	signature:() const
matPrefix	src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat	access:public
matSuffix	src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat	access:public
match	src/Core/Ref.h	/^  template<typename Derived> struct match {$/;"	s	struct:Eigen::internal::traits	access:public
matrix	src/Core/ArrayBase.h	/^    MatrixWrapper<Derived> matrix() { return derived(); }$/;"	f	class:Eigen::ArrayBase	access:public	signature:()
matrix	src/Core/ArrayBase.h	/^    const MatrixWrapper<const Derived> matrix() const { return derived(); }$/;"	f	class:Eigen::ArrayBase	access:public	signature:() const
matrix	src/Core/MatrixBase.h	/^    MatrixBase<Derived>& matrix() { return *this; }$/;"	f	class:Eigen::MatrixBase	access:public	signature:()
matrix	src/Core/MatrixBase.h	/^    const MatrixBase<Derived>& matrix() const { return *this; }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
matrix	src/Eigen2Support/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:()
matrix	src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:() const
matrix	src/Geometry/RotationBase.h	/^    inline RotationMatrixType matrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
matrix	src/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:()
matrix	src/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:() const
matrix	src/SparseCore/SparseSelfAdjointView.h	/^    _MatrixTypeNested& matrix() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:()
matrix	src/SparseCore/SparseSelfAdjointView.h	/^    const _MatrixTypeNested& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
matrixFunction	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> matrixFunction(StemFunction f) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(StemFunction f) const
matrixH	src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixHReturnType matrixH() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
matrixL	src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
matrixL	src/Cholesky/LLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
matrixL	src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
matrixL	src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
matrixL	src/SparseLU/SparseLU.h	/^    SparseLUMatrixLReturnType<SCMatrix> matrixL() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
matrixL	src/SuperLUSupport/SuperLUSupport.h	/^    inline const LMatrixType& matrixL() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
matrixL	src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixL() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
matrixLDLT	src/Cholesky/LDLT.h	/^    inline const MatrixType& matrixLDLT() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
matrixLLT	src/Cholesky/LLT.h	/^    inline const MatrixType& matrixLLT() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
matrixLU	src/LU/FullPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
matrixLU	src/LU/PartialPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
matrixQ	src/Eigen2Support/QR.h	/^    MatrixType matrixQ(void) const {$/;"	f	class:Eigen::QR	access:public	signature:(void) const
matrixQ	src/Eigenvalues/HessenbergDecomposition.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
matrixQ	src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixQ() const {$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
matrixQ	src/Eigenvalues/Tridiagonalization.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
matrixQ	src/QR/ColPivHouseholderQR.h	/^    HouseholderSequenceType matrixQ(void) const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(void) const
matrixQ	src/QR/FullPivHouseholderQR.h	/^    MatrixQReturnType matrixQ(void) const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:(void) const
matrixQ	src/QR/FullPivHouseholderQR.h	/^inline typename FullPivHouseholderQR<MatrixType>::MatrixQReturnType FullPivHouseholderQR<MatrixType>::matrixQ() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
matrixQ	src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQRMatrixQReturnType<SPQR> matrixQ() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
matrixQ	src/SparseQR/SparseQR.h	/^    SparseQRMatrixQReturnType<SparseQR> matrixQ() const $/;"	f	class:Eigen::SparseQR	access:public	signature:() const
matrixQR	src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
matrixQR	src/QR/FullPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
matrixQR	src/QR/HouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
matrixR	src/Eigen2Support/QR.h	/^    matrixR(void) const$/;"	f	class:Eigen::QR	access:public	signature:(void) const
matrixR	src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixR() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
matrixR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    const MatrixType matrixR() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
matrixR	src/SparseQR/SparseQR.h	/^    const QRMatrixType& matrixR() const { return m_R; }$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
matrixS	src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixS() const {$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
matrixT	src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixT() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
matrixT	src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixT() const {$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
matrixT	src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixT() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
matrixT	src/Eigenvalues/Tridiagonalization.h	/^    MatrixTReturnType matrixT() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
matrixU	src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
matrixU	src/Cholesky/LLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
matrixU	src/Eigen2Support/SVD.h	/^    const MatrixUType& matrixU() const { return m_matU; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
matrixU	src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixU() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
matrixU	src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixU() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
matrixU	src/SVD/JacobiSVD.h	/^    const MatrixUType& matrixU() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
matrixU	src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
matrixU	src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
matrixU	src/SparseLU/SparseLU.h	/^    SparseLUMatrixUReturnType<SCMatrix,MappedSparseMatrix<Scalar,ColMajor,Index> > matrixU() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
matrixU	src/SuperLUSupport/SuperLUSupport.h	/^    inline const UMatrixType& matrixU() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
matrixU	src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixU() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
matrixV	src/Eigen2Support/SVD.h	/^    const MatrixVType& matrixV() const { return m_matV; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
matrixV	src/SVD/JacobiSVD.h	/^    const MatrixVType& matrixV() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
matrixZ	src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixZ() const {$/;"	f	class:Eigen::RealQZ	access:public	signature:() const
matrix_swap_impl	src/Core/PlainObjectBase.h	/^struct matrix_swap_impl$/;"	s	namespace:Eigen::internal
matrix_swap_impl	src/Core/PlainObjectBase.h	/^struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>$/;"	s	namespace:Eigen::internal
matrix_type_times_scalar_type	src/Householder/HouseholderSequence.h	/^template<typename OtherScalarType, typename MatrixType> struct matrix_type_times_scalar_type$/;"	s	namespace:Eigen::internal
max	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
max	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
max	src/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
max	src/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
max	src/plugins/ArrayCwiseBinaryOps.h	/^max$/;"	f	signature:(const Scalar &other) const
maxCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
maxCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* index) const
maxCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* row, IndexType* col) const
maxCoeff	src/Core/Redux.h	/^DenseBase<Derived>::maxCoeff() const$/;"	f	class:Eigen::DenseBase	signature:() const
maxCoeff	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_maxCoeff>::Type maxCoeff() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
maxCoeff	src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* index) const
maxCoeff	src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* rowPtr, IndexType* colPtr) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* rowPtr, IndexType* colPtr) const
maxIterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int maxIterations() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
maxPivot	src/LU/FullPivLU.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
maxPivot	src/QR/ColPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
maxPivot	src/QR/FullPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
max_coeff_visitor	src/Core/Visitor.h	/^struct max_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal	inherits:coeff_visitor
max_size	src/Core/util/Memory.h	/^    size_type max_size() const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:() const
maxsuper	src/SparseLU/SparseLU_Structs.h	/^  Index maxsuper; \/\/ The maximum size for a supernode in complete LU$/;"	m	struct:Eigen::internal::perfvalues	access:public
mc	src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex mc() const { return m_mc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
mean	src/Core/DenseBase.h	/^    Scalar mean() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
mean	src/Core/Redux.h	/^DenseBase<Derived>::mean() const$/;"	f	class:Eigen::DenseBase	signature:() const
mean	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_mean>::Type mean() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
memInit	src/SparseLU/SparseLUImpl.h	/^     Index memInit(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size,  GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size, GlobalLU_t& glu)
memInit	src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,Index>::memInit(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size,  GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size, GlobalLU_t& glu)
memXpand	src/SparseLU/SparseLUImpl.h	/^     Index memXpand(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions)
memXpand	src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,Index>::memXpand(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions)
mem_expand	src/SparseLU/SparseLU_column_dfs.h	/^  void mem_expand(IndexVector& lsub, Index& nextl, Index chmark)$/;"	f	struct:Eigen::internal::column_dfs_traits	access:public	signature:(IndexVector& lsub, Index& nextl, Index chmark)
mem_expand	src/SparseLU/SparseLU_panel_dfs.h	/^  void mem_expand(IndexVector& \/*glu.lsub*\/, Index \/*nextl*\/, Index \/*chmark*\/) {}$/;"	f	struct:Eigen::internal::panel_dfs_traits	access:public	signature:(IndexVector& , Index , Index )
member_redux	src/Core/VectorwiseOp.h	/^  member_redux(const BinaryOp func) : m_functor(func) {}$/;"	f	struct:Eigen::internal::member_redux	access:public	signature:(const BinaryOp func)
member_redux	src/Core/VectorwiseOp.h	/^struct member_redux {$/;"	s	namespace:Eigen::internal
merged	src/Geometry/AlignedBox.h	/^  inline AlignedBox merged(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
meta_sqrt	src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c	namespace:Eigen
middle	src/Core/MathFunctions.h	/^  enum { middle = (lower + upper) \/ 2,$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon278
middleCols	src/plugins/BlockMethods.h	/^inline ColsBlockXpr middleCols(Index startCol, Index numCols)$/;"	f	signature:(Index startCol, Index numCols)
middleCols	src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr middleCols(Index startCol, Index numCols) const$/;"	f	signature:(Index startCol, Index numCols) const
middleCols	src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type middleCols(Index startCol, Index n = N) const$/;"	f	signature:(Index startCol, Index n = N) const
middleCols	src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type middleCols(Index startCol, Index n = N)$/;"	f	signature:(Index startCol, Index n = N)
middleRows	src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr middleRows(Index startRow, Index n) const$/;"	f	signature:(Index startRow, Index n) const
middleRows	src/plugins/BlockMethods.h	/^inline RowsBlockXpr middleRows(Index startRow, Index n)$/;"	f	signature:(Index startRow, Index n)
middleRows	src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type middleRows(Index startRow, Index n = N) const$/;"	f	signature:(Index startRow, Index n = N) const
middleRows	src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type middleRows(Index startRow, Index n = N)$/;"	f	signature:(Index startRow, Index n = N)
min	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
min	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
min	src/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
min	src/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
min	src/plugins/ArrayCwiseBinaryOps.h	/^min$/;"	f	signature:(const Scalar &other) const
minCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
minCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* index) const
minCoeff	src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* row, IndexType* col) const
minCoeff	src/Core/Redux.h	/^DenseBase<Derived>::minCoeff() const$/;"	f	class:Eigen::DenseBase	signature:() const
minCoeff	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_minCoeff>::Type minCoeff() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
minCoeff	src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* index) const
minCoeff	src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* rowId, IndexType* colId) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* rowId, IndexType* colId) const
min_coeff_visitor	src/Core/Visitor.h	/^struct min_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal	inherits:coeff_visitor
minimum_degree_ordering	src/OrderingMethods/Amd.h	/^void minimum_degree_ordering(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)$/;"	f	namespace:Eigen::internal	signature:(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)
minor	src/Core/MatrixBase.h	/^    Minor<Derived> minor(Index row, Index col);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index row, Index col)
minor	src/Core/MatrixBase.h	/^    const Minor<Derived> minor(Index row, Index col) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index row, Index col) const
minor	src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col) const$/;"	f	class:Eigen::MatrixBase	signature:(Index row, Index col) const
minor	src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col)$/;"	f	class:Eigen::MatrixBase	signature:(Index row, Index col)
mp_matrix	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const MatrixType* mp_matrix;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
mr	src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
mr	src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
mr	src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
mr	src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2*ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
n	src/SparseLU/SparseLU_Structs.h	/^  Index   n; \/\/ Number of columns in the matrix  $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
nbThreads	src/Core/products/Parallelizer.h	/^inline int nbThreads()$/;"	f	namespace:Eigen	signature:()
nc	src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex nc() const { return m_nc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
nestByValue	src/Core/DenseBase.h	/^    inline const NestByValue<Derived> nestByValue() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
nestByValue	src/Core/NestByValue.h	/^DenseBase<Derived>::nestByValue() const$/;"	f	class:Eigen::DenseBase	signature:() const
nested	src/Core/ProductBase.h	/^struct nested<GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>$/;"	s	namespace:internal
nested	src/Core/ProductBase.h	/^struct nested<const GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>$/;"	s	namespace:internal
nested	src/Core/ReturnByValue.h	/^struct nested<ReturnByValue<Derived>, n, PlainObject>$/;"	s	namespace:Eigen::internal
nested	src/Core/products/CoeffBasedProduct.h	/^struct nested<CoeffBasedProduct<Lhs,Rhs,EvalBeforeNestingBit|EvalBeforeAssigningBit>, N, PlainObject>$/;"	s	namespace:Eigen::internal
nestedExpression	src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
nestedExpression	src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
nestedExpression	src/Core/Block.h	/^    const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const $/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
nestedExpression	src/Core/CwiseUnaryOp.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
nestedExpression	src/Core/CwiseUnaryOp.h	/^    nestedExpression() { return m_xpr.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:()
nestedExpression	src/Core/CwiseUnaryView.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
nestedExpression	src/Core/CwiseUnaryView.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:()
nestedExpression	src/Core/Diagonal.h	/^    nestedExpression() const $/;"	f	class:Eigen::Diagonal	access:public	signature:() const
nestedExpression	src/Core/Replicate.h	/^    const _MatrixTypeNested& nestedExpression() const$/;"	f	class:Eigen::Replicate	access:public	signature:() const
nestedExpression	src/Core/Reverse.h	/^    nestedExpression() const $/;"	f	class:Eigen::Reverse	access:public	signature:() const
nestedExpression	src/Core/SelfAdjointView.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:()
nestedExpression	src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
nestedExpression	src/Core/Transpose.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
nestedExpression	src/Core/Transpose.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::Transpose	access:public	signature:()
nestedExpression	src/Core/TriangularMatrix.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
nestedExpression	src/Core/TriangularMatrix.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
nestedExpression	src/SparseCore/SparseBlock.h	/^    inline const _MatrixTypeNested& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
nestedExpression	src/SparseCore/SparseTriangularView.h	/^    inline const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
nestedPermutation	src/Core/PermutationMatrix.h	/^    const PermutationType& nestedPermutation() const { return m_permutation; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
next	src/SparseCore/AmbiVector.h	/^      Index next;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
nnz	src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon466::__anon467	access:public
no_assignment_operator	src/Core/util/XprHelper.h	/^class no_assignment_operator$/;"	c	namespace:Eigen::internal
noalias	src/Core/MatrixBase.h	/^    NoAlias<Derived,Eigen::MatrixBase > noalias();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
noalias	src/Core/NoAlias.h	/^NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()$/;"	f	class:Eigen::MatrixBase	signature:()
nonZeros	src/Core/DenseBase.h	/^    inline Index nonZeros() const { return size(); }$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
nonZeros	src/SparseCore/AmbiVector.h	/^    Index nonZeros() const;$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:() const
nonZeros	src/SparseCore/AmbiVector.h	/^_Index AmbiVector<_Scalar,_Index>::nonZeros() const$/;"	f	class:Eigen::internal::AmbiVector	signature:() const
nonZeros	src/SparseCore/MappedSparseMatrix.h	/^    inline Index nonZeros() const  { return m_nnz; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
nonZeros	src/SparseCore/SparseBlock.h	/^    Index nonZeros() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
nonZeros	src/SparseCore/SparseBlock.h	/^    Index nonZeros() const;$/;"	p	class:Eigen::BlockImpl	access:private	signature:() const
nonZeros	src/SparseCore/SparseMatrix.h	/^    inline Index nonZeros() const$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
nonZeros	src/SparseCore/SparseMatrixBase.h	/^    inline Index nonZeros() const { return derived().nonZeros(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
nonZeros	src/SparseCore/SparseTranspose.h	/^    inline Index nonZeros() const { return derived().nestedExpression().nonZeros(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
nonZeros	src/SparseCore/SparseVector.h	/^    inline Index nonZeros() const  { return static_cast<Index>(m_data.size()); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
noncopyable	src/Core/util/Meta.h	/^  noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable	access:protected	signature:()
noncopyable	src/Core/util/Meta.h	/^  noncopyable(const noncopyable&);$/;"	p	class:Eigen::internal::noncopyable	access:private	signature:(const noncopyable&)
noncopyable	src/Core/util/Meta.h	/^class noncopyable$/;"	c	namespace:Eigen::internal
nonzeroPivots	src/LU/FullPivLU.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
nonzeroPivots	src/QR/ColPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
nonzeroPivots	src/QR/FullPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
nonzeroSingularValues	src/SVD/JacobiSVD.h	/^    Index nonzeroSingularValues() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
norm	src/Core/Dot.h	/^inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
norm	src/Core/MatrixBase.h	/^    RealScalar norm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
norm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_norm,RealScalar>::Type norm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
norm	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar norm() const { return m_coeffs.norm(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
norm	src/Geometry/Quaternion.h	/^  inline Scalar norm() const { return coeffs().norm(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
norm	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::norm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
norm	src/SparseCore/SparseMatrixBase.h	/^    RealScalar norm()  const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
norm1	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
norm1_default_impl	src/Core/MathFunctions.h	/^struct norm1_default_impl$/;"	s	namespace:Eigen::internal
norm1_default_impl	src/Core/MathFunctions.h	/^struct norm1_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
norm1_impl	src/Core/MathFunctions.h	/^struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal	inherits:norm1_default_impl
norm1_retval	src/Core/MathFunctions.h	/^struct norm1_retval$/;"	s	namespace:Eigen::internal
normal	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
normal	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const NormalReturnType normal() const { return NormalReturnType(*const_cast<Coefficients*>(&m_coeffs),0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
normal	src/Geometry/Hyperplane.h	/^  inline ConstNormalReturnType normal() const { return ConstNormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
normal	src/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
normalize	src/Core/Dot.h	/^inline void MatrixBase<Derived>::normalize()$/;"	f	class:Eigen::MatrixBase	signature:()
normalize	src/Core/MatrixBase.h	/^    void normalize();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
normalize	src/Core/VectorwiseOp.h	/^    void normalize() {$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:()
normalize	src/Eigen2Support/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(void)
normalize	src/Eigen2Support/Geometry/Quaternion.h	/^  inline void normalize() { m_coeffs.normalize(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
normalize	src/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(void)
normalize	src/Geometry/Quaternion.h	/^  inline void normalize() { coeffs().normalize(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
normalized	src/Core/Dot.h	/^MatrixBase<Derived>::normalized() const$/;"	f	class:Eigen::MatrixBase	signature:() const
normalized	src/Core/MatrixBase.h	/^    const PlainObject normalized() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
normalized	src/Core/VectorwiseOp.h	/^    normalized() const { return m_matrix.cwiseQuotient(extendedToOpposite(this->norm())); }$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
normalized	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion normalized() const { return Quaternion(m_coeffs.normalized()); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
normalized	src/Geometry/Quaternion.h	/^  inline Quaternion<Scalar> normalized() const { return Quaternion<Scalar>(coeffs().normalized()); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
nr	src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 2,$/;"	e	enum:Eigen::internal::gebp_traits::__anon36
nr	src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon37
nr	src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon34
nr	src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon35
nr_etdfs	src/SparseCore/SparseColEtree.h	/^void nr_etdfs (Index n, IndexVector& parent, IndexVector& first_kid, IndexVector& next_kid, IndexVector& post, Index postnum)$/;"	f	namespace:Eigen::internal	signature:(Index n, IndexVector& parent, IndexVector& first_kid, IndexVector& next_kid, IndexVector& post, Index postnum)
nsuper	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index nsuper() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
num_expansions	src/SparseLU/SparseLU_Structs.h	/^  Index   num_expansions; $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
numext	src/Core/MathFunctions.h	/^namespace numext {$/;"	n	namespace:Eigen
nzlmax	src/SparseLU/SparseLU_Structs.h	/^  Index   nzlmax; \/\/ Current max size of lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
nzlumax	src/SparseLU/SparseLU_Structs.h	/^  Index   nzlumax; \/\/ Current max size of lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
nzumax	src/SparseLU/SparseLU_Structs.h	/^  Index   nzumax; \/\/ Current max size of ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
offset	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
offset	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
offset	src/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
offset	src/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
operator !=	src/Core/MatrixBase.h	/^    inline bool operator!=(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator !=	src/Core/util/Memory.h	/^    bool operator!=(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(const aligned_allocator<T>& ) const
operator !=	src/Eigen2Support/Cwise.h	/^    operator!=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator !=	src/Eigen2Support/Cwise.h	/^    operator!=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator !=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator !=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator &&	src/plugins/ArrayCwiseBinaryOps.h	/^operator&&(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
operator ()	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType operator()(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
operator ()	src/Core/DenseCoeffsBase.h	/^    operator()(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
operator ()	src/Core/DenseCoeffsBase.h	/^    operator()(Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
operator ()	src/Core/DenseCoeffsBase.h	/^    operator()(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col)
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a \/ m_other; }$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a && b; }$/;"	f	struct:Eigen::internal::scalar_boolean_and_op	access:public	signature:(const bool& a, const bool& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a || b; }$/;"	f	struct:Eigen::internal::scalar_boolean_or_op	access:public	signature:(const bool& a, const bool& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return !(a<=b || b<=a);}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a!=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a<=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a<b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a==b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }$/;"	f	struct:Eigen::internal::scalar_cast_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const $/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return impl(i); }$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index i) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return m_low+i*m_step; }$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const $/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index row, Index col) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const { return row==col ? Scalar(1) : Scalar(0); }$/;"	f	struct:Eigen::internal::scalar_identity_op	access:public	signature:(Index row, Index col) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index, Index = 0) const { return m_other; }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(Index, Index = 0) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& _x, const Scalar& _y) const$/;"	f	struct:Eigen::internal::scalar_hypot_op	access:public	signature:(const Scalar& _x, const Scalar& _y) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }$/;"	f	struct:Eigen::internal::scalar_opposite_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { using numext::conj; return conj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a - b; }$/;"	f	struct:Eigen::internal::scalar_difference_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::max; return (max)(a, b); }$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::min; return (min)(a, b); }$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a \/ b; }$/;"	f	struct:Eigen::internal::scalar_quotient_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs2(a); }$/;"	f	struct:Eigen::internal::scalar_abs2_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { using std::abs; return abs(a); }$/;"	f	struct:Eigen::internal::scalar_abs_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::imag(a); }$/;"	f	struct:Eigen::internal::scalar_imag_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::real(a); }$/;"	f	struct:Eigen::internal::scalar_real_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar1& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const Scalar1& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::imag_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_imag_ref_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::real_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_real_ref_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return Scalar(1)\/a; }$/;"	f	struct:Eigen::internal::scalar_inverse_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a + m_other; }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a*a; }$/;"	f	struct:Eigen::internal::scalar_cube_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a; }$/;"	f	struct:Eigen::internal::scalar_square_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return m_other \/ a; }$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return numext::pow(a, m_exponent); }$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { using std::cos; return cos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a, const OtherScalar& b) const { return numext::pow(a, b); }$/;"	f	struct:Eigen::internal::scalar_binary_pow_op	access:public	signature:(const Scalar& a, const OtherScalar& b) const
operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::acos; return acos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::asin; return asin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::exp; return exp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::log; return log(a); }$/;"	f	struct:Eigen::internal::scalar_log_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::sin; return sin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::sqrt; return sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::tan; return tan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op	access:public	signature:(const Scalar& a) const
operator ()	src/Core/GeneralProduct.h	/^      template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const {$/;"	f	struct:Eigen::GeneralProduct::adds	access:public	signature:(const Dst& dst, const Src& src) const
operator ()	src/Core/GeneralProduct.h	/^    struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	f	struct:Eigen::GeneralProduct::add	access:public	signature:(const Dst& dst, const Src& src) const
operator ()	src/Core/GeneralProduct.h	/^    struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	f	struct:Eigen::GeneralProduct::set	access:public	signature:(const Dst& dst, const Src& src) const
operator ()	src/Core/GeneralProduct.h	/^    struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	f	struct:Eigen::GeneralProduct::sub	access:public	signature:(const Dst& dst, const Src& src) const
operator ()	src/Core/Random.h	/^  inline const Scalar operator() (Index, Index = 0) const { return random<Scalar>(); }$/;"	f	struct:Eigen::internal::scalar_random_op	access:public	signature:(Index, Index = 0) const
operator ()	src/Core/Reverse.h	/^    inline Scalar& operator()(Index index)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index)
operator ()	src/Core/Reverse.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col)
operator ()	src/Core/Transpositions.h	/^    inline Index& operator()(Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
operator ()	src/Core/Transpositions.h	/^    inline const Index& operator()(Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
operator ()	src/Core/TriangularMatrix.h	/^    inline Scalar operator()(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col) const
operator ()	src/Core/TriangularMatrix.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col)
operator ()	src/Core/VectorwiseOp.h	/^  inline result_type operator()(const DenseBase<Derived>& mat) const$/;"	f	struct:Eigen::internal::member_redux	access:public	signature:(const DenseBase<Derived>& mat) const
operator ()	src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::max_coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
operator ()	src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::min_coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha,$/;"	f	class:Eigen::internal::gebp_kernel	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha, Index strideA, Index strideB, Index offsetA, Index offsetB, RhsScalar* unpackedB)
operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_lhs	signature:(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride, Index offset)
operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_rhs	signature:(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride, Index offset)
operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride=0, Index offset=0);$/;"	p	struct:Eigen::internal::gemm_pack_lhs	access:public	signature:(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride=0, Index offset=0)
operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride=0, Index offset=0);$/;"	p	struct:Eigen::internal::gemm_pack_rhs	access:public	signature:(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride=0, Index offset=0)
operator ()	src/Core/products/GeneralBlockPanelKernel.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha,$/;"	p	struct:Eigen::internal::gebp_kernel	access:public	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0, RhsScalar* unpackedB=0)
operator ()	src/Core/products/GeneralMatrixMatrix.h	/^  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:(Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const
operator ()	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, const ResScalar& alpha, RhsScalar* workspace)$/;"	f	struct:Eigen::internal::tribb_kernel	access:public	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, const ResScalar& alpha, RhsScalar* workspace)
operator ()	src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)$/;"	f	struct:Eigen::internal::symm_pack_lhs	access:public	signature:(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)
operator ()	src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)$/;"	f	struct:Eigen::internal::symm_pack_rhs	access:public	signature:(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)
operator ()	src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i, Index j)$/;"	f	class:Eigen::internal::blas_data_mapper	access:public	signature:(Index i, Index j)
operator ()	src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i, Index j) const$/;"	f	class:Eigen::internal::const_blas_data_mapper	access:public	signature:(Index i, Index j) const
operator ()	src/Core/util/BlasUtil.h	/^  inline T operator()(const T& x) { return numext::conj(x); }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
operator ()	src/Core/util/BlasUtil.h	/^  inline const T& operator()(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
operator ()	src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar operator() (int row, int col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(int row, int col) const
operator ()	src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar& operator() (int row, int col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(int row, int col)
operator ()	src/Geometry/Transform.h	/^  inline Scalar operator() (Index row, Index col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(Index row, Index col) const
operator ()	src/Geometry/Transform.h	/^  inline Scalar& operator() (Index row, Index col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(Index row, Index col)
operator ()	src/IterativeLinearSolvers/IncompleteLUT.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::IncompleteLUT::keep_diag	access:public	signature:(const Index& row, const Index& col, const Scalar&) const
operator ()	src/MetisSupport/MetisSupport.h	/^  void operator() (const MatrixType& A, PermutationType& matperm)$/;"	f	class:Eigen::MetisOrdering	access:public	signature:(const MatrixType& A, PermutationType& matperm)
operator ()	src/OrderingMethods/Ordering.h	/^    void operator() (const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::COLAMDOrdering	access:public	signature:(const MatrixType& mat, PermutationType& perm)
operator ()	src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& \/*mat*\/, PermutationType& perm)$/;"	f	class:Eigen::NaturalOrdering	access:public	signature:(const MatrixType& , PermutationType& perm)
operator ()	src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering	access:public	signature:(const MatrixType& mat, PermutationType& perm)
operator ()	src/OrderingMethods/Ordering.h	/^    void operator()(const SparseSelfAdjointView<SrcType, SrcUpLo>& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering	access:public	signature:(const SparseSelfAdjointView<SrcType, SrcUpLo>& mat, PermutationType& perm)
operator ()	src/SparseCholesky/SimplicialCholesky.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::SimplicialCholeskyBase::keep_diag	access:public	signature:(const Index& row, const Index& col, const Scalar&) const
operator ()	src/SparseCore/SparseMatrix.h	/^    inline bool operator() (const Index&, const Index&, const Scalar& value) const$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func	access:public	signature:(const Index&, const Index&, const Scalar& value) const
operator *	src/Core/DiagonalMatrix.h	/^    operator*(const MatrixBase<MatrixDerived> &matrix) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const MatrixBase<MatrixDerived> &matrix) const
operator *	src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const Scalar& scalar) const
operator *	src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar, const DiagonalBase& other)$/;"	f	class:Eigen::DiagonalBase	access:friend	signature:(const Scalar& scalar, const DiagonalBase& other)
operator *	src/Core/DiagonalProduct.h	/^MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &a_diagonal) const$/;"	f	class:Eigen::MatrixBase	signature:(const DiagonalBase<DiagonalDerived> &a_diagonal) const
operator *	src/Core/GeneralProduct.h	/^MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
operator *	src/Core/MatrixBase.h	/^    ScalarMultipleReturnType operator*(const UniformScaling<Scalar>& s) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const UniformScaling<Scalar>& s) const
operator *	src/Core/MatrixBase.h	/^    operator*(const DiagonalBase<DiagonalDerived> &diagonal) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const DiagonalBase<DiagonalDerived> &diagonal) const
operator *	src/Core/MatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator *	src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const PermutationBase<Other>& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase<Other>& other) const
operator *	src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const Transpose<PermutationBase<Other> >& other) const
operator *	src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)$/;"	f	class:Eigen::PermutationBase	access:friend	signature:(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)
operator *	src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::Transpose	access:public	signature:(const MatrixBase<OtherDerived>& matrix) const
operator *	src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)$/;"	f	class:Eigen::Transpose	access:friend	signature:(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)
operator *	src/Core/PermutationMatrix.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& matrix, const PermutationBase<PermutationDerived> &permutation)
operator *	src/Core/PermutationMatrix.h	/^operator*(const PermutationBase<PermutationDerived> &permutation,$/;"	f	namespace:Eigen	signature:(const PermutationBase<PermutationDerived> &permutation, const MatrixBase<Derived>& matrix)
operator *	src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, const typename Derived::RealScalar& x)$/;"	f	signature:(const ProductBase<Derived,Lhs,Rhs>& prod, const typename Derived::RealScalar& x)
operator *	src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, const typename Derived::Scalar& x)$/;"	f	signature:(const ProductBase<Derived,Lhs,Rhs>& prod, const typename Derived::Scalar& x)
operator *	src/Core/ProductBase.h	/^operator*(const typename Derived::RealScalar& x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f	signature:(const typename Derived::RealScalar& x,const ProductBase<Derived,Lhs,Rhs>& prod)
operator *	src/Core/ProductBase.h	/^operator*(const typename Derived::Scalar& x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f	signature:(const typename Derived::Scalar& x,const ProductBase<Derived,Lhs,Rhs>& prod)
operator *	src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)$/;"	f	class:Eigen::SelfAdjointView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)
operator *	src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
operator *	src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix) const$/;"	f	class:Eigen::Transpose	access:public	signature:(const MatrixBase<Derived>& matrix) const
operator *	src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix, const Transpose& trt)$/;"	f	class:Eigen::Transpose	access:friend	signature:(const MatrixBase<Derived>& matrix, const Transpose& trt)
operator *	src/Core/Transpositions.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& matrix, const TranspositionsBase<TranspositionsDerived> &transpositions)
operator *	src/Core/Transpositions.h	/^operator*(const TranspositionsBase<TranspositionDerived> &transpositions,$/;"	f	namespace:Eigen	signature:(const TranspositionsBase<TranspositionDerived> &transpositions, const MatrixBase<Derived>& matrix)
operator *	src/Core/TriangularMatrix.h	/^    operator*(const EigenBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const EigenBase<OtherDerived>& rhs) const
operator *	src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)$/;"	f	class:Eigen::TriangularView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)
operator *	src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
operator *	src/Core/VectorwiseOp.h	/^    operator*(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
operator *	src/Eigen2Support/Cwise.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator *	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const QuaternionType& a, const AngleAxis& b)
operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Matrix3 operator* (const Matrix3& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Matrix3& other) const
operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other) const
operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& other) const
operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Vector3 operator* (const Vector3& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Vector3& other) const
operator *	src/Eigen2Support/Geometry/AngleAxis.h	/^  inline friend Matrix3 operator* (const Matrix3& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const Matrix3& a, const AngleAxis& b)
operator *	src/Eigen2Support/Geometry/Quaternion.h	/^  Vector3 operator* (const MatrixBase<Derived>& vec) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& vec) const
operator *	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion operator* (const Quaternion& q) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& q) const
operator *	src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::operator* (const MatrixBase<Derived>& v) const$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived>& v) const
operator *	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::operator* (const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other) const
operator *	src/Eigen2Support/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Vector2& vec) const
operator *	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other) const
operator *	src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const Scaling<Scalar,Dim>& s) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Scaling<Scalar,Dim>& s) const
operator *	src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Transform<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Transform<Scalar,Dim>& t) const
operator *	src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Translation<Scalar,Dim>& t) const
operator *	src/Eigen2Support/Geometry/Scaling.h	/^  friend inline LinearMatrixType operator* (const LinearMatrixType& other, const Scaling& s)$/;"	f	class:Eigen::Scaling	access:friend	signature:(const LinearMatrixType& other, const Scaling& s)
operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator* (const LinearMatrixType& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const LinearMatrixType& other) const
operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling operator* (const Scaling& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other) const
operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline TransformType operator* (const TransformType& t) const;$/;"	p	class:Eigen::Scaling	access:public	signature:(const TransformType& t) const
operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline TransformType operator* (const TranslationType& t) const;$/;"	p	class:Eigen::Scaling	access:public	signature:(const TranslationType& t) const
operator *	src/Eigen2Support/Geometry/Scaling.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const VectorType& other) const
operator *	src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Scaling	signature:(const TransformType& t) const
operator *	src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TranslationType& t) const$/;"	f	class:Eigen::Scaling	signature:(const TranslationType& t) const
operator *	src/Eigen2Support/Geometry/Transform.h	/^  friend inline Transform operator*(const LinearMatrixType& mat, const Transform& t)$/;"	f	class:Eigen::Transform	access:friend	signature:(const LinearMatrixType& mat, const Transform& t)
operator *	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const RotationBase<Derived,Dim>& r) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const ScalingType& s) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const ScalingType& s) const
operator *	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const TranslationType& t) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t) const
operator *	src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const MatrixBase<OtherDerived> &a, const Transform &b)
operator *	src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator *	src/Eigen2Support/Geometry/Transform.h	/^  operator * (const Transform& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other) const
operator *	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r) const
operator *	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const ScalingType& s) const$/;"	f	class:Eigen::Transform	signature:(const ScalingType& s) const
operator *	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t) const
operator *	src/Eigen2Support/Geometry/Translation.h	/^  friend inline TransformType operator* (const LinearMatrixType& linear, const Translation& t)$/;"	f	class:Eigen::Translation	access:friend	signature:(const LinearMatrixType& linear, const Translation& t)
operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const LinearMatrixType& linear) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const LinearMatrixType& linear) const
operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const ScalingType& other) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const ScalingType& other) const
operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const TransformType& t) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const TransformType& t) const
operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other) const
operator *	src/Eigen2Support/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& other) const
operator *	src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const LinearMatrixType& linear) const$/;"	f	class:Eigen::Translation	signature:(const LinearMatrixType& linear) const
operator *	src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const ScalingType& other) const$/;"	f	class:Eigen::Translation	signature:(const ScalingType& other) const
operator *	src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Translation	signature:(const TransformType& t) const
operator *	src/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const QuaternionType& a, const AngleAxis& b)
operator *	src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other) const
operator *	src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& other) const
operator *	src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous	access:friend	signature:(const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)
operator *	src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Rhs>& rhs) const$/;"	f	class:Eigen::Homogeneous	access:public	signature:(const MatrixBase<Rhs>& rhs) const
operator *	src/Geometry/Homogeneous.h	/^    operator* (const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous	access:friend	signature:(const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)
operator *	src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Quaternion<Scalar> operator* (const QuaternionBase<OtherDerived>& q) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& q) const
operator *	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::operator* (const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other) const
operator *	src/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Vector2& vec) const
operator *	src/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other) const
operator *	src/Geometry/RotationBase.h	/^    friend inline Transform<Scalar,Dim,Affine> operator*(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase	access:friend	signature:(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)
operator *	src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const EigenBase<OtherDerived>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase	access:friend	signature:(const EigenBase<OtherDerived>& l, const Derived& r)
operator *	src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const UniformScaling<Scalar>& s) const
operator *	src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Isometry> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Translation<Scalar,Dim>& t) const
operator *	src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Mode> operator*(const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Transform<Scalar,Dim,Mode,Options>& t) const
operator *	src/Geometry/RotationBase.h	/^    operator*(const EigenBase<OtherDerived>& e) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const EigenBase<OtherDerived>& e) const
operator *	src/Geometry/Scaling.h	/^  inline Matrix<Scalar,Dim,Dim> operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?Affine:Mode)> operator* (const Transform<Scalar,Dim, Mode, Options>& t) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const Transform<Scalar,Dim, Mode, Options>& t) const
operator *	src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,Affine> operator* (const Translation<Scalar,Dim>& t) const;$/;"	p	class:Eigen::UniformScaling	access:public	signature:(const Translation<Scalar,Dim>& t) const
operator *	src/Geometry/Scaling.h	/^  inline UniformScaling operator* (const UniformScaling& other) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling& other) const
operator *	src/Geometry/Scaling.h	/^  inline typename internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const MatrixBase<Derived>& other) const
operator *	src/Geometry/Scaling.h	/^MatrixBase<Derived>::operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::MatrixBase	signature:(const UniformScaling<Scalar>& s) const
operator *	src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::UniformScaling	signature:(const Translation<Scalar,Dim>& t) const
operator *	src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const DiagonalBase<DiagonalDerived> &a, const Transform &b)
operator *	src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &b) const$/;"	f	class:Eigen::Transform	access:public	signature:(const DiagonalBase<DiagonalDerived> &b) const
operator *	src/Geometry/Transform.h	/^    operator * (const EigenBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const EigenBase<OtherDerived> &a, const Transform &b)
operator *	src/Geometry/Transform.h	/^    operator * (const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const
operator *	src/Geometry/Transform.h	/^  inline Transform operator*(const RotationBase<Derived,Dim>& r) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	src/Geometry/Transform.h	/^  inline Transform operator*(const TranslationType& t) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t) const
operator *	src/Geometry/Transform.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?int(Affine):int(Mode))> operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s) const
operator *	src/Geometry/Transform.h	/^  inline const Transform operator * (const Transform& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other) const
operator *	src/Geometry/Transform.h	/^  operator * (const EigenBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived> &other) const
operator *	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r) const
operator *	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t) const
operator *	src/Geometry/Translation.h	/^  inline AffineTransformType operator* (const EigenBase<OtherDerived>& linear) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const EigenBase<OtherDerived>& linear) const
operator *	src/Geometry/Translation.h	/^  inline AffineTransformType operator* (const UniformScaling<Scalar>& other) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const UniformScaling<Scalar>& other) const
operator *	src/Geometry/Translation.h	/^  inline AffineTransformType operator*(const EigenBase<OtherDerived>& linear, const Translation& t)$/;"	f	class:Eigen::Translation	access:friend	signature:(const EigenBase<OtherDerived>& linear, const Translation& t)
operator *	src/Geometry/Translation.h	/^  inline IsometryTransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	src/Geometry/Translation.h	/^  inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Transform<Scalar,Dim,Mode,Options>& t) const
operator *	src/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other) const
operator *	src/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& other) const
operator *	src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const EigenBase<OtherDerived>& linear) const$/;"	f	class:Eigen::Translation	signature:(const EigenBase<OtherDerived>& linear) const
operator *	src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const UniformScaling<Scalar>& other) const$/;"	f	class:Eigen::Translation	signature:(const UniformScaling<Scalar>& other) const
operator *	src/Householder/HouseholderSequence.h	/^    typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator *	src/Householder/HouseholderSequence.h	/^typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)$/;"	f	namespace:Eigen	signature:(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)
operator *	src/Jacobi/Jacobi.h	/^    JacobiRotation operator*(const JacobiRotation& other)$/;"	f	class:Eigen::JacobiRotation	access:public	signature:(const JacobiRotation& other)
operator *	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQReturnType	access:public	signature:(const MatrixBase<Derived>& other)
operator *	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType	access:public	signature:(const MatrixBase<Derived>& other)
operator *	src/SparseCore/SparseDiagonalProduct.h	/^SparseMatrixBase<Derived>::operator*(const DiagonalBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const DiagonalBase<OtherDerived> &other) const
operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)
operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const DiagonalBase<OtherDerived> &other) const
operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)
operator *	src/SparseCore/SparseMatrixBase.h	/^    operator*(const SparseMatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived> &other) const
operator *	src/SparseCore/SparsePermutation.h	/^operator*( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen	signature:( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)
operator *	src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)$/;"	f	namespace:Eigen	signature:(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)
operator *	src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)$/;"	f	namespace:Eigen	signature:(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)
operator *	src/SparseCore/SparsePermutation.h	/^operator*(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen	signature:(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)
operator *	src/SparseCore/SparseProduct.h	/^SparseMatrixBase<Derived>::operator*(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived> &other) const
operator *	src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)
operator *	src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
operator *	src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView	access:friend	signature:(const SparseMatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)
operator *	src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseMatrixBase<OtherDerived>& rhs) const
operator *	src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:(const MatrixBase<Derived>& other)
operator *	src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType	access:public	signature:(const MatrixBase<Derived>& other)
operator *	src/plugins/ArrayCwiseBinaryOps.h	/^operator*(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
operator *	src/plugins/CommonCwiseUnaryOps.h	/^const ScalarMultipleReturnType operator*(const RealScalar& scalar) const;$/;"	p	signature:(const RealScalar& scalar) const
operator *	src/plugins/CommonCwiseUnaryOps.h	/^operator*(const Scalar& scalar) const$/;"	f	signature:(const Scalar& scalar) const
operator *	src/plugins/CommonCwiseUnaryOps.h	/^operator*(const Scalar& scalar, const StorageBaseType& matrix)$/;"	f	signature:(const Scalar& scalar, const StorageBaseType& matrix)
operator *	src/plugins/CommonCwiseUnaryOps.h	/^operator*(const std::complex<Scalar>& scalar) const$/;"	f	signature:(const std::complex<Scalar>& scalar) const
operator *	src/plugins/CommonCwiseUnaryOps.h	/^operator*(const std::complex<Scalar>& scalar, const StorageBaseType& matrix)$/;"	f	signature:(const std::complex<Scalar>& scalar, const StorageBaseType& matrix)
operator *=	src/Core/ArrayBase.h	/^    Derived& operator*=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator *=	src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator*=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
operator *=	src/Core/DenseBase.h	/^    inline Derived& operator*=(const Scalar& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& other)
operator *=	src/Core/MatrixBase.h	/^    Derived& operator*=(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
operator *=	src/Core/MatrixBase.h	/^MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
operator *=	src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& other)
operator *=	src/Core/TriangularMatrix.h	/^    TriangularView&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix * other; }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const typename internal::traits<MatrixType>::Scalar& other)
operator *=	src/Core/VectorwiseOp.h	/^    ExpressionType& operator*=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator *=	src/Eigen2Support/Cwise.h	/^    inline ExpressionType& operator*=(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other)
operator *=	src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator*=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other)
operator *=	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& operator*= (const Quaternion& q);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& q)
operator *=	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator*= (const Quaternion& other)$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other)
operator *=	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other)
operator *=	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
operator *=	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const ScalingType& s) { return scale(s.coeffs()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const ScalingType& s)
operator *=	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
operator *=	src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Derived& operator*= (const QuaternionBase<OtherDerived>& q);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& q)
operator *=	src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator*= (const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other)
operator *=	src/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other)
operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const DiagonalMatrix<Scalar,Dim>& s) { linear() *= s; return *this; }$/;"	f	class:Eigen::Transform	access:public	signature:(const DiagonalMatrix<Scalar,Dim>& s)
operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const EigenBase<OtherDerived>& other) { return *this = *this * other; }$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
operator *=	src/Geometry/Transform.h	/^  inline Transform& operator*=(const UniformScaling<Scalar>& s) { return scale(s.factor()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s)
operator *=	src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const Scalar& other)
operator *=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator*=(const Scalar& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const Scalar& other)
operator *=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator*=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator +	src/Core/VectorwiseOp.h	/^    operator+(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
operator +	src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar) const
operator +	src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar, const Cwise& mat)$/;"	f	class:Eigen::Cwise	access:friend	signature:(const Scalar& scalar, const Cwise& mat)
operator +	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator+(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar) const
operator +	src/plugins/ArrayCwiseBinaryOps.h	/^operator+(const Scalar& scalar) const$/;"	f	signature:(const Scalar& scalar) const
operator +	src/plugins/ArrayCwiseBinaryOps.h	/^operator+(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)$/;"	f	signature:(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)
operator ++	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++() { m_inner++; return *this; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:()
operator ++	src/SparseCore/AmbiVector.h	/^    Iterator& operator++()$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:()
operator ++	src/SparseCore/MappedSparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:()
operator ++	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Derived& operator++()$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:()
operator ++	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:()
operator ++	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:()
operator ++	src/SparseCore/SparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:()
operator ++	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:()
operator ++	src/SparseCore/SparseVector.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:()
operator ++	src/SparseCore/SparseView.h	/^  EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseView::InnerIterator	access:public	signature:()
operator ++	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline InnerIterator& operator++()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:()
operator +=	src/Core/ArrayBase.h	/^    Derived& operator+=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator +=	src/Core/ArrayBase.h	/^    Derived& operator+=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const Scalar& scalar)
operator +=	src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator+=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase	access:protected	signature:(const MatrixBase<OtherDerived>& )
operator +=	src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator+=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
operator +=	src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other)
operator +=	src/Core/DenseBase.h	/^    Derived& operator+=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator +=	src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
operator +=	src/Core/MatrixBase.h	/^    Derived& operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
operator +=	src/Core/MatrixBase.h	/^    Derived& operator+=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator +=	src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase	access:protected	signature:(const ArrayBase<OtherDerived>& )
operator +=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
operator +=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator +=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
operator +=	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator +=	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
operator +=	src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator+=(const DenseBase<Other>& other) { return *this = m_matrix + other.derived(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const DenseBase<Other>& other)
operator +=	src/Core/VectorwiseOp.h	/^    ExpressionType& operator+=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator +=	src/Eigen2Support/Cwise.h	/^    ExpressionType& operator+=(const Scalar& scalar);$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar)
operator +=	src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator+=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar)
operator +=	src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
operator +=	src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator+=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived>& other)
operator +=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator+=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator ,	src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const DenseBase<OtherDerived>& other)
operator ,	src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const Scalar& s)
operator -	src/Core/VectorwiseOp.h	/^    operator-(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
operator -	src/Eigen2Support/Cwise.h	/^    operator-(const Scalar& scalar) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar) const
operator -	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator-(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar) const
operator -	src/plugins/ArrayCwiseBinaryOps.h	/^operator-(const Scalar& scalar) const$/;"	f	signature:(const Scalar& scalar) const
operator -	src/plugins/ArrayCwiseBinaryOps.h	/^operator-(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)$/;"	f	signature:(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)
operator -	src/plugins/CommonCwiseUnaryOps.h	/^operator-() const { return derived(); }$/;"	f	signature:() const
operator --	src/SparseCore/MappedSparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:()
operator --	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:()
operator --	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:()
operator --	src/SparseCore/SparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { --m_id; return *this; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:()
operator --	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:()
operator --	src/SparseCore/SparseVector.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:()
operator -=	src/Core/ArrayBase.h	/^    Derived& operator-=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator -=	src/Core/ArrayBase.h	/^    Derived& operator-=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const Scalar& scalar)
operator -=	src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator-=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase	access:protected	signature:(const MatrixBase<OtherDerived>& )
operator -=	src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator-=(const ArrayBase<OtherDerived> &other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived> &other)
operator -=	src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other)
operator -=	src/Core/DenseBase.h	/^    Derived& operator-=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator -=	src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
operator -=	src/Core/MatrixBase.h	/^    Derived& operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
operator -=	src/Core/MatrixBase.h	/^    Derived& operator-=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator -=	src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator-=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase	access:protected	signature:(const ArrayBase<OtherDerived>& )
operator -=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
operator -=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator -=	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
operator -=	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator -=	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
operator -=	src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator-=(const DenseBase<Other>& other) { return *this = m_matrix - other.derived(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const DenseBase<Other>& other)
operator -=	src/Core/VectorwiseOp.h	/^    ExpressionType& operator-=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator -=	src/Eigen2Support/Cwise.h	/^    ExpressionType& operator-=(const Scalar& scalar);$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar)
operator -=	src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator-=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar)
operator -=	src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
operator -=	src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator-=(const SparseMatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived> &other)
operator -=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator-=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator /	src/Core/GlobalFunctions.h	/^    operator\/(const typename Derived::Scalar& s, const Eigen::ArrayBase<Derived>& a)$/;"	f	namespace:Eigen	signature:(const typename Derived::Scalar& s, const Eigen::ArrayBase<Derived>& a)
operator /	src/Core/VectorwiseOp.h	/^    operator\/(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
operator /	src/Eigen2Support/Cwise.h	/^    operator\/(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator /	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator\/(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator /	src/plugins/ArrayCwiseBinaryOps.h	/^operator\/(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
operator /	src/plugins/CommonCwiseUnaryOps.h	/^operator\/(const Scalar& scalar) const$/;"	f	signature:(const Scalar& scalar) const
operator /=	src/Core/ArrayBase.h	/^    Derived& operator\/=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator /=	src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator\/=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
operator /=	src/Core/DenseBase.h	/^    inline Derived& operator\/=(const Scalar& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& other)
operator /=	src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& other)
operator /=	src/Core/TriangularMatrix.h	/^    TriangularView&  operator\/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix \/ other; }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const typename internal::traits<MatrixType>::Scalar& other)
operator /=	src/Core/VectorwiseOp.h	/^    ExpressionType& operator\/=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator /=	src/Eigen2Support/Cwise.h	/^    inline ExpressionType& operator\/=(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other)
operator /=	src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator\/=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other)
operator /=	src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const Scalar& other)
operator /=	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator\/=(const Scalar& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const Scalar& other)
operator <	src/Eigen2Support/Cwise.h	/^    operator<(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator <	src/Eigen2Support/Cwise.h	/^    operator<(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator <	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator <	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator <<	src/Core/CommaInitializer.h	/^DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
operator <<	src/Core/CommaInitializer.h	/^inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& s)
operator <<	src/Core/DenseBase.h	/^    CommaInitializer<Derived> operator<< (const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
operator <<	src/Core/DenseBase.h	/^    CommaInitializer<Derived> operator<< (const Scalar& s);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& s)
operator <<	src/Core/IO.h	/^    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)$/;"	f	class:Eigen::WithFormat	access:friend	signature:(std::ostream & s, const WithFormat& wf)
operator <<	src/Core/IO.h	/^std::ostream & operator <<$/;"	f	namespace:Eigen	signature:(std::ostream & s, const DenseBase<Derived> & m)
operator <<	src/SparseCore/SparseMatrix.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrix& m)$/;"	f	class:Eigen::SparseMatrix	access:friend	signature:(std::ostream & s, const SparseMatrix& m)
operator <<	src/SparseCore/SparseMatrixBase.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrixBase& m)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(std::ostream & s, const SparseMatrixBase& m)
operator <<	src/SparseCore/SparseVector.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseVector& m)$/;"	f	class:Eigen::SparseVector	access:friend	signature:(std::ostream & s, const SparseVector& m)
operator <=	src/Eigen2Support/Cwise.h	/^    operator<=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator <=	src/Eigen2Support/Cwise.h	/^    operator<=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator <=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator <=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator =	src/Core/Array.h	/^    Array& operator=(Array&& other)$/;"	f	class:Eigen::Array	access:public	signature:(Array&& other)
operator =	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Array& other)$/;"	f	class:Eigen::Array	access:public	signature:(const Array& other)
operator =	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator =	src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	src/Core/ArrayBase.h	/^    Derived& operator=(const ArrayBase& other)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase& other)
operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase& other)
operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const DenseBase<OtherDerived>& other)
operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived>& other)
operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const MatrixBase& other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase& other)
operator =	src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const ReturnByValue<OtherDerived>& other)
operator =	src/Core/DenseBase.h	/^    Derived& operator=(const DenseBase& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase& other)
operator =	src/Core/DenseBase.h	/^    Derived& operator=(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
operator =	src/Core/DenseBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	src/Core/DenseBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const ReturnByValue<OtherDerived>& func)
operator =	src/Core/DenseStorage.h	/^    DenseStorage& operator=(DenseStorage&& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage&& other)
operator =	src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage& other)
operator =	src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage&) { return *this; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(const DenseStorage&)
operator =	src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage&);$/;"	p	class:Eigen::DenseStorage	access:private	signature:(const DenseStorage&)
operator =	src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalBase<OtherDerived>& other)
operator =	src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalMatrix& other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalMatrix& other)
operator =	src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
operator =	src/Core/ForceAlignedAccess.h	/^    ForceAlignedAccess& operator=(const ForceAlignedAccess&);$/;"	p	class:Eigen::ForceAlignedAccess	access:private	signature:(const ForceAlignedAccess&)
operator =	src/Core/MapBase.h	/^    Derived& operator=(const MapBase& other)$/;"	f	class:Eigen::MapBase	access:public	signature:(const MapBase& other)
operator =	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Matrix& other)
operator =	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator =	src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::Matrix	access:public	signature:(const ReturnByValue<OtherDerived>& func)
operator =	src/Core/Matrix.h	/^    Matrix& operator=(Matrix&& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(Matrix&& other)
operator =	src/Core/Matrix.h	/^    Matrix& operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
operator =	src/Core/Matrix.h	/^    Matrix& operator=(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r)
operator =	src/Core/MatrixBase.h	/^    Derived& operator=(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const DenseBase<OtherDerived>& other)
operator =	src/Core/MatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
operator =	src/Core/MatrixBase.h	/^    Derived& operator=(const MatrixBase& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase& other)
operator =	src/Core/MatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
operator =	src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
operator =	src/Core/NoAlias.h	/^    ExpressionType& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ReturnByValue<OtherDerived>& func)
operator =	src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase& other)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase& other)
operator =	src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase<OtherDerived>& other)
operator =	src/Core/PermutationMatrix.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& tr)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const TranspositionsBase<OtherDerived>& tr)
operator =	src/Core/PermutationMatrix.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map	access:public	signature:(const Map& other)
operator =	src/Core/PermutationMatrix.h	/^    Map& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::Map	access:public	signature:(const PermutationBase<Other>& other)
operator =	src/Core/PermutationMatrix.h	/^    Map& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::Map	access:public	signature:(const TranspositionsBase<Other>& tr)
operator =	src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationBase<Other>& other)
operator =	src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationMatrix& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationMatrix& other)
operator =	src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const TranspositionsBase<Other>& tr)
operator =	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const PlainObjectBase& other)
operator =	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const ReturnByValue<OtherDerived>& func)
operator =	src/Core/PlainObjectBase.h	/^    PlainObjectBase& operator=(PlainObjectBase&& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(PlainObjectBase&& other)
operator =	src/Core/ReturnByValue.h	/^      Unusable& operator=(const Unusable&) {return *this;}$/;"	f	class:Eigen::ReturnByValue::Unusable	access:private	signature:(const Unusable&)
operator =	src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const ReturnByValue<OtherDerived>& other)
operator =	src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator =	src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const TriangularView<OtherMatrixType, OtherMode>& other)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const TriangularView<OtherMatrixType, OtherMode>& other)
operator =	src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const Rhs& _rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(const Rhs& _rhs)
operator =	src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const SelfCwiseBinaryOp&);$/;"	p	class:Eigen::SelfCwiseBinaryOp	access:private	signature:(const SelfCwiseBinaryOp&)
operator =	src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase& other)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(const TranspositionsBase& other)
operator =	src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
operator =	src/Core/Transpositions.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map	access:public	signature:(const Map& other)
operator =	src/Core/Transpositions.h	/^    Map& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Map	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
operator =	src/Core/Transpositions.h	/^    Transpositions& operator=(const Transpositions& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const Transpositions& other)
operator =	src/Core/Transpositions.h	/^    Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
operator =	src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
operator =	src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(const TranspositionsWrapper& other)
operator =	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator =	src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
operator =	src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator =	src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const TriangularBase<OtherDerived>& other)
operator =	src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularView& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const TriangularView& other)
operator =	src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& other)
operator =	src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const TriangularBase<OtherDerived>& other)
operator =	src/Core/VectorwiseOp.h	/^    ExpressionType& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator =	src/Core/util/Meta.h	/^  const noncopyable& operator=(const noncopyable&);$/;"	p	class:Eigen::internal::noncopyable	access:private	signature:(const noncopyable&)
operator =	src/Core/util/XprHelper.h	/^    no_assignment_operator& operator=(const no_assignment_operator&);$/;"	p	class:Eigen::internal::no_assignment_operator	access:private	signature:(const no_assignment_operator&)
operator =	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
operator =	src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const QuaternionType& q);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& q)
operator =	src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
operator =	src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionType& q)$/;"	f	class:Eigen::AngleAxis	signature:(const QuaternionType& q)
operator =	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const AngleAxisType& aa);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
operator =	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& m)
operator =	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const Quaternion& other);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other)
operator =	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::Quaternion	signature:(const AngleAxisType& aa)
operator =	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const MatrixBase<Derived>& xpr)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived>& xpr)
operator =	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const Quaternion& other)$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other)
operator =	src/Eigen2Support/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
operator =	src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling& operator=(const Scaling& other)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other)
operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const RotationBase<Derived,Dim>& r);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const ScalingType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const ScalingType& t)
operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
operator =	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const TranslationType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
operator =	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
operator =	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
operator =	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r)
operator =	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const ScalingType& s)$/;"	f	class:Eigen::Transform	signature:(const ScalingType& s)
operator =	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t)
operator =	src/Eigen2Support/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other)
operator =	src/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
operator =	src/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const QuaternionBase<QuatDerived>& q);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const QuaternionBase<QuatDerived>& q)
operator =	src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
operator =	src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionBase<QuatDerived>& q)$/;"	f	class:Eigen::AngleAxis	signature:(const QuaternionBase<QuatDerived>& q)
operator =	src/Geometry/Quaternion.h	/^  Derived& operator=(const AngleAxisType& aa);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const AngleAxisType& aa)
operator =	src/Geometry/Quaternion.h	/^  EIGEN_STRONG_INLINE QuaternionBase<Derived>& operator=(const QuaternionBase<Derived>& other);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<Derived>& other)
operator =	src/Geometry/Quaternion.h	/^  template<class OtherDerived> Derived& operator=(const MatrixBase<OtherDerived>& m);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const MatrixBase<OtherDerived>& m)
operator =	src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Derived& operator=(const QuaternionBase<OtherDerived>& other);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other)
operator =	src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::QuaternionBase	signature:(const AngleAxisType& aa)
operator =	src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other)
operator =	src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE QuaternionBase<Derived>& QuaternionBase<Derived>::operator=(const QuaternionBase<Derived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<Derived>& other)
operator =	src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::operator=(const MatrixBase<MatrixDerived>& xpr)$/;"	f	class:Eigen::QuaternionBase	signature:(const MatrixBase<MatrixDerived>& xpr)
operator =	src/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
operator =	src/Geometry/Transform.h	/^  Transform& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const ReturnByValue<OtherDerived>& other)
operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const RotationBase<Derived,Dim>& r);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const TranslationType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
operator =	src/Geometry/Transform.h	/^  inline Transform& operator=(const UniformScaling<Scalar>& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& t)
operator =	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
operator =	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
operator =	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r)
operator =	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t)
operator =	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform	signature:(const UniformScaling<Scalar>& s)
operator =	src/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other)
operator =	src/SparseCore/CompressedStorage.h	/^    CompressedStorage& operator=(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const CompressedStorage& other)
operator =	src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const BlockType& other)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const BlockType& other)
operator =	src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::BlockImpl	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator =	src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct& operator=(const DenseTimeSparseProduct&);$/;"	p	class:Eigen::DenseTimeSparseProduct	access:private	signature:(const DenseTimeSparseProduct&)
operator =	src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct& operator=(const SparseTimeDenseProduct&);$/;"	p	class:Eigen::SparseTimeDenseProduct	access:private	signature:(const SparseTimeDenseProduct&)
operator =	src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE SparseMatrix& operator=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator =	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const EigenBase<OtherDerived>& other)
operator =	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
operator =	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrix& other)
operator =	src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
operator =	src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE SparseMatrix<Scalar,_Options,_Index>& SparseMatrix<Scalar,_Options,_Index>::operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	signature:(const SparseMatrixBase<OtherDerived>& other)
operator =	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
operator =	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const Derived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const Derived& other)
operator =	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator =	src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseSparseProduct<Lhs,Rhs>& product);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
operator =	src/SparseCore/SparseProduct.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
operator =	src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct& operator=(const DenseTimeSparseSelfAdjointProduct&);$/;"	p	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:private	signature:(const DenseTimeSparseSelfAdjointProduct&)
operator =	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct& operator=(const SparseSelfAdjointTimeDenseProduct&);$/;"	p	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:private	signature:(const SparseSelfAdjointTimeDenseProduct&)
operator =	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView& src)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSelfAdjointView& src)
operator =	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)
operator =	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)
operator =	src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator =	src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
operator =	src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseVector& other)
operator =	src/StlSupport/details.h	/^    inline T& operator=(const OtherT& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const OtherT& other)
operator =	src/StlSupport/details.h	/^    inline workaround_msvc_stl_support& operator=(const workaround_msvc_stl_support& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const workaround_msvc_stl_support& other)
operator =	src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix& operator=(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(const SluMatrix& other)
operator ==	src/Core/MatrixBase.h	/^    inline bool operator==(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator ==	src/Core/util/Memory.h	/^    bool operator==(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(const aligned_allocator<T>& ) const
operator ==	src/Eigen2Support/Cwise.h	/^    operator==(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator ==	src/Eigen2Support/Cwise.h	/^    operator==(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator ==	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator ==	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator >	src/Eigen2Support/Cwise.h	/^    operator>(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator >	src/Eigen2Support/Cwise.h	/^    operator>(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator >	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator >	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator >=	src/Eigen2Support/Cwise.h	/^    operator>=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator >=	src/Eigen2Support/Cwise.h	/^    operator>=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator >=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator >=	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator T&	src/StlSupport/details.h	/^    inline operator T& () { return *static_cast<T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:()
operator []	src/Core/DenseCoeffsBase.h	/^    operator[](Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
operator []	src/Core/DenseCoeffsBase.h	/^    operator[](Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
operator []	src/Core/Transpositions.h	/^    inline Index& operator[](Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
operator []	src/Core/Transpositions.h	/^    inline const Index& operator[](Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
operator []	src/SparseCore/SparseMatrix.h	/^        Index operator[](Index i) const { return i==m_index ? m_value : 0; }$/;"	f	class:Eigen::SparseMatrix::SingletonVector	access:public	signature:(Index i) const
operator bool	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
operator bool	src/SparseCore/AmbiVector.h	/^    operator bool() const { return m_cachedIndex>=0; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
operator bool	src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end) && (m_id>=m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
operator bool	src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id <= m_end) && (m_id>m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
operator bool	src/SparseCore/SparseBlock.h	/^      inline operator bool() const { return Base::operator bool() && Base::index() < m_end; }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
operator bool	src/SparseCore/SparseBlock.h	/^      inline operator bool() const { return Base::operator bool() && Base::index() >= m_begin; }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
operator bool	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return (m_lhsIter && m_rhsIter); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
operator bool	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id>=0; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
operator bool	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_lhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
operator bool	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_rhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
operator bool	src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
operator bool	src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
operator bool	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
operator bool	src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
operator bool	src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
operator bool	src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
operator bool	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline operator bool() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
operator const ExpressionType&	src/Core/ForceAlignedAccess.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
operator const ExpressionType&	src/Core/NestByValue.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
operator const PlainObject&	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE operator const PlainObject& () const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
operator const T&	src/StlSupport/details.h	/^    inline operator const T& () const { return *static_cast<const T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:() const
operator const typename Base::Scalar	src/Core/GeneralProduct.h	/^    operator const typename Base::Scalar() const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:() const
operator ||	src/plugins/ArrayCwiseBinaryOps.h	/^operator||(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
operatorInverseSqrt	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorInverseSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
operatorNorm	src/Core/MatrixBase.h	/^    RealScalar operatorNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
operatorNorm	src/Core/SelfAdjointView.h	/^    RealScalar operatorNorm() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
operatorNorm	src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::operatorNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
operatorNorm	src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::operatorNorm() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
operatorSqrt	src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
options	src/SuperLUSupport/SuperLUSupport.h	/^    inline superlu_options_t& options() { return m_sluOptions; }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
order	src/OrderingMethods/Eigen_Colamd.h	/^    Index order ; \/* pivot ordering of this column, if col is dead *\/$/;"	m	union:internal::colamd_col::__anon403	access:public
order_children	src/OrderingMethods/Eigen_Colamd.h	/^static inline  void order_children$/;"	f	namespace:internal	signature:( Index n_col, colamd_col<Index> Col [], Index p [] )
order_children	src/OrderingMethods/Eigen_Colamd.h	/^static void order_children (Index n_col, colamd_col<Index> Col [], Index p []);$/;"	p	namespace:internal	signature:(Index n_col, colamd_col<Index> Col [], Index p [])
ordering	src/SparseCholesky/SimplicialCholesky.h	/^    void ordering(const MatrixType& a, CholMatrixType& ap);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a, CholMatrixType& ap)
ordering	src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::ordering(const MatrixType& a, CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const MatrixType& a, CholMatrixType& ap)
ordering_helper_at_plus_a	src/OrderingMethods/Ordering.h	/^void ordering_helper_at_plus_a(const MatrixType& mat, MatrixType& symmat)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, MatrixType& symmat)
origin	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
origin	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
origin	src/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
origin	src/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
originalMatrix	src/misc/Image.h	/^  inline const MatrixType& originalMatrix() const { return m_originalMatrix; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
other	src/Core/util/Memory.h	/^        typedef aligned_allocator<U> other;$/;"	t	struct:Eigen::aligned_allocator::rebind	access:public
other	src/StlSupport/details.h	/^      typedef aligned_allocator_indirection<U> other;$/;"	t	struct:Eigen::aligned_allocator_indirection::rebind	access:public
outer	src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon136
outer	src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon137
outer	src/Core/Redux.h	/^    outer = Start \/ Derived::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon302
outer	src/Core/Redux.h	/^    outer = index \/ int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon304
outer	src/Core/Stride.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::Stride	access:public	signature:() const
outer	src/SparseCore/SparseBlock.h	/^      inline Index outer()  const { return Base::outer() - (IsRowMajor ? m_block.m_startRow.value() : m_block.m_startCol.value()); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
outer	src/SparseCore/SparseBlock.h	/^      inline Index outer()  const { return Base::outer() - (IsRowMajor ? m_block.m_startRow.value() : m_block.m_startCol.value()); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
outer	src/SparseCore/SparseDenseProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
outer	src/SparseCore/SparseDiagonalProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:() const
outer	src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
outer	src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
outerInd	src/SuperLUSupport/SuperLUSupport.h	/^    int *outerInd;$/;"	m	struct:Eigen::SluMatrix::__anon466	access:public
outerIndexPtr	src/SparseCore/MappedSparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
outerIndexPtr	src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
outerIndexPtr	src/SparseCore/SparseBlock.h	/^    inline Index* outerIndexPtr()$/;"	f	class:Eigen::BlockImpl	access:public	signature:()
outerIndexPtr	src/SparseCore/SparseBlock.h	/^    inline const Index* outerIndexPtr() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
outerIndexPtr	src/SparseCore/SparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
outerIndexPtr	src/SparseCore/SparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
outerSize	src/Core/DenseBase.h	/^    Index outerSize() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
outerSize	src/SparseCore/MappedSparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
outerSize	src/SparseCore/SparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
outerSize	src/SparseCore/SparseMatrixBase.h	/^    Index outerSize() const { return (int(Flags)&RowMajorBit) ? this->rows() : this->cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
outerSize	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index outerSize() const { return 1; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
outerSize	src/SparseCore/SparseView.h	/^  inline Index outerSize() const { return m_matrix.outerSize(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
outerStride	src/Core/Array.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Array	access:public	signature:() const
outerStride	src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
outerStride	src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
outerStride	src/Core/Block.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
outerStride	src/Core/Block.h	/^    inline Index outerStride() const;$/;"	p	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
outerStride	src/Core/CwiseUnaryView.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
outerStride	src/Core/DenseCoeffsBase.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
outerStride	src/Core/DenseCoeffsBase.h	/^    void outerStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
outerStride	src/Core/Diagonal.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
outerStride	src/Core/Flagged.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
outerStride	src/Core/ForceAlignedAccess.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
outerStride	src/Core/Map.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Map	access:public	signature:() const
outerStride	src/Core/Matrix.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Matrix	access:public	signature:() const
outerStride	src/Core/NestByValue.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
outerStride	src/Core/Ref.h	/^  inline Index outerStride() const$/;"	f	class:Eigen::RefBase	access:public	signature:() const
outerStride	src/Core/SelfAdjointView.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
outerStride	src/Core/SelfCwiseBinaryOp.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
outerStride	src/Core/Swap.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
outerStride	src/Core/Transpose.h	/^    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
outerStride	src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().outerStride(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
outerStride	src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
outer_product_selector_run	src/Core/GeneralProduct.h	/^EIGEN_DONT_INLINE void outer_product_selector_run(const ProductType& prod, Dest& dest, const Func& func, const false_type&)$/;"	f	namespace:Eigen::internal	signature:(const ProductType& prod, Dest& dest, const Func& func, const false_type&)
outer_product_selector_run	src/Core/GeneralProduct.h	/^EIGEN_DONT_INLINE void outer_product_selector_run(const ProductType& prod, Dest& dest, const Func& func, const true_type&) {$/;"	f	namespace:Eigen::internal	signature:(const ProductType& prod, Dest& dest, const Func& func, const true_type&)
outer_stride_at_compile_time	src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time$/;"	s	namespace:Eigen::internal
outer_stride_at_compile_time	src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
p	src/OrderingMethods/Eigen_Colamd.h	/^    Index p ;   \/* used as a row pointer in init_rows_cols () *\/$/;"	m	union:internal::Colamd_Row::__anon406	access:public
p16uc_COMPLEX_IM	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_IM   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 1), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_RE	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_RE   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_REV	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV  = vec_sld(p16uc_REVERSE, p16uc_REVERSE, 8);\/\/{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_REV2	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV2 = vec_sld(p16uc_FORWARD, p16uc_FORWARD, 8);\/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_DUPLICATE	src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE = {0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7};$/;"	m	namespace:Eigen::internal
p16uc_FORWARD	src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = vec_lvsl(0, (float*)0);$/;"	m	namespace:Eigen::internal
p16uc_PSET_HI	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_HI = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 1));\/\/{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_PSET_LO	src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_LO = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 2), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 3));\/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE	src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE = {12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3};$/;"	m	namespace:Eigen::internal
p2ui_CONJ_XOR	src/Core/arch/NEON/Complex.h	/^static uint32x2_t p2ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET2(0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
p4f_COUNTDOWN	src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 3.0, 2.0, 1.0, 0.0 };$/;"	m	namespace:Eigen::internal
p4f_ONE	src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ONE = vec_ctf(p4i_ONE, 0);$/;"	m	namespace:Eigen::internal
p4f_ZERO_	src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ZERO_ = (Packet4f) vec_sl((Packet4ui)p4i_MINUS1, (Packet4ui)p4i_MINUS1);$/;"	m	namespace:Eigen::internal
p4i_COUNTDOWN	src/Core/arch/AltiVec/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 3, 2, 1, 0 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	src/Core/arch/AltiVec/Complex.h	/^static Packet4ui  p4ui_CONJ_XOR = vec_mergeh((Packet4ui)p4i_ZERO, (Packet4ui)p4f_ZERO_);\/\/{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	src/Core/arch/NEON/Complex.h	/^static uint32x4_t p4ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET4(0x00000000, 0x80000000, 0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
pabs	src/Core/GenericPacketMath.h	/^pabs(const Packet& a) { using std::abs; return abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pabs	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pabs	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pabs	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vabsq_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pabs	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vabsq_s32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pabs	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pabs	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pabs	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pack	src/Core/products/SelfadjointMatrixMatrix.h	/^  void pack(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)$/;"	f	struct:Eigen::internal::symm_pack_lhs	access:public	signature:(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)
packedMatrix	src/Eigenvalues/HessenbergDecomposition.h	/^    const MatrixType& packedMatrix() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
packedMatrix	src/Eigenvalues/Tridiagonalization.h	/^    inline const MatrixType& packedMatrix() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
packet	src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
packet	src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
packet	src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/Block.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index) const
packet	src/Core/Block.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index index) const
packet	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index index) const
packet	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index index) const
packet	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
packet	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
packet	src/Core/Diagonal.h	/^    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index) const;$/;"	p	class:Eigen::Diagonal	access:private	signature:(Index) const
packet	src/Core/Diagonal.h	/^    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index,Index) const;$/;"	p	class:Eigen::Diagonal	access:private	signature:(Index,Index) const
packet	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index idx) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index idx) const
packet	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index row, Index col) const
packet	src/Core/Flagged.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
packet	src/Core/Flagged.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
packet	src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index) const
packet	src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col) const
packet	src/Core/MapBase.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
packet	src/Core/MapBase.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index) const
packet	src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col) const
packet	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
packet	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/Replicate.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::Replicate	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/ReturnByValue.h	/^    template<int LoadMode>  Unusable& packet(Index) const;$/;"	p	class:Eigen::ReturnByValue	access:public	signature:(Index) const
packet	src/Core/ReturnByValue.h	/^    template<int LoadMode>  Unusable& packet(Index, Index) const;$/;"	p	class:Eigen::ReturnByValue	access:public	signature:(Index, Index) const
packet	src/Core/Reverse.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index) const
packet	src/Core/Reverse.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col) const
packet	src/Core/Transpose.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
packet	src/Core/Transpose.h	/^    inline const PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId) const
packet	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index row, Index col) const
packetByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const { return impl.packetOp(i); }$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index i) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index row, Index col) const$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index row, Index col) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index) const { return m_base = padd(m_base,m_packetStep); }$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index, Index = 0) const { return internal::pset1<Packet>(m_other); }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(Index, Index = 0) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs2_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_opposite_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_difference_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_quotient_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::plog(a); }$/;"	f	struct:Eigen::internal::scalar_log_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_cube_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_op	access:public	signature:(const Packet& a) const
packetOp	src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_square_op	access:public	signature:(const Packet& a) const
packet_impl	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::false_type) const$/;"	f	class:Eigen::DiagonalProduct	access:protected	signature:(Index row, Index col, Index id, internal::false_type) const
packet_impl	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::true_type) const$/;"	f	class:Eigen::DiagonalProduct	access:protected	signature:(Index row, Index col, Index id, internal::true_type) const
packet_traits	src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
pacos	src/Core/GenericPacketMath.h	/^Packet pacos(const Packet& a) { using std::acos; return acos(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
padd	src/Core/GenericPacketMath.h	/^padd(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
padd	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_add(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
padd	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
padd	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
padd	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
padd	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vaddq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
padd	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vaddq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
padd	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
padd	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
padd	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
padd	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
padd	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
palign	src/Core/GenericPacketMath.h	/^inline void palign(PacketType& first, const PacketType& second)$/;"	f	namespace:Eigen::internal	signature:(PacketType& first, const PacketType& second)
palign_impl	src/Core/GenericPacketMath.h	/^struct palign_impl$/;"	s	namespace:Eigen::internal
palign_impl	src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
palign_impl	src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
pand	src/Core/GenericPacketMath.h	/^pand(const Packet& a, const Packet& b) { return a & b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pand	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pand	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pand	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pand	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pand	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pand	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vandq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pand	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pand	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pand	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pand	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pand	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pandnot	src/Core/GenericPacketMath.h	/^pandnot(const Packet& a, const Packet& b) { return a & (!b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pandnot	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v, vec_nor(b.v,b.v))); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pandnot	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pandnot	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pandnot	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pandnot	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pandnot	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vbicq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pandnot	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pandnot	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pandnot	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pandnot	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pandnot	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
panel_bmod	src/SparseLU/SparseLUImpl.h	/^     void panel_bmod(const Index m, const Index w, const Index jcol, const Index nseg, ScalarVector& dense, ScalarVector& tempv, IndexVector& segrep, IndexVector& repfnz, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index m, const Index w, const Index jcol, const Index nseg, ScalarVector& dense, ScalarVector& tempv, IndexVector& segrep, IndexVector& repfnz, GlobalLU_t& glu)
panel_bmod	src/SparseLU/SparseLU_panel_bmod.h	/^void SparseLUImpl<Scalar,Index>::panel_bmod(const Index m, const Index w, const Index jcol, $/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index m, const Index w, const Index jcol, const Index nseg, ScalarVector& dense, ScalarVector& tempv, IndexVector& segrep, IndexVector& repfnz, GlobalLU_t& glu)
panel_dfs	src/SparseLU/SparseLUImpl.h	/^     void panel_dfs(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)
panel_dfs	src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,Index>::panel_dfs(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)
panel_dfs_traits	src/SparseLU/SparseLU_panel_dfs.h	/^  panel_dfs_traits(Index jcol, Index* marker)$/;"	f	struct:Eigen::internal::panel_dfs_traits	access:public	signature:(Index jcol, Index* marker)
panel_dfs_traits	src/SparseLU/SparseLU_panel_dfs.h	/^struct panel_dfs_traits$/;"	s	namespace:Eigen::internal
panel_size	src/SparseLU/SparseLU_Structs.h	/^  Index panel_size; \/\/ a panel consists of at most <panel_size> consecutive columns$/;"	m	struct:Eigen::internal::perfvalues	access:public
parallelize_gemm	src/Core/products/Parallelizer.h	/^void parallelize_gemm(const Functor& func, Index rows, Index cols, bool transpose)$/;"	f	namespace:Eigen::internal	signature:(const Functor& func, Index rows, Index cols, bool transpose)
pardisoInit	src/PardisoSupport/PardisoSupport.h	/^    void pardisoInit(int type)$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:(int type)
pardisoParameterArray	src/PardisoSupport/PardisoSupport.h	/^    ParameterType& pardisoParameterArray()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
pardisoRelease	src/PardisoSupport/PardisoSupport.h	/^    void pardisoRelease()$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:()
pardiso_run_selector	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector$/;"	s	namespace:Eigen::internal
pardiso_run_selector	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector<long long int>$/;"	s	namespace:Eigen::internal
pardiso_traits	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLDLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
parent	src/OrderingMethods/Eigen_Colamd.h	/^    Index parent ;  \/* parent in parent tree super-column structure, if *\/$/;"	m	union:internal::colamd_col::__anon402	access:public
part	src/Core/MatrixBase.h	/^    const DiagonalWrapper<ConstDiagonalReturnType> part() const$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
part	src/Core/MatrixBase.h	/^    template<unsigned int Mode> const typename internal::eigen2_part_return_type<Derived, Mode>::type part() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
part	src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename internal::eigen2_part_return_type<Derived, Mode>::type part();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
part	src/Core/TriangularMatrix.h	/^const typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part() const$/;"	f	class:Eigen::MatrixBase	signature:() const
part	src/Core/TriangularMatrix.h	/^typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part()$/;"	f	class:Eigen::MatrixBase	signature:()
partialPivLu	src/Core/MatrixBase.h	/^    const PartialPivLU<PlainObject> partialPivLu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
partialPivLu	src/LU/PartialPivLU.h	/^MatrixBase<Derived>::partialPivLu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
partial_lu_impl	src/LU/PartialPivLU.h	/^struct partial_lu_impl$/;"	s	namespace:Eigen::internal
partial_lu_inplace	src/LU/PartialPivLU.h	/^void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)
pasin	src/Core/GenericPacketMath.h	/^Packet pasin(const Packet& a) { using std::asin; return asin(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pastix_traits	src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLDLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
pconj	src/Core/GenericPacketMath.h	/^pconj(const Packet& a) { return numext::conj(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pconj	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf((Packet4f)vec_xor((Packet4ui)a.v, p4ui_CONJ_XOR)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pconj	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pconj	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pconj	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pconj	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pconj	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pconj	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
pconj	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pconj	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pconj	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pconj	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pconj	src/Core/util/BlasUtil.h	/^  inline T pconj(const T& x) { return internal::pconj(x); }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
pconj	src/Core/util/BlasUtil.h	/^  inline const T& pconj(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
pcos	src/Core/GenericPacketMath.h	/^Packet pcos(const Packet& a) { using std::cos; return cos(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pcos	src/Core/arch/SSE/MathFunctions.h	/^Packet4f pcos<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
pcplxflip	src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet pcplxflip(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pcplxflip	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& x)
pcplxflip	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pcplxflip	src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& x)
pcplxflip	src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/*<Packet2cf>*\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& x)
pdiv	src/Core/GenericPacketMath.h	/^pdiv(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pdiv	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pdiv	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pdiv	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
pdiv	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pdiv	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pdiv	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
pdiv	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pdiv	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pdiv	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pdiv	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pdiv	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
performFrancisQRStep	src/Eigenvalues/RealSchur.h	/^    void performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)
performFrancisQRStep	src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)$/;"	f	class:Eigen::RealSchur	signature:(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)
perfvalues	src/SparseLU/SparseLU_Structs.h	/^struct perfvalues {$/;"	s	namespace:Eigen::internal
permut_matrix_product_retval	src/Core/PermutationMatrix.h	/^    permut_matrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:(const PermutationType& perm, const MatrixType& matrix)
permut_matrix_product_retval	src/Core/PermutationMatrix.h	/^struct permut_matrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
permut_sparsematrix_product_retval	src/SparseCore/SparsePermutation.h	/^    permut_sparsematrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:(const PermutationType& perm, const MatrixType& matrix)
permut_sparsematrix_product_retval	src/SparseCore/SparsePermutation.h	/^struct permut_sparsematrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
permutationP	src/LU/FullPivLU.h	/^    inline const PermutationPType& permutationP() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
permutationP	src/LU/PartialPivLU.h	/^    inline const PermutationType& permutationP() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
permutationP	src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationP() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
permutationP	src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
permutationP	src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
permutationPinv	src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationPinv() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
permutationQ	src/LU/FullPivLU.h	/^    inline const PermutationQType& permutationQ() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
permutationQ	src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
permutationQ	src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
permute_symm_to_fullsymm	src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0);$/;"	p	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0)
permute_symm_to_fullsymm	src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)
permute_symm_to_symm	src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0);$/;"	p	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0)
permute_symm_to_symm	src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)
pexp	src/Core/GenericPacketMath.h	/^Packet pexp(const Packet& a) { using std::exp; return exp(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pexp	src/Core/arch/SSE/MathFunctions.h	/^Packet2d pexp<Packet2d>(const Packet2d& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& _x)
pexp	src/Core/arch/SSE/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
pfirst	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type pfirst(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pfirst	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pfirst	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pfirst	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pfirst	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vst1q_f32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vst1q_s32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pfirst	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
pfirst	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pfirst	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pivotL	src/SparseLU/SparseLUImpl.h	/^     Index pivotL(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu)
pivotL	src/SparseLU/SparseLU_pivotL.h	/^Index SparseLUImpl<Scalar,Index>::pivotL(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu)
plain_array	src/Core/DenseStorage.h	/^  plain_array() $/;"	f	struct:Eigen::internal::plain_array	access:public	signature:()
plain_array	src/Core/DenseStorage.h	/^  plain_array() {}$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:()
plain_array	src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) $/;"	f	struct:Eigen::internal::plain_array	access:public	signature:(constructor_without_unaligned_array_assert)
plain_array	src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) {}$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:(constructor_without_unaligned_array_assert)
plain_array	src/Core/DenseStorage.h	/^struct plain_array$/;"	s	namespace:Eigen::internal
plain_array	src/Core/DenseStorage.h	/^struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>$/;"	s	namespace:Eigen::internal
plain_array	src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 16>$/;"	s	namespace:Eigen::internal
plain_matrix_type	src/SparseCore/SparseUtil.h	/^template<typename T> struct plain_matrix_type<T,Sparse>$/;"	s	namespace:Eigen::internal
pload	src/Core/GenericPacketMath.h	/^pload(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
pload	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
pload	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
pload	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
pload	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
pload	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
pload	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*   from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
pload	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
pload	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
pload	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double* from)
pload	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
pload	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploaddup	src/Core/GenericPacketMath.h	/^ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
ploaddup	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*     from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploaddup	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploaddup	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploaddup	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploaddup	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploaddup	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploaddup	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
ploaddup	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploaddup	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)$/;"	f	namespace:Eigen::internal	signature:(const double* from)
ploaddup	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploaddup	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploadt	src/Core/GenericPacketMath.h	/^inline Packet ploadt(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
ploadu	src/Core/GenericPacketMath.h	/^ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
ploadu	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploadu	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploadu	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploadu	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploadu	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploadu	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)   { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploadu	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
ploadu	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploadu	src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double* from)
ploadu	src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploadu	src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploadu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal	signature:(const double* from)
ploadu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploadu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
plog	src/Core/GenericPacketMath.h	/^Packet plog(const Packet& a) { using std::log; return log(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
plog	src/Core/arch/SSE/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
plset	src/Core/GenericPacketMath.h	/^plset(const Scalar& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Scalar& a)
plset	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return vec_add(pset1<Packet4f>(a), p4f_COUNTDOWN); }$/;"	f	namespace:Eigen::internal	signature:(const float& a)
plset	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)     { return vec_add(pset1<Packet4i>(a), p4i_COUNTDOWN); }$/;"	f	namespace:Eigen::internal	signature:(const int& a)
plset	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a)$/;"	f	namespace:Eigen::internal	signature:(const float& a)
plset	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)$/;"	f	namespace:Eigen::internal	signature:(const int& a)
plset	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<double>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const double& a)
plset	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const float& a)
plset	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const int& a)
pmadd	src/Core/GenericPacketMath.h	/^pmadd(const Packet&  a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b, const Packet& c)
pmadd	src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
pmadd	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b, const Packet4f& c)
pmadd	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
pmadd	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
pmadd	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vmlaq_f32(c,a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b, const Packet4f& c)
pmadd	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return vmlaq_s32(c,a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const
pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const
pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const
pmadd	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const
pmadd	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
pmadd	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const RealScalar& x, const Scalar& y, const Scalar& c) const
pmadd	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const RealScalar& y, const Scalar& c) const
pmadd	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& c) const
pmadd	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& c) const
pmax	src/Core/GenericPacketMath.h	/^pmax(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pmax	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmax	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmax	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmaxq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmax	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmaxq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmax	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pmax	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmax	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmin	src/Core/GenericPacketMath.h	/^pmin(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pmin	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmin	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmin	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vminq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmin	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vminq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmin	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pmin	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmin	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmul	src/Core/GenericPacketMath.h	/^pmul(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pmul	src/Core/GenericPacketMath.h	/^template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>& a, const std::complex<double>& b)
pmul	src/Core/GenericPacketMath.h	/^template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& a, const std::complex<float>& b)
pmul	src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
pmul	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pmul	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_madd(a,b,p4f_ZERO); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmul	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
pmul	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pmul	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmulq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmul	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmulq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& a, const Packet1cd& b) const
pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& x, const Packet2d& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet2d& y) const
pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet2d& x, const Packet1cd& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2d& x, const Packet1cd& y) const
pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& x, const Packet4f& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet4f& y) const
pmul	src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet4f& x, const Packet2cf& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet4f& x, const Packet2cf& y) const
pmul	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pmul	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pmul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pmul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmul	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const RealScalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const RealScalar& x, const Scalar& y) const
pmul	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const RealScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const RealScalar& y) const
pmul	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y) const
pmul	src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y) const
pnegate	src/Core/GenericPacketMath.h	/^pnegate(const Packet& a) { return -a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pnegate	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pnegate	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return psub<Packet4f>(p4f_ZERO, a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pnegate	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return psub<Packet4i>(p4i_ZERO, a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pnegate	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate<Packet4f>(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pnegate	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return vnegq_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pnegate	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return vnegq_s32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pnegate	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
pnegate	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pnegate	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pnegate	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pnegate	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pointAt	src/Geometry/ParametrizedLine.h	/^  VectorType pointAt(const Scalar& t) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Scalar& t) const
pointAt	src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::pointAt(const _Scalar& t) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const _Scalar& t) const
pointer	src/Core/util/Memory.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator	access:public
pointer	src/StlSupport/details.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
por	src/Core/GenericPacketMath.h	/^por(const Packet& a, const Packet& b) { return a | b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
por	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_or(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
por	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
por	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
por	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
por	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
por	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vorrq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
por	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
por	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
por	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
por	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
por	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pow	src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents) $/;"	f	namespace:Eigen	signature:(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents)
pow	src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent) {$/;"	f	namespace:Eigen	signature:(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent)
pow	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(pow, Scalar) pow(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x, const Scalar& y)
pow	src/Core/MatrixBase.h	/^    const MatrixPowerReturnValue<Derived> pow(const RealScalar& p) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const RealScalar& p) const
pow	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_pow_op)      pow(const Scalar& exponent) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& exponent) const
pow	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::pow(const Scalar& exponent) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& exponent) const
pow	src/plugins/ArrayCwiseUnaryOps.h	/^pow(const Scalar& exponent) const$/;"	f	signature:(const Scalar& exponent) const
pow_default_impl	src/Core/MathFunctions.h	/^struct pow_default_impl$/;"	s	namespace:Eigen::internal
pow_default_impl	src/Core/MathFunctions.h	/^struct pow_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
pow_impl	src/Core/MathFunctions.h	/^struct pow_impl : pow_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:pow_default_impl
pow_retval	src/Core/MathFunctions.h	/^struct pow_retval$/;"	s	namespace:Eigen::internal
precision	src/Core/IO.h	/^  int precision;$/;"	m	struct:Eigen::IOFormat	access:public
precision	src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T precision () { return NumTraits<T>::dummy_precision(); }$/;"	f	namespace:Eigen	signature:()
preconditioner	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner& preconditioner() { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
preconditioner	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Preconditioner& preconditioner() const { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
predux	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Packet& a) const
predux	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Packet& a) const
predux	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Packet& a) const
predux	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const Packet& a) const
predux	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
predux	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
predux	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return pfirst(_mm_hadd_pd(a, a)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_max	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_max(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
predux_max	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_max	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_max	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_max	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_max	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux_max	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_max	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_min	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_min(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
predux_min	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_min	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_min	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_min	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_min	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux_min	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_min	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_mul	src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_mul(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
predux_mul	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux_mul	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_mul	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_mul	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux_mul	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_mul	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_mul	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
predux_mul	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux_mul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux_mul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_mul	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
preduxp	src/Core/GenericPacketMath.h	/^preduxp(const Packet* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet* vecs)
preduxp	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
preduxp	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
preduxp	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
preduxp	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
preduxp	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
preduxp	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
preduxp	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd* vecs)
preduxp	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
preduxp	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d* vecs)
preduxp	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
preduxp	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
prefetch	src/Core/GenericPacketMath.h	/^template<typename Scalar> inline void prefetch(const Scalar* addr)$/;"	f	namespace:Eigen::internal	signature:(const Scalar* addr)
prefetch	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { vec_dstt((float *)addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
prefetch	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
prefetch	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
prefetch	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { EIGEN_ARM_PREFETCH((float *)addr); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
prefetch	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
prefetch	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
prefetch	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double> * addr)
prefetch	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
prefetch	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const double* addr)
prefetch	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
prefetch	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
prerotate	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prerotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
prerotate	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
prerotate	src/Geometry/Transform.h	/^  inline Transform& prerotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
prerotate	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
prescale	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prescale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
prescale	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prescale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
prescale	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
prescale	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::prescale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
prescale	src/Geometry/Transform.h	/^  inline Transform& prescale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
prescale	src/Geometry/Transform.h	/^  inline Transform& prescale(const Scalar& s);$/;"	p	class:Eigen::Transform	access:public	signature:(const Scalar& s)
prescale	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
prescale	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::prescale(const Scalar& s)$/;"	f	class:Eigen::Transform	signature:(const Scalar& s)
preshear	src/Eigen2Support/Geometry/Transform.h	/^  Transform& preshear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
preshear	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::preshear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
preshear	src/Geometry/Transform.h	/^  Transform& preshear(const Scalar& sx, const Scalar& sy);$/;"	p	class:Eigen::Transform	access:public	signature:(const Scalar& sx, const Scalar& sy)
preshear	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::preshear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform	signature:(const Scalar& sx, const Scalar& sy)
pretranslate	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& pretranslate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
pretranslate	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
pretranslate	src/Geometry/Transform.h	/^  inline Transform& pretranslate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
pretranslate	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
prev	src/OrderingMethods/Eigen_Colamd.h	/^    Index prev ;  \/* previous column in degree list, if col is in a *\/$/;"	m	union:internal::colamd_col::__anon404	access:public
preverse	src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet preverse(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
preverse	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
preverse	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) { return (Packet4f)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
preverse	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) { return (Packet4i)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
preverse	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
preverse	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) {$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
preverse	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) {$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
preverse	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
preverse	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(_mm_castps_pd(a.v)))); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
preverse	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
preverse	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
preverse	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
print_matrix	src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)$/;"	f	namespace:Eigen::internal	signature:(std::ostream & s, const Derived& _m, const IOFormat& fmt)
print_matrix	src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt);$/;"	p	namespace:Eigen::internal	signature:(std::ostream & s, const Derived& _m, const IOFormat& fmt)
prod	src/Core/DenseBase.h	/^    Scalar prod() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
prod	src/Core/Redux.h	/^DenseBase<Derived>::prod() const$/;"	f	class:Eigen::DenseBase	signature:() const
prod	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_prod>::Type prod() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, 0, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, 1, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, 0, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,1>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,RhsCols>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,LhsRows,1>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_unroller	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_unroller	src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller<0, Lhs, Rhs, Packet>$/;"	s	namespace:Eigen::internal
product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_size_category	src/Core/GeneralProduct.h	/^template<int Size, int MaxSize> struct product_size_category$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix_trmm	src/Core/products/TriangularMatrixMatrix_MKL.h	/^struct product_triangular_matrix_matrix_trmm :$/;"	s	namespace:Eigen::internal	inherits:product_triangular_matrix_matrix
product_type	src/Core/GeneralProduct.h	/^template<typename Lhs, typename Rhs> struct product_type$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	s	namespace:Eigen::internal
projection	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
projection	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
projection	src/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
projection	src/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
projective_transform_inverse	src/Geometry/Transform.h	/^struct projective_transform_inverse$/;"	s	namespace:Eigen::internal
projective_transform_inverse	src/Geometry/Transform.h	/^struct projective_transform_inverse<TransformType, Projective>$/;"	s	namespace:Eigen::internal
promote_index_type	src/Core/util/XprHelper.h	/^struct promote_index_type$/;"	s	namespace:Eigen::internal
promote_storage_type	src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Dense,Sparse>$/;"	s	namespace:Eigen::internal
promote_storage_type	src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Sparse,Dense>$/;"	s	namespace:Eigen::internal
prune	src/SparseCore/CompressedStorage.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())
prune	src/SparseCore/SparseMatrix.h	/^    void prune(const KeepFunc& keep = KeepFunc())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const KeepFunc& keep = KeepFunc())
prune	src/SparseCore/SparseMatrix.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())
prune	src/SparseCore/SparseVector.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseVector	access:public	signature:(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())
pruneL	src/SparseLU/SparseLUImpl.h	/^     void pruneL(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg, const IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg, const IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, GlobalLU_t& glu)
pruneL	src/SparseLU/SparseLU_pruneL.h	/^void SparseLUImpl<Scalar,Index>::pruneL(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg, const IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg, const IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, GlobalLU_t& glu)
pruned	src/SparseCore/SparseProduct.h	/^    SparseSparseProduct pruned(const Scalar& reference = 0, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision()) const$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Scalar& reference = 0, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision()) const
pset1	src/Core/GenericPacketMath.h	/^pset1(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type& a)
pset1	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
pset1	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) {$/;"	f	namespace:Eigen::internal	signature:(const float& from)
pset1	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   {$/;"	f	namespace:Eigen::internal	signature:(const int& from)
pset1	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
pset1	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return vdupq_n_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
pset1	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   { return vdupq_n_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
pset1	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>& from)
pset1	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double& from)
pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }$/;"	f	namespace:Eigen::internal	signature:(const double& from)
pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set1_ps(from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
pset1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
pseudoEigenvalueMatrix	src/Eigenvalues/EigenSolver.h	/^    MatrixType pseudoEigenvalueMatrix() const;$/;"	p	class:Eigen::EigenSolver	access:public	signature:() const
pseudoEigenvalueMatrix	src/Eigenvalues/EigenSolver.h	/^MatrixType EigenSolver<MatrixType>::pseudoEigenvalueMatrix() const$/;"	f	class:Eigen::EigenSolver	signature:() const
pseudoEigenvectors	src/Eigenvalues/EigenSolver.h	/^    const MatrixType& pseudoEigenvectors() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
psin	src/Core/GenericPacketMath.h	/^Packet psin(const Packet& a) { using std::sin; return sin(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
psin	src/Core/arch/SSE/MathFunctions.h	/^Packet4f psin<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
psqrt	src/Core/GenericPacketMath.h	/^Packet psqrt(const Packet& a) { using std::sqrt; return sqrt(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
psqrt	src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
psqrt	src/Core/arch/SSE/MathFunctions.h	/^template<> EIGEN_STRONG_INLINE Packet2d psqrt<Packet2d>(const Packet2d& x) { return _mm_sqrt_pd(x); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& x)
psqrt	src/Core/arch/SSE/MathFunctions.h	/^template<> EIGEN_STRONG_INLINE Packet4f psqrt<Packet4f>(const Packet4f& x) { return _mm_sqrt_ps(x); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& x)
pstore	src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstore(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
pstore	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstore	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstore	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstore	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstore	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstore	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstore	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<double> * to, const Packet1cd& from)
pstore	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstore	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }$/;"	f	namespace:Eigen::internal	signature:(double* to, const Packet2d& from)
pstore	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstore	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<Packet4i*>(to), from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstore1	src/Core/GenericPacketMath.h	/^inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)$/;"	f	namespace:Eigen::internal	signature:(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)
pstore1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal	signature:(double* to, const double& a)
pstore1	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal	signature:(float* to, const float& a)
pstoret	src/Core/GenericPacketMath.h	/^inline void pstoret(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
pstoreu	src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstoreu(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
pstoreu	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstoreu	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from)$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstoreu	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from)$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstoreu	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstoreu	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstoreu	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstoreu	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<double> * to, const Packet1cd& from)
pstoreu	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstoreu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) {$/;"	f	namespace:Eigen::internal	signature:(double* to, const Packet2d& from)
pstoreu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castps_pd(from)); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstoreu	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castsi128_pd(from)); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
psub	src/Core/GenericPacketMath.h	/^psub(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
psub	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_sub(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
psub	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
psub	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
psub	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
psub	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vsubq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
psub	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vsubq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
psub	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
psub	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
psub	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
psub	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
psub	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
ptan	src/Core/GenericPacketMath.h	/^Packet ptan(const Packet& a) { using std::tan; return tan(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
punpackp	src/Core/arch/SSE/PacketMath.h	/^EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(Packet4f* vecs)
pushDownZero	src/Eigenvalues/RealQZ.h	/^      void pushDownZero(Index z, Index f, Index l);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index z, Index f, Index l)
pushDownZero	src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::pushDownZero(Index z, Index f, Index l)$/;"	f	class:Eigen::RealQZ	signature:(Index z, Index f, Index l)
push_back	src/StlSupport/StdDeque.h	/^  void push_back(const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const value_type& x)
push_back	src/StlSupport/StdList.h	/^    void push_back(const value_type& x)$/;"	f	class:std::list	access:private	signature:(const value_type& x)
push_back	src/StlSupport/StdVector.h	/^  void push_back(const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const value_type& x)
push_front	src/StlSupport/StdDeque.h	/^  void push_front(const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const value_type& x)
pxor	src/Core/GenericPacketMath.h	/^pxor(const Packet& a, const Packet& b) { return a ^ b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pxor	src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_xor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pxor	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pxor	src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pxor	src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pxor	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pxor	src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return veorq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pxor	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pxor	src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pxor	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pxor	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pxor	src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
qamax	src/misc/blas.h	/^double BLASFUNC(qamax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qamin	src/misc/blas.h	/^double BLASFUNC(qamin) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qasum	src/misc/blas.h	/^double BLASFUNC(qasum) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qaxpy	src/misc/blas.h	/^int    BLASFUNC(qaxpy) (int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
qcopy	src/misc/blas.h	/^int    BLASFUNC(qcopy) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
qdot	src/misc/blas.h	/^double BLASFUNC(qdot)  (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
qgbmv	src/misc/blas.h	/^int BLASFUNC(qgbmv)(char *, int *, int *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qgemm	src/misc/blas.h	/^int BLASFUNC(qgemm)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qgemv	src/misc/blas.h	/^int BLASFUNC(qgemv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qger	src/misc/blas.h	/^int BLASFUNC(qger)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
qgesv	src/misc/blas.h	/^int BLASFUNC(qgesv)(int *, int *, double *, int *, int *, double*, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, double*, int *, int *)
qgetf2	src/misc/blas.h	/^int BLASFUNC(qgetf2)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
qgetrf	src/misc/blas.h	/^int BLASFUNC(qgetrf)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
qgetrs	src/misc/blas.h	/^int BLASFUNC(qgetrs)(char *, int *, int *, double *, int *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *, int *, double *, int *, int *)
qlaswp	src/misc/blas.h	/^int BLASFUNC(qlaswp)(int *, double *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, double *, int *, int *, int *, int *, int *)
qlauu2	src/misc/blas.h	/^int BLASFUNC(qlauu2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qlauum	src/misc/blas.h	/^int BLASFUNC(qlauum)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qmax	src/misc/blas.h	/^double BLASFUNC(qmax)  (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qmin	src/misc/blas.h	/^double BLASFUNC(qmin)  (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qnrm2	src/misc/blas.h	/^double BLASFUNC(qnrm2) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qpotf2	src/misc/blas.h	/^int BLASFUNC(qpotf2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qpotrf	src/misc/blas.h	/^int BLASFUNC(qpotrf)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qpotri	src/misc/blas.h	/^int BLASFUNC(qpotri)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qr	src/Core/MatrixBase.h	/^    const QR<PlainObject> qr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
qr	src/Eigen2Support/QR.h	/^MatrixBase<Derived>::qr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^> struct qr_preconditioner_impl {};$/;"	s	namespace:Eigen::internal
qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, QRPreconditioner, Case, false>$/;"	c	namespace:Eigen::internal
qr_preconditioner_should_do_anything	src/SVD/JacobiSVD.h	/^struct qr_preconditioner_should_do_anything$/;"	s	namespace:Eigen::internal
qrot	src/misc/blas.h	/^int    BLASFUNC(qrot)  (int *, double *, int *, double *, int *, double *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *, double *)
qrotg	src/misc/blas.h	/^int    BLASFUNC(qrotg) (double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *)
qrotm	src/misc/blas.h	/^int    BLASFUNC(qrotm) (int *, double *, int *, double *, int *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *)
qsbmv	src/misc/blas.h	/^int BLASFUNC(qsbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qscal	src/misc/blas.h	/^int    BLASFUNC(qscal) (int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
qspmv	src/misc/blas.h	/^int BLASFUNC(qspmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
qspr	src/misc/blas.h	/^int BLASFUNC(qspr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
qspr2	src/misc/blas.h	/^int BLASFUNC(qspr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
qswap	src/misc/blas.h	/^int    BLASFUNC(qswap) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
qsymm	src/misc/blas.h	/^int BLASFUNC(qsymm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qsymv	src/misc/blas.h	/^int BLASFUNC(qsymv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qsyr	src/misc/blas.h	/^int BLASFUNC(qsyr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
qsyr2	src/misc/blas.h	/^int BLASFUNC(qsyr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
qsyr2k	src/misc/blas.h	/^int BLASFUNC(qsyr2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
qsyrk	src/misc/blas.h	/^int BLASFUNC(qsyrk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
qtbmv	src/misc/blas.h	/^int BLASFUNC(qtbmv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
qtbsv	src/misc/blas.h	/^int BLASFUNC(qtbsv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
qtpmv	src/misc/blas.h	/^int BLASFUNC(qtpmv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
qtpsv	src/misc/blas.h	/^int BLASFUNC(qtpsv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
qtrmm	src/misc/blas.h	/^int BLASFUNC(qtrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
qtrmv	src/misc/blas.h	/^int BLASFUNC(qtrmv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
qtrsm	src/misc/blas.h	/^int BLASFUNC(qtrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
qtrsv	src/misc/blas.h	/^int BLASFUNC(qtrsv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
qtrti2	src/misc/blas.h	/^int BLASFUNC(qtrti2)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
qtrtri	src/misc/blas.h	/^int BLASFUNC(qtrtri)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
quat_product	src/Geometry/Quaternion.h	/^template<int Arch, class Derived1, class Derived2, typename Scalar, int _Options> struct quat_product$/;"	s	namespace:Eigen::internal
quat_product	src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, double, Aligned>$/;"	s	namespace:Eigen::internal
quat_product	src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, float, Aligned>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,3,3>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,4,1>$/;"	s	namespace:Eigen::internal
queryCacheSizes	src/Core/util/Memory.h	/^inline void queryCacheSizes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
queryCacheSizes_amd	src/Core/util/Memory.h	/^inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
queryCacheSizes_intel	src/Core/util/Memory.h	/^inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3, int max_std_funcs)
queryCacheSizes_intel_codes	src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
queryCacheSizes_intel_direct	src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
queryL1CacheSize	src/Core/util/Memory.h	/^inline int queryL1CacheSize()$/;"	f	namespace:Eigen::internal	signature:()
queryTopLevelCacheSize	src/Core/util/Memory.h	/^inline int queryTopLevelCacheSize()$/;"	f	namespace:Eigen::internal	signature:()
qxamax	src/misc/blas.h	/^double BLASFUNC(qxamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxamin	src/misc/blas.h	/^double BLASFUNC(qxamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxasum	src/misc/blas.h	/^double BLASFUNC(qxasum)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxmax	src/misc/blas.h	/^double BLASFUNC(qxmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxmin	src/misc/blas.h	/^double BLASFUNC(qxmin) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxnrm2	src/misc/blas.h	/^double BLASFUNC(qxnrm2)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
random	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()$/;"	f	namespace:Eigen::internal	signature:()
random	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
random	src/Core/MathFunctions.h	/^template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random();$/;"	p	namespace:Eigen::internal	signature:()
random	src/Core/MathFunctions.h	/^template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y);$/;"	p	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
random_default_impl	src/Core/MathFunctions.h	/^struct random_default_impl {};$/;"	s	namespace:Eigen::internal
random_default_impl	src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
random_default_impl	src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
random_default_impl	src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
random_impl	src/Core/MathFunctions.h	/^struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:random_default_impl
random_impl	src/Core/MathFunctions.h	/^template<> struct random_impl<bool>$/;"	s	namespace:Eigen::internal
random_retval	src/Core/MathFunctions.h	/^struct random_retval$/;"	s	namespace:Eigen::internal
rank	src/LU/FullPivLU.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
rank	src/QR/ColPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
rank	src/QR/FullPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
rank	src/SPQRSupport/SuiteSparseQRSupport.h	/^    Index rank() const$/;"	f	class:Eigen::SPQR	access:public	signature:() const
rank	src/SVD/JacobiSVD.h	/^    inline Index rank() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
rank	src/SparseQR/SparseQR.h	/^    Index rank() const $/;"	f	class:Eigen::SparseQR	access:public	signature:() const
rank	src/misc/Image.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
rank	src/misc/Kernel.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
rankUpdate	src/Cholesky/LDLT.h	/^    LDLT& rankUpdate(const MatrixBase<Derived>& w, const RealScalar& alpha=1);$/;"	p	class:Eigen::LDLT	access:public	signature:(const MatrixBase<Derived>& w, const RealScalar& alpha=1)
rankUpdate	src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::rankUpdate(const MatrixBase<Derived>& w, const typename LDLT<MatrixType,_UpLo>::RealScalar& sigma)$/;"	f	class:Eigen::LDLT	signature:(const MatrixBase<Derived>& w, const typename LDLT<MatrixType,_UpLo>::RealScalar& sigma)
rankUpdate	src/Cholesky/LLT.h	/^    LLT rankUpdate(const VectorType& vec, const RealScalar& sigma = 1);$/;"	p	class:Eigen::LLT	access:public	signature:(const VectorType& vec, const RealScalar& sigma = 1)
rankUpdate	src/Cholesky/LLT.h	/^  static typename MatrixType::Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)
rankUpdate	src/Cholesky/LLT.h	/^LLT<_MatrixType,_UpLo> LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)$/;"	f	class:Eigen::LLT	signature:(const VectorType& v, const RealScalar& sigma)
rankUpdate	src/Core/SelfAdjointView.h	/^    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha = Scalar(1));$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha = Scalar(1))
rankUpdate	src/Core/SelfAdjointView.h	/^    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, const Scalar& alpha = Scalar(1));$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<DerivedU>& u, const Scalar& alpha = Scalar(1))
rankUpdate	src/Core/products/SelfadjointProduct.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView	signature:(const MatrixBase<DerivedU>& u, const Scalar& alpha)
rankUpdate	src/Core/products/SelfadjointRank2Update.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView	signature:(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha)
rankUpdate	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& rankUpdate(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha = Scalar(1));$/;"	p	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha = Scalar(1))
rankUpdate	src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<MatrixType,UpLo>::rankUpdate(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SparseSelfAdjointView	signature:(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha)
rawMatrix	src/SparseCholesky/SimplicialCholesky.h	/^    inline const CholMatrixType rawMatrix() const {$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
real	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
real	src/plugins/CommonCwiseUnaryOps.h	/^real() const { return derived(); }$/;"	f	signature:() const
real	src/plugins/CommonCwiseUnaryOps.h	/^real() { return derived(); }$/;"	f	signature:()
real_2x2_jacobi_svd	src/SVD/JacobiSVD.h	/^void real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& matrix, Index p, Index q, JacobiRotation<RealScalar> *j_left, JacobiRotation<RealScalar> *j_right)
real_default_impl	src/Core/MathFunctions.h	/^struct real_default_impl$/;"	s	namespace:Eigen::internal
real_default_impl	src/Core/MathFunctions.h	/^struct real_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
real_impl	src/Core/MathFunctions.h	/^template<typename Scalar> struct real_impl : real_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal	inherits:real_default_impl
real_ref	src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) real_ref(Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(Scalar& x)
real_ref	src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) >::type real_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext	signature:(const Scalar& x)
real_ref_impl	src/Core/MathFunctions.h	/^struct real_ref_impl$/;"	s	namespace:Eigen::internal
real_ref_retval	src/Core/MathFunctions.h	/^struct real_ref_retval$/;"	s	namespace:Eigen::internal
real_retval	src/Core/MathFunctions.h	/^struct real_retval$/;"	s	namespace:Eigen::internal
reallocate	src/SparseCore/AmbiVector.h	/^    void reallocate(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:protected	signature:(Index size)
reallocate	src/SparseCore/CompressedStorage.h	/^    inline void reallocate(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:protected	signature:(size_t size)
reallocateSparse	src/SparseCore/AmbiVector.h	/^    void reallocateSparse()$/;"	f	class:Eigen::internal::AmbiVector	access:protected	signature:()
rebind	src/Core/util/Memory.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator	access:public
rebind	src/StlSupport/details.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator_indirection	access:public
reconstructedMatrix	src/Cholesky/LDLT.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::LDLT	access:public	signature:() const
reconstructedMatrix	src/Cholesky/LDLT.h	/^MatrixType LDLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LDLT	signature:() const
reconstructedMatrix	src/Cholesky/LLT.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::LLT	access:public	signature:() const
reconstructedMatrix	src/Cholesky/LLT.h	/^MatrixType LLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LLT	signature:() const
reconstructedMatrix	src/LU/FullPivLU.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::FullPivLU	access:public	signature:() const
reconstructedMatrix	src/LU/FullPivLU.h	/^MatrixType FullPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::FullPivLU	signature:() const
reconstructedMatrix	src/LU/PartialPivLU.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::PartialPivLU	access:public	signature:() const
reconstructedMatrix	src/LU/PartialPivLU.h	/^MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::PartialPivLU	signature:() const
reduceToTriangularForm	src/Eigenvalues/ComplexSchur.h	/^    void reduceToTriangularForm(bool computeU);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(bool computeU)
reduceToTriangularForm	src/Eigenvalues/ComplexSchur.h	/^void ComplexSchur<MatrixType>::reduceToTriangularForm(bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(bool computeU)
redux	src/Core/DenseBase.h	/^    redux(const BinaryOp& func) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const BinaryOp& func) const
redux	src/Core/Redux.h	/^DenseBase<Derived>::redux(const Func& func) const$/;"	f	class:Eigen::DenseBase	signature:(const Func& func) const
redux	src/Core/VectorwiseOp.h	/^    redux(const BinaryOp& func = BinaryOp()) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const BinaryOp& func = BinaryOp()) const
redux_impl	src/Core/Redux.h	/^struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	src/Core/Redux.h	/^struct redux_impl<Func, Derived, SliceVectorizedTraversal, Unrolling>$/;"	s	namespace:Eigen::internal
redux_impl	src/Core/Redux.h	/^struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal	inherits:redux_novec_unroller
redux_novec_unroller	src/Core/Redux.h	/^struct redux_novec_unroller$/;"	s	namespace:Eigen::internal
redux_novec_unroller	src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 0>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
redux_traits	src/Core/Redux.h	/^struct redux_traits$/;"	s	namespace:Eigen::internal
redux_vec_unroller	src/Core/Redux.h	/^struct redux_vec_unroller$/;"	s	namespace:Eigen::internal
redux_vec_unroller	src/Core/Redux.h	/^struct redux_vec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
reference	src/Core/util/Memory.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator	access:public
reference	src/SparseCore/SparseMatrix.h	/^    Scalar reference;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func	access:public
reference	src/StlSupport/details.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
relax	src/SparseLU/SparseLU_Structs.h	/^  Index relax; \/\/ To control degree of relaxing supernodes. If the number of nodes (columns) $/;"	m	struct:Eigen::internal::perfvalues	access:public
relax_snode	src/SparseLU/SparseLUImpl.h	/^     void relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)
relax_snode	src/SparseLU/SparseLU_relax_snode.h	/^void SparseLUImpl<Scalar,Index>::relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl	signature:(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)
remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_const	src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	s	namespace:Eigen::internal
remove_const	src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	s	namespace:Eigen::internal
remove_pointer	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	s	namespace:Eigen::internal
replicate	src/Core/DenseBase.h	/^    inline const Replicate<Derived,RowFactor,ColFactor> replicate() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
replicate	src/Core/DenseBase.h	/^    inline const ReplicateReturnType replicate(Index rowFacor,Index colFactor) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rowFacor,Index colFactor) const
replicate	src/Core/Replicate.h	/^DenseBase<Derived>::replicate() const$/;"	f	class:Eigen::DenseBase	signature:() const
replicate	src/Core/Replicate.h	/^DenseBase<Derived>::replicate(Index rowFactor,Index colFactor) const$/;"	f	class:Eigen::DenseBase	signature:(Index rowFactor,Index colFactor) const
replicate	src/Core/Replicate.h	/^VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const$/;"	f	class:Eigen::VectorwiseOp	signature:(Index factor) const
replicate	src/Core/VectorwiseOp.h	/^    const ReplicateReturnType replicate(Index factor) const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:(Index factor) const
replicate	src/Core/VectorwiseOp.h	/^    replicate(Index factor = Factor) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(Index factor = Factor) const
res	src/Core/Visitor.h	/^  Scalar res;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
reserve	src/SparseCore/CompressedStorage.h	/^    void reserve(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size)
reserve	src/SparseCore/SparseMatrix.h	/^    inline void reserve(Index reserveSize)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index reserveSize)
reserve	src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes)
reserve	src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif =$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif = typename SizesType::Scalar())
reserve	src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())
reserve	src/SparseCore/SparseVector.h	/^    inline void reserve(Index reserveSize) { m_data.reserve(reserveSize); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index reserveSize)
reserveInnerVectors	src/SparseCore/SparseMatrix.h	/^    inline void reserveInnerVectors(const SizesType& reserveSizes)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(const SizesType& reserveSizes)
resize	src/Core/ArrayWrapper.h	/^    void resize(Index nbRows, Index nbCols) { m_expression.const_cast_derived().resize(nbRows,nbCols); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index nbRows, Index nbCols)
resize	src/Core/ArrayWrapper.h	/^    void resize(Index nbRows, Index nbCols) { m_expression.const_cast_derived().resize(nbRows,nbCols); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index nbRows, Index nbCols)
resize	src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.const_cast_derived().resize(newSize); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index newSize)
resize	src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.const_cast_derived().resize(newSize); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index newSize)
resize	src/Core/DenseBase.h	/^    void resize(Index nbRows, Index nbCols)$/;"	f	class:Eigen::DenseBase	access:public	signature:(Index nbRows, Index nbCols)
resize	src/Core/DenseBase.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::DenseBase	access:public	signature:(Index newSize)
resize	src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex nbRows, DenseIndex)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex)
resize	src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex nbCols)
resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)
resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex, DenseIndex nbRows, DenseIndex nbCols) { m_rows = nbRows; m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex nbCols)
resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex, DenseIndex nbRows, DenseIndex) { m_rows = nbRows; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex nbRows, DenseIndex)
resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex, DenseIndex, DenseIndex nbCols) { m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex nbCols)
resize	src/Core/DenseStorage.h	/^    void resize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
resize	src/Core/DiagonalMatrix.h	/^    inline void resize(Index size) { m_diagonal.resize(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
resize	src/Core/PermutationMatrix.h	/^    inline void resize(Index newSize)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index newSize)
resize	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index nbRows, Index nbCols)
resize	src/Core/PlainObjectBase.h	/^    inline void resize(Index nbRows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index nbRows, NoChange_t)
resize	src/Core/PlainObjectBase.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size)
resize	src/Core/PlainObjectBase.h	/^    inline void resize(NoChange_t, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(NoChange_t, Index nbCols)
resize	src/Core/Transpositions.h	/^    inline void resize(int newSize)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(int newSize)
resize	src/SparseCore/AmbiVector.h	/^    void resize(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index size)
resize	src/SparseCore/CompressedStorage.h	/^    void resize(size_t size, double reserveSizeFactor = 0)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size, double reserveSizeFactor = 0)
resize	src/SparseCore/SparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
resize	src/SparseCore/SparseVector.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index newSize)
resize	src/SparseCore/SparseVector.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index rows, Index cols)
resize	src/StlSupport/StdDeque.h	/^  void resize(size_type new_size)$/;"	f	class:std::deque	access:private	signature:(size_type new_size)
resize	src/StlSupport/StdDeque.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(size_type new_size, const value_type& x)
resize	src/StlSupport/StdList.h	/^    void resize(size_type new_size)$/;"	f	class:std::list	access:private	signature:(size_type new_size)
resize	src/StlSupport/StdList.h	/^    void resize(size_type new_size, const value_type& x)$/;"	f	class:std::list	access:private	signature:(size_type new_size, const value_type& x)
resize	src/StlSupport/StdVector.h	/^  void resize(size_type new_size)$/;"	f	class:std::vector	access:private	signature:(size_type new_size)
resize	src/StlSupport/StdVector.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(size_type new_size, const value_type& x)
resizeLike	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived>& _other)
resizeNonZeros	src/SparseCore/SparseMatrix.h	/^    void resizeNonZeros(Index size)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index size)
resizeNonZeros	src/SparseCore/SparseVector.h	/^    void resizeNonZeros(Index size) { m_data.resize(size); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index size)
restart	src/SparseCore/AmbiVector.h	/^    void restart();$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:()
restart	src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::restart()$/;"	f	class:Eigen::internal::AmbiVector	signature:()
result	src/Core/ProductBase.h	/^      Matrix<Scalar,1,1> result = *this;$/;"	m	class:Eigen::ProductBase	access:public
result_of	src/Core/Functors.h	/^struct result_of<scalar_cmp_op<Scalar, Cmp>(Scalar,Scalar)> {$/;"	s	namespace:Eigen::internal
result_of	src/Core/util/Meta.h	/^struct result_of<Func(ArgType)> {$/;"	s	namespace:Eigen::internal
result_of	src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1)> {$/;"	s	namespace:Eigen::internal
result_of	src/Core/util/Meta.h	/^template<typename T> struct result_of {};$/;"	s	namespace:Eigen::internal
result_type	src/Core/Functors.h	/^  typedef NewType result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs2_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_ref_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_ref_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_conj_product_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_product_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_quotient_op	access:public
result_type	src/Core/Functors.h	/^  typedef typename scalar_product_traits<Scalar1,Scalar2>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_multiple2_op	access:public
result_type	src/Core/VectorwiseOp.h	/^                   >::type  result_type;$/;"	t	struct:Eigen::internal::member_redux	access:public
ret	src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon158
ret	src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon160
ret	src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::InnerStrideAtCompileTime };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon157
ret	src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::OuterStrideAtCompileTime };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon159
ret	src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon200
ret	src/Core/Functors.h	/^template<typename Functor> struct functor_is_product_like { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon202
ret	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon204
ret	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon203
ret	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_quotient_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon205
ret	src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon201
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon248
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon256
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon255
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon257
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon250
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon254
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon259
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon258
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon264
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon267
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon262
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon265
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon253
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon252
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon260
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon249
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon263
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon266
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon261
ret	src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon251
ret	src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon247
ret	src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon246
ret	src/Core/Transpose.h	/^  enum { ret =    bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon325
ret	src/Core/Transpose.h	/^  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon324
ret	src/Core/util/ForwardDeclarations.h	/^  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };$/;"	e	enum:Eigen::internal::has_direct_access::__anon70
ret	src/Core/util/Meta.h	/^    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::internal::__anon116
ret	src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:Eigen::meta_sqrt::__anon117
ret	src/Core/util/Meta.h	/^{ enum { ret = false }; };$/;"	e	enum:Eigen::is_diagonal::__anon122
ret	src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon123
ret	src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon124
ret	src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon125
ret	src/Eigen2Support/Meta.h	/^    enum { ret = ei_meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::__anon356
ret	src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:ei_meta_sqrt::__anon357
ret	src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_meta_false::__anon353
ret	src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	t	struct:Eigen::ei_meta_if	access:public
ret	src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	t	struct:Eigen::ei_meta_if	access:public
ret	src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_meta_true::__anon352
ret	src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon354
ret	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon355
ret	src/Householder/Householder.h	/^    ret = n==Dynamic ? n : n-1$/;"	e	enum:Eigen::internal::decrement_size::__anon392
ret	src/SVD/JacobiSVD.h	/^         ret = !( (QRPreconditioner == NoQRPreconditioner) ||$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon417
ret	src/SparseCore/SparseCwiseBinaryOp.h	/^{ typedef Sparse ret; };$/;"	t	struct:Eigen::internal::promote_storage_type	access:public
retval	src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::atanh2_default_impl	access:public
retval	src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::pow_default_impl	access:public
reverse	src/Core/DenseBase.h	/^    ConstReverseReturnType reverse() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
reverse	src/Core/DenseBase.h	/^    ReverseReturnType reverse();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
reverse	src/Core/Reverse.h	/^DenseBase<Derived>::reverse() const$/;"	f	class:Eigen::DenseBase	signature:() const
reverse	src/Core/Reverse.h	/^DenseBase<Derived>::reverse()$/;"	f	class:Eigen::DenseBase	signature:()
reverse	src/Core/VectorwiseOp.h	/^    const Reverse<ExpressionType, Direction> reverse() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
reverseInPlace	src/Core/DenseBase.h	/^    void reverseInPlace();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
reverseInPlace	src/Core/Reverse.h	/^inline void DenseBase<Derived>::reverseInPlace()$/;"	f	class:Eigen::DenseBase	signature:()
reverse_packet	src/Core/Reverse.h	/^    typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;$/;"	t	class:Eigen::Reverse	access:protected
reverse_packet_cond	src/Core/Reverse.h	/^template<typename PacketScalar, bool ReversePacket> struct reverse_packet_cond$/;"	s	namespace:Eigen::internal
reverse_packet_cond	src/Core/Reverse.h	/^template<typename PacketScalar> struct reverse_packet_cond<PacketScalar,false>$/;"	s	namespace:Eigen::internal
rhs	src/Core/CwiseBinaryOp.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
rhs	src/Core/products/CoeffBasedProduct.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
rhs	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
rhs	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
rhs	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
rhs	src/misc/Solve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
rhs	src/misc/SparseSolve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
rhs_length	src/Core/products/Parallelizer.h	/^  Index rhs_length;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
rhs_start	src/Core/products/Parallelizer.h	/^  Index rhs_start;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
rightCols	src/plugins/BlockMethods.h	/^inline ColsBlockXpr rightCols(Index n)$/;"	f	signature:(Index n)
rightCols	src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr rightCols(Index n) const$/;"	f	signature:(Index n) const
rightCols	src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type rightCols(Index n = N) const$/;"	f	signature:(Index n = N) const
rightCols	src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type rightCols(Index n = N)$/;"	f	signature:(Index n = N)
rightHouseholderSequence	src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen	signature:(const VectorsType& v, const CoeffsType& h)
rotate	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& rotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
rotate	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
rotate	src/Geometry/Transform.h	/^  inline Transform& rotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
rotate	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
rotation	src/Eigen2Support/Geometry/Transform.h	/^  LinearMatrixType rotation() const;$/;"	p	class:Eigen::Transform	access:public	signature:() const
rotation	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotation() const$/;"	f	class:Eigen::Transform	signature:() const
rotation	src/Geometry/Transform.h	/^  const LinearMatrixType rotation() const;$/;"	p	class:Eigen::Transform	access:public	signature:() const
rotation	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotation() const$/;"	f	class:Eigen::Transform	signature:() const
rotation_base_generic_product_selector	src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector< RotationDerived, DiagonalMatrix<Scalar,Dim,MaxDim>, false >$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,MatrixType,false>$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,OtherVectorType,true>$/;"	s	namespace:Eigen::internal
row	src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::all_unroller::__anon147
row	src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::any_unroller::__anon148
row	src/Core/CoreIterators.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
row	src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon316
row	src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon317
row	src/Core/TriangularMatrix.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon329
row	src/Core/Visitor.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::visitor_impl::__anon336
row	src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
row	src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
row	src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
row	src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
row	src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
row	src/SparseCore/SparseBlock.h	/^      inline Index row()    const { return Base::row()   - m_block.m_startRow.value(); }$/;"	f	class:Eigen::BlockImpl::InnerIterator	access:public	signature:() const
row	src/SparseCore/SparseBlock.h	/^      inline Index row()    const { return Base::row()   - m_block.m_startRow.value(); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator	access:public	signature:() const
row	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return Lhs::IsRowMajor ? m_lhsIter.row() : index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
row	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_lhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
row	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_rhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
row	src/SparseCore/SparseDenseProduct.h	/^    inline Index row() const { return Transpose ? m_outer : Base::index(); }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
row	src/SparseCore/SparseDiagonalProduct.h	/^    inline Index row() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:() const
row	src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
row	src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
row	src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:() const
row	src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:() const
row	src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return (MatrixType::Flags&RowMajorBit ? Base::outer() : this->index()); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
row	src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return Base::row(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
row	src/SparseCore/SparseUtil.h	/^  const Index& row() const { return m_row; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
row	src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
row	src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
row	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index row() const { return index(); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
row	src/plugins/BlockMethods.h	/^inline ConstRowXpr row(Index i) const$/;"	f	signature:(Index i) const
row	src/plugins/BlockMethods.h	/^inline RowXpr row(Index i)$/;"	f	signature:(Index i)
rowIndex	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* rowIndex()  { return m_rowind; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
rowIndex	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* rowIndex() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
rowIndexByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
rowIndexPtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* rowIndexPtr() { return m_rowind_colptr; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
rowIndexPtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* rowIndexPtr() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
rowOffset	src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value()>0 ? 0 : -m_index.value(); }$/;"	f	class:Eigen::Diagonal	access:private	signature:() const
rowPrefix	src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
rowSeparator	src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
rowSpacer	src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
rowStride	src/Core/DenseCoeffsBase.h	/^    inline Index rowStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
rowStride	src/Core/DenseCoeffsBase.h	/^    void rowStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
rowSuffix	src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
rowblk	src/SparseLU/SparseLU_Structs.h	/^  Index rowblk; \/\/ The minimum row dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues	access:public
rows	src/Cholesky/LDLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LDLT	access:public	signature:() const
rows	src/Cholesky/LLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LLT	access:public	signature:() const
rows	src/CholmodSupport/CholmodSupport.h	/^    inline Index rows() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
rows	src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
rows	src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
rows	src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
rows	src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
rows	src/Core/Block.h	/^    inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
rows	src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
rows	src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
rows	src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
rows	src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
rows	src/Core/DenseStorage.h	/^    DenseIndex rows() const {return m_rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
rows	src/Core/DenseStorage.h	/^    DenseIndex rows(void) const {return _Rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
rows	src/Core/DenseStorage.h	/^    DenseIndex rows(void) const {return m_rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
rows	src/Core/DenseStorage.h	/^    static DenseIndex rows(void) {return _Rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void)
rows	src/Core/Diagonal.h	/^    inline Index rows() const$/;"	f	class:Eigen::Diagonal	access:public	signature:() const
rows	src/Core/DiagonalMatrix.h	/^    inline Index rows() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
rows	src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:() const
rows	src/Core/EigenBase.h	/^  inline Index rows() const { return derived().rows(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
rows	src/Core/Flagged.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
rows	src/Core/ForceAlignedAccess.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
rows	src/Core/MapBase.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
rows	src/Core/NestByValue.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
rows	src/Core/PermutationMatrix.h	/^    inline Index rows() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
rows	src/Core/PermutationMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:() const
rows	src/Core/PermutationMatrix.h	/^    inline int rows() const { return m_permutation.rows(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
rows	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
rows	src/Core/Replicate.h	/^    inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }$/;"	f	class:Eigen::Replicate	access:public	signature:() const
rows	src/Core/ReturnByValue.h	/^    inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:() const
rows	src/Core/Reverse.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Reverse	access:public	signature:() const
rows	src/Core/Select.h	/^    Index rows() const { return m_condition.rows(); }$/;"	f	class:Eigen::Select	access:public	signature:() const
rows	src/Core/SelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
rows	src/Core/SelfCwiseBinaryOp.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
rows	src/Core/SolveTriangular.h	/^  inline Index rows() const { return m_rhs.rows(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:() const
rows	src/Core/Swap.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
rows	src/Core/Transpose.h	/^    inline Index rows() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
rows	src/Core/Transpositions.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:() const
rows	src/Core/TriangularMatrix.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
rows	src/Core/TriangularMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
rows	src/Core/VectorwiseOp.h	/^    Index rows() const { return (Direction==Vertical   ? 1 : m_matrix.rows()); }$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:() const
rows	src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
rows	src/Eigen2Support/Minor.h	/^    inline Index rows() const { return m_matrix.rows() - 1; }$/;"	f	class:Eigen::Minor	access:public	signature:() const
rows	src/Eigenvalues/HessenbergDecomposition.h	/^    Index rows() const { return m_hess.packedMatrix().rows(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:() const
rows	src/Eigenvalues/Tridiagonalization.h	/^    Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:() const
rows	src/Geometry/Homogeneous.h	/^    inline Index rows() const { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous	access:public	signature:() const
rows	src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:() const
rows	src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:() const
rows	src/Householder/HouseholderSequence.h	/^    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
rows	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index rows() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:() const
rows	src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
rows	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index rows() const { return mp_matrix ? mp_matrix->rows() : 0; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
rows	src/LU/FullPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
rows	src/LU/Inverse.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:() const
rows	src/LU/PartialPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
rows	src/PaStiXSupport/PaStiXSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
rows	src/PardisoSupport/PardisoSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
rows	src/QR/ColPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
rows	src/QR/FullPivHouseholderQR.h	/^    Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:() const
rows	src/QR/FullPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
rows	src/QR/HouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
rows	src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index rows() const {return m_cR->nrow; }$/;"	f	class:Eigen::SPQR	access:public	signature:() const
rows	src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index rows() const { return m_transpose ? m_spqr.rows() : m_spqr.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct	access:public	signature:() const
rows	src/SVD/JacobiSVD.h	/^    inline Index rows() const { return m_rows; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
rows	src/SparseCholesky/SimplicialCholesky.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
rows	src/SparseCore/MappedSparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
rows	src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
rows	src/SparseCore/SparseBlock.h	/^    inline int rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
rows	src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return Tr ? m_rhs.rows() : m_lhs.rows(); }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
rows	src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
rows	src/SparseCore/SparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
rows	src/SparseCore/SparseMatrixBase.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
rows	src/SparseCore/SparsePermutation.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:() const
rows	src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
rows	src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
rows	src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:() const
rows	src/SparseCore/SparseTriangularView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
rows	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsColVector ? m_size : 1; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
rows	src/SparseCore/SparseView.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
rows	src/SparseLU/SparseLU.h	/^    inline Index rows() const { return m_mat.rows(); }$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
rows	src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType	access:public	signature:()
rows	src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType	access:public	signature:()
rows	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index rows() { return m_row; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
rows	src/SparseQR/SparseQR.h	/^    inline Index rows() const { return m_pmat.rows(); }$/;"	f	class:Eigen::SparseQR	access:public	signature:() const
rows	src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:() const
rows	src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_transpose ? m_qr.rows() : m_qr.cols(); }$/;"	f	struct:Eigen::SparseQR_QProduct	access:public	signature:() const
rows	src/SuperLUSupport/SuperLUSupport.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
rows	src/UmfPackSupport/UmfPackSupport.h	/^    inline Index rows() const { return m_copyMatrix.rows(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
rows	src/misc/Image.h	/^  inline Index rows() const { return m_dec.rows(); }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
rows	src/misc/Kernel.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
rows	src/misc/Solve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
rows	src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:() const
rows	src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
rowsPermutation	src/SparseLU/SparseLU.h	/^    inline const PermutationType& rowsPermutation() const$/;"	f	class:Eigen::SparseLU	access:public	signature:() const
rowsTranspositions	src/QR/FullPivHouseholderQR.h	/^    const IntDiagSizeVectorType& rowsTranspositions() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
rows_select	src/Core/GeneralProduct.h	/^    rows_select = product_size_category<Rows,MaxRows>::value,$/;"	e	enum:Eigen::internal::product_type::__anon244
rowwise	src/Core/DenseBase.h	/^    ConstRowwiseReturnType rowwise() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
rowwise	src/Core/DenseBase.h	/^    RowwiseReturnType rowwise();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
rowwise	src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise() const$/;"	f	class:Eigen::DenseBase	signature:() const
rowwise	src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise()$/;"	f	class:Eigen::DenseBase	signature:()
run	src/Core/Assign.h	/^  static EIGEN_DONT_INLINE void run(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)$/;"	f	struct:Eigen::internal::unaligned_assign_impl	access:public	signature:(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.eval()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose().eval()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, typename Derived1::Index) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling	access:public	signature:(Derived1 &, const Derived2 &, typename Derived1::Index)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, typename Derived1::Index) {}$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling	access:public	signature:(Derived1 &, const Derived2 &, typename Derived1::Index)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)
run	src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index) {}$/;"	f	struct:Eigen::internal::unaligned_assign_impl	access:public	signature:(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index)
run	src/Core/Assign.h	/^  static inline void run(Derived1 &, const Derived2 &) { }$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &, const Derived2 &)
run	src/Core/Assign.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	src/Core/Assign_MKL.h	/^  static inline void run(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)$/;"	f	struct:Eigen::internal::vml_assign_impl	access:public	signature:(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)
run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived & \/*mat*\/) { return false; }$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived & )
run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &)
run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &)
run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &\/*mat*\/) { return true; }$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived & )
run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &mat)
run	src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &mat)
run	src/Core/CwiseNullaryOp.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& m)$/;"	f	struct:Eigen::internal::setIdentity_impl	access:public	signature:(Derived& m)
run	src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived& m)$/;"	f	struct:Eigen::internal::first_aligned_impl	access:public	signature:(const Derived& m)
run	src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived&)$/;"	f	struct:Eigen::internal::first_aligned_impl	access:public	signature:(const Derived&)
run	src/Core/Dot.h	/^  static inline RealScalar run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector	access:public	signature:(const MatrixBase<Derived>& m)
run	src/Core/Dot.h	/^  static inline ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)$/;"	f	struct:Eigen::internal::dot_nocheck	access:public	signature:(const MatrixBase<T>& a, const MatrixBase<U>& b)
run	src/Core/Dot.h	/^  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector	access:public	signature:(const MatrixBase<Derived>& m)
run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isApprox_selector	access:public	signature:(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)
run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector	access:public	signature:(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)
run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isApprox_selector	access:public	signature:(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar&)
run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector	access:public	signature:(const Derived& x, const OtherDerived&, const typename Derived::RealScalar&)
run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector	access:public	signature:(const Derived& x, const typename Derived::RealScalar& y, const typename Derived::RealScalar& prec)
run	src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector	access:public	signature:(const Derived& x, const typename Derived::RealScalar&, const typename Derived::RealScalar&)
run	src/Core/GeneralProduct.h	/^  static inline void run(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_selector	access:public	signature:(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)
run	src/Core/GeneralProduct.h	/^  static void run(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_selector	access:public	signature:(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)
run	src/Core/GenericPacketMath.h	/^  static inline void run(PacketType&, const PacketType&) {}$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(PacketType&, const PacketType&)
run	src/Core/IO.h	/^  static inline int run()$/;"	f	struct:Eigen::internal::significant_decimals_default_impl	access:public	signature:()
run	src/Core/MathFunctions.h	/^  static inline NewType run(const OldType& x)$/;"	f	struct:Eigen::internal::cast_impl	access:public	signature:(const OldType& x)
run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl	access:public	signature:(const Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_default_impl	access:public	signature:(const Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl	access:public	signature:(const Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_default_impl	access:public	signature:(const Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::hypot_impl	access:public	signature:(const Scalar& x, const Scalar& y)
run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_default_impl	access:public	signature:(const Scalar&)
run	src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::abs2_impl	access:public	signature:(const std::complex<RealScalar>& x)
run	src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl	access:public	signature:(Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline Scalar run()$/;"	f	struct:Eigen::internal::random_default_impl	access:public	signature:()
run	src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar x, Scalar y)$/;"	f	struct:Eigen::internal::pow_default_impl	access:public	signature:(Scalar x, Scalar y)
run	src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(Scalar&)
run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::conj_impl	access:public	signature:(const Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl	access:public	signature:(const Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::atanh2_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::pow_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::random_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
run	src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar&, const Scalar&)$/;"	f	struct:Eigen::internal::atanh2_default_impl	access:public	signature:(const Scalar&, const Scalar&)
run	src/Core/MathFunctions.h	/^  static inline bool run()$/;"	f	struct:Eigen::internal::random_impl	access:public	signature:()
run	src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(const Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl	access:public	signature:(const Scalar& x)
run	src/Core/MathFunctions.h	/^  static inline const Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(const Scalar&)
run	src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index rows, Index cols)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow	access:public	signature:(Index rows, Index cols)
run	src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index, Index)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow	access:public	signature:(Index, Index)
run	src/Core/PlainObjectBase.h	/^  static inline void run(MatrixTypeA& a, MatrixTypeB& b)$/;"	f	struct:Eigen::internal::matrix_swap_impl	access:public	signature:(MatrixTypeA& a, MatrixTypeB& b)
run	src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index rows, Index cols)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, Index rows, Index cols)
run	src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index size)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, Index size)
run	src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)
run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_vec_unroller	access:public	signature:(const Derived &mat, const Func& func)
run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_vec_unroller	access:public	signature:(const Derived &mat, const Func&)
run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived &mat, const Func& func)
run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived &mat, const Func&)
run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl	access:public	signature:(const Derived& mat, const Func& func)
run	src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived&, const Func&) { return Scalar(); }$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived&, const Func&)
run	src/Core/Redux.h	/^  static Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl	access:public	signature:(const Derived& mat, const Func& func)
run	src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return preverse(x); }$/;"	f	struct:Eigen::internal::reverse_packet_cond	access:public	signature:(const PacketScalar& x)
run	src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return x; }$/;"	f	struct:Eigen::internal::reverse_packet_cond	access:public	signature:(const PacketScalar& x)
run	src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &, const Derived2 &)
run	src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_selector	access:public	signature:(const Lhs& lhs, Rhs& rhs)
run	src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_unroller	access:public	signature:(const Lhs& lhs, Rhs& rhs)
run	src/Core/SolveTriangular.h	/^  static void run(const Lhs&, Rhs&) {}$/;"	f	struct:Eigen::internal::triangular_solver_unroller	access:public	signature:(const Lhs&, Rhs&)
run	src/Core/Transpose.h	/^    static void run(const Derived& dst, const OtherDerived& other)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl	access:public	signature:(const Derived& dst, const OtherDerived& other)
run	src/Core/Transpose.h	/^    static void run(const Derived&, const OtherDerived&)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl	access:public	signature:(const Derived&, const OtherDerived&)
run	src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector	access:public	signature:(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)
run	src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const OtherDerived& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector	access:public	signature:(const Scalar* dest, const OtherDerived& src)
run	src/Core/Transpose.h	/^  static void run(MatrixType& m) {$/;"	f	struct:Eigen::internal::inplace_transpose_selector	access:public	signature:(MatrixType& m)
run	src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &, const Derived2 &)
run	src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	src/Core/Visitor.h	/^  static inline void run(const Derived &mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl	access:public	signature:(const Derived &mat, Visitor& visitor)
run	src/Core/Visitor.h	/^  static inline void run(const Derived& mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl	access:public	signature:(const Derived& mat, Visitor& visitor)
run	src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
run	src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4f& first, const Packet4f& second)
run	src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4i& first, const Packet4i& second)
run	src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE static void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
run	src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet1cd& , const Packet1cd& )
run	src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
run	src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2d& first, const Packet2d& second)
run	src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4f& first, const Packet4f& second)
run	src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4i& first, const Packet4i& second)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& \/*lhs*\/, const Rhs& \/*rhs*\/, Packet &res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index , Index , const Lhs& , const Rhs& , Packet &res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& \/*lhs*\/, const Rhs& \/*rhs*\/, RetScalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index , Index , const Lhs& , const Rhs& , RetScalar &res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index , Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index , Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index row, Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_unroller	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, A& a, B& b, C& c, T& \/*t*\/)$/;"	f	struct:Eigen::internal::gebp_madd_selector	access:public	signature:(const CJ& cj, A& a, B& b, C& c, T& )
run	src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, T& a, T& b, T& c, T& t)$/;"	f	struct:Eigen::internal::gebp_madd_selector	access:public	signature:(const CJ& cj, T& a, T& b, T& c, T& t)
run	src/Core/products/GeneralMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::general_matrix_matrix_product	access:public	signature:( Index rows, Index cols, Index depth, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha, level3_blocking<RhsScalar,LhsScalar>& blocking, GemmParallelInfo<Index>* info = 0)
run	src/Core/products/GeneralMatrixMatrix.h	/^static void run(Index rows, Index cols, Index depth,$/;"	f	struct:Eigen::internal::general_matrix_matrix_product	access:public	signature:(Index rows, Index cols, Index depth, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha, level3_blocking<LhsScalar,RhsScalar>& blocking, GemmParallelInfo<Index>* info = 0)
run	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public	signature:(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsStride, ResScalar* res, Index resStride, const ResScalar& alpha)
run	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public	signature:(Index size, Index depth,const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride, const ResScalar& alpha)
run	src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static void run(MatrixType& mat, const ProductType& prod, const typename MatrixType::Scalar& alpha)$/;"	f	struct:Eigen::general_product_to_triangular_selector	access:public	signature:(MatrixType& mat, const ProductType& prod, const typename MatrixType::Scalar& alpha)
run	src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE static void run($/;"	p	struct:Eigen::internal::general_matrix_vector_product	access:public	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, ResScalar alpha)
run	src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE static void run($/;"	p	struct:Eigen::internal::general_matrix_vector_product	access:public	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, RhsScalar alpha)
run	src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, RhsScalar alpha)
run	src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, ResScalar alpha)
run	src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	p	struct:Eigen::internal::product_selfadjoint_matrix	access:public	signature:( Index rows, Index cols, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha)
run	src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix	access:public	signature:( Index rows, Index cols, const Scalar* lhs, Index lhsStride, const Scalar* rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha)
run	src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix	signature:( Index rows, Index cols, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha)
run	src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix	signature:( Index rows, Index cols, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha)
run	src/Core/products/SelfadjointMatrixVector.h	/^EIGEN_DONT_INLINE void selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::selfadjoint_matrix_vector_product	signature:( Index size, const Scalar* lhs, Index lhsStride, const Scalar* _rhs, Index rhsIncr, Scalar* res, Scalar alpha)
run	src/Core/products/SelfadjointMatrixVector.h	/^static EIGEN_DONT_INLINE void run($/;"	p	struct:Eigen::internal::selfadjoint_matrix_vector_product	access:public	signature:( Index size, const Scalar* lhs, Index lhsStride, const Scalar* _rhs, Index rhsIncr, Scalar* res, Scalar alpha)
run	src/Core/products/SelfadjointProduct.h	/^  static void run(Index size, Scalar* mat, Index stride, const Scalar* vecX, const Scalar* vecY, const Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_rank1_update	access:public	signature:(Index size, Scalar* mat, Index stride, const Scalar* vecX, const Scalar* vecY, const Scalar& alpha)
run	src/Core/products/SelfadjointProduct.h	/^  static void run(MatrixType& mat, const OtherType& other, const typename MatrixType::Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_product_selector	access:public	signature:(MatrixType& mat, const OtherType& other, const typename MatrixType::Scalar& alpha)
run	src/Core/products/SelfadjointRank2Update.h	/^  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, const Scalar& alpha)$/;"	f	struct:Eigen::internal::selfadjoint_rank2_update_selector	access:public	signature:(Scalar* mat, Index stride, const UType& u, const VType& v, const Scalar& alpha)
run	src/Core/products/TriangularMatrixMatrix.h	/^                                                        RhsStorageOrder,ConjugateRhs,ColMajor,Version>::run($/;"	f	class:Eigen::internal::product_triangular_matrix_matrix	signature:( Index _rows, Index _cols, Index _depth, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
run	src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	p	struct:Eigen::internal::product_triangular_matrix_matrix	access:public	signature:( Index _rows, Index _cols, Index _depth, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
run	src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix	access:public	signature:( Index rows, Index cols, Index depth, const Scalar* lhs, Index lhsStride, const Scalar* rhs, Index rhsStride, Scalar* res, Index resStride, const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
run	src/Core/products/TriangularMatrixVector.h	/^  ::run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	class:Eigen::internal::triangular_matrix_vector_product	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, const ResScalar& alpha)
run	src/Core/products/TriangularMatrixVector.h	/^  static EIGEN_DONT_INLINE  void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	p	struct:Eigen::internal::triangular_matrix_vector_product	access:public	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, const ResScalar& alpha)
run	src/Core/products/TriangularMatrixVector.h	/^  static EIGEN_DONT_INLINE void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	p	struct:Eigen::internal::triangular_matrix_vector_product	access:public	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, const ResScalar& alpha)
run	src/Core/products/TriangularMatrixVector.h	/^  static void run(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, const typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar& alpha)$/;"	f	struct:Eigen::internal::trmv_selector	access:public	signature:(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, const typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar& alpha)
run	src/Core/products/TriangularSolverMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	p	struct:Eigen::internal::triangular_solve_matrix	access:public	signature:( Index size, Index otherSize, const Scalar* _tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
run	src/Core/products/TriangularSolverMatrix.h	/^  static void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix	access:public	signature:( Index size, Index cols, const Scalar* tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
run	src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix	signature:( Index size, Index otherSize, const Scalar* _tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
run	src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix	signature:( Index size, Index otherSize, const Scalar* _tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
run	src/Core/products/TriangularSolverVector.h	/^  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)$/;"	f	struct:Eigen::internal::triangular_solve_vector	access:public	signature:(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)
run	src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE To run(const From& x) { return x; }$/;"	f	struct:Eigen::internal::get_factor	access:public	signature:(const From& x)
run	src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return numext::real(x); }$/;"	f	struct:Eigen::internal::get_factor	access:public	signature:(const Scalar& x)
run	src/Core/util/BlasUtil.h	/^  static const typename T::Scalar* run(const T& m)$/;"	f	struct:Eigen::internal::extract_data_selector	access:public	signature:(const T& m)
run	src/Core/util/BlasUtil.h	/^  static typename T::Scalar* run(const T&) { return 0; }$/;"	f	struct:Eigen::internal::extract_data_selector	access:public	signature:(const T&)
run	src/Core/util/Memory.h	/^  static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_copy_helper	access:public	signature:(const T* start, const T* end, T* target)
run	src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& mat)$/;"	f	struct:Eigen::ei_quaternion_assign_impl	access:public	signature:(Quaternion<Scalar>& q, const Other& mat)
run	src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& vec)$/;"	f	struct:Eigen::ei_quaternion_assign_impl	access:public	signature:(Quaternion<Scalar>& q, const Other& vec)
run	src/Eigen2Support/Geometry/Transform.h	/^    static inline void run(Transform *transform, const MatrixBase<OtherDerived>& other)$/;"	f	struct:Eigen::Transform::construct_from_matrix	access:public	signature:(Transform *transform, const MatrixBase<OtherDerived>& other)
run	src/Eigen2Support/Geometry/Transform.h	/^  static ResultType run(const TransformType& tr, const Other& other)$/;"	f	struct:Eigen::ei_transform_product_impl	access:public	signature:(const TransformType& tr, const Other& other)
run	src/Eigenvalues/ComplexSchur.h	/^  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)$/;"	f	struct:Eigen::internal::complex_schur_reduce_to_hessenberg	access:public	signature:(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)
run	src/Eigenvalues/MatrixBaseEigenvalues.h	/^  run(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::internal::eigenvalues_selector::MatrixBase	access:public	signature:(const MatrixBase<Derived>& m)
run	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& eig, const typename SolverType::MatrixType& A, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(SolverType& eig, const typename SolverType::MatrixType& A, int options)
run	src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& solver, const MatrixType& mat, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(SolverType& solver, const MatrixType& mat, int options)
run	src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
run	src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)
run	src/Geometry/Homogeneous.h	/^  static const type& run (const TransformType& x) { return x.matrix(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const TransformType& x)
run	src/Geometry/Homogeneous.h	/^  static const type& run(const type &x) { return x; }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const type &x)
run	src/Geometry/Homogeneous.h	/^  static type run (const TransformType& x) { return x.affine(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const TransformType& x)
run	src/Geometry/OrthoMethods.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl	access:public	signature:(const VectorLhs& lhs, const VectorRhs& rhs)
run	src/Geometry/OrthoMethods.h	/^  static inline VectorType run(const Derived& src)$/;"	f	struct:Eigen::internal::unitOrthogonal_selector	access:public	signature:(const Derived& src)
run	src/Geometry/Quaternion.h	/^  static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b){$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b)
run	src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& mat)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl	access:public	signature:(QuaternionBase<Derived>& q, const Other& mat)
run	src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& vec)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl	access:public	signature:(QuaternionBase<Derived>& q, const Other& vec)
run	src/Geometry/RotationBase.h	/^  static EIGEN_STRONG_INLINE ReturnType run(const RotationDerived& r, const OtherVectorType& v)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const OtherVectorType& v)
run	src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)
run	src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const MatrixType& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const MatrixType& m)
run	src/Geometry/Transform.h	/^  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)$/;"	f	struct:Eigen::internal::transform_right_product_impl	access:public	signature:(const TransformType& T, const MatrixType& other)
run	src/Geometry/Transform.h	/^  static ResultType run(const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::transform_transform_product_impl	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
run	src/Geometry/Transform.h	/^  static ResultType run(const Other& other, const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl	access:public	signature:(const Other& other, const TransformType& tr)
run	src/Geometry/Transform.h	/^  static ResultType run(const Other& other,const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl	access:public	signature:(const Other& other,const TransformType& tr)
run	src/Geometry/Transform.h	/^  static inline AffinePart run(MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(MatrixType& m)
run	src/Geometry/Transform.h	/^  static inline ConstAffinePart run(const MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(const MatrixType& m)
run	src/Geometry/Transform.h	/^  static inline MatrixType& run(MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(MatrixType& m)
run	src/Geometry/Transform.h	/^  static inline const MatrixType& run(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(const MatrixType& m)
run	src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix	access:public	signature:(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)
run	src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix	access:public	signature:(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)
run	src/Geometry/Transform.h	/^  static inline void run(const TransformType& m, TransformType& res)$/;"	f	struct:Eigen::internal::projective_transform_inverse	access:public	signature:(const TransformType& m, TransformType& res)
run	src/Geometry/Transform.h	/^  static inline void run(const TransformType&, TransformType&)$/;"	f	struct:Eigen::internal::projective_transform_inverse	access:public	signature:(const TransformType&, TransformType&)
run	src/Geometry/Transform.h	/^  static void run(MatrixType &mat)$/;"	f	struct:Eigen::internal::transform_make_affine	access:public	signature:(MatrixType &mat)
run	src/Geometry/Transform.h	/^  template<typename MatrixType> static void run(MatrixType &) { }$/;"	f	struct:Eigen::internal::transform_make_affine	access:public	signature:(MatrixType &)
run	src/Geometry/arch/Geometry_SSE.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl	access:public	signature:(const VectorLhs& lhs, const VectorRhs& rhs)
run	src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)
run	src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)
run	src/LU/Determinant.h	/^  static inline typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl	access:public	signature:(const Derived& m)
run	src/LU/Determinant.h	/^  static typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl	access:public	signature:(const Derived& m)
run	src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check	access:public	signature:( const MatrixType& matrix, const typename MatrixType::RealScalar& absDeterminantThreshold, ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible )
run	src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check	access:public	signature:( const MatrixType& matrix, const typename MatrixType::RealScalar& absDeterminantThreshold, ResultType& result, typename ResultType::Scalar& determinant, bool& invertible )
run	src/LU/Inverse.h	/^  static inline void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse	access:public	signature:(const MatrixType& matrix, ResultType& result)
run	src/LU/Inverse.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4	access:public	signature:(const MatrixType& matrix, ResultType& result)
run	src/LU/arch/Inverse_SSE.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4	access:public	signature:(const MatrixType& matrix, ResultType& result)
run	src/PardisoSupport/PardisoSupport.h	/^    static Index run( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a,$/;"	f	struct:Eigen::internal::pardiso_run_selector	access:public	signature:( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a, Index *ia, Index *ja, Index *perm, Index nrhs, Index *iparm, Index msglvl, void *b, void *x)
run	src/QR/HouseholderQR.h	/^  static void run(MatrixQR& mat, HCoeffs& hCoeffs,$/;"	f	struct:Eigen::internal::householder_qr_inplace_blocked	access:public	signature:(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Index maxBlockSize=32, typename MatrixQR::Scalar* tempData = 0)
run	src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
run	src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
run	src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)
run	src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)
run	src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public	signature:(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)
run	src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType&, SVD&, Index, Index) {}$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public	signature:(typename SVD::WorkMatrixType&, SVD&, Index, Index)
run	src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res)
run	src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl	access:public	signature:(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha)
run	src/SparseCore/SparseSparseProductWithPruning.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res, const RealScalar& tolerance)$/;"	f	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res, const RealScalar& tolerance)
run	src/SparseCore/SparseVector.h	/^  static void run(Dest& dst, const Src& src) {$/;"	f	struct:Eigen::internal::sparse_vector_assign_selector	access:public	signature:(Dest& dst, const Src& src)
run	src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_selector	access:public	signature:(const Lhs& lhs, Rhs& other)
run	src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public	signature:(const Lhs& lhs, Rhs& other)
run	src/SparseLU/SparseLU_kernel_bmod.h	/^  static EIGEN_DONT_INLINE void run(const int \/*segsize*\/, BlockScalarVector& dense, ScalarVector& \/*tempv*\/, ScalarVector& lusup, Index& luptr,$/;"	p	struct:Eigen::internal::LU_kernel_bmod	access:public	signature:(const int , BlockScalarVector& dense, ScalarVector& , ScalarVector& lusup, Index& luptr, const Index lda, const Index nrow, IndexVector& lsub, const Index lptr, const Index no_zeros)
run	src/SparseLU/SparseLU_kernel_bmod.h	/^  static EIGEN_DONT_INLINE void run(const int segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda,$/;"	p	struct:Eigen::internal::LU_kernel_bmod	access:public	signature:(const int segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda, const Index nrow, IndexVector& lsub, const Index lptr, const Index no_zeros)
run	src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<1>::run(const int \/*segsize*\/, BlockScalarVector& dense, ScalarVector& \/*tempv*\/, ScalarVector& lusup, Index& luptr,$/;"	f	class:Eigen::internal::LU_kernel_bmod	signature:(const int , BlockScalarVector& dense, ScalarVector& , ScalarVector& lusup, Index& luptr, const Index lda, const Index nrow, IndexVector& lsub, const Index lptr, const Index no_zeros)
run	src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<SegSizeAtCompileTime>::run(const int segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda,$/;"	f	class:Eigen::internal::LU_kernel_bmod	signature:(const int segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda, const Index nrow, IndexVector& lsub, const Index lptr, const Index no_zeros)
run	src/SuperLUSupport/SuperLUSupport.h	/^  static void run(MatrixType& mat, SluMatrix& res)$/;"	f	struct:Eigen::SluMatrixMapHelper	access:public	signature:(MatrixType& mat, SluMatrix& res)
s	src/Jacobi/Jacobi.h	/^    Scalar s() const { return m_s; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
s	src/Jacobi/Jacobi.h	/^    Scalar& s() { return m_s; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
samax	src/misc/blas.h	/^float  BLASFUNC(samax) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
samin	src/misc/blas.h	/^float  BLASFUNC(samin) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
sample	src/Geometry/AlignedBox.h	/^  inline VectorType sample() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
sasum	src/misc/blas.h	/^float  BLASFUNC(sasum) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
saxpy	src/misc/blas.h	/^int    BLASFUNC(saxpy) (int *, float  *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *, float *, int *)
scalar_abs2_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs2_op {$/;"	s	namespace:Eigen::internal
scalar_abs_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs_op {$/;"	s	namespace:Eigen::internal
scalar_acos_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_acos_op {$/;"	s	namespace:Eigen::internal
scalar_add_op	src/Core/Functors.h	/^  inline scalar_add_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Scalar& other)
scalar_add_op	src/Core/Functors.h	/^  inline scalar_add_op(const scalar_add_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const scalar_add_op& other)
scalar_add_op	src/Core/Functors.h	/^struct scalar_add_op {$/;"	s	namespace:Eigen::internal
scalar_asin_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_asin_op {$/;"	s	namespace:Eigen::internal
scalar_binary_pow_op	src/Core/Functors.h	/^template<typename Scalar, typename OtherScalar> struct scalar_binary_pow_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_and_op	src/Core/Functors.h	/^struct scalar_boolean_and_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_or_op	src/Core/Functors.h	/^struct scalar_boolean_or_op {$/;"	s	namespace:Eigen::internal
scalar_cast_op	src/Core/Functors.h	/^struct scalar_cast_op {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_EQ> {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_LE> {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_LT> {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_NEQ> {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_UNORD> {$/;"	s	namespace:Eigen::internal
scalar_conj_product_op	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_conj_product_op {$/;"	s	namespace:Eigen::internal
scalar_conjugate_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_conjugate_op {$/;"	s	namespace:Eigen::internal
scalar_constant_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(const Scalar& other)
scalar_constant_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(const scalar_constant_op& other)
scalar_constant_op	src/Core/Functors.h	/^struct scalar_constant_op {$/;"	s	namespace:Eigen::internal
scalar_cos_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_cos_op {$/;"	s	namespace:Eigen::internal
scalar_cube_op	src/Core/Functors.h	/^struct scalar_cube_op {$/;"	s	namespace:Eigen::internal
scalar_difference_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_difference_op {$/;"	s	namespace:Eigen::internal
scalar_exp_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_exp_op {$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	src/Core/MathFunctions.h	/^struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:scalar_fuzzy_default_impl
scalar_fuzzy_impl	src/Core/MathFunctions.h	/^template<> struct scalar_fuzzy_impl<bool>$/;"	s	namespace:Eigen::internal
scalar_hypot_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_hypot_op {$/;"	s	namespace:Eigen::internal
scalar_identity_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_identity_op {$/;"	s	namespace:Eigen::internal
scalar_imag_op	src/Core/Functors.h	/^struct scalar_imag_op {$/;"	s	namespace:Eigen::internal
scalar_imag_ref_op	src/Core/Functors.h	/^struct scalar_imag_ref_op {$/;"	s	namespace:Eigen::internal
scalar_inverse_mult_op	src/Core/Functors.h	/^  scalar_inverse_mult_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Scalar& other)
scalar_inverse_mult_op	src/Core/Functors.h	/^struct scalar_inverse_mult_op {$/;"	s	namespace:Eigen::internal
scalar_inverse_op	src/Core/Functors.h	/^struct scalar_inverse_op {$/;"	s	namespace:Eigen::internal
scalar_log_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_log_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_max_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_max_op)$/;"	f	class:Eigen::Cwise	access:public	signature:(max) const
scalar_min_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_min_op {$/;"	s	namespace:Eigen::internal
scalar_min_op	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_min_op)$/;"	f	class:Eigen::Cwise	access:public	signature:(min) const
scalar_multiple2_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const Scalar2& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const Scalar2& other)
scalar_multiple2_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const scalar_multiple2_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const scalar_multiple2_op& other)
scalar_multiple2_op	src/Core/Functors.h	/^struct scalar_multiple2_op {$/;"	s	namespace:Eigen::internal
scalar_multiple_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Scalar& other)
scalar_multiple_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const scalar_multiple_op& other)
scalar_multiple_op	src/Core/Functors.h	/^struct scalar_multiple_op {$/;"	s	namespace:Eigen::internal
scalar_opposite_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_opposite_op {$/;"	s	namespace:Eigen::internal
scalar_pow_op	src/Core/Functors.h	/^  inline scalar_pow_op(const Scalar& exponent) : m_exponent(exponent) {}$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const Scalar& exponent)
scalar_pow_op	src/Core/Functors.h	/^  inline scalar_pow_op(const scalar_pow_op& other) : m_exponent(other.m_exponent) { }$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const scalar_pow_op& other)
scalar_pow_op	src/Core/Functors.h	/^struct scalar_pow_op {$/;"	s	namespace:Eigen::internal
scalar_product_op	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_product_op {$/;"	s	namespace:Eigen::internal
scalar_product_traits	src/Core/util/Meta.h	/^template<typename T, typename U> struct scalar_product_traits$/;"	s	namespace:Eigen
scalar_product_traits	src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,T>$/;"	s	namespace:Eigen
scalar_product_traits	src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,std::complex<T> >$/;"	s	namespace:Eigen
scalar_product_traits	src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<std::complex<T>, T>$/;"	s	namespace:Eigen
scalar_quotient1_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const Scalar& other)
scalar_quotient1_op	src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const scalar_quotient1_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const scalar_quotient1_op& other)
scalar_quotient1_op	src/Core/Functors.h	/^struct scalar_quotient1_op {$/;"	s	namespace:Eigen::internal
scalar_quotient_op	src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_quotient_op {$/;"	s	namespace:Eigen::internal
scalar_random_op	src/Core/Random.h	/^template<typename Scalar> struct scalar_random_op {$/;"	s	namespace:Eigen::internal
scalar_real_op	src/Core/Functors.h	/^struct scalar_real_op {$/;"	s	namespace:Eigen::internal
scalar_real_ref_op	src/Core/Functors.h	/^struct scalar_real_ref_op {$/;"	s	namespace:Eigen::internal
scalar_sin_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_sin_op {$/;"	s	namespace:Eigen::internal
scalar_sqrt_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_sqrt_op {$/;"	s	namespace:Eigen::internal
scalar_square_op	src/Core/Functors.h	/^struct scalar_square_op {$/;"	s	namespace:Eigen::internal
scalar_sum_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_sum_op {$/;"	s	namespace:Eigen::internal
scalar_tan_op	src/Core/Functors.h	/^template<typename Scalar> struct scalar_tan_op {$/;"	s	namespace:Eigen::internal
scale	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& scale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
scale	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& scale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
scale	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
scale	src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::scale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
scale	src/Geometry/Transform.h	/^  inline Transform& scale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
scale	src/Geometry/Transform.h	/^  inline Transform& scale(const Scalar& s);$/;"	p	class:Eigen::Transform	access:public	signature:(const Scalar& s)
scale	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
scale	src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::scale(const Scalar& s)$/;"	f	class:Eigen::Transform	signature:(const Scalar& s)
scaleAndAddTo	src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest, const Scalar& alpha) const
scaleAndAddTo	src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dst, const Scalar& alpha) const
scaleAndAddTo	src/Core/ProductBase.h	/^    inline void scaleAndAddTo(Dest& dst, const Scalar& a_alpha) const { m_prod.derived().scaleAndAddTo(dst,a_alpha * m_alpha); }$/;"	f	class:ScaledProduct	access:public	signature:(Dest& dst, const Scalar& a_alpha) const
scaleAndAddTo	src/Core/products/GeneralMatrixMatrix.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dst, const Scalar& alpha) const
scaleAndAddTo	src/Core/products/SelfadjointMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(Dest& dst, const Scalar& alpha) const
scaleAndAddTo	src/Core/products/SelfadjointMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(Dest& dest, const Scalar& alpha) const
scaleAndAddTo	src/Core/products/TriangularMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(Dest& dst, const Scalar& alpha) const
scaleAndAddTo	src/Core/products/TriangularMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(Dest& dst, const Scalar& alpha) const
scaleAndAddTo	src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::DenseTimeSparseProduct	access:public	signature:(Dest& dest, const Scalar& alpha) const
scaleAndAddTo	src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::SparseTimeDenseProduct	access:public	signature:(Dest& dest, const Scalar& alpha) const
scaleAndAddTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& \/*dest*\/, const Scalar& \/*alpha*\/) const$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:public	signature:(Dest& , const Scalar& ) const
scaleAndAddTo	src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:public	signature:(Dest& dest, const Scalar& alpha) const
scamax	src/misc/blas.h	/^float  BLASFUNC(scamax)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scamin	src/misc/blas.h	/^float  BLASFUNC(scamin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scasum	src/misc/blas.h	/^float  BLASFUNC(scasum)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scmax	src/misc/blas.h	/^float  BLASFUNC(scmax) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scmin	src/misc/blas.h	/^float  BLASFUNC(scmin) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scnrm2	src/misc/blas.h	/^float  BLASFUNC(scnrm2)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scomplex	src/Core/util/MKL_support.h	/^typedef std::complex<float>  scomplex;$/;"	t	namespace:Eigen
scopy	src/misc/blas.h	/^int    BLASFUNC(scopy) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
score	src/OrderingMethods/Eigen_Colamd.h	/^    Index score ; \/* the score used to maintain heap, if col is alive *\/$/;"	m	union:internal::colamd_col::__anon403	access:public
sdot	src/misc/blas.h	/^float  BLASFUNC(sdot)  (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
sdsdot	src/misc/blas.h	/^float  BLASFUNC(sdsdot)(int *, float  *,        float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *, float *, int *)
searchLowerIndex	src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index key) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key) const
searchLowerIndex	src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(size_t start, size_t end, Index key) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t start, size_t end, Index key) const
second	src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket second;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket	access:public
segment	src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType segment(Index start, Index n) const$/;"	f	signature:(Index start, Index n) const
segment	src/plugins/BlockMethods.h	/^inline SegmentReturnType segment(Index start, Index n)$/;"	f	signature:(Index start, Index n)
segment	src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type segment(Index start, Index n = N) const$/;"	f	signature:(Index start, Index n = N) const
segment	src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type segment(Index start, Index n = N)$/;"	f	signature:(Index start, Index n = N)
select	src/Core/DenseBase.h	/^    select(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar) const
select	src/Core/DenseBase.h	/^    select(const DenseBase<ThenDerived>& thenMatrix,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<ThenDerived>& thenMatrix, const DenseBase<ElseDerived>& elseMatrix) const
select	src/Core/DenseBase.h	/^    select(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix) const
select	src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<ThenDerived>& thenMatrix, const DenseBase<ElseDerived>& elseMatrix) const
select	src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar) const
select	src/Core/Select.h	/^DenseBase<Derived>::select(const typename ElseDerived::Scalar& thenScalar,$/;"	f	class:Eigen::DenseBase	signature:(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix) const
selector	src/Core/GeneralProduct.h	/^  typedef product_type_selector<rows_select, cols_select, depth_select> selector;$/;"	t	struct:Eigen::internal::product_type	access:private
selfadjointView	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> typename ConstSelfAdjointViewReturnType<UpLo>::Type selfadjointView() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
selfadjointView	src/Core/MatrixBase.h	/^    template<unsigned int UpLo> typename SelfAdjointViewReturnType<UpLo>::Type selfadjointView();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
selfadjointView	src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::MatrixBase	signature:() const
selfadjointView	src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::MatrixBase	signature:()
selfadjointView	src/Core/TriangularMatrix.h	/^    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
selfadjointView	src/Core/TriangularMatrix.h	/^    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
selfadjointView	src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> inline SparseSelfAdjointView<Derived, UpLo> selfadjointView();$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:()
selfadjointView	src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> inline const SparseSelfAdjointView<Derived, UpLo> selfadjointView() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
selfadjointView	src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::SparseMatrixBase	signature:()
selfadjointView	src/SparseCore/SparseSelfAdjointView.h	/^const SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
selfadjoint_matrix_vector_product	src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_matrix_vector_product$/;"	s	namespace:Eigen::internal
selfadjoint_matrix_vector_product_symv	src/Core/products/SelfadjointMatrixVector_MKL.h	/^struct selfadjoint_matrix_vector_product_symv :$/;"	s	namespace:Eigen::internal	inherits:selfadjoint_matrix_vector_product
selfadjoint_product_selector	src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,false>$/;"	s	namespace:Eigen
selfadjoint_product_selector	src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank2_update_selector	src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>$/;"	s	namespace:Eigen::internal
selfadjoint_rank2_update_selector	src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Upper>$/;"	s	namespace:Eigen::internal
set	src/Core/GeneralProduct.h	/^    struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	s	class:Eigen::GeneralProduct	access:public
setBounds	src/SparseCore/AmbiVector.h	/^    void setBounds(Index start, Index end) { m_start = start; m_end = end; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index start, Index end)
setConstant	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setConstant(const Scalar& val)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& val)
setConstant	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index nbRows, Index nbCols, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index nbRows, Index nbCols, const Scalar& val)
setConstant	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index size, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size, const Scalar& val)
setConstant	src/Core/DenseBase.h	/^    Derived& setConstant(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
setConstant	src/Core/PlainObjectBase.h	/^    Derived& setConstant(Index rows, Index cols, const Scalar& value);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols, const Scalar& value)
setConstant	src/Core/TriangularMatrix.h	/^    TriangularView& setConstant(const Scalar& value)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const Scalar& value)
setCpuCacheSizes	src/Core/products/GeneralBlockPanelKernel.h	/^inline void setCpuCacheSizes(std::ptrdiff_t l1, std::ptrdiff_t l2)$/;"	f	namespace:Eigen	signature:(std::ptrdiff_t l1, std::ptrdiff_t l2)
setDroptol	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void setDroptol(const RealScalar& droptol); $/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const RealScalar& droptol)
setDroptol	src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setDroptol(const RealScalar& droptol)$/;"	f	class:Eigen::IncompleteLUT	signature:(const RealScalar& droptol)
setEmpty	src/Geometry/AlignedBox.h	/^  inline void setEmpty()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
setFillfactor	src/IterativeLinearSolvers/IncompleteLUT.h	/^    void setFillfactor(int fillfactor); $/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(int fillfactor)
setFillfactor	src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setFillfactor(int fillfactor)$/;"	f	class:Eigen::IncompleteLUT	signature:(int fillfactor)
setFromTriplets	src/SparseCore/SparseMatrix.h	/^    void setFromTriplets(const InputIterators& begin, const InputIterators& end);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const InputIterators& begin, const InputIterators& end)
setFromTriplets	src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::setFromTriplets(const InputIterators& begin, const InputIterators& end)$/;"	f	class:Eigen::SparseMatrix	signature:(const InputIterators& begin, const InputIterators& end)
setFromTwoVectors	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
setFromTwoVectors	src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
setFromTwoVectors	src/Geometry/Quaternion.h	/^  Derived& setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
setFromTwoVectors	src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::QuaternionBase	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
setIdentity	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity()$/;"	f	class:Eigen::MatrixBase	signature:()
setIdentity	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity(Index nbRows, Index nbCols)$/;"	f	class:Eigen::MatrixBase	signature:(Index nbRows, Index nbCols)
setIdentity	src/Core/DiagonalMatrix.h	/^    inline void setIdentity() { m_diagonal.setOnes(); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
setIdentity	src/Core/DiagonalMatrix.h	/^    inline void setIdentity(Index size) { m_diagonal.setOnes(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
setIdentity	src/Core/MatrixBase.h	/^    Derived& setIdentity();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
setIdentity	src/Core/MatrixBase.h	/^    Derived& setIdentity(Index rows, Index cols);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index rows, Index cols)
setIdentity	src/Core/PermutationMatrix.h	/^    void setIdentity()$/;"	f	class:Eigen::PermutationBase	access:public	signature:()
setIdentity	src/Core/PermutationMatrix.h	/^    void setIdentity(Index newSize)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index newSize)
setIdentity	src/Core/Transpositions.h	/^    void setIdentity()$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
setIdentity	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& setIdentity() { m_coeffs << 0, 0, 0, 1; return *this; }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
setIdentity	src/Eigen2Support/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
setIdentity	src/Geometry/Quaternion.h	/^  inline QuaternionBase& setIdentity() { coeffs() << Scalar(0), Scalar(0), Scalar(0), Scalar(1); return *this; }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
setIdentity	src/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
setIdentity	src/SparseCore/SparseMatrix.h	/^    inline void setIdentity()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
setIdentity_impl	src/Core/CwiseNullaryOp.h	/^struct setIdentity_impl<Derived, true>$/;"	s	namespace:Eigen::internal
setInfos	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    void setInfos(Index m, Index n, ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:(Index m, Index n, ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, IndexVector& rowind_colptr, IndexVector& col_to_sup, IndexVector& sup_to_col )
setLength	src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setLength(Index length)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index length)
setLinSpaced	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(Index newSize, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Index newSize, const Scalar& low, const Scalar& high)
setLinSpaced	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& low, const Scalar& high)
setLinSpaced	src/Core/DenseBase.h	/^    Derived& setLinSpaced(Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& low, const Scalar& high)
setLinSpaced	src/Core/DenseBase.h	/^    Derived& setLinSpaced(const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& low, const Scalar& high)
setMaxIterations	src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(Index maxIters)
setMaxIterations	src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(Index maxIters)
setMaxIterations	src/Eigenvalues/EigenSolver.h	/^    EigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(Index maxIters)
setMaxIterations	src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::GeneralizedEigenSolver	access:public	signature:(Index maxIters)
setMaxIterations	src/Eigenvalues/RealQZ.h	/^      RealQZ& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealQZ	access:public	signature:(Index maxIters)
setMaxIterations	src/Eigenvalues/RealSchur.h	/^    RealSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealSchur	access:public	signature:(Index maxIters)
setMaxIterations	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setMaxIterations(int maxIters)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(int maxIters)
setMode	src/CholmodSupport/CholmodSupport.h	/^    void setMode(CholmodMode mode)$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:(CholmodMode mode)
setMode	src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& setMode(SimplicialCholeskyMode mode)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(SimplicialCholeskyMode mode)
setNbThreads	src/Core/products/Parallelizer.h	/^inline void setNbThreads(int v)$/;"	f	namespace:Eigen	signature:(int v)
setNull	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline void setNull()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
setNull	src/Geometry/AlignedBox.h	/^  inline void setNull() { setEmpty(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
setOnes	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setOnes()$/;"	f	class:Eigen::DenseBase	signature:()
setOnes	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index nbRows, Index nbCols)
setOnes	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index newSize)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index newSize)
setOnes	src/Core/DenseBase.h	/^    Derived& setOnes();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
setOnes	src/Core/PlainObjectBase.h	/^    Derived& setOnes(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
setOnes	src/Core/TriangularMatrix.h	/^    TriangularView& setOnes() { return setConstant(Scalar(1)); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
setPivotThreshold	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setPivotThreshold(const RealScalar& tol)$/;"	f	class:Eigen::SPQR	access:public	signature:(const RealScalar& tol)
setPivotThreshold	src/SparseLU/SparseLU.h	/^    void setPivotThreshold(const RealScalar& thresh)$/;"	f	class:Eigen::SparseLU	access:public	signature:(const RealScalar& thresh)
setPivotThreshold	src/SparseQR/SparseQR.h	/^    void setPivotThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::SparseQR	access:public	signature:(const RealScalar& threshold)
setRandom	src/Core/DenseBase.h	/^    Derived& setRandom();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
setRandom	src/Core/PlainObjectBase.h	/^    Derived& setRandom(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
setRandom	src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index nbRows, Index nbCols)
setRandom	src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index newSize)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index newSize)
setRandom	src/Core/Random.h	/^inline Derived& DenseBase<Derived>::setRandom()$/;"	f	class:Eigen::DenseBase	signature:()
setSPQROrdering	src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setSPQROrdering(int ord) { m_ordering = ord;}$/;"	f	class:Eigen::SPQR	access:public	signature:(int ord)
setScalarType	src/SuperLUSupport/SuperLUSupport.h	/^  void setScalarType()$/;"	f	struct:Eigen::SluMatrix	access:public	signature:()
setShift	src/CholmodSupport/CholmodSupport.h	/^    Derived& setShift(const RealScalar& offset)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const RealScalar& offset)
setShift	src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setShift(Index shift)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index shift)
setShift	src/SparseCholesky/SimplicialCholesky.h	/^    Derived& setShift(const RealScalar& offset, const RealScalar& scale = 1)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const RealScalar& offset, const RealScalar& scale = 1)
setStorageType	src/SuperLUSupport/SuperLUSupport.h	/^  void setStorageType(Stype_t t)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(Stype_t t)
setThreshold	src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivLU	access:public	signature:(Default_t)
setThreshold	src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const RealScalar& threshold)
setThreshold	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(Default_t)
setThreshold	src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const RealScalar& threshold)
setThreshold	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(Default_t)
setThreshold	src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const RealScalar& threshold)
setThreshold	src/SVD/JacobiSVD.h	/^    JacobiSVD& setThreshold(Default_t)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(Default_t)
setThreshold	src/SVD/JacobiSVD.h	/^    JacobiSVD& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const RealScalar& threshold)
setTolerance	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setTolerance(const RealScalar& tolerance)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const RealScalar& tolerance)
setTrans	src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setTrans(bool trans)$/;"	f	class:Eigen::HouseholderSequence	access:protected	signature:(bool trans)
setZero	src/Cholesky/LDLT.h	/^    void setZero()$/;"	f	class:Eigen::LDLT	access:public	signature:()
setZero	src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setZero()$/;"	f	class:Eigen::DenseBase	signature:()
setZero	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index nbRows, Index nbCols)
setZero	src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index newSize)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index newSize)
setZero	src/Core/DenseBase.h	/^    Derived& setZero();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
setZero	src/Core/DiagonalMatrix.h	/^    inline void setZero() { m_diagonal.setZero(); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
setZero	src/Core/DiagonalMatrix.h	/^    inline void setZero(Index size) { m_diagonal.setZero(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
setZero	src/Core/PlainObjectBase.h	/^    Derived& setZero(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
setZero	src/Core/TriangularMatrix.h	/^    TriangularView& setZero() { return setConstant(Scalar(0)); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
setZero	src/SparseCore/AmbiVector.h	/^    void setZero();$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:()
setZero	src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::setZero()$/;"	f	class:Eigen::internal::AmbiVector	signature:()
setZero	src/SparseCore/SparseMatrix.h	/^    inline void setZero()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
setZero	src/SparseCore/SparseVector.h	/^    inline void setZero() { m_data.clear(); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
set_from_triplets	src/SparseCore/SparseMatrix.h	/^void set_from_triplets(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)$/;"	f	namespace:Eigen::internal	signature:(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)
set_is_malloc_allowed	src/Core/util/Memory.h	/^inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }$/;"	f	namespace:Eigen::internal	signature:(bool new_value)
sgbmv	src/misc/blas.h	/^int BLASFUNC(sgbmv)(char *, int *, int *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sge2mm	src/misc/blas.h	/^int BLASFUNC(sge2mm)(char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sgema	src/misc/blas.h	/^int BLASFUNC(sgema)(char *, char *, int *, int *, float  *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *, float *, int *)
sgemm	src/misc/blas.h	/^int BLASFUNC(sgemm)(char *, char *, int *, int *, int *, float *,$/;"	p	signature:(char *, char *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sgems	src/misc/blas.h	/^int BLASFUNC(sgems)(char *, char *, int *, int *, float  *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *, float *, int *)
sgemt	src/misc/blas.h	/^int BLASFUNC(sgemt)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *)
sgemv	src/misc/blas.h	/^int BLASFUNC(sgemv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sger	src/misc/blas.h	/^int BLASFUNC(sger)(int *,    int *, float *,  float *, int *,$/;"	p	signature:(int *, int *, float *, float *, int *, float *, int *, float *, int *)
sgesv	src/misc/blas.h	/^int BLASFUNC(sgesv)(int *, int *, float  *, int *, int *, float *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, float *, int *, int *)
sgetf2	src/misc/blas.h	/^int BLASFUNC(sgetf2)(int *, int *, float  *, int *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, int *)
sgetrf	src/misc/blas.h	/^int BLASFUNC(sgetrf)(int *, int *, float  *, int *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, int *)
sgetrs	src/misc/blas.h	/^int BLASFUNC(sgetrs)(char *, int *, int *, float  *, int *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, int *, float *, int *, int *, float *, int *, int *)
shared1	src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon406	access:public
shared1	src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon402	access:public
shared2	src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon407	access:public
shared2	src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon403	access:public
shared3	src/OrderingMethods/Eigen_Colamd.h	/^  } shared3 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon404	access:public
shared4	src/OrderingMethods/Eigen_Colamd.h	/^  } shared4 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon405	access:public
shear	src/Eigen2Support/Geometry/Transform.h	/^  Transform& shear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
shear	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::shear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
shear	src/Geometry/Transform.h	/^  Transform& shear(const Scalar& sx, const Scalar& sy);$/;"	p	class:Eigen::Transform	access:public	signature:(const Scalar& sx, const Scalar& sy)
shear	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::shear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform	signature:(const Scalar& sx, const Scalar& sy)
shift	src/Householder/HouseholderSequence.h	/^    Index shift() const { return m_shift; }    \/**< \\brief Returns the shift of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
signDeterminant	src/SparseLU/SparseLU.h	/^    Scalar signDeterminant()$/;"	f	class:Eigen::SparseLU	access:public	signature:()
signedDistance	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return p.eigen2_dot(normal()) + offset(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
signedDistance	src/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return normal().dot(p) + offset(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
significant_decimals_default_impl	src/Core/IO.h	/^struct significant_decimals_default_impl$/;"	s	namespace:Eigen::internal
significant_decimals_default_impl	src/Core/IO.h	/^struct significant_decimals_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
significant_decimals_impl	src/Core/IO.h	/^struct significant_decimals_impl$/;"	s	namespace:Eigen::internal	inherits:significant_decimals_default_impl
simplicialfactorize	src/SparseLU/SparseLU.h	/^    void simplicialfactorize(const MatrixType& matrix);$/;"	p	class:Eigen::SparseLU	access:public	signature:(const MatrixType& matrix)
sin	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> sin() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
sin	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_sin_op)      sin() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
sin	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sin() const$/;"	f	class:Eigen::Cwise	signature:() const
sin	src/plugins/ArrayCwiseUnaryOps.h	/^sin() const$/;"	f	signature:() const
singularValues	src/Eigen2Support/SVD.h	/^    const SingularValuesType& singularValues() const { return m_sigma; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
singularValues	src/SVD/JacobiSVD.h	/^    const SingularValuesType& singularValues() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
sinh	src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> sinh() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
size	src/Core/EigenBase.h	/^  inline Index size() const { return rows() * cols(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
size	src/Core/GenericPacketMath.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon270
size	src/Core/PermutationMatrix.h	/^    inline Index size() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
size	src/Core/Transpositions.h	/^    inline Index size() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
size	src/Core/Transpositions.h	/^    inline int size() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
size	src/Core/arch/AltiVec/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon5
size	src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon6
size	src/Core/arch/AltiVec/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon8
size	src/Core/arch/AltiVec/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon7
size	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon9
size	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon10
size	src/Core/arch/NEON/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
size	src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon12
size	src/Core/arch/NEON/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon13
size	src/Core/arch/NEON/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon14
size	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon15
size	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon16
size	src/Core/arch/SSE/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon19
size	src/Core/arch/SSE/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
size	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon20
size	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon18
size	src/Core/arch/SSE/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon25
size	src/Core/arch/SSE/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon26
size	src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon24
size	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon28
size	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon27
size	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon29
size	src/SparseCore/AmbiVector.h	/^    Index size() const { return m_size; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:() const
size	src/SparseCore/CompressedStorage.h	/^    inline size_t size() const { return m_size; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:() const
size	src/SparseCore/SparseMatrixBase.h	/^    inline Index size() const { return rows() * cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
size_type	src/Core/util/Memory.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator	access:public
size_type	src/StlSupport/details.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
sizes	src/Geometry/AlignedBox.h	/^  inline const CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> sizes() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
slaswp	src/misc/blas.h	/^int BLASFUNC(slaswp)(int *, float  *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, float *, int *, int *, int *, int *, int *)
slauu2	src/misc/blas.h	/^int BLASFUNC(slauu2)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
slauum	src/misc/blas.h	/^int BLASFUNC(slauum)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
slerp	src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion slerp(Scalar t, const Quaternion& other) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(Scalar t, const Quaternion& other) const
slerp	src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar> Quaternion<Scalar>::slerp(Scalar t, const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(Scalar t, const Quaternion& other) const
slerp	src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(Scalar t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar t, const Rotation2D& other) const
slerp	src/Geometry/Quaternion.h	/^  template<class OtherDerived> Quaternion<Scalar> slerp(const Scalar& t, const QuaternionBase<OtherDerived>& other) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const Scalar& t, const QuaternionBase<OtherDerived>& other) const
slerp	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::slerp(const Scalar& t, const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const Scalar& t, const QuaternionBase<OtherDerived>& other) const
slerp	src/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(const Scalar& t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Scalar& t, const Rotation2D& other) const
smart_copy	src/Core/util/Memory.h	/^template<typename T> void smart_copy(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal	signature:(const T* start, const T* end, T* target)
smart_copy_helper	src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,false> {$/;"	s	namespace:Eigen::internal
smart_copy_helper	src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,true> {$/;"	s	namespace:Eigen::internal
smax	src/misc/blas.h	/^float  BLASFUNC(smax)  (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
smin	src/misc/blas.h	/^float  BLASFUNC(smin)  (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
snode_bmod	src/SparseLU/SparseLUImpl.h	/^     Index snode_bmod (const Index jcol, const Index fsupc, ScalarVector& dense, GlobalLU_t& glu);$/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const Index fsupc, ScalarVector& dense, GlobalLU_t& glu)
snode_dfs	src/SparseLU/SparseLUImpl.h	/^     Index snode_dfs(const Index jcol, const Index kcol,const MatrixType& mat,  IndexVector& xprune, IndexVector& marker, GlobalLU_t& glu); $/;"	p	class:Eigen::internal::SparseLUImpl	access:protected	signature:(const Index jcol, const Index kcol,const MatrixType& mat, IndexVector& xprune, IndexVector& marker, GlobalLU_t& glu)
snorm	src/misc/blas.h	/^int BLASFUNC(snorm)(char *, int *, int *, float  *, int *);$/;"	p	signature:(char *, int *, int *, float *, int *)
snrm2	src/misc/blas.h	/^float  BLASFUNC(snrm2) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
solve	src/Cholesky/LDLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
solve	src/Cholesky/LDLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/Cholesky/LLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
solve	src/Cholesky/LLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/CholmodSupport/CholmodSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/CholmodSupport/CholmodSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
solve	src/Core/SolveTriangular.h	/^TriangularView<Derived,Mode>::solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<Other>& other) const
solve	src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<Other>& other) const
solve	src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const;$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<Other>& other) const
solve	src/Eigen2Support/LU.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
solve	src/Eigen2Support/QR.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::QR	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
solve	src/Eigen2Support/SVD.h	/^    bool solve(const MatrixBase<OtherDerived> &b, ResultType* result) const;$/;"	p	class:Eigen::SVD	access:public	signature:(const MatrixBase<OtherDerived> &b, ResultType* result) const
solve	src/Eigen2Support/SVD.h	/^bool SVD<MatrixType>::solve(const MatrixBase<OtherDerived> &b, ResultType* result) const$/;"	f	class:Eigen::SVD	signature:(const MatrixBase<OtherDerived> &b, ResultType* result) const
solve	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    inline const Rhs& solve(const Rhs& b) const { return b; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const Rhs& b) const
solve	src/IterativeLinearSolvers/BasicPreconditioners.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/IterativeLinearSolvers/IncompleteLUT.h	/^     solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
solve	src/LU/FullPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/LU/PartialPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/PaStiXSupport/PaStiXSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/PaStiXSupport/PaStiXSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
solve	src/PardisoSupport/PardisoSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/PardisoSupport/PardisoSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
solve	src/QR/ColPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/QR/FullPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/QR/HouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline const internal::solve_retval<SPQR, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SPQR	access:public	signature:(const MatrixBase<Rhs>& B) const
solve	src/SVD/JacobiSVD.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/SparseCholesky/SimplicialCholesky.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/SparseCholesky/SimplicialCholesky.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
solve	src/SparseCore/SparseTriangularView.h	/^    solve(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solve	src/SparseCore/TriangularSolver.h	/^SparseTriangularView<ExpressionType,Mode>::solve(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(const MatrixBase<OtherDerived>& other) const
solve	src/SparseLU/SparseLU.h	/^    inline const internal::solve_retval<SparseLU, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseLU	access:public	signature:(const MatrixBase<Rhs>& B) const
solve	src/SparseLU/SparseLU.h	/^    inline const internal::sparse_solve_retval<SparseLU, Rhs> solve(const SparseMatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseLU	access:public	signature:(const SparseMatrixBase<Rhs>& B) const
solve	src/SparseQR/SparseQR.h	/^    inline const internal::solve_retval<SparseQR, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseQR	access:public	signature:(const MatrixBase<Rhs>& B) const
solve	src/SparseQR/SparseQR.h	/^    inline const internal::sparse_solve_retval<SparseQR, Rhs> solve(const SparseMatrixBase<Rhs>& B) const$/;"	f	class:Eigen::SparseQR	access:public	signature:(const SparseMatrixBase<Rhs>& B) const
solve	src/SuperLUSupport/SuperLUSupport.h	/^    inline const internal::solve_retval<SuperLUBase, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/SuperLUSupport/SuperLUSupport.h	/^    inline const internal::sparse_solve_retval<SuperLUBase, Rhs> solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
solve	src/UmfPackSupport/UmfPackSupport.h	/^    inline const internal::solve_retval<UmfPackLU, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	src/UmfPackSupport/UmfPackSupport.h	/^    inline const internal::sparse_solve_retval<UmfPackLU, Rhs> solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
solveInPlace	src/Cholesky/LDLT.h	/^    bool solveInPlace(MatrixBase<Derived> &bAndX) const;$/;"	p	class:Eigen::LDLT	access:public	signature:(MatrixBase<Derived> &bAndX) const
solveInPlace	src/Cholesky/LDLT.h	/^bool LDLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LDLT	signature:(MatrixBase<Derived> &bAndX) const
solveInPlace	src/Cholesky/LLT.h	/^    void solveInPlace(MatrixBase<Derived> &bAndX) const;$/;"	p	class:Eigen::LLT	access:public	signature:(MatrixBase<Derived> &bAndX) const
solveInPlace	src/Cholesky/LLT.h	/^void LLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LLT	signature:(MatrixBase<Derived> &bAndX) const
solveInPlace	src/Core/SolveTriangular.h	/^void TriangularView<MatrixType,Mode>::solveInPlace(const MatrixBase<OtherDerived>& _other) const$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& _other) const
solveInPlace	src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveInPlace	src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveInPlace	src/SparseCore/SparseTriangularView.h	/^    template<typename OtherDerived> void solveInPlace(MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(MatrixBase<OtherDerived>& other) const
solveInPlace	src/SparseCore/SparseTriangularView.h	/^    template<typename OtherDerived> void solveInPlace(SparseMatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(SparseMatrixBase<OtherDerived>& other) const
solveInPlace	src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(MatrixBase<OtherDerived>& other) const
solveInPlace	src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(SparseMatrixBase<OtherDerived>& other) const
solveInPlace	src/SparseLU/SparseLU.h	/^  template<typename Dest>   void solveInPlace(MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixUReturnType	access:public	signature:(MatrixBase<Dest> &X) const
solveInPlace	src/SparseLU/SparseLU.h	/^  void solveInPlace( MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixLReturnType	access:public	signature:( MatrixBase<Dest> &X) const
solveInPlace	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    void solveInPlace( MatrixBase<Dest>&X) const;$/;"	p	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:( MatrixBase<Dest>&X) const
solveInPlace	src/SparseLU/SparseLU_SupernodalMatrix.h	/^void MappedSuperNodalMatrix<Scalar,Index>::solveInPlace( MatrixBase<Dest>&X) const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	signature:( MatrixBase<Dest>&X) const
solveTriangular	src/Core/Flagged.h	/^    typename ExpressionType::PlainObject solveTriangular(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Flagged	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangular	src/Eigen2Support/TriangularSolver.h	/^Flagged<ExpressionType,Added,Removed>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangular	src/SparseCore/SparseMatrixBase.h	/^    solveTriangular(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangular	src/SparseCore/TriangularSolver.h	/^SparseMatrixBase<Derived>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangularInPlace	src/Core/Flagged.h	/^    void solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Flagged	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangularInPlace	src/Eigen2Support/TriangularSolver.h	/^void Flagged<ExpressionType,Added,Removed>::solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangularInPlace	src/SparseCore/SparseMatrixBase.h	/^    void solveTriangularInPlace(MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(MatrixBase<OtherDerived>& other) const
solveTriangularInPlace	src/SparseCore/TriangularSolver.h	/^void SparseMatrixBase<Derived>::solveTriangularInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(MatrixBase<OtherDerived>& other) const
solveWithGuess	src/IterativeLinearSolvers/BiCGSTAB.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const MatrixBase<Rhs>& b, const Guess& x0) const
solveWithGuess	src/IterativeLinearSolvers/ConjugateGradient.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const MatrixBase<Rhs>& b, const Guess& x0) const
solve_retval	src/Cholesky/LDLT.h	/^struct solve_retval<LDLT<_MatrixType,_UpLo>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/Cholesky/LLT.h	/^struct solve_retval<LLT<_MatrixType, UpLo>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/CholmodSupport/CholmodSupport.h	/^struct solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/IterativeLinearSolvers/BasicPreconditioners.h	/^struct solve_retval<DiagonalPreconditioner<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/IterativeLinearSolvers/BiCGSTAB.h	/^struct solve_retval<BiCGSTAB<_MatrixType, _Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/IterativeLinearSolvers/ConjugateGradient.h	/^struct solve_retval<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/IterativeLinearSolvers/IncompleteLUT.h	/^struct solve_retval<IncompleteLUT<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/LU/FullPivLU.h	/^struct solve_retval<FullPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/LU/PartialPivLU.h	/^struct solve_retval<PartialPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/PaStiXSupport/PaStiXSupport.h	/^struct solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/PardisoSupport/PardisoSupport.h	/^struct solve_retval<PardisoImpl<_Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/QR/ColPivHouseholderQR.h	/^struct solve_retval<ColPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/QR/FullPivHouseholderQR.h	/^struct solve_retval<FullPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/QR/HouseholderQR.h	/^struct solve_retval<HouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/SPQRSupport/SuiteSparseQRSupport.h	/^struct solve_retval<SPQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/SVD/JacobiSVD.h	/^struct solve_retval<JacobiSVD<_MatrixType, QRPreconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/SparseCholesky/SimplicialCholesky.h	/^struct solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/SparseLU/SparseLU.h	/^struct solve_retval<SparseLU<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/SparseQR/SparseQR.h	/^struct solve_retval<SparseQR<_MatrixType,OrderingType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/SuperLUSupport/SuperLUSupport.h	/^struct solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	src/UmfPackSupport/UmfPackSupport.h	/^struct solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval_base	src/misc/Solve.h	/^  solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:(const DecompositionType& dec, const Rhs& rhs)
solve_retval_base	src/misc/Solve.h	/^template<typename _DecompositionType, typename Rhs> struct solve_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
solve_retval_with_guess	src/misc/SparseSolve.h	/^  solve_retval_with_guess(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)
solve_retval_with_guess	src/misc/SparseSolve.h	/^template<typename DecompositionType, typename Rhs, typename Guess> struct solve_retval_with_guess$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
sort	src/Eigen2Support/SVD.h	/^    SVD& sort();$/;"	p	class:Eigen::SVD	access:public	signature:()
sort	src/Eigen2Support/SVD.h	/^SVD<MatrixType>& SVD<MatrixType>::sort()$/;"	f	class:Eigen::SVD	signature:()
sortEigenvalues	src/Eigenvalues/ComplexEigenSolver.h	/^    void sortEigenvalues(bool computeEigenvectors);$/;"	p	class:Eigen::ComplexEigenSolver	access:private	signature:(bool computeEigenvectors)
sortEigenvalues	src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::sortEigenvalues(bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(bool computeEigenvectors)
sort_matrix_Q	src/SparseQR/SparseQR.h	/^    inline void sort_matrix_Q()$/;"	f	class:Eigen::SparseQR	access:protected	signature:()
sparseView	src/Core/MatrixBase.h	/^    const SparseView<Derived> sparseView(const Scalar& m_reference = Scalar(0),$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Scalar& m_reference = Scalar(0), const typename NumTraits<Scalar>::Real& m_epsilon = NumTraits<Scalar>::dummy_precision()) const
sparseView	src/SparseCore/SparseView.h	/^const SparseView<Derived> MatrixBase<Derived>::sparseView(const Scalar& m_reference,$/;"	f	class:Eigen::MatrixBase	signature:(const Scalar& m_reference, const typename NumTraits<Scalar>::Real& m_epsilon) const
sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE sparse_cwise_binary_op_inner_iterator_selector(const CwiseBinaryXpr& xpr, Index outer)$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:(const CwiseBinaryXpr& xpr, Index outer)
sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<BinaryOp, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Dense, Sparse>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Dense>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
sparse_diagonal_product_inner_iterator_selector	src/SparseCore/SparseDiagonalProduct.h	/^    inline sparse_diagonal_product_inner_iterator_selector($/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:( const SparseDiagonalProductType& expr, Index outer)
sparse_diagonal_product_inner_iterator_selector	src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal	inherits:CwiseBinaryOp::InnerIterator
sparse_diagonal_product_inner_iterator_selector	src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal	inherits:CwiseUnaryOp::InnerIterator
sparse_eval	src/SparseCore/SparseUtil.h	/^template<typename T,int Cols> struct sparse_eval<T,1,Cols> {$/;"	s	namespace:Eigen::internal
sparse_eval	src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Cols> struct sparse_eval {$/;"	s	namespace:Eigen::internal
sparse_eval	src/SparseCore/SparseUtil.h	/^template<typename T,int Rows> struct sparse_eval<T,Rows,1> {$/;"	s	namespace:Eigen::internal
sparse_eval	src/SparseCore/SparseUtil.h	/^template<typename T> struct sparse_eval<T,1,1> {$/;"	s	namespace:Eigen::internal
sparse_solve_retval	src/CholmodSupport/CholmodSupport.h	/^struct sparse_solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct sparse_solve_retval<IterativeSolverBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	src/PaStiXSupport/PaStiXSupport.h	/^struct sparse_solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	src/PardisoSupport/PardisoSupport.h	/^struct sparse_solve_retval<PardisoImpl<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	src/SparseCholesky/SimplicialCholesky.h	/^struct sparse_solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	src/SparseLU/SparseLU.h	/^struct sparse_solve_retval<SparseLU<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	src/SparseQR/SparseQR.h	/^struct sparse_solve_retval<SparseQR<_MatrixType, OrderingType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	src/SuperLUSupport/SuperLUSupport.h	/^struct sparse_solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	src/UmfPackSupport/UmfPackSupport.h	/^struct sparse_solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval_base	src/misc/SparseSolve.h	/^  sparse_solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:(const DecompositionType& dec, const Rhs& rhs)
sparse_solve_retval_base	src/misc/SparseSolve.h	/^template<typename _DecompositionType, typename Rhs> struct sparse_solve_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
sparse_solve_triangular_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_sparse_selector	src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_sparse_selector<Lhs,Rhs,Mode,UpLo,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_impl	src/SparseCore/SparseSparseProductWithPruning.h	/^static void sparse_sparse_product_with_pruning_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, const typename ResultType::RealScalar& tolerance)$/;"	f	namespace:Eigen::internal	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res, const typename ResultType::RealScalar& tolerance)
sparse_sparse_product_with_pruning_selector	src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product	src/SparseCore/SparseDenseProduct.h	/^inline void sparse_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal	signature:(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)
sparse_time_dense_product_impl	src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, true>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, true>$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Inner> {$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Outer> {$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_RuntimeSwitch> {$/;"	s	namespace:Eigen::internal
sparselu_gemm	src/SparseLU/SparseLU_gemm_kernel.h	/^void sparselu_gemm(Index m, Index n, Index d, const Scalar* A, Index lda, const Scalar* B, Index ldb, Scalar* C, Index ldc)$/;"	f	namespace:Eigen::internal	signature:(Index m, Index n, Index d, const Scalar* A, Index lda, const Scalar* B, Index ldb, Scalar* C, Index ldc)
splitOffTwoRows	src/Eigenvalues/RealQZ.h	/^      void splitOffTwoRows(Index i);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index i)
splitOffTwoRows	src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::splitOffTwoRows(Index i)$/;"	f	class:Eigen::RealQZ	signature:(Index i)
splitOffTwoRows	src/Eigenvalues/RealSchur.h	/^    void splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, bool computeU, const Scalar& exshift)
splitOffTwoRows	src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, bool computeU, const Scalar& exshift)
spotf2	src/misc/blas.h	/^int BLASFUNC(spotf2)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
spotrf	src/misc/blas.h	/^int BLASFUNC(spotrf)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
spotri	src/misc/blas.h	/^int BLASFUNC(spotri)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
sqrt	src/Core/MatrixBase.h	/^    const MatrixSquareRootReturnValue<Derived> sqrt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
sqrt	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_sqrt_op)     sqrt() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
sqrt	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sqrt() const$/;"	f	class:Eigen::Cwise	signature:() const
sqrt	src/plugins/ArrayCwiseUnaryOps.h	/^sqrt() const$/;"	f	signature:() const
square	src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_square_op)   square() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
square	src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::square() const$/;"	f	class:Eigen::Cwise	signature:() const
square	src/plugins/ArrayCwiseUnaryOps.h	/^square() const$/;"	f	signature:() const
squaredDistance	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
squaredDistance	src/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
squaredExteriorDistance	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const VectorType& p) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
squaredExteriorDistance	src/Eigen2Support/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbiantDim>::squaredExteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	signature:(const VectorType& p) const
squaredExteriorDistance	src/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const AlignedBox& b) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
squaredExteriorDistance	src/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const MatrixBase<Derived>& p) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p) const
squaredExteriorDistance	src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	signature:(const AlignedBox& b) const
squaredExteriorDistance	src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox	signature:(const MatrixBase<Derived>& a_p) const
squaredNorm	src/Core/Dot.h	/^EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
squaredNorm	src/Core/MatrixBase.h	/^    RealScalar squaredNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
squaredNorm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_squaredNorm,RealScalar>::Type squaredNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
squaredNorm	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return m_coeffs.squaredNorm(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
squaredNorm	src/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return coeffs().squaredNorm(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
squaredNorm	src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
squaredNorm	src/SparseCore/SparseMatrixBase.h	/^    RealScalar squaredNorm() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
squeeze	src/SparseCore/CompressedStorage.h	/^    void squeeze()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
srot	src/misc/blas.h	/^int    BLASFUNC(srot)  (int *, float  *, int *, float  *, int *, float  *, float  *);$/;"	p	signature:(int *, float *, int *, float *, int *, float *, float *)
srotg	src/misc/blas.h	/^int    BLASFUNC(srotg) (float  *, float  *, float  *, float  *);$/;"	p	signature:(float *, float *, float *, float *)
srotm	src/misc/blas.h	/^int    BLASFUNC(srotm) (int *, float  *, int *, float  *, int *, float  *);$/;"	p	signature:(int *, float *, int *, float *, int *, float *)
srotmg	src/misc/blas.h	/^int    BLASFUNC(srotmg)(float  *, float  *, float  *, float  *, float  *);$/;"	p	signature:(float *, float *, float *, float *, float *)
ssbmv	src/misc/blas.h	/^int BLASFUNC(ssbmv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sscal	src/misc/blas.h	/^int    BLASFUNC(sscal) (int *,  float  *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *)
sspmv	src/misc/blas.h	/^int BLASFUNC(sspmv) (char *, int *, float  *, float *,$/;"	p	signature:(char *, int *, float *, float *, float *, int *, float *, float *, int *)
sspr	src/misc/blas.h	/^int BLASFUNC(sspr) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *)
sspr2	src/misc/blas.h	/^int BLASFUNC(sspr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *)
sswap	src/misc/blas.h	/^int    BLASFUNC(sswap) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
ssymm	src/misc/blas.h	/^int BLASFUNC(ssymm)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
ssymv	src/misc/blas.h	/^int BLASFUNC(ssymv) (char *, int *, float  *, float *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
ssyr	src/misc/blas.h	/^int BLASFUNC(ssyr) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *)
ssyr2	src/misc/blas.h	/^int BLASFUNC(ssyr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, int *)
ssyr2k	src/misc/blas.h	/^int BLASFUNC(ssyr2k)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
ssyrk	src/misc/blas.h	/^int BLASFUNC(ssyrk)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *)
stableNorm	src/Core/MatrixBase.h	/^    RealScalar stableNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
stableNorm	src/Core/StableNorm.h	/^MatrixBase<Derived>::stableNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
stableNorm	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_stableNorm,RealScalar>::Type stableNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
stable_norm_kernel	src/Core/StableNorm.h	/^inline void stable_norm_kernel(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)$/;"	f	namespace:Eigen::internal	signature:(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)
start	src/Core/MatrixBase.h	/^    VectorBlock<Derived> start(Index size);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size)
start	src/Core/MatrixBase.h	/^    const VectorBlock<const Derived> start(Index size) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size) const
start	src/Core/MatrixBase.h	/^    template<int Size> VectorBlock<Derived,Size> start();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
start	src/Core/MatrixBase.h	/^    template<int Size> const VectorBlock<const Derived,Size> start() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
start	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start() const$/;"	f	class:Eigen::MatrixBase	signature:() const
start	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start()$/;"	f	class:Eigen::MatrixBase	signature:()
start	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size) const$/;"	f	class:Eigen::MatrixBase	signature:(Index size) const
start	src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size)$/;"	f	class:Eigen::MatrixBase	signature:(Index size)
start	src/OrderingMethods/Eigen_Colamd.h	/^  Index start ;   \/* index for A of first col in this row *\/$/;"	m	struct:internal::Colamd_Row	access:public
start	src/OrderingMethods/Eigen_Colamd.h	/^  Index start ;   \/* index for A of first row in this column, or DEAD *\/$/;"	m	struct:internal::colamd_col	access:public
startCol	src/Core/Block.h	/^    Index startCol() const $/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
startFill	src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void startFill(Index reserve)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index reserve)
startRow	src/Core/Block.h	/^    Index startRow() const $/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:() const
startVec	src/SparseCore/SparseMatrix.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer)
startVec	src/SparseCore/SparseVector.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index outer)
static_assertion	src/Core/util/StaticAssert.h	/^    struct static_assertion {};$/;"	s	namespace:Eigen::internal
static_assertion	src/Core/util/StaticAssert.h	/^    struct static_assertion<true>$/;"	s	namespace:Eigen::internal
stbmv	src/misc/blas.h	/^int BLASFUNC(stbmv) (char *, char *, char *, int *, int *, float  *, int *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, float *, int *, float *, int *)
stbsv	src/misc/blas.h	/^int BLASFUNC(stbsv) (char *, char *, char *, int *, int *, float  *, int *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, float *, int *, float *, int *)
std	src/StlSupport/StdDeque.h	/^namespace std {$/;"	n
std	src/StlSupport/StdList.h	/^namespace std$/;"	n
std	src/StlSupport/StdVector.h	/^namespace std {$/;"	n
std::deque	src/StlSupport/StdDeque.h	/^  class deque<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:deque
std::deque::deque_base	src/StlSupport/StdDeque.h	/^                Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > deque_base;$/;"	t	class:std::deque	access:private
std::deque::insert	src/StlSupport/StdDeque.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const_iterator position, const value_type& x)
std::deque::insert	src/StlSupport/StdDeque.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
std::deque::push_back	src/StlSupport/StdDeque.h	/^  void push_back(const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const value_type& x)
std::deque::push_front	src/StlSupport/StdDeque.h	/^  void push_front(const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const value_type& x)
std::deque::resize	src/StlSupport/StdDeque.h	/^  void resize(size_type new_size)$/;"	f	class:std::deque	access:private	signature:(size_type new_size)
std::deque::resize	src/StlSupport/StdDeque.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(size_type new_size, const value_type& x)
std::list	src/StlSupport/StdList.h	/^  class list<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:list
std::list::insert	src/StlSupport/StdList.h	/^    iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::list	access:private	signature:(const_iterator position, const value_type& x)
std::list::insert	src/StlSupport/StdList.h	/^    void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::list	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
std::list::list_base	src/StlSupport/StdList.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > list_base;$/;"	t	class:std::list	access:private
std::list::push_back	src/StlSupport/StdList.h	/^    void push_back(const value_type& x)$/;"	f	class:std::list	access:private	signature:(const value_type& x)
std::list::resize	src/StlSupport/StdList.h	/^    void resize(size_type new_size)$/;"	f	class:std::list	access:private	signature:(size_type new_size)
std::list::resize	src/StlSupport/StdList.h	/^    void resize(size_type new_size, const value_type& x)$/;"	f	class:std::list	access:private	signature:(size_type new_size, const value_type& x)
std::vector	src/StlSupport/StdVector.h	/^  class vector<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:vector
std::vector::insert	src/StlSupport/StdVector.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const_iterator position, const value_type& x)
std::vector::insert	src/StlSupport/StdVector.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
std::vector::push_back	src/StlSupport/StdVector.h	/^  void push_back(const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const value_type& x)
std::vector::resize	src/StlSupport/StdVector.h	/^  void resize(size_type new_size)$/;"	f	class:std::vector	access:private	signature:(size_type new_size)
std::vector::resize	src/StlSupport/StdVector.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(size_type new_size, const value_type& x)
std::vector::vector_base	src/StlSupport/StdVector.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > vector_base;$/;"	t	class:std::vector	access:private
stem_function	src/Core/util/ForwardDeclarations.h	/^struct stem_function$/;"	s	namespace:Eigen::internal
step	src/Eigenvalues/RealQZ.h	/^      void step(Index f, Index l, Index iter);$/;"	p	class:Eigen::RealQZ	access:private	signature:(Index f, Index l, Index iter)
step	src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::step(Index f, Index l, Index iter)$/;"	f	class:Eigen::RealQZ	signature:(Index f, Index l, Index iter)
storage	src/SuperLUSupport/SuperLUSupport.h	/^  } storage;$/;"	m	struct:Eigen::SluMatrix	typeref:struct:Eigen::SluMatrix::__anon466	access:public
stpmv	src/misc/blas.h	/^int BLASFUNC(stpmv) (char *, char *, char *, int *, float  *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, float *, float *, int *)
stpsv	src/misc/blas.h	/^int BLASFUNC(stpsv) (char *, char *, char *, int *, float  *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, float *, float *, int *)
stride	src/Core/DenseCoeffsBase.h	/^    inline Index stride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
stride	src/Core/DenseCoeffsBase.h	/^    void stride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
strmm	src/misc/blas.h	/^int BLASFUNC(strmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, float *, float *, int *, float *, int *)
strmv	src/misc/blas.h	/^int BLASFUNC(strmv) (char *, char *, char *, int *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, float *, int *, float *, int *)
strsm	src/misc/blas.h	/^int BLASFUNC(strsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, float *, float *, int *, float *, int *)
strsv	src/misc/blas.h	/^int BLASFUNC(strsv) (char *, char *, char *, int *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, float *, int *, float *, int *)
strti2	src/misc/blas.h	/^int BLASFUNC(strti2)(char *, char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, char *, int *, float *, int *, int *)
strtri	src/misc/blas.h	/^int BLASFUNC(strtri)(char *, char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, char *, int *, float *, int *, int *)
sub	src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<-1>::Type sub() const$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:() const
sub	src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<-1>::Type sub()$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:()
sub	src/Core/GeneralProduct.h	/^    struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	s	class:Eigen::GeneralProduct	access:public
subDiagonal	src/Eigenvalues/Tridiagonalization.h	/^    SubDiagonalReturnType subDiagonal() const;$/;"	p	class:Eigen::Tridiagonalization	access:public	signature:() const
subDiagonal	src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::subDiagonal() const$/;"	f	class:Eigen::Tridiagonalization	signature:() const
subTo	src/Core/DiagonalMatrix.h	/^    void subTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
subTo	src/Core/EigenBase.h	/^  template<typename Dest> inline void subTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
subTo	src/Core/GeneralProduct.h	/^    inline void subTo(Dest& dest) const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest) const
subTo	src/Core/ProductBase.h	/^    inline void subTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(-1)); }$/;"	f	class:ScaledProduct	access:public	signature:(Dest& dst) const
subVector	src/Core/VectorwiseOp.h	/^    SubVector subVector(Index i)$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(Index i)
subVectors	src/Core/VectorwiseOp.h	/^    Index subVectors() const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:() const
subdiagonalEntryIsNeglegible	src/Eigenvalues/ComplexSchur.h	/^    bool subdiagonalEntryIsNeglegible(Index i);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(Index i)
subdiagonalEntryIsNeglegible	src/Eigenvalues/ComplexSchur.h	/^inline bool ComplexSchur<MatrixType>::subdiagonalEntryIsNeglegible(Index i)$/;"	f	class:Eigen::ComplexSchur	signature:(Index i)
subs	src/Core/BandMatrix.h	/^    inline Index subs() const { return derived().subs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
subs	src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
subs	src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
sum	src/Core/DenseBase.h	/^    Scalar sum() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
sum	src/Core/Redux.h	/^DenseBase<Derived>::sum() const$/;"	f	class:Eigen::DenseBase	signature:() const
sum	src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_sum>::Type sum() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
sum	src/SparseCore/SparseMatrix.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseMatrix	access:public	signature:() const
sum	src/SparseCore/SparseMatrixBase.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
sum	src/SparseCore/SparseRedux.h	/^SparseMatrix<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseMatrix	signature:() const
sum	src/SparseCore/SparseRedux.h	/^SparseMatrixBase<Derived>::sum() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
sum	src/SparseCore/SparseRedux.h	/^SparseVector<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseVector	signature:() const
sum	src/SparseCore/SparseVector.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseVector	access:public	signature:() const
sumupDuplicates	src/SparseCore/SparseMatrix.h	/^    void sumupDuplicates();$/;"	p	class:Eigen::SparseMatrix	access:public	signature:()
sumupDuplicates	src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::sumupDuplicates()$/;"	f	class:Eigen::SparseMatrix	signature:()
supIndex	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index supIndex() const { return m_supno; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
supToCol	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* supToCol() { return m_sup_to_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
supToCol	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* supToCol() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
super	src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<1>::Type super() const$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:() const
super	src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<1>::Type super()$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:()
supers	src/Core/BandMatrix.h	/^    inline Index supers() const { return derived().supers(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
supers	src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
supers	src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
supno	src/SparseLU/SparseLU_Structs.h	/^  IndexVector supno; \/\/ Supernode number corresponding to this column (column to supernode mapping)$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
svd	src/Core/MatrixBase.h	/^    SVD<PlainObject> svd() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
svd	src/Eigen2Support/SVD.h	/^MatrixBase<Derived>::svd() const$/;"	f	class:Eigen::MatrixBase	signature:() const
svd_precondition_2x2_block_to_be_real	src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real {};$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, false>$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>$/;"	s	namespace:Eigen::internal
swap	src/Core/Array.h	/^    void swap(ArrayBase<OtherDerived> const & other)$/;"	f	class:Eigen::Array	access:public	signature:(ArrayBase<OtherDerived> const & other)
swap	src/Core/DenseBase.h	/^    void swap(PlainObjectBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	access:public	signature:(PlainObjectBase<OtherDerived>& other)
swap	src/Core/DenseBase.h	/^    void swap(const DenseBase<OtherDerived>& other,$/;"	f	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, int = OtherDerived::ThisConstantIsPrivateInPlainObjectBase)
swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& ) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& )
swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
swap	src/Core/DenseStorage.h	/^    void swap(DenseStorage& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
swap	src/Core/Matrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::Matrix	access:public	signature:(MatrixBase<OtherDerived> const & other)
swap	src/Core/TriangularMatrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(MatrixBase<OtherDerived> const & other)
swap	src/Core/TriangularMatrix.h	/^    void swap(TriangularBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(TriangularBase<OtherDerived> const & other)
swap	src/SparseCore/CompressedStorage.h	/^    void swap(CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(CompressedStorage& other)
swap	src/SparseCore/SparseMatrix.h	/^    inline void swap(SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(SparseMatrix& other)
swap	src/SparseCore/SparseVector.h	/^    inline void swap(SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(SparseVector& other)
symm_pack_lhs	src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_lhs$/;"	s	namespace:Eigen::internal
symm_pack_rhs	src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_rhs$/;"	s	namespace:Eigen::internal
sync	src/Core/products/Parallelizer.h	/^  int volatile sync;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
tail	src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType tail(Index n) const$/;"	f	signature:(Index n) const
tail	src/plugins/BlockMethods.h	/^inline SegmentReturnType tail(Index n)$/;"	f	signature:(Index n)
tail	src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type tail(Index n = N) const$/;"	f	signature:(Index n = N) const
tail	src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type tail(Index n = N)$/;"	f	signature:(Index n = N)
take_affine_part	src/Geometry/Transform.h	/^  typedef internal::transform_take_affine_part<Transform> take_affine_part;$/;"	t	class:Eigen::Transform	access:public
take_matrix_for_product	src/Geometry/Homogeneous.h	/^struct take_matrix_for_product$/;"	s	namespace:Eigen::internal
take_matrix_for_product	src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Mode, Options> >$/;"	s	namespace:Eigen::internal
take_matrix_for_product	src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Projective, Options> >$/;"	s	namespace:Eigen::internal
tan	src/plugins/ArrayCwiseUnaryOps.h	/^tan() const$/;"	f	signature:() const
testFunctor	src/Core/util/Meta.h	/^    static has_none            testFunctor(...);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(....)
testFunctor	src/Core/util/Meta.h	/^    static has_std_result_type testFunctor(T const *, typename T::result_type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::result_type const * = 0)
testFunctor	src/Core/util/Meta.h	/^    static has_tr1_result      testFunctor(T const *, typename T::template result<T(ArgType)>::type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::template result<T(ArgType)>::type const * = 0)
testFunctor	src/Core/util/Meta.h	/^    static has_tr1_result      testFunctor(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0)
thenMatrix	src/Core/Select.h	/^    const ThenMatrixType& thenMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
thickness	src/OrderingMethods/Eigen_Colamd.h	/^    Index thickness ; \/* number of original columns represented by this *\/$/;"	m	union:internal::colamd_col::__anon402	access:public
threshold	src/LU/FullPivLU.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
threshold	src/QR/ColPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
threshold	src/QR/FullPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
threshold	src/SVD/JacobiSVD.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
throw_std_bad_alloc	src/Core/util/Memory.h	/^inline void throw_std_bad_alloc()$/;"	f	namespace:Eigen::internal	signature:()
toDense	src/SparseCore/SparseMatrixBase.h	/^    Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> toDense() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
toDenseMatrix	src/Core/BandMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
toDenseMatrix	src/Core/DiagonalMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
toDenseMatrix	src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return *this; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
toDenseMatrix	src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
toDenseMatrix	src/Core/TriangularMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
toQMatrix	src/Eigen2Support/Geometry/Transform.h	/^  inline QMatrix toQMatrix(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
toQMatrix	src/Eigen2Support/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim>::toQMatrix(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
toQMatrix	src/Geometry/Transform.h	/^  inline QMatrix toQMatrix(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
toQMatrix	src/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim,Mode,Options>::toQMatrix(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
toQTransform	src/Eigen2Support/Geometry/Transform.h	/^  inline QTransform toQTransform(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
toQTransform	src/Eigen2Support/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim>::toQTransform(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
toQTransform	src/Geometry/Transform.h	/^  inline QTransform toQTransform(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
toQTransform	src/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim,Mode,Options>::toQTransform(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
toRotationMatrix	src/Eigen2Support/Geometry/AngleAxis.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::AngleAxis	access:public	signature:(void) const
toRotationMatrix	src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis	signature:(void) const
toRotationMatrix	src/Eigen2Support/Geometry/Quaternion.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
toRotationMatrix	src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Quaternion	signature:(void) const
toRotationMatrix	src/Eigen2Support/Geometry/Rotation2D.h	/^  Matrix2 toRotationMatrix(void) const;$/;"	p	class:Eigen::Rotation2D	access:public	signature:(void) const
toRotationMatrix	src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D	signature:(void) const
toRotationMatrix	src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
toRotationMatrix	src/Geometry/AngleAxis.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::AngleAxis	access:public	signature:(void) const
toRotationMatrix	src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis	signature:(void) const
toRotationMatrix	src/Geometry/Quaternion.h	/^  Matrix3 toRotationMatrix() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
toRotationMatrix	src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::toRotationMatrix(void) const$/;"	f	class:Eigen::QuaternionBase	signature:(void) const
toRotationMatrix	src/Geometry/Rotation2D.h	/^  Matrix2 toRotationMatrix() const;$/;"	p	class:Eigen::Rotation2D	access:public	signature:() const
toRotationMatrix	src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D	signature:(void) const
toRotationMatrix	src/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
toRotationMatrix	src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& s)
toRotationMatrix	src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen::internal	signature:(const RotationBase<OtherDerived,Dim>& r)
toRotationMatrix	src/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<OtherDerived>& mat)
tolerance	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar tolerance() const { return m_tolerance; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
topLeftCorner	src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topLeftCorner()$/;"	f	signature:()
topLeftCorner	src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topLeftCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
topLeftCorner	src/plugins/BlockMethods.h	/^inline Block<Derived> topLeftCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
topLeftCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topLeftCorner() const$/;"	f	signature:() const
topLeftCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topLeftCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
topLeftCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived> topLeftCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
topRightCorner	src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topRightCorner()$/;"	f	signature:()
topRightCorner	src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topRightCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
topRightCorner	src/plugins/BlockMethods.h	/^inline Block<Derived> topRightCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
topRightCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topRightCorner() const$/;"	f	signature:() const
topRightCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topRightCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
topRightCorner	src/plugins/BlockMethods.h	/^inline const Block<const Derived> topRightCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
topRows	src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr topRows(Index n) const$/;"	f	signature:(Index n) const
topRows	src/plugins/BlockMethods.h	/^inline RowsBlockXpr topRows(Index n)$/;"	f	signature:(Index n)
topRows	src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type topRows(Index n = N) const$/;"	f	signature:(Index n = N) const
topRows	src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type topRows(Index n = N)$/;"	f	signature:(Index n = N)
trace	src/Core/DenseBase.h	/^    Scalar trace() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
trace	src/Core/MatrixBase.h	/^    Scalar trace() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
trace	src/Core/Redux.h	/^MatrixBase<Derived>::trace() const$/;"	f	class:Eigen::MatrixBase	signature:() const
traits	src/Core/Array.h	/^struct traits<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > : traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/ArrayWrapper.h	/^struct traits<ArrayWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/ArrayWrapper.h	/^struct traits<MatrixWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/BandMatrix.h	/^struct traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	src/Core/BandMatrix.h	/^struct traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	src/Core/Block.h	/^struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel> > : traits<XprType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/CwiseBinaryOp.h	/^struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	src/Core/CwiseNullaryOp.h	/^struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/CwiseUnaryOp.h	/^struct traits<CwiseUnaryOp<UnaryOp, XprType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/CwiseUnaryView.h	/^struct traits<CwiseUnaryView<ViewOp, MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Diagonal.h	/^struct traits<Diagonal<MatrixType,DiagIndex> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/DiagonalMatrix.h	/^struct traits<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/DiagonalMatrix.h	/^struct traits<DiagonalWrapper<_DiagonalVectorType> >$/;"	s	namespace:Eigen::internal
traits	src/Core/DiagonalProduct.h	/^struct traits<DiagonalProduct<MatrixType, DiagonalType, ProductOrder> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Flagged.h	/^struct traits<Flagged<ExpressionType, Added, Removed> > : traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/ForceAlignedAccess.h	/^struct traits<ForceAlignedAccess<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemvProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,InnerProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,OuterProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Map.h	/^struct traits<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Matrix.h	/^struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	src/Core/NestByValue.h	/^struct traits<NestByValue<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/PermutationMatrix.h	/^struct traits<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/PermutationMatrix.h	/^struct traits<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/PermutationMatrix.h	/^struct traits<PermutationWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	src/Core/PermutationMatrix.h	/^struct traits<Transpose<PermutationBase<Derived> > >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/PermutationMatrix.h	/^struct traits<permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	src/Core/ProductBase.h	/^struct traits<ProductBase<Derived,_Lhs,_Rhs> >$/;"	s	namespace:Eigen::internal
traits	src/Core/ProductBase.h	/^struct traits<ScaledProduct<NestedProduct> >$/;"	s	namespace:internal	inherits:traits
traits	src/Core/Ref.h	/^struct traits<Ref<_PlainObjectType, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Ref.h	/^struct traits<RefBase<Derived> > : public traits<Derived> {};$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Replicate.h	/^struct traits<Replicate<MatrixType,RowFactor,ColFactor> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/ReturnByValue.h	/^struct traits<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Reverse.h	/^struct traits<Reverse<MatrixType, Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Select.h	/^struct traits<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/SelfAdjointView.h	/^struct traits<SelfAdjointView<MatrixType, UpLo> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/SelfCwiseBinaryOp.h	/^struct traits<SelfCwiseBinaryOp<BinaryOp,Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/SolveTriangular.h	/^struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	src/Core/Swap.h	/^struct traits<SwapWrapper<ExpressionType> > : traits<ExpressionType> {};$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Transpose.h	/^struct traits<Transpose<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/Transpositions.h	/^struct traits<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	src/Core/Transpositions.h	/^struct traits<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	s	namespace:Eigen::internal
traits	src/Core/Transpositions.h	/^struct traits<TranspositionsWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	src/Core/Transpositions.h	/^struct traits<transposition_matrix_product_retval<TranspositionType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	src/Core/TriangularMatrix.h	/^struct traits<TriangularView<MatrixType, _Mode> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/VectorBlock.h	/^struct traits<VectorBlock<VectorType, Size> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/VectorwiseOp.h	/^struct traits<PartialReduxExpr<MatrixType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/products/CoeffBasedProduct.h	/^struct traits<CoeffBasedProduct<LhsNested,RhsNested,NestingFlags> >$/;"	s	namespace:Eigen::internal
traits	src/Core/products/GeneralMatrixMatrix.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemmProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/products/SelfadjointMatrixMatrix.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/products/TriangularMatrixMatrix.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,true> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,true,Rhs,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Core/util/ForwardDeclarations.h	/^template<typename T> struct traits<const T> : traits<T> {};$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Eigen2Support/Minor.h	/^struct traits<Minor<MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Eigenvalues/HessenbergDecomposition.h	/^struct traits<HessenbergDecompositionMatrixHReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	src/Eigenvalues/Tridiagonalization.h	/^struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	src/Geometry/AngleAxis.h	/^template<typename _Scalar> struct traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	src/Geometry/Homogeneous.h	/^struct traits<Homogeneous<MatrixType,Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Geometry/Homogeneous.h	/^struct traits<homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs> >$/;"	s	namespace:Eigen::internal
traits	src/Geometry/Homogeneous.h	/^struct traits<homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs> >$/;"	s	namespace:Eigen::internal
traits	src/Geometry/Quaternion.h	/^  struct traits<Map<Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Geometry/Quaternion.h	/^  struct traits<Map<const Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/Geometry/Quaternion.h	/^struct traits<Quaternion<_Scalar,_Options> >$/;"	s	namespace:Eigen::internal
traits	src/Geometry/Rotation2D.h	/^template<typename _Scalar> struct traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	src/Householder/HouseholderSequence.h	/^struct traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
traits	src/IterativeLinearSolvers/BiCGSTAB.h	/^struct traits<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	src/IterativeLinearSolvers/ConjugateGradient.h	/^struct traits<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	src/LU/Inverse.h	/^struct traits<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	src/QR/FullPivHouseholderQR.h	/^struct traits<FullPivHouseholderQRMatrixQReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType, typename Derived> struct traits<SPQR_QProduct<SPQRType, Derived> >$/;"	s	namespace:Eigen::internal
traits	src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
traits	src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQTransposeReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType,int _UpLo, typename _Ordering> struct traits<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCore/MappedSparseMatrix.h	/^struct traits<MappedSparseMatrix<_Scalar, _Flags, _Index> > : traits<SparseMatrix<_Scalar, _Flags, _Index> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/SparseCore/SparseDenseProduct.h	/^struct traits<DenseTimeSparseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseDenseOuterProduct<Lhs,Rhs,Tr> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseTimeDenseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/SparseCore/SparseDiagonalProduct.h	/^struct traits<SparseDiagonalProduct<Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<const SparseMatrix<_Scalar, _Options, _Index>, DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCore/SparseMatrix.h	/^struct traits<SparseMatrix<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCore/SparsePermutation.h	/^struct traits<permut_sparsematrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCore/SparseProduct.h	/^struct traits<SparseSparseProduct<LhsNested, RhsNested> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCore/SparseSelfAdjointView.h	/^struct traits<DenseTimeSparseSelfAdjointProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointTimeDenseProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointView<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSymmetricPermutationProduct<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/SparseCore/SparseTriangularView.h	/^struct traits<SparseTriangularView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/SparseCore/SparseVector.h	/^struct traits<SparseVector<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
traits	src/SparseCore/SparseView.h	/^struct traits<SparseView<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	src/SparseQR/SparseQR.h	/^  template <typename SparseQRType, typename Derived> struct traits<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen::internal
traits	src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
traits	src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQTransposeReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
traits	src/misc/Image.h	/^struct traits<image_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	src/misc/Kernel.h	/^struct traits<kernel_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	src/misc/Solve.h	/^struct traits<solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	src/misc/SparseSolve.h	/^struct traits<solve_retval_with_guess<DecompositionType, Rhs, Guess> >$/;"	s	namespace:Eigen::internal
traits	src/misc/SparseSolve.h	/^struct traits<sparse_solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
trans	src/Householder/HouseholderSequence.h	/^    bool trans() const { return m_trans; }     \/**< \\brief Returns the transpose flag. *\/$/;"	f	class:Eigen::HouseholderSequence	access:protected	signature:() const
transform	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)
transform	src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime>& t,$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Transform<Scalar,AmbientDimAtCompileTime>& t, TransformTraits traits = Affine)
transform	src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)
transform	src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t,$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t, TransformTraits traits = Affine)
transform_construct_from_matrix	src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_make_affine	src/Geometry/Transform.h	/^struct transform_make_affine$/;"	s	namespace:Eigen::internal
transform_make_affine	src/Geometry/Transform.h	/^struct transform_make_affine<AffineCompact>$/;"	s	namespace:Eigen::internal
transform_product_result	src/Geometry/Transform.h	/^struct transform_product_result$/;"	s	namespace:Eigen::internal
transform_right_product_impl	src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 0 >$/;"	s	namespace:Eigen::internal
transform_right_product_impl	src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 1 >$/;"	s	namespace:Eigen::internal
transform_right_product_impl	src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2 >$/;"	s	namespace:Eigen::internal
transform_take_affine_part	src/Geometry/Transform.h	/^struct transform_take_affine_part<Transform<Scalar,Dim,AffineCompact, Options> > {$/;"	s	namespace:Eigen::internal
transform_take_affine_part	src/Geometry/Transform.h	/^template<typename TransformType> struct transform_take_affine_part {$/;"	s	namespace:Eigen::internal
transform_traits	src/Geometry/Transform.h	/^struct transform_traits$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,AffineCompact,LhsOptions>,Transform<Scalar,Dim,Projective,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,false >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,Projective,LhsOptions>,Transform<Scalar,Dim,AffineCompact,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
translate	src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const VectorType& t)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& t)
translate	src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& translate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
translate	src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
translate	src/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const MatrixBase<Derived>& a_t)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_t)
translate	src/Geometry/Transform.h	/^  inline Transform& translate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
translate	src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
translation	src/Eigen2Support/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
translation	src/Eigen2Support/Geometry/Transform.h	/^  inline TranslationPart translation() { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:()
translation	src/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return ConstTranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
translation	src/Geometry/Transform.h	/^  inline TranslationPart translation() { return TranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:()
translation	src/Geometry/Translation.h	/^  VectorType& translation() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
translation	src/Geometry/Translation.h	/^  const VectorType& translation() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
translationExt	src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt()$/;"	f	class:Eigen::Transform	access:public	signature:()
translationExt	src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
transpose	src/Core/DenseBase.h	/^    ConstTransposeReturnType transpose() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
transpose	src/Core/DenseBase.h	/^    Eigen::Transpose<Derived> transpose();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
transpose	src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> transpose() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
transpose	src/Core/Transpose.h	/^DenseBase<Derived>::transpose() const$/;"	f	class:Eigen::DenseBase	signature:() const
transpose	src/Core/Transpose.h	/^DenseBase<Derived>::transpose()$/;"	f	class:Eigen::DenseBase	signature:()
transpose	src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> transpose() const$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
transpose	src/Core/TriangularMatrix.h	/^    inline TriangularView<Transpose<MatrixType>,TransposeMode> transpose()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
transpose	src/Core/TriangularMatrix.h	/^    inline const TriangularView<Transpose<MatrixType>,TransposeMode> transpose() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
transpose	src/Householder/HouseholderSequence.h	/^    HouseholderSequence transpose() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
transpose	src/Jacobi/Jacobi.h	/^    JacobiRotation transpose() const { using numext::conj; return JacobiRotation(m_c, -conj(m_s)); }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
transpose	src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> transpose() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType	access:public	signature:() const
transpose	src/SparseCore/SparseMatrixBase.h	/^    Transpose<Derived> transpose() { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
transpose	src/SparseCore/SparseMatrixBase.h	/^    const Transpose<const Derived> transpose() const { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
transpose	src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> transpose() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType	access:public	signature:() const
transposeInPlace	src/Core/DenseBase.h	/^    void transposeInPlace();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
transposeInPlace	src/Core/Transpose.h	/^inline void DenseBase<Derived>::transposeInPlace()$/;"	f	class:Eigen::DenseBase	signature:()
transposition_matrix_product_retval	src/Core/Transpositions.h	/^    transposition_matrix_product_retval(const TranspositionType& tr, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:(const TranspositionType& tr, const MatrixType& matrix)
transposition_matrix_product_retval	src/Core/Transpositions.h	/^struct transposition_matrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
transpositionsP	src/Cholesky/LDLT.h	/^    inline const TranspositionType& transpositionsP() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
treePostorder	src/SparseCore/SparseColEtree.h	/^void treePostorder(Index n, IndexVector& parent, IndexVector& post)$/;"	f	namespace:Eigen::internal	signature:(Index n, IndexVector& parent, IndexVector& post)
triangularView	src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename ConstTriangularViewReturnType<Mode>::Type triangularView() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
triangularView	src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename TriangularViewReturnType<Mode>::Type triangularView();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
triangularView	src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::MatrixBase	signature:() const
triangularView	src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView()$/;"	f	class:Eigen::MatrixBase	signature:()
triangularView	src/SparseCore/SparseMatrixBase.h	/^    inline const SparseTriangularView<Derived, Mode> triangularView() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
triangularView	src/SparseCore/SparseTriangularView.h	/^SparseMatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Lower), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Upper), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Mode, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product	src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product	src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product_trmv	src/Core/products/TriangularMatrixVector_MKL.h	/^struct triangular_matrix_vector_product_trmv :$/;"	s	namespace:Eigen::internal	inherits:triangular_matrix_vector_product
triangular_solve_matrix	src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_retval	src/Core/SolveTriangular.h	/^  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:(const TriangularType& tri, const Rhs& rhs)
triangular_solve_retval	src/Core/SolveTriangular.h	/^template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
triangular_solve_vector	src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,false> {$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,true> {$/;"	s	namespace:Eigen::internal
tribb_kernel	src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct tribb_kernel$/;"	s	namespace:Eigen::internal
tridiagonal_qr_step	src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)$/;"	f	namespace:Eigen::internal	signature:(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
tridiagonal_qr_step	src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n);$/;"	p	namespace:Eigen::internal	signature:(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
tridiagonalization_inplace	src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
tridiagonalization_inplace	src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& matA, CoeffVectorType& hCoeffs)
tridiagonalization_inplace	src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs);$/;"	p	namespace:Eigen::internal	signature:(MatrixType& matA, CoeffVectorType& hCoeffs)
tridiagonalization_inplace_selector	src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,3,false>$/;"	s	namespace:Eigen::internal
trmv_selector	src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<ColMajor>$/;"	s	namespace:Eigen::internal
trmv_selector	src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<RowMajor>$/;"	s	namespace:Eigen::internal
trsolve_traits	src/Core/SolveTriangular.h	/^class trsolve_traits$/;"	c	namespace:Eigen::internal
true_type	src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
twistedBy	src/SparseCore/SparseMatrixBase.h	/^    SparseSymmetricPermutationProduct<Derived,Upper|Lower> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const
twistedBy	src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct<_MatrixTypeNested,UpLo> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const
type	src/Core/DenseCoeffsBase.h	/^  typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;$/;"	t	struct:Eigen::internal::add_const_on_value_type_if_arithmetic	access:public
type	src/Core/Functors.h	/^  typedef bool type;$/;"	t	struct:Eigen::internal::result_of	access:public
type	src/Core/GenericPacketMath.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::atanh2_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::conj_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::pow_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::random_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base	access:public
type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::imag_ref_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::real_ref_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs2_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::hypot_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::imag_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::norm1_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::real_retval	access:public
type	src/Core/MathFunctions.h	/^  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base	access:public
type	src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	t	struct:Eigen::internal::always_void	access:public
type	src/Core/MatrixBase.h	/^      typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type	access:public
type	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedAlignedMapType	access:public
type	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstAlignedMapType	access:public
type	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstMapType	access:public
type	src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedMapType	access:public
type	src/Core/ProductBase.h	/^  typedef typename GeneralProduct<Lhs,Rhs,Mode>::PlainObject const& type;$/;"	t	class:internal::nested::GeneralProduct	access:public
type	src/Core/Ref.h	/^    typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type;$/;"	t	struct:Eigen::internal::traits::match	access:public
type	src/Core/ReturnByValue.h	/^  typedef typename traits<Derived>::ReturnType type;$/;"	t	struct:Eigen::internal::nested	access:public
type	src/Core/Transpose.h	/^  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;$/;"	t	struct:Eigen::internal::TransposeImpl_base	access:public
type	src/Core/TriangularMatrix.h	/^      typedef typename ProdRetType::PlainObject type;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
type	src/Core/TriangularMatrix.h	/^  typedef SelfAdjointView<MatrixType, Upper> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type	access:public
type	src/Core/TriangularMatrix.h	/^  typedef TriangularView<MatrixType, Mode> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type	access:public
type	src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	src/Core/products/CoeffBasedProduct.h	/^  typedef PlainObject const& type;$/;"	t	struct:Eigen::internal::nested	access:public
type	src/Core/util/ForwardDeclarations.h	/^  typedef ComplexScalar type(ComplexScalar, int);$/;"	t	struct:Eigen::internal::stem_function	access:public
type	src/Core/util/Meta.h	/^    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of	access:public
type	src/Core/util/Meta.h	/^    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of	access:public
type	src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
type	src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	t	struct:Eigen::internal::conditional	access:public
type	src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	t	struct:Eigen::internal::conditional	access:public
type	src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
type	src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
type	src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
type	src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	t	struct:Eigen::internal::remove_const	access:public
type	src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const	access:public
type	src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const	access:public
type	src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	t	struct:Eigen::internal::remove_const	access:public
type	src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	t	struct:Eigen::internal::add_const	access:public
type	src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	t	struct:Eigen::internal::add_const	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference	access:public
type	src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference	access:public
type	src/Core/util/Meta.h	/^{ typedef T type; };$/;"	t	struct:Eigen::internal::enable_if	access:public
type	src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
type	src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	t	struct:Eigen::ei_unconst	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	t	struct:Eigen::ei_unconst	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	t	struct:Eigen::ei_unconst	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	t	struct:Eigen::ei_unconst	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	t	struct:Eigen::ei_unref	access:public
type	src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	t	struct:Eigen::ei_unref	access:public
type	src/Geometry/Homogeneous.h	/^  typedef MatrixOrTransformType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
type	src/Geometry/Homogeneous.h	/^  typedef typename TransformType::MatrixType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
type	src/Geometry/Homogeneous.h	/^  typedef typename internal::add_const<typename TransformType::ConstAffinePart>::type type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
type	src/Geometry/Umeyama.h	/^  > type;$/;"	t	struct:Eigen::internal::umeyama_transform_matrix_type	access:public
type	src/SparseCore/SparseUtil.h	/^    typedef Matrix<_Scalar, 1, 1> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
type	src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> type;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
type	src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
type	src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, ColMajor, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
type	src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, RowMajor, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
ucol	src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  ucol; \/\/ nonzero values of U ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
umeyama	src/Geometry/Umeyama.h	/^umeyama(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)
umeyama_transform_matrix_type	src/Geometry/Umeyama.h	/^struct umeyama_transform_matrix_type$/;"	s	namespace:Eigen::internal
umfpack_free_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, double)$/;"	f	namespace:Eigen	signature:(void **Numeric, double)
umfpack_free_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, std::complex<double>)$/;"	f	namespace:Eigen	signature:(void **Numeric, std::complex<double>)
umfpack_free_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, double)$/;"	f	namespace:Eigen	signature:(void **Symbolic, double)
umfpack_free_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, std::complex<double>)$/;"	f	namespace:Eigen	signature:(void **Symbolic, std::complex<double>)
umfpack_get_determinant	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen	signature:(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])
umfpack_get_determinant	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen	signature:(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])
umfpack_get_lunz	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)$/;"	f	namespace:Eigen	signature:(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)
umfpack_get_lunz	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)$/;"	f	namespace:Eigen	signature:(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)
umfpack_get_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[],$/;"	f	namespace:Eigen	signature:(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[], int P[], int Q[], double Dx[], int *do_recip, double Rs[], void *Numeric)
umfpack_get_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[],$/;"	f	namespace:Eigen	signature:(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[], int P[], int Q[], std::complex<double> Dx[], int *do_recip, double Rs[], void *Numeric)
umfpack_helper_is_sparse_plain	src/UmfPackSupport/UmfPackSupport.h	/^  struct umfpack_helper_is_sparse_plain<MappedSparseMatrix<Scalar,Options,StorageIndex> >$/;"	s	namespace:Eigen::internal	inherits:true_type
umfpack_helper_is_sparse_plain	src/UmfPackSupport/UmfPackSupport.h	/^  struct umfpack_helper_is_sparse_plain<SparseMatrix<Scalar,Options,StorageIndex> >$/;"	s	namespace:Eigen::internal	inherits:true_type
umfpack_helper_is_sparse_plain	src/UmfPackSupport/UmfPackSupport.h	/^  template<typename T> struct umfpack_helper_is_sparse_plain : false_type {};$/;"	s	namespace:Eigen::internal	inherits:false_type
umfpack_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen	signature:( const int Ap[], const int Ai[], const double Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])
umfpack_numeric	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen	signature:( const int Ap[], const int Ai[], const std::complex<double> Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])
umfpack_solve	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen	signature:( int sys, const int Ap[], const int Ai[], const double Ax[], double X[], const double B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])
umfpack_solve	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen	signature:( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[], std::complex<double> X[], const std::complex<double> B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])
umfpack_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen	signature:(int n_row,int n_col, const int Ap[], const int Ai[], const double Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])
umfpack_symbolic	src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen	signature:(int n_row,int n_col, const int Ap[], const int Ai[], const std::complex<double> Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])
unaligned_assign_impl	src/Core/Assign.h	/^struct unaligned_assign_impl$/;"	s	namespace:Eigen::internal
unaligned_assign_impl	src/Core/Assign.h	/^struct unaligned_assign_impl<false>$/;"	s	namespace:Eigen::internal
unaryExpr	src/plugins/CommonCwiseUnaryOps.h	/^unaryExpr(const CustomUnaryOp& func = CustomUnaryOp()) const$/;"	f	signature:(const CustomUnaryOp& func = CustomUnaryOp()) const
unaryViewExpr	src/plugins/CommonCwiseUnaryOps.h	/^unaryViewExpr(const CustomViewOp& func = CustomViewOp()) const$/;"	f	signature:(const CustomViewOp& func = CustomViewOp()) const
unary_result_of_select	src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	s	namespace:Eigen::internal
unblocked	src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)
unblocked	src/Cholesky/LDLT.h	/^  static bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)
unblocked	src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
unblocked	src/Cholesky/LLT.h	/^  static typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
unblocked_lu	src/LU/PartialPivLU.h	/^  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)$/;"	f	struct:Eigen::internal::partial_lu_impl	access:public	signature:(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)
uncompress	src/SparseCore/SparseMatrix.h	/^    void uncompress()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
unitOrthogonal	src/Core/MatrixBase.h	/^    PlainObject unitOrthogonal(void) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(void) const
unitOrthogonal	src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::unitOrthogonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
unitOrthogonal_selector	src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,2>$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,3>$/;"	s	namespace:Eigen::internal
unpackRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)
unpackRhs	src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const Scalar* rhs, Scalar* b)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DenseIndex n, const Scalar* rhs, Scalar* b)
unpacket_traits	src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
update	src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool update(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, const typename MatrixType::RealScalar& sigma=1)
update	src/Cholesky/LDLT.h	/^  static bool update(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, const typename MatrixType::RealScalar& sigma=1)
updateInPlace	src/Cholesky/LDLT.h	/^  static bool updateInPlace(MatrixType& mat, MatrixBase<WDerived>& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, MatrixBase<WDerived>& w, const typename MatrixType::RealScalar& sigma=1)
update_segrep	src/SparseLU/SparseLU_column_dfs.h	/^  bool update_segrep(Index \/*krep*\/, Index \/*jj*\/)$/;"	f	struct:Eigen::internal::column_dfs_traits	access:public	signature:(Index , Index )
update_segrep	src/SparseLU/SparseLU_panel_dfs.h	/^  bool update_segrep(Index krep, Index jj)$/;"	f	struct:Eigen::internal::panel_dfs_traits	access:public	signature:(Index krep, Index jj)
users	src/Core/products/Parallelizer.h	/^  int volatile users;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
usub	src/SparseLU/SparseLU_Structs.h	/^  IndexVector usub; \/\/ row indices of U columns in ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
v	src/Core/arch/AltiVec/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
v	src/Core/arch/NEON/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
v	src/Core/arch/SSE/Complex.h	/^  __m128  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
v	src/Core/arch/SSE/Complex.h	/^  __m128d  v;$/;"	m	struct:Eigen::internal::Packet1cd	access:public
value	src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
value	src/Core/DenseBase.h	/^    CoeffReturnType value() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
value	src/Core/GeneralProduct.h	/^         value = is_large  ? Large$/;"	e	enum:Eigen::internal::product_size_category::__anon242
value	src/Core/GeneralProduct.h	/^    value = selector::ret$/;"	e	enum:Eigen::internal::product_type::__anon245
value	src/Core/MathFunctions.h	/^         value = (upper <= lower + 1) ? int(floor_log2_terminate)$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon278
value	src/Core/MathFunctions.h	/^  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };$/;"	e	enum:Eigen::internal::floor_log2::__anon281
value	src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, floor_log2_selector<n, lower, upper>::middle, upper>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon280
value	src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, lower, floor_log2_selector<n, lower, upper>::middle>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon279
value	src/Core/VectorwiseOp.h	/^  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };$/;"	e	enum:Eigen::internal::member_redux::Cost::__anon333
value	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon21
value	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon23
value	src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon22
value	src/Core/util/ForwardDeclarations.h	/^         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)$/;"	e	enum:Eigen::internal::accessors_level::__anon71
value	src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::false_type::__anon95
value	src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	e	enum:Eigen::internal::true_type::__anon94
value	src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_const::__anon112
value	src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_const::__anon113
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon102
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon103
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon100
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon99
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon101
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon104
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon108
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon110
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon106
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon105
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon109
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon111
value	src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon107
value	src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_same::__anon96
value	src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon98
value	src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_same::__anon97
value	src/SparseCore/AmbiVector.h	/^      Scalar value;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
value	src/SparseCore/AmbiVector.h	/^    Scalar value() const { return m_cachedValue; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
value	src/SparseCore/CompressedStorage.h	/^    inline Scalar& value(size_t i) { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i)
value	src/SparseCore/CompressedStorage.h	/^    inline const Scalar& value(size_t i) const { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i) const
value	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
value	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
value	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(m_lhsIter.value(), m_rhsIter.value()); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
value	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_value; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
value	src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
value	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:() const
value	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:() const
value	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:() const
value	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:() const
value	src/SparseCore/SparseDenseProduct.h	/^    inline Scalar value() const { return Base::value() * m_factor; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
value	src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
value	src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
value	src/SparseCore/SparseTriangularView.h	/^    inline Scalar value() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
value	src/SparseCore/SparseUtil.h	/^  const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
value	src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
value	src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
value	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_idval]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:() const
valuePtr	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar* valuePtr() { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
valuePtr	src/SparseCore/MappedSparseMatrix.h	/^    inline const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
valuePtr	src/SparseCore/SparseBlock.h	/^    inline Scalar* valuePtr()$/;"	f	class:Eigen::BlockImpl	access:public	signature:()
valuePtr	src/SparseCore/SparseBlock.h	/^    inline const Scalar* valuePtr() const$/;"	f	class:Eigen::BlockImpl	access:public	signature:() const
valuePtr	src/SparseCore/SparseMatrix.h	/^    inline Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
valuePtr	src/SparseCore/SparseMatrix.h	/^    inline const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
valuePtr	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
valuePtr	src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
valuePtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* valuePtr() {  return m_nzval; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
valuePtr	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Scalar* valuePtr() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:() const
valueRef	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id-1]); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:()
valueRef	src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id]); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:()
valueRef	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:()
valueRef	src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:()
valueRef	src/SparseCore/SparseCwiseUnaryOp.h	/^    typename CwiseUnaryOpImpl::Scalar& valueRef();$/;"	p	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private	signature:()
valueRef	src/SparseCore/SparseCwiseUnaryOp.h	/^    typename CwiseUnaryOpImpl::Scalar& valueRef();$/;"	p	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private	signature:()
valueRef	src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id-1]); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:()
valueRef	src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id]); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:()
valueRef	src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id)); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:()
valueRef	src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id-1)); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:()
valueRef	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_idval]); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator	access:public	signature:()
value_type	src/Core/util/Memory.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator	access:public
value_type	src/SparseCore/SparseMatrix.h	/^        typedef Index value_type;$/;"	t	class:Eigen::SparseMatrix::SingletonVector	access:public
value_type	src/StlSupport/details.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
values	src/SuperLUSupport/SuperLUSupport.h	/^    void *values;$/;"	m	struct:Eigen::SluMatrix::__anon466	access:public
vec	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Block<Coefficients,3,1> vec() { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
vec	src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Block<const Coefficients,3,1> vec() const { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
vec	src/Geometry/Quaternion.h	/^  inline VectorBlock<Coefficients,3> vec() { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
vec	src/Geometry/Quaternion.h	/^  inline const VectorBlock<const Coefficients,3> vec() const { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
vec2d_swizzle1	src/Core/arch/SSE/PacketMath.h	39;"	d
vec4f_swizzle1	src/Core/arch/SSE/PacketMath.h	33;"	d
vec4f_swizzle2	src/Core/arch/SSE/PacketMath.h	42;"	d
vec4i_swizzle1	src/Core/arch/SSE/PacketMath.h	36;"	d
vec4i_swizzle2	src/Core/arch/SSE/PacketMath.h	45;"	d
vector	src/Eigen2Support/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
vector	src/Eigen2Support/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
vector	src/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
vector	src/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
vector	src/StlSupport/StdVector.h	/^  class vector<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:vector
vectorD	src/Cholesky/LDLT.h	/^    inline Diagonal<const MatrixType> vectorD() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
vectorD	src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
vectorD	src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
vector_base	src/StlSupport/StdVector.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > vector_base;$/;"	t	class:std::vector	access:private
viewAsCholmod	src/CholmodSupport/CholmodSupport.h	/^cholmod_dense viewAsCholmod(MatrixBase<Derived>& mat)$/;"	f	namespace:Eigen	signature:(MatrixBase<Derived>& mat)
viewAsCholmod	src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen	signature:(SparseMatrix<_Scalar,_Options,_Index>& mat)
viewAsCholmod	src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)$/;"	f	namespace:Eigen	signature:(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)
viewAsCholmod	src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen	signature:(const SparseMatrix<_Scalar,_Options,_Index>& mat)
viewAsEigen	src/CholmodSupport/CholmodSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> viewAsEigen(cholmod_sparse& cm)$/;"	f	namespace:Eigen	signature:(cholmod_sparse& cm)
visit	src/Core/DenseBase.h	/^    void visit(Visitor& func) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Visitor& func) const
visit	src/Core/Visitor.h	/^void DenseBase<Derived>::visit(Visitor& visitor) const$/;"	f	class:Eigen::DenseBase	signature:(Visitor& visitor) const
visitor_impl	src/Core/Visitor.h	/^struct visitor_impl$/;"	s	namespace:Eigen::internal
visitor_impl	src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, 1>$/;"	s	namespace:Eigen::internal
visitor_impl	src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, Dynamic>$/;"	s	namespace:Eigen::internal
vld1_f32	src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_f32 (const float* x) { return ::vld1_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal	signature:(const float* x)
vld1q_f32	src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x4_t vld1q_f32(const float* x) { return ::vld1q_f32((const float32_t*)x); }$/;"	f	namespace:Eigen::internal	signature:(const float* x)
vml_assign_impl	src/Core/Assign_MKL.h	/^struct vml_assign_impl$/;"	s	namespace:Eigen::internal	inherits:assign_impl
vml_assign_impl	src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, InnerVectorizedTraversal>$/;"	s	namespace:Eigen::internal
vml_assign_impl	src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, LinearVectorizedTraversal>$/;"	s	namespace:Eigen::internal
vml_assign_traits	src/Core/Assign_MKL.h	/^class vml_assign_traits$/;"	c	namespace:Eigen::internal
vml_call	src/Core/Assign_MKL.h	/^template<typename Op> struct vml_call$/;"	s	namespace:Eigen::internal
volume	src/Geometry/AlignedBox.h	/^  inline Scalar volume() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
vst1_f32	src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1_f32 (float* to, float32x2_t from) { ::vst1_f32 ((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, float32x2_t from)
vst1q_f32	src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1q_f32(float* to, float32x4_t from) { ::vst1q_f32((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, float32x4_t from)
w	src/Core/DenseCoeffsBase.h	/^    w() const { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
w	src/Core/DenseCoeffsBase.h	/^    w() { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
w	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar w() const { return m_coeffs.coeff(3); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
w	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& w() { return m_coeffs.coeffRef(3); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
w	src/Geometry/Quaternion.h	/^  inline Scalar w() const { return this->derived().coeffs().coeff(3); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
w	src/Geometry/Quaternion.h	/^  inline Scalar& w() { return this->derived().coeffs().coeffRef(3); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
workaround_msvc_stl_support	src/StlSupport/details.h	/^    inline workaround_msvc_stl_support() : T() {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:()
workaround_msvc_stl_support	src/StlSupport/details.h	/^    inline workaround_msvc_stl_support(const T& other) : T(other) {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const T& other)
workaround_msvc_stl_support	src/StlSupport/details.h	/^  template<typename T> struct workaround_msvc_stl_support : public T$/;"	s	namespace:Eigen::internal	inherits:T
writePacket	src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index, const PacketScalar& val)
writePacket	src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index, const PacketScalar& val)
writePacket	src/Core/ArrayWrapper.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index rowId, Index colId, const PacketScalar& val)
writePacket	src/Core/ArrayWrapper.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index rowId, Index colId, const PacketScalar& val)
writePacket	src/Core/Block.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index index, const PacketScalar& val)
writePacket	src/Core/Block.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense	access:public	signature:(Index rowId, Index colId, const PacketScalar& val)
writePacket	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const typename internal::packet_traits<Scalar>::type& val)
writePacket	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const typename internal::packet_traits<Scalar>::type& val)
writePacket	src/Core/DenseCoeffsBase.h	/^    void writePacket();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
writePacket	src/Core/Flagged.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index, const PacketScalar& x)
writePacket	src/Core/Flagged.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index, const PacketScalar& x)
writePacket	src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	src/Core/MapBase.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index, const PacketScalar& val)
writePacket	src/Core/MapBase.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& val)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col, const PacketScalar& val)
writePacket	src/Core/NestByValue.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index, const PacketScalar& x)
writePacket	src/Core/NestByValue.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index, const PacketScalar& val)
writePacket	src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rowId, Index colId, const PacketScalar& val)
writePacket	src/Core/Reverse.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index, const PacketScalar& x)
writePacket	src/Core/Reverse.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	src/Core/Transpose.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index, const PacketScalar& x)
writePacket	src/Core/Transpose.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index rowId, Index colId, const PacketScalar& x)
writePacketByOuterInner	src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacketByOuterInner$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const typename internal::packet_traits<Scalar>::type& val)
writePacketByOuterInner	src/Core/DenseCoeffsBase.h	/^    void writePacketByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
x	src/Core/DenseCoeffsBase.h	/^    x() const { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
x	src/Core/DenseCoeffsBase.h	/^    x() { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
x	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar x() const { return m_coeffs.coeff(0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
x	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& x() { return m_coeffs.coeffRef(0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
x	src/Geometry/Quaternion.h	/^  inline Scalar x() const { return this->derived().coeffs().coeff(0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
x	src/Geometry/Quaternion.h	/^  inline Scalar& x() { return this->derived().coeffs().coeffRef(0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
x	src/Geometry/Translation.h	/^  inline Scalar x() const { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
x	src/Geometry/Translation.h	/^  inline Scalar& x() { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
xaxpy	src/misc/blas.h	/^int    BLASFUNC(xaxpy) (int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
xaxpyc	src/misc/blas.h	/^int    BLASFUNC(xaxpyc)(int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
xcopy	src/misc/blas.h	/^int    BLASFUNC(xcopy) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
xerbla	src/misc/blas.h	/^int    BLASFUNC(xerbla)(const char *, int *info, int);$/;"	p	signature:(const char *, int *info, int)
xgbmv	src/misc/blas.h	/^int BLASFUNC(xgbmv)(char *, int *, int *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xgemm	src/misc/blas.h	/^int BLASFUNC(xgemm)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xgemm3m	src/misc/blas.h	/^int BLASFUNC(xgemm3m)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xgemv	src/misc/blas.h	/^int BLASFUNC(xgemv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xgerc	src/misc/blas.h	/^int BLASFUNC(xgerc)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
xgeru	src/misc/blas.h	/^int BLASFUNC(xgeru)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
xgesv	src/misc/blas.h	/^int BLASFUNC(xgesv)(int *, int *, double *, int *, int *, double*, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, double*, int *, int *)
xgetf2	src/misc/blas.h	/^int BLASFUNC(xgetf2)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
xgetrf	src/misc/blas.h	/^int BLASFUNC(xgetrf)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
xgetrs	src/misc/blas.h	/^int BLASFUNC(xgetrs)(char *, int *, int *, double *, int *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *, int *, double *, int *, int *)
xhbmv	src/misc/blas.h	/^int BLASFUNC(xhbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xhemm	src/misc/blas.h	/^int BLASFUNC(xhemm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xhemm3m	src/misc/blas.h	/^int BLASFUNC(xhemm3m)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xhemv	src/misc/blas.h	/^int BLASFUNC(xhemv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xher	src/misc/blas.h	/^int BLASFUNC(xher) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
xher2	src/misc/blas.h	/^int BLASFUNC(xher2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
xher2k	src/misc/blas.h	/^int BLASFUNC(xher2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
xher2m	src/misc/blas.h	/^int BLASFUNC(xher2m)(char *, char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
xherk	src/misc/blas.h	/^int BLASFUNC(xherk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
xhpmv	src/misc/blas.h	/^int BLASFUNC(xhpmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
xhpr	src/misc/blas.h	/^int BLASFUNC(xhpr) (char *, int *, double  *, double *, int *, double *);$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
xhpr2	src/misc/blas.h	/^int BLASFUNC(xhpr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
xlaswp	src/misc/blas.h	/^int BLASFUNC(xlaswp)(int *, double *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, double *, int *, int *, int *, int *, int *)
xlauu2	src/misc/blas.h	/^int BLASFUNC(xlauu2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
xlauum	src/misc/blas.h	/^int BLASFUNC(xlauum)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
xlsub	src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlsub; \/\/ pointers to the beginning of each column in lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
xlusup	src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlusup; \/\/ pointers to the beginning of each column in lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
xpotf2	src/misc/blas.h	/^int BLASFUNC(xpotf2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
xpotrf	src/misc/blas.h	/^int BLASFUNC(xpotrf)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
xpotri	src/misc/blas.h	/^int BLASFUNC(xpotri)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
xqrot	src/misc/blas.h	/^int    BLASFUNC(xqrot) (int *, double *, int *, double *, int *, double *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *, double *)
xqscal	src/misc/blas.h	/^int    BLASFUNC(xqscal)(int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
xrotg	src/misc/blas.h	/^int    BLASFUNC(xrotg) (double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *)
xsbmv	src/misc/blas.h	/^int BLASFUNC(xsbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xscal	src/misc/blas.h	/^int    BLASFUNC(xscal) (int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
xspmv	src/misc/blas.h	/^int BLASFUNC(xspmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
xspr	src/misc/blas.h	/^int BLASFUNC(xspr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
xspr2	src/misc/blas.h	/^int BLASFUNC(xspr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
xsup	src/SparseLU/SparseLU_Structs.h	/^  IndexVector xsup; \/\/First supernode column ... xsup(s) points to the beginning of the s-th supernode$/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
xswap	src/misc/blas.h	/^int    BLASFUNC(xswap) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
xsymm	src/misc/blas.h	/^int BLASFUNC(xsymm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xsymm3m	src/misc/blas.h	/^int BLASFUNC(xsymm3m)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xsymv	src/misc/blas.h	/^int BLASFUNC(xsymv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xsyr	src/misc/blas.h	/^int BLASFUNC(xsyr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
xsyr2	src/misc/blas.h	/^int BLASFUNC(xsyr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
xsyr2k	src/misc/blas.h	/^int BLASFUNC(xsyr2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
xsyrk	src/misc/blas.h	/^int BLASFUNC(xsyrk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
xtbmv	src/misc/blas.h	/^int BLASFUNC(xtbmv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
xtbsv	src/misc/blas.h	/^int BLASFUNC(xtbsv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
xtpmv	src/misc/blas.h	/^int BLASFUNC(xtpmv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
xtpsv	src/misc/blas.h	/^int BLASFUNC(xtpsv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
xtrmm	src/misc/blas.h	/^int BLASFUNC(xtrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
xtrmv	src/misc/blas.h	/^int BLASFUNC(xtrmv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
xtrsm	src/misc/blas.h	/^int BLASFUNC(xtrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
xtrsv	src/misc/blas.h	/^int BLASFUNC(xtrsv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
xtrti2	src/misc/blas.h	/^int BLASFUNC(xtrti2)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
xtrtri	src/misc/blas.h	/^int BLASFUNC(xtrtri)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
xusub	src/SparseLU/SparseLU_Structs.h	/^  IndexVector xusub; \/\/ Pointers to the beginning of each column of U in ucol $/;"	m	struct:Eigen::internal::LU_GlobalLU_t	access:public
y	src/Core/DenseCoeffsBase.h	/^    y() const { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
y	src/Core/DenseCoeffsBase.h	/^    y() { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
y	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar y() const { return m_coeffs.coeff(1); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
y	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& y() { return m_coeffs.coeffRef(1); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
y	src/Geometry/Quaternion.h	/^  inline Scalar y() const { return this->derived().coeffs().coeff(1); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
y	src/Geometry/Quaternion.h	/^  inline Scalar& y() { return this->derived().coeffs().coeffRef(1); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
y	src/Geometry/Translation.h	/^  inline Scalar y() const { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
y	src/Geometry/Translation.h	/^  inline Scalar& y() { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
z	src/Core/DenseCoeffsBase.h	/^    z() const { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
z	src/Core/DenseCoeffsBase.h	/^    z() { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
z	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar z() const { return m_coeffs.coeff(2); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
z	src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& z() { return m_coeffs.coeffRef(2); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
z	src/Geometry/Quaternion.h	/^  inline Scalar z() const { return this->derived().coeffs().coeff(2); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
z	src/Geometry/Quaternion.h	/^  inline Scalar& z() { return this->derived().coeffs().coeffRef(2); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
z	src/Geometry/Translation.h	/^  inline Scalar z() const { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
z	src/Geometry/Translation.h	/^  inline Scalar& z() { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
zaxpy	src/misc/blas.h	/^int    BLASFUNC(zaxpy) (int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
zaxpyc	src/misc/blas.h	/^int    BLASFUNC(zaxpyc)(int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
zcopy	src/misc/blas.h	/^int    BLASFUNC(zcopy) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
zdotcw	src/misc/blas.h	/^int  BLASFUNC(zdotcw)  (int *, double  *, int *, double  *, int *, double*);$/;"	p	signature:(int *, double *, int *, double *, int *, double*)
zdotuw	src/misc/blas.h	/^int  BLASFUNC(zdotuw)  (int *, double  *, int *, double  *, int *, double*);$/;"	p	signature:(int *, double *, int *, double *, int *, double*)
zdrot	src/misc/blas.h	/^int    BLASFUNC(zdrot) (int *, double *, int *, double *, int *, double *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *, double *)
zdscal	src/misc/blas.h	/^int    BLASFUNC(zdscal)(int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
zgbmv	src/misc/blas.h	/^int BLASFUNC(zgbmv)(char *, int *, int *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zge2mm	src/misc/blas.h	/^int BLASFUNC(zge2mm)(char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zgema	src/misc/blas.h	/^int BLASFUNC(zgema)(char *, char *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, double *, int *, double*, int *)
zgemm	src/misc/blas.h	/^int BLASFUNC(zgemm)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zgemm3m	src/misc/blas.h	/^int BLASFUNC(zgemm3m)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zgems	src/misc/blas.h	/^int BLASFUNC(zgems)(char *, char *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, double *, int *, double*, int *)
zgemt	src/misc/blas.h	/^int BLASFUNC(zgemt)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *)
zgemv	src/misc/blas.h	/^int BLASFUNC(zgemv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zgerc	src/misc/blas.h	/^int BLASFUNC(zgerc)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
zgeru	src/misc/blas.h	/^int BLASFUNC(zgeru)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
zgesv	src/misc/blas.h	/^int BLASFUNC(zgesv)(int *, int *, double *, int *, int *, double*, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, double*, int *, int *)
zgetf2	src/misc/blas.h	/^int BLASFUNC(zgetf2)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
zgetrf	src/misc/blas.h	/^int BLASFUNC(zgetrf)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
zgetrs	src/misc/blas.h	/^int BLASFUNC(zgetrs)(char *, int *, int *, double *, int *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *, int *, double *, int *, int *)
zhbmv	src/misc/blas.h	/^int BLASFUNC(zhbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zhemm	src/misc/blas.h	/^int BLASFUNC(zhemm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zhemm3m	src/misc/blas.h	/^int BLASFUNC(zhemm3m)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zhemv	src/misc/blas.h	/^int BLASFUNC(zhemv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zher	src/misc/blas.h	/^int BLASFUNC(zher) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
zher2	src/misc/blas.h	/^int BLASFUNC(zher2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
zher2k	src/misc/blas.h	/^int BLASFUNC(zher2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
zher2m	src/misc/blas.h	/^int BLASFUNC(zher2m)(char *, char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
zherk	src/misc/blas.h	/^int BLASFUNC(zherk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
zhpmv	src/misc/blas.h	/^int BLASFUNC(zhpmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
zhpr	src/misc/blas.h	/^int BLASFUNC(zhpr) (char *, int *, double  *, double *, int *, double *);$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
zhpr2	src/misc/blas.h	/^int BLASFUNC(zhpr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
zlaswp	src/misc/blas.h	/^int BLASFUNC(zlaswp)(int *, double *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, double *, int *, int *, int *, int *, int *)
zlauu2	src/misc/blas.h	/^int BLASFUNC(zlauu2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
zlauum	src/misc/blas.h	/^int BLASFUNC(zlauum)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
znorm	src/misc/blas.h	/^int BLASFUNC(znorm)(char *, int *, int *, double *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *)
zpotf2	src/misc/blas.h	/^int BLASFUNC(zpotf2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
zpotrf	src/misc/blas.h	/^int BLASFUNC(zpotrf)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
zpotri	src/misc/blas.h	/^int BLASFUNC(zpotri)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
zrotg	src/misc/blas.h	/^int    BLASFUNC(zrotg) (double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *)
zsbmv	src/misc/blas.h	/^int BLASFUNC(zsbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zscal	src/misc/blas.h	/^int    BLASFUNC(zscal) (int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
zspmv	src/misc/blas.h	/^int BLASFUNC(zspmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
zspr	src/misc/blas.h	/^int BLASFUNC(zspr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
zspr2	src/misc/blas.h	/^int BLASFUNC(zspr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
zswap	src/misc/blas.h	/^int    BLASFUNC(zswap) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
zsymm	src/misc/blas.h	/^int BLASFUNC(zsymm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zsymm3m	src/misc/blas.h	/^int BLASFUNC(zsymm3m)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zsymv	src/misc/blas.h	/^int BLASFUNC(zsymv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zsyr	src/misc/blas.h	/^int BLASFUNC(zsyr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
zsyr2	src/misc/blas.h	/^int BLASFUNC(zsyr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
zsyr2k	src/misc/blas.h	/^int BLASFUNC(zsyr2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
zsyrk	src/misc/blas.h	/^int BLASFUNC(zsyrk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
ztbmv	src/misc/blas.h	/^int BLASFUNC(ztbmv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
ztbsv	src/misc/blas.h	/^int BLASFUNC(ztbsv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
ztpmv	src/misc/blas.h	/^int BLASFUNC(ztpmv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
ztpsv	src/misc/blas.h	/^int BLASFUNC(ztpsv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
ztrmm	src/misc/blas.h	/^int BLASFUNC(ztrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
ztrmv	src/misc/blas.h	/^int BLASFUNC(ztrmv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
ztrsm	src/misc/blas.h	/^int BLASFUNC(ztrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
ztrsv	src/misc/blas.h	/^int BLASFUNC(ztrsv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
ztrti2	src/misc/blas.h	/^int BLASFUNC(ztrti2)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
ztrtri	src/misc/blas.h	/^int BLASFUNC(ztrtri)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
~AlignedBox	src/Eigen2Support/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
~AlignedBox	src/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
~AmbiVector	src/SparseCore/AmbiVector.h	/^    ~AmbiVector() { delete[] m_buffer; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:()
~BiCGSTAB	src/IterativeLinearSolvers/BiCGSTAB.h	/^  ~BiCGSTAB() {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:()
~CholmodBase	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodBase()$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
~CholmodDecomposition	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodDecomposition() {}$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:()
~CholmodSimplicialLDLT	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLDLT() {}$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:()
~CholmodSimplicialLLT	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLLT() {}$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:()
~CholmodSupernodalLLT	src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSupernodalLLT() {}$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:()
~CommaInitializer	src/Core/CommaInitializer.h	/^  inline ~CommaInitializer()$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:()
~CompressedStorage	src/SparseCore/CompressedStorage.h	/^    ~CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
~ConjugateGradient	src/IterativeLinearSolvers/ConjugateGradient.h	/^  ~ConjugateGradient() {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:()
~DenseStorage	src/Core/DenseStorage.h	/^    ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
~DenseStorage	src/Core/DenseStorage.h	/^    ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
~DenseStorage	src/Core/DenseStorage.h	/^    ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
~Hyperplane	src/Eigen2Support/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
~Hyperplane	src/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
~IterativeSolverBase	src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ~IterativeSolverBase() {}$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
~MappedSparseMatrix	src/SparseCore/MappedSparseMatrix.h	/^    inline ~MappedSparseMatrix() {}$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
~MappedSuperNodalMatrix	src/SparseLU/SparseLU_SupernodalMatrix.h	/^    ~MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix	access:public	signature:()
~ParametrizedLine	src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
~ParametrizedLine	src/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
~PardisoImpl	src/PardisoSupport/PardisoSupport.h	/^    ~PardisoImpl()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
~PastixBase	src/PaStiXSupport/PaStiXSupport.h	/^    ~PastixBase() $/;"	f	class:Eigen::PastixBase	access:public	signature:()
~SPQR	src/SPQRSupport/SuiteSparseQRSupport.h	/^    ~SPQR()$/;"	f	class:Eigen::SPQR	access:public	signature:()
~SimplicialCholeskyBase	src/SparseCholesky/SimplicialCholesky.h	/^    ~SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
~SparseLU	src/SparseLU/SparseLU.h	/^    ~SparseLU()$/;"	f	class:Eigen::SparseLU	access:public	signature:()
~SparseMatrix	src/SparseCore/SparseMatrix.h	/^    inline ~SparseMatrix()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
~SparseVector	src/SparseCore/SparseVector.h	/^    inline ~SparseVector() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
~SuperILU	src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperILU()$/;"	f	class:Eigen::SuperILU	access:public	signature:()
~SuperLU	src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLU()$/;"	f	class:Eigen::SuperLU	access:public	signature:()
~SuperLUBase	src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLUBase()$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
~UmfPackLU	src/UmfPackSupport/UmfPackSupport.h	/^    ~UmfPackLU()$/;"	f	class:Eigen::UmfPackLU	access:public	signature:()
~aligned_allocator	src/Core/util/Memory.h	/^    ~aligned_allocator()$/;"	f	class:Eigen::aligned_allocator	access:public	signature:()
~aligned_allocator_indirection	src/StlSupport/details.h	/^    ~aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:()
~aligned_stack_memory_handler	src/Core/util/Memory.h	/^    ~aligned_stack_memory_handler()$/;"	f	class:Eigen::internal::aligned_stack_memory_handler	access:public	signature:()
~gemm_blocking_space	src/Core/products/GeneralMatrixMatrix.h	/^    ~gemm_blocking_space()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
~noncopyable	src/Core/util/Meta.h	/^  ~noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable	access:protected	signature:()
